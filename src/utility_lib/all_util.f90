!
! ---------------------------------------------------------------------|--
!                                                                      |
! Full Boyce Fortran Utility Library                                   |
!                                                                      |
!            Developed for MODFLOW-OWHMv2 (Boyce etal, 2020)           |
!                                                                      |
!     Library is is dependent on:                                      |
!                   generic_open_module.fpp    --which contains Fortran preprocessing macros for Intel vs GFortran compilers.
!                                                                      |
!                                                                      |
! Code is a merger of multiple files for faster compilation.           |
!                                                                      |
!                                                                      |
! Developed by SCOTT E BOYCE                                           |
!              Contact <seboyce@usgs.gov>                              |
!                                                                      |
!                                                                      |
! ---------------------------------------------------------------------|--
!
!
!Module List:
!            CONSTANTS
!            NAME_ID_INTERFACE
!            SIMPLE_TIMER_INSTRUCTION
!            OPENSPEC_LOADER_SUBROUTINE
!            OPENSPEC
!            LINKED_LIST_INSTRUCTION
!            INTEGER_QUEUE_INSTRUCTION
!            CAST_TO_STRING
!            CALENDAR_FUNCTIONS
!            DATE_OPERATOR_INSTRUCTION
!            XY_GRID_COORDINATE_INTERFACE
!            OBS_GROUP_INTERPOLATOR
!            BINARY_HEAP_INSTRUCTION
!            ARRAY_DATA_TYPES
!            SORT_INTERFACE
!            ALLOC_INTERFACE
!            NUM2STR_INTERFACE
!            EquationParser
!            RANDOM_ROUTINES
!            IS_PRESENT_INTERFACE
!            UTIL_INTERFACE
!            WARNING_TYPE_INSTRUCTION
!            FILE_INCREMENTER_INTERFACE
!            GENERIC_INPUT_OUTPUT_DATAFILES
!            GENERIC_INPUT_FILE_INSTRUCTION
!            GENERIC_OUTPUT_FILE_INSTRUCTION
!            CYCLING_TEXT_FILE_INTERFACE
!            GENERIC_BLOCK_READER_INSTRUCTION
!            ADJACENCY_LIST_INSTRUCTION
!                             SubModule: VERTEX_VERTEX_PATH_SUBS
!                             SubModule: VERTEX_BACKPATH_SUBS
!            IXJ_INSTRUCTION
!            LOOKUP_TABLE_INSTRUCTION
!            TIME_SERIES_INSTRUCTION
!            VARIABLE_POINTER_LIST_INTERFACE
!            BUDGET_GROUP_INTERFACE
!            ULOAD_AND_SFAC_INTERFACE
!            TRANSIENT_FILE_READER_INSTRUCTION
!            LIST_ARRAY_INPUT_INTERFACE
!            SUB_BLOCK_INPUT_INTERFACE
!
!
!
!
!
!
!
!#######################################################################
!#######################################################################
!#######################################################################
!#######################################################################
!#######################################################################
!#######################################################################
!
!
!
! NOTE THAT BLOCK CONSTRUCT IS USED BY SET_NAN FUNCTIONS
! IF COMPILER DOES NOT SUPPORT THIS FORTRAN 2008 FEATURE
! THEN REMOVE FUNCTIONS AND REPLACE WITH COMMENTED VERSIONS AT BOTTOM
! OF THIS SOURCE FILE.
!
!    MODULE CONSTANTS
!    MODULE ARRAY_DATA_TYPES
!
MODULE CONSTANTS !, ONLY:BLNK,NL,TAB,COM,Z,ONE,TWO,THREE,FOUR,FIVE,TEN,DZ,UNO,DOS,DIEZ,NEG,DNEG,TRUE,FALSE,NEARZERO_5,NEARZERO_10,NEARZERO_30,NEARZERO_50, NEGNEARZERO_10, GET_NAN, SET_NaN
  !
  USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: i8 => INT8,   i16 => INT16,  &
                                         i32 => INT32,  i64 => INT64,  &
                                         SNG => REAL32, DBL => REAL64, &
                                                        QAD => REAL128
  !
  PRIVATE:: i8, i16, i32, i64, SNG, DBL, QAD
  !
  PRIVATE:: SET_REAL_NAN, SET_DBLE_NAN
  !
  !---------------------------------------------------------------------------------------------------
  !
  LOGICAL,       PARAMETER:: TRUE       = .TRUE.
  LOGICAL,       PARAMETER:: FALSE      = .FALSE.
  !
  !---------------------------------------------------------------------------------------------------
  !
  CHARACTER,     PARAMETER:: NL         = NEW_LINE(' ')
  CHARACTER(2),  PARAMETER:: BLN        = NL//NL
  !
  CHARACTER,     PARAMETER:: BLNK       = ' '
  CHARACTER(2),  PARAMETER:: BLNK2      = BLNK
  CHARACTER(3),  PARAMETER:: BLNK3      = BLNK
  CHARACTER(4),  PARAMETER:: BLNK4      = BLNK
  CHARACTER(5),  PARAMETER:: BLNK5      = BLNK
  !
  !---------------------------------------------------------------------------------------------------
  !
  CHARACTER,     PARAMETER:: TAB        =  ACHAR(9)
  CHARACTER,     PARAMETER:: COM        = '#'
  CHARACTER,     PARAMETER:: CM         = ','
  CHARACTER,     PARAMETER:: SLASH      = '/'
  CHARACTER,     PARAMETER:: BSLASH     = '\'
  CHARACTER,     PARAMETER:: MINUS      = '-'
  CHARACTER,     PARAMETER:: PLUS       = '+'
  !                                     
  CHARACTER(3),  PARAMETER:: YES        = 'YES'
  CHARACTER(2),  PARAMETER:: NO         = 'NO'
  !                                     
  CHARACTER,     PARAMETER:: CR         = ACHAR(13)  !CARAGE RETURN (UNIX ENDING)
  CHARACTER,     PARAMETER:: LF         = ACHAR(10)  !LINE   FEED (CRLF IS WINDOWNS ENDING)
  CHARACTER(2),  PARAMETER:: winNL      = CR//LF
  !                                     
  CHARACTER(10), PARAMETER:: NUMBERS    ='0123456789'
  CHARACTER(11), PARAMETER:: NUMPNT     ='0123456789.'
  !
  !---------------------------------------------------------------------------------------------------
  !
  INTEGER(i32),  PARAMETER:: NINER      = -999
  INTEGER(i32),  PARAMETER:: NEG3       = -3
  INTEGER(i32),  PARAMETER:: NEG2       = -2
  INTEGER(i32),  PARAMETER:: NEG        = -1
  INTEGER(i32),  PARAMETER:: Z          = 0
  INTEGER(i32),  PARAMETER:: ONE        = 1
  INTEGER(i32),  PARAMETER:: TWO        = 2
  INTEGER(i32),  PARAMETER:: THREE      = 3
  INTEGER(i32),  PARAMETER:: FOUR       = 4
  INTEGER(i32),  PARAMETER:: FIVE       = 5
  INTEGER(i32),  PARAMETER:: SIX        = 6
  INTEGER(i32),  PARAMETER:: SEV        = 7
  INTEGER(i32),  PARAMETER:: EIGHT      = 8
  INTEGER(i32),  PARAMETER:: NINE       = 9
  INTEGER(i32),  PARAMETER:: TEN        = 10
  INTEGER(i32),  PARAMETER:: TWENTY     = 20
  INTEGER(i32),  PARAMETER:: FIFTY      = 50
  INTEGER(i32),  PARAMETER:: SIXTY      = 60
  INTEGER(i32),  PARAMETER:: HUND       = 100
  INTEGER(i32),  PARAMETER:: QUIN       = 500
  INTEGER(i32),  PARAMETER:: THOU       = 1000
  INTEGER(i32),  PARAMETER:: THOU10     = 10000
  INTEGER(i32),  PARAMETER:: THOU20     = 20000
  INTEGER(i32),  PARAMETER:: THOU30     = 30000
  INTEGER(i32),  PARAMETER:: THOU40     = 30000
  INTEGER(i32),  PARAMETER:: THOU50     = 50000
  INTEGER(i32),  PARAMETER:: THOU60     = 60000
  !
  !---------------------------------------------------------------------------------------------------
  !
  REAL(DBL),     PARAMETER:: PI         =     3.141592653589793_dbl
  REAL(DBL),     PARAMETER:: TWOPI      =     6.283185307179586_dbl
  REAL(DBL),     PARAMETER:: DNEG       =    -1_dbl
  REAL(DBL),     PARAMETER:: DZ         =     0_dbl
  REAL(DBL),     PARAMETER:: UNO        =     1_dbl
  REAL(DBL),     PARAMETER:: DOS        =     2_dbl
  REAL(DBL),     PARAMETER:: TRES       =     3_dbl
  REAL(DBL),     PARAMETER:: QUAD       =     4_dbl
  REAL(DBL),     PARAMETER:: CINCO      =     5_dbl
  REAL(DBL),     PARAMETER:: DIEZ       =    10_dbl
  REAL(DBL),     PARAMETER:: VIGINTI    =    20_dbl
  REAL(DBL),     PARAMETER:: SEXAGEN    =    60_dbl
  REAL(DBL),     PARAMETER:: HECTO      =   100_dbl
  REAL(DBL),     PARAMETER:: QUINCEN    =   500_dbl
  REAL(DBL),     PARAMETER:: KILO       =  1000_dbl
  !
  !---------------------------------------------------------------------------------------------------
  !
  REAL(DBL),     PARAMETER:: D3         =  1E3_dbl
  REAL(DBL),     PARAMETER:: D5         =  1E5_dbl
  REAL(DBL),     PARAMETER:: D6         =  1E6_dbl
  REAL(DBL),     PARAMETER:: D10        =  1E10_dbl
  REAL(DBL),     PARAMETER:: D29        =  1E29_dbl
  REAL(DBL),     PARAMETER:: D30        =  1E30_dbl
  REAL(DBL),     PARAMETER:: D40        =  1E40_dbl
  REAL(DBL),     PARAMETER:: D50        =  1E50_dbl
  REAL(DBL),     PARAMETER:: D99        =  1E99_dbl
  REAL(DBL),     PARAMETER:: D100       = 1E100_dbl
  REAL(DBL),     PARAMETER:: D200       = 1E200_dbl
  REAL(DBL),     PARAMETER:: D250       = 1E250_dbl
  REAL(DBL),     PARAMETER:: D300       = 1E300_dbl
  !
  !---------------------------------------------------------------------------------------------------
  !
  REAL(DBL),     PARAMETER:: DODRANT    = 0.75_dbl
  REAL(DBL),     PARAMETER:: HALF       =   0.5_dbl
  REAL(DBL),     PARAMETER:: THIRD      = 0.33333333333333333_dbl
  REAL(DBL),     PARAMETER:: FOURTH     = 0.25_dbl
  REAL(DBL),     PARAMETER:: FIFTH      = 0.2_dbl
  REAL(DBL),     PARAMETER:: TENTH      = 0.1_dbl
  REAL(DBL),     PARAMETER:: CENTI      = 0.01_dbl
  REAL(DBL),     PARAMETER:: MILLI      = 0.001_dbl
  REAL(DBL),     PARAMETER:: DECIMILLI  = 0.0001_dbl
  !
  !---------------------------------------------------------------------------------------------------
  !
  REAL(DBL),     PARAMETER:: negD100    = -1E100_dbl
  REAL(DBL),     PARAMETER:: negD200    = -1E200_dbl
  REAL(DBL),     PARAMETER:: negD250    = -1E250_dbl
  REAL(DBL),     PARAMETER:: negD300    = -1E300_dbl
  !
  !---------------------------------------------------------------------------------------------------
  !
  REAL(DBL),     PARAMETER:: YEARTOL_05 = 1.590E-8_dbl  ! ~ 0.5 second in years
  REAL(DBL),     PARAMETER:: YEARTOL    = 3.960E-8_dbl  ! ~ 1.25 seconds in years
  REAL(DBL),     PARAMETER:: YEARTOL_1  = 3.190E-8_dbl  ! ~ 1.0 second in years
  REAL(DBL),     PARAMETER:: YEARTOL_5  = 1.590E-7_dbl  ! ~ 5.0 second in years
  REAL(DBL),     PARAMETER:: YEARTOL_10 = 3.175E-7_dbl  ! ~ 10. second in years
  REAL(DBL),     PARAMETER:: YEARTOL_60 = 1.905E-6_dbl  ! ~ 60. second in years
  !
  !---------------------------------------------------------------------------------------------------
  ! FOR CHECKING < DZ
  REAL(DBL),     PARAMETER:: NEARZERO_3  = 1E-3_dbl
  REAL(DBL),     PARAMETER:: NEARZERO_5  = 1E-5_dbl
  REAL(DBL),     PARAMETER:: NEARZERO_6  = 1E-6_dbl
  REAL(DBL),     PARAMETER:: NEARZERO_7  = 1E-7_dbl
  REAL(DBL),     PARAMETER:: NEARZERO_10 = 1E-10_dbl
  REAL(DBL),     PARAMETER:: NEARZERO_12 = 1E-12_dbl  !COMMON PRECISION ERROR
  REAL(DBL),     PARAMETER:: NEARZERO_14 = 1E-14_dbl
  REAL(DBL),     PARAMETER:: NEARZERO_15 = 1E-15_dbl
  REAL(DBL),     PARAMETER:: NEARZERO_20 = 1E-20_dbl
  REAL(DBL),     PARAMETER:: NEARZERO_29 = 1E-29_dbl  !SNGL LIMIT ~1E-38, DBLE LIMT ~1D-308
  REAL(DBL),     PARAMETER:: NEARZERO_30 = 1E-30_dbl
  !
  !---------------------------------------------------------------------------------------------------
  ! FOR CHECKING > UNO  
  REAL(DBL),     PARAMETER:: NEAR_ONE    = 1.000000001_dbl  !NEAR_ONE_9
  REAL(DBL),     PARAMETER:: NEAR_ONE_3  = 1.001_dbl
  REAL(DBL),     PARAMETER:: NEAR_ONE_5  = 1.00001_dbl
  REAL(DBL),     PARAMETER:: NEAR_ONE_7  = 1.0000001_dbl
  REAL(DBL),     PARAMETER:: NEAR_ONE_10 = 1.0000000001_dbl
  !
  ! FOR CHECKING > UNO  
  REAL(DBL),     PARAMETER:: SUB_ONE     = 0.999999999_dbl  !NEAR_ONE_9
  REAL(DBL),     PARAMETER:: SUB_ONE_3   = 0.999_dbl
  REAL(DBL),     PARAMETER:: SUB_ONE_5   = 0.99999_dbl
  REAL(DBL),     PARAMETER:: SUB_ONE_7   = 0.9999999_dbl
  REAL(DBL),     PARAMETER:: SUB_ONE_10  = 0.9999999999_dbl
  !
  !---------------------------------------------------------------------------------------------------
  !
  REAL(DBL),     PARAMETER:: NEGNEARZERO_3  = -1E-3_dbl
  REAL(DBL),     PARAMETER:: NEGNEARZERO_5  = -1E-5_dbl
  REAL(DBL),     PARAMETER:: NEGNEARZERO_6  = -1E-6_dbl
  REAL(DBL),     PARAMETER:: NEGNEARZERO_7  = -1E-7_dbl
  REAL(DBL),     PARAMETER:: NEGNEARZERO_8  = -1E-8_dbl
  REAL(DBL),     PARAMETER:: NEGNEARZERO_10 = -1E-10_dbl
  REAL(DBL),     PARAMETER:: NEGNEARZERO_12 = -1E-12_dbl
  REAL(DBL),     PARAMETER:: NEGNEARZERO_15 = -1E-15_dbl
  REAL(DBL),     PARAMETER:: NEGNEARZERO_30 = -1E-30_dbl
  !
  !---------------------------------------------------------------------------------------------------
  !
  INTEGER(i32),  PARAMETER:: inf_I       =  HUGE(Z)
  REAL(DBL),     PARAMETER:: inf         =  HUGE(DZ)
  REAL(DBL),     PARAMETER:: ninf        = -HUGE(DZ)
  INTEGER(i32),  PARAMETER:: ninf_I      = -HUGE(Z)
  !
  REAL(SNG),     PARAMETER::  inf_R      =  HUGE(1.0_sng)
  REAL(SNG),     PARAMETER:: ninf_R      = -HUGE(inf_R)
  !              
  REAL(DBL),     PARAMETER:: SNGL_inf    =  3.4E38_dbl   !Close to Single Precision INF =  3.4028235E+38
  REAL(DBL),     PARAMETER:: SNGL_ninf   = -3.4E38_dbl   !Close to Single Precision INF = -3.4028235E+38
  REAL(SNG),     PARAMETER:: SNGL_inf_R  =  3.4E38_sng   !dito
  REAL(SNG),     PARAMETER:: SNGL_ninf_R = -3.4E38_sng   !dito
  !
  REAL(DBL),     PARAMETER:: NEAR_inf    = HUGE(DZ)*0.99999_dbl
  INTEGER(i32),  PARAMETER:: NEAR_inf_I  = inf_I - EIGHT
  !
  REAL(DBL),     PARAMETER:: NEAR_ninf   = -HUGE(DZ)*0.99999_dbl
  !
  !---------------------------------------------------------------------------------------------------
  !
  REAL(SNG),     PARAMETER:: LOG_2_R     = LOG(2.0_SNG)
  REAL(DBL),     PARAMETER:: LOG_2       = LOG(2.0_DBL)
  !
  !---------------------------------------------------------------------------------------------------
  !
  INTEGER(i64),  PARAMETER:: LONG_NEG    = -1_i64
  INTEGER(i64),  PARAMETER:: LONG_ZER    =  0_i64
  INTEGER(i64),  PARAMETER:: LONG_ONE    =  1_i64
  INTEGER(i64),  PARAMETER:: LONG_TWO    =  2_i64
  INTEGER(i64),  PARAMETER:: LONG_TEN    = 10_i64
  !
  INTEGER(i64),  PARAMETER:: LONG_inf_I  =  INT( inf_I, i64)
  INTEGER(i64),  PARAMETER:: LONG_ninf_I =  INT(ninf_I, i64)
  !
  !#########################################################################
  !
  INTERFACE GET_NAN  !MAKE X = NaN ==> X = GET_NAN(X)
    MODULE PROCEDURE GET_REAL_NAN  !(X)   X => REAL
    MODULE PROCEDURE GET_DBLE_NAN  !(X)   X => DOUBLE PRECISION
  END INTERFACE
  !
  !------------------------------------------------------------------------
  !
  INTERFACE SET_NAN  !MAKE X = NaN ==> CALL SET_NAN(X)
    MODULE PROCEDURE SET_REAL_NAN!(X)
    MODULE PROCEDURE SET_DBLE_NAN!(X)
  END INTERFACE
  !
  !#########################################################################
  !
  CONTAINS
  !
  IMPURE ELEMENTAL FUNCTION GET_REAL_NAN(X) RESULT(NaN)
     REAL(SNG), INTENT(IN):: X
     REAL(SNG):: NaN
     CALL SET_REAL_NAN(NaN)
  END FUNCTION
  !
  IMPURE ELEMENTAL FUNCTION GET_DBLE_NAN(X) RESULT(NaN)
     REAL(DBL), INTENT(IN):: X
     REAL(DBL):: NaN
     CALL  SET_DBLE_NAN(NaN)
  END FUNCTION 
  !
  IMPURE ELEMENTAL SUBROUTINE SET_REAL_NAN(NaN)
     REAL(SNG), INTENT(OUT):: NaN
     REAL(SNG),        SAVE:: NaN_REL=0.0
     LOGICAL,             SAVE:: SET_REL=TRUE
     !
     IF(SET_REL) THEN
        SET_REL = FALSE
                           BLOCK
                                CHARACTER(3):: CNAN
                                CNAN = 'NaN'
                                READ(CNAN,*) NaN_REL
                           END BLOCK
     END IF
     !
     NaN = NaN_REL
     !
  END SUBROUTINE  
  !
  IMPURE ELEMENTAL SUBROUTINE SET_DBLE_NAN(NaN)
     REAL(DBL), INTENT(OUT):: NaN
     REAL(DBL),        SAVE:: NaN_DBL = DZ
     LOGICAL,                 SAVE:: SET_DBL  = TRUE
     !
     IF(SET_DBL) THEN
        SET_DBL = FALSE
                           BLOCK
                                CHARACTER(3):: CNAN
                                CNAN = 'NaN'
                                READ(CNAN,*) NaN_DBL
                           END BLOCK
     END IF
     !
     NaN = NaN_DBL
     !
  END SUBROUTINE  
  !
END MODULE
!
!
!
!
MODULE NAME_ID_INTERFACE
  USE CONSTANTS
  USE, INTRINSIC:: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN
  IMPLICIT NONE
  !
  PRIVATE
  PUBLIC:: NAME_ID, ID_TYPE_BASE
  !
  TYPE ID_TYPE_BASE
      INTEGER,                          ALLOCATABLE:: IVAL
      INTEGER, DIMENSION(:),            ALLOCATABLE:: IVEC
      INTEGER, DIMENSION(:,:),          ALLOCATABLE:: IARR
      DOUBLE PRECISION,                 ALLOCATABLE:: DVAL
      DOUBLE PRECISION, DIMENSION(:),   ALLOCATABLE:: DVEC
      DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE:: DARR
  END TYPE
  !
  TYPE NAME_ID
      INTEGER:: N = Z
      CHARACTER(TWENTY), DIMENSION(:), ALLOCATABLE:: NAM
      TYPE(ID_TYPE_BASE),DIMENSION(:), ALLOCATABLE:: PT
      !
      CONTAINS
      !
      PROCEDURE, PASS(TYP):: INIT         =>         ALLOC_NAME_ID_TYPE  !(DIM)
      PROCEDURE, PASS(TYP):: SET_NAM      =>       SET_NAM_NAME_ID_TYPE  !(POS, NAM)
      PROCEDURE, PASS(TYP):: SET_ID_ALLOC =>  SET_ID_ALLOC_NAME_ID_TYPE  !(POS, IVAL, IVEC, IARR, DVAL, DVEC, DARR)
      PROCEDURE, PASS(TYP):: ALLOC_ID     =>      ALLOC_ID_NAME_ID_TYPE  !DEFINE DIM instead => (POS, IVAL, IVEC, IARR1, IARR2, DVAL, DVEC, DARR1, DARR2)
      GENERIC             :: SET_ID       => SET_ID_BY_POS_NAME_ID_TYPE, & !(NAM, IVAL, IVEC, IARR, DVAL, DVEC, DARR)
                                             SET_ID_BY_NAM_NAME_ID_TYPE    !(POS, IVAL, IVEC, IARR, DVAL, DVEC, DARR)
      PROCEDURE, PASS(TYP):: NAM_POS => GET_NAM_POS_NAME_ID_TYPE           !(NAM) 
      PROCEDURE, PASS(TYP):: GET_ID  => GET_ID_BY_NAM_NAME_ID_TYPE         !(NAM, ERR_IVAL, ERR_DVAL, IVAL, IVEC, IARR, DVAL, DVEC, DARR)
      
      PROCEDURE, PASS(TYP), PRIVATE:: SET_ID_BY_POS_NAME_ID_TYPE 
      PROCEDURE, PASS(TYP), PRIVATE:: SET_ID_BY_NAM_NAME_ID_TYPE
  END TYPE
  !
  CONTAINS
  !
  PURE SUBROUTINE ALLOC_NAME_ID_TYPE(TYP, DIM) !Allocate %NAM and %PT    
    CLASS(NAME_ID), INTENT(INOUT):: TYP
    INTEGER,        INTENT(IN   ):: DIM
    !
    IF(ALLOCATED(TYP%PT)) DEALLOCATE(TYP%PT)
    !
    IF(DIM > Z) THEN
                  ALLOCATE(TYP%NAM(DIM))
                  ALLOCATE(TYP%PT (DIM))
                  TYP%N = DIM
    ELSE
                  TYP%N     = Z
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_NAM_NAME_ID_TYPE(TYP, POS, NAM)  !SET %NAM 
    CLASS(NAME_ID), INTENT(INOUT):: TYP
    INTEGER,        INTENT(IN   ):: POS
    CHARACTER(*),   INTENT(IN   ):: NAM
    !
    TYP%NAM(POS) = NAM
    !
  END SUBROUTINE
  !
  PURE FUNCTION GET_NAM_POS_NAME_ID_TYPE(TYP, NAM) RESULT(POS)  !RETURN NAME POSITION
    CLASS(NAME_ID), INTENT(IN):: TYP
    CHARACTER(*),   INTENT(IN):: NAM
    INTEGER:: POS
    INTEGER:: I
    !
    POS = Z
    DO I=ONE, TYP%N
                   IF(NAM == TYP%NAM(POS)) THEN
                                                  POS = I
                                                  EXIT
                   END IF
    END DO
    !
  END FUNCTION
  !
  PURE SUBROUTINE SET_ID_ALLOC_NAME_ID_TYPE(TYP, POS, IVAL, IVEC, IARR, DVAL, DVEC, DARR) !ALLOC and SET %PT 
    CLASS(NAME_ID),                             INTENT(INOUT):: TYP
    INTEGER,                                    INTENT(IN):: POS
    INTEGER,                          OPTIONAL, INTENT(IN):: IVAL
    INTEGER, DIMENSION(:),            OPTIONAL, INTENT(IN):: IVEC
    INTEGER, DIMENSION(:,:),          OPTIONAL, INTENT(IN):: IARR
    DOUBLE PRECISION,                 OPTIONAL, INTENT(IN):: DVAL
    DOUBLE PRECISION, DIMENSION(:),   OPTIONAL, INTENT(IN):: DVEC
    DOUBLE PRECISION, DIMENSION(:,:), OPTIONAL, INTENT(IN):: DARR
    !
    ASSOCIATE(PT => TYP%PT(POS))
       !
       IF(PRESENT(IVAL)) THEN; IF(ALLOCATED(PT%IVAL)) DEALLOCATE(PT%IVAL); ALLOCATE(PT%IVAL, SOURCE=IVAL); END IF
       IF(PRESENT(IVEC)) THEN; IF(ALLOCATED(PT%IVEC)) DEALLOCATE(PT%IVEC); ALLOCATE(PT%IVEC, SOURCE=IVEC); END IF
       IF(PRESENT(IARR)) THEN; IF(ALLOCATED(PT%IARR)) DEALLOCATE(PT%IARR); ALLOCATE(PT%IARR, SOURCE=IARR); END IF
       IF(PRESENT(DVAL)) THEN; IF(ALLOCATED(PT%DVAL)) DEALLOCATE(PT%DVAL); ALLOCATE(PT%DVAL, SOURCE=DVAL); END IF
       IF(PRESENT(DVEC)) THEN; IF(ALLOCATED(PT%DVEC)) DEALLOCATE(PT%DVEC); ALLOCATE(PT%DVEC, SOURCE=DVEC); END IF
       IF(PRESENT(DARR)) THEN; IF(ALLOCATED(PT%DARR)) DEALLOCATE(PT%DARR); ALLOCATE(PT%DARR, SOURCE=DARR); END IF
    END ASSOCIATE
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOC_ID_NAME_ID_TYPE(TYP, POS, IVAL, IVEC, IARR1, IARR2, DVAL, DVEC, DARR1, DARR2) ! ALLOC %PT
    CLASS(NAME_ID),      INTENT(INOUT):: TYP
    INTEGER,             INTENT(IN):: POS
    INTEGER, OPTIONAL,   INTENT(IN):: IVAL
    INTEGER, OPTIONAL,   INTENT(IN):: IVEC
    INTEGER, OPTIONAL,   INTENT(IN):: IARR1, IARR2
    INTEGER, OPTIONAL,   INTENT(IN):: DVAL
    INTEGER, OPTIONAL,   INTENT(IN):: DVEC
    INTEGER, OPTIONAL,   INTENT(IN):: DARR1, DARR2
    !
    ASSOCIATE(PT => TYP%PT(POS))
       !
       IF(PRESENT(IVAL )) THEN; IF(.NOT. ALLOCATED(PT%IVAL))                ALLOCATE(PT%IVAL);              END IF
       IF(PRESENT(IVEC )) THEN; IF(ALLOCATED(PT%IVEC)) DEALLOCATE(PT%IVEC); ALLOCATE(PT%IVEC(IVEC));        END IF
       IF(PRESENT(IARR1)) THEN; IF(ALLOCATED(PT%IARR)) DEALLOCATE(PT%IARR); ALLOCATE(PT%IARR(IARR1,IARR2)); END IF
       IF(PRESENT(DVAL )) THEN; IF(.NOT. ALLOCATED(PT%DVAL))                ALLOCATE(PT%DVAL);              END IF
       IF(PRESENT(DVEC )) THEN; IF(ALLOCATED(PT%DVEC)) DEALLOCATE(PT%DVEC); ALLOCATE(PT%DVEC(DVEC));        END IF
       IF(PRESENT(DARR1)) THEN; IF(ALLOCATED(PT%DARR)) DEALLOCATE(PT%DARR); ALLOCATE(PT%DARR(DARR1,DARR2)); END IF
    END ASSOCIATE
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_ID_BY_POS_NAME_ID_TYPE(TYP, POS, IVAL, IVEC, IARR, DVAL, DVEC, DARR)  ! SET %PT 
    CLASS(NAME_ID),                             INTENT(INOUT)::TYP
    INTEGER,                                    INTENT(IN):: POS
    INTEGER,                          OPTIONAL, INTENT(IN):: IVAL
    INTEGER, DIMENSION(:),            OPTIONAL, INTENT(IN):: IVEC
    INTEGER, DIMENSION(:,:),          OPTIONAL, INTENT(IN):: IARR
    DOUBLE PRECISION,                 OPTIONAL, INTENT(IN):: DVAL
    DOUBLE PRECISION, DIMENSION(:),   OPTIONAL, INTENT(IN):: DVEC
    DOUBLE PRECISION, DIMENSION(:,:), OPTIONAL, INTENT(IN):: DARR
    !
    ASSOCIATE(PT => TYP%PT(POS))
       !
       IF(PRESENT(IVAL)) THEN; IF(ALLOCATED(PT%IVAL)) PT%IVAL = IVAL; END IF
       IF(PRESENT(IVEC)) THEN; IF(ALLOCATED(PT%IVEC)) PT%IVEC = IVEC; END IF
       IF(PRESENT(IARR)) THEN; IF(ALLOCATED(PT%IARR)) PT%IARR = IARR; END IF
       IF(PRESENT(DVAL)) THEN; IF(ALLOCATED(PT%DVAL)) PT%DVAL = DVAL; END IF
       IF(PRESENT(DVEC)) THEN; IF(ALLOCATED(PT%DVEC)) PT%DVEC = DVEC; END IF
       IF(PRESENT(DARR)) THEN; IF(ALLOCATED(PT%DARR)) PT%DARR = DARR; END IF
    END ASSOCIATE
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_ID_BY_NAM_NAME_ID_TYPE(TYP, NAM, IVAL, IVEC, IARR, DVAL, DVEC, DARR)  ! SET %PT 
    CLASS(NAME_ID),                             INTENT(INOUT)::TYP
    CHARACTER(*),                               INTENT(IN):: NAM
    INTEGER,                          OPTIONAL, INTENT(IN):: IVAL
    INTEGER, DIMENSION(:),            OPTIONAL, INTENT(IN):: IVEC
    INTEGER, DIMENSION(:,:),          OPTIONAL, INTENT(IN):: IARR
    DOUBLE PRECISION,                 OPTIONAL, INTENT(IN):: DVAL
    DOUBLE PRECISION, DIMENSION(:),   OPTIONAL, INTENT(IN):: DVEC
    DOUBLE PRECISION, DIMENSION(:,:), OPTIONAL, INTENT(IN):: DARR
    INTEGER:: I
    !
    DO I=ONE, TYP%N
    IF(NAM == TYP%NAM(I)) THEN
    ASSOCIATE(PT => TYP%PT(I))
       !
       IF(PRESENT(IVAL)) THEN; IF(ALLOCATED(PT%IVAL)) PT%IVAL = IVAL; END IF
       IF(PRESENT(IVEC)) THEN; IF(ALLOCATED(PT%IVEC)) PT%IVEC = IVEC; END IF
       IF(PRESENT(IARR)) THEN; IF(ALLOCATED(PT%IARR)) PT%IARR = IARR; END IF
       IF(PRESENT(DVAL)) THEN; IF(ALLOCATED(PT%DVAL)) PT%DVAL = DVAL; END IF
       IF(PRESENT(DVEC)) THEN; IF(ALLOCATED(PT%DVEC)) PT%DVEC = DVEC; END IF
       IF(PRESENT(DARR)) THEN; IF(ALLOCATED(PT%DARR)) PT%DARR = DARR; END IF
    END ASSOCIATE
    EXIT
    END IF
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE GET_ID_BY_NAM_NAME_ID_TYPE(TYP, NAM, ERR_IVAL, ERR_DVAL, IVAL, IVEC, IARR, DVAL, DVEC, DARR)  ! GET %PT 
    CLASS(NAME_ID),                             INTENT(IN):: TYP
    CHARACTER(*),                               INTENT(IN):: NAM
    INTEGER,                          OPTIONAL, INTENT(IN):: ERR_IVAL
    DOUBLE PRECISION,                 OPTIONAL, INTENT(IN):: ERR_DVAL
    INTEGER,                          OPTIONAL, INTENT(INOUT):: IVAL
    INTEGER, DIMENSION(:),            OPTIONAL, INTENT(INOUT):: IVEC
    INTEGER, DIMENSION(:,:),          OPTIONAL, INTENT(INOUT):: IARR
    DOUBLE PRECISION,                 OPTIONAL, INTENT(INOUT):: DVAL
    DOUBLE PRECISION, DIMENSION(:),   OPTIONAL, INTENT(INOUT):: DVEC
    DOUBLE PRECISION, DIMENSION(:,:), OPTIONAL, INTENT(INOUT):: DARR
    INTEGER:: I
    DOUBLE PRECISION:: NaN
    !
    IF(PRESENT(ERR_IVAL)) THEN
                          IF(PRESENT(IVAL)) IVAL = ERR_IVAL
                          IF(PRESENT(IVEC)) IVEC = ERR_IVAL
                          IF(PRESENT(IARR)) IARR = ERR_IVAL
    ELSE                  
                          IF(PRESENT(IVAL)) IVAL = inf_I
                          IF(PRESENT(IVEC)) IVEC = inf_I
                          IF(PRESENT(IARR)) IARR = inf_I
    END IF
    !
    IF(PRESENT(ERR_DVAL)) THEN
                          IF(PRESENT(DVAL)) DVAL = ERR_DVAL
                          IF(PRESENT(DVEC)) DVEC = ERR_DVAL
                          IF(PRESENT(DARR)) DARR = ERR_DVAL
    ELSE     
                          NaN = IEEE_VALUE(NaN, IEEE_QUIET_NAN)
                          !           
                          IF(PRESENT(DVAL)) DVAL = NaN
                          IF(PRESENT(DVEC)) DVEC = NaN
                          IF(PRESENT(DARR)) DARR = NaN
    END IF
    !
    DO I=ONE, TYP%N
    IF(NAM == TYP%NAM(I)) THEN
    ASSOCIATE(PT => TYP%PT(I))
       !
       IF(PRESENT(IVAL)) THEN; IF(ALLOCATED(PT%IVAL)) IVAL = PT%IVAL; END IF
       IF(PRESENT(IVEC)) THEN; IF(ALLOCATED(PT%IVEC)) IVEC = PT%IVEC; END IF
       IF(PRESENT(IARR)) THEN; IF(ALLOCATED(PT%IARR)) IARR = PT%IARR; END IF
       IF(PRESENT(DVAL)) THEN; IF(ALLOCATED(PT%DVAL)) DVAL = PT%DVAL; END IF
       IF(PRESENT(DVEC)) THEN; IF(ALLOCATED(PT%DVEC)) DVEC = PT%DVEC; END IF
       IF(PRESENT(DARR)) THEN; IF(ALLOCATED(PT%DARR)) DARR = PT%DARR; END IF
    END ASSOCIATE
    EXIT
    END IF
    END DO
    !
  END SUBROUTINE
  !
  !!!!PURE SUBROUTINE EXTEND_ID_VAL_TYPE(TYP, ID, VAL)
  !!!!  CLASS(ID_VAL_TYPE), INTENT(INOUT)::TYP
  !!!!  INTEGER,            INTENT(IN   ):: ID
  !!!!  DOUBLE PRECISION,   INTENT(IN   ):: VAL
  !!!!  TYPE (ID_VAL_TYPE):: EXT
  !!!!  !
  !!!!  TYP%INUSE = TRUE
  !!!!  !
  !!!!  IF(TYP%N == Z) THEN
  !!!!                TYP%N = ONE
  !!!!                !
  !!!!                ALLOCATE( TYP%PT(TYP%N) )
  !!!!                TYP%PT(TYP%N)%ID = ID;   TYP%PT(TYP%N)%VAL = VAL
  !!!!  ELSE
  !!!!                EXT%N = TYP%N + ONE
  !!!!                !
  !!!!                ALLOCATE( EXT%PT (EXT%N) )
  !!!!                EXT%PT(:TYP%N)  = TYP%PT
  !!!!                !
  !!!!                EXT%PT(EXT%N)%ID = ID;   EXT%PT(EXT%N)%VAL = VAL
  !!!!                !
  !!!!                CALL MOVE_ALLOC(EXT%PT,  TYP%PT)
  !!!!                TYP%N = EXT%N
  !!!!  END IF
  !!!!END SUBROUTINE
  !

END MODULE
!
!!
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
MODULE SIMPLE_TIMER_INSTRUCTION
  USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: DBL => REAL64
  PRIVATE
  PUBLIC:: SIMPLE_TIMER
  !
  TYPE SIMPLE_TIMER
      INTEGER  :: EPOCH     = 0
      INTEGER  :: FINISH    = 0
      REAL(DBL):: ClockRate = -999_DBL
      !
      CONTAINS
      !
      PROCEDURE, PASS(TIMER):: INIT     =>    INIT_SIMPLE_TIMER   !()       - Optional, sets up ClockRate
      PROCEDURE, PASS(TIMER):: START    =>   START_SIMPLE_TIMER   !()       - Start the timer
      PROCEDURE, PASS(TIMER):: LAP      =>     LAP_SIMPLE_TIMER   !(SEC)    - SEC is set to the number of sections since start of last lap
      PROCEDURE, PASS(TIMER):: ELAPSED  => ELAPSED_SIMPLE_TIMER   !(SEC)    - SEC is set to the number of sections since %START()
      PROCEDURE, PASS(TIMER):: PRINT_LAP=> PRINT_LAP_SIMPLE_TIMER !([TEXT]) - write to prompt elapsed time in seconds since start of last lap
      !
  END TYPE 
  !
  CONTAINS
  !
  SUBROUTINE INIT_SIMPLE_TIMER(TIMER)
    CLASS(SIMPLE_TIMER), INTENT(INOUT):: TIMER
    INTEGER:: I, ClockRate
    !
    TIMER%EPOCH  = 0
    TIMER%FINISH = 0
    !
    CALL SYSTEM_CLOCK(COUNT_RATE=ClockRate)
    !
    IF(ClockRate.LE.0) THEN
                             DO I=1, 1000                                     !  -- Spin a milisecond to prevent mis-fire of subroutine (compiler bug)
                                     CALL SYSTEM_CLOCK(COUNT_RATE=ClockRate)  ! Find the rate  
                                     IF(ClockRate > 0) EXIT
                             END DO
                             IF(ClockRate.LE.0) CALL SYSTEM_CLOCK(COUNT_RATE=ClockRate)
    END IF
    !
    IF(ClockRate > 0 ) THEN
                       TIMER%ClockRate = 1_DBL / REAL(ClockRate, DBL)
    ELSE
                       TIMER%ClockRate = 0_DBL
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE GET_SYSTEM_CLOCK_COUNT(TIMER, IVAL)
    CLASS(SIMPLE_TIMER), INTENT(IN   ):: TIMER
    INTEGER,             INTENT(INOUT):: IVAL
    INTEGER:: I
    !
    IF(TIMER%ClockRate < 1.0E-250_DBL) THEN
                                   IVAL = TIMER%EPOCH
    ELSE
        CALL SYSTEM_CLOCK(COUNT=IVAL)
        !
        IF(IVAL.LE.0) THEN
                      DO I=1, 1000                                   !  -- Spin a milisecond to prevent mis-fire of subroutine (compiler bug)
                              CALL SYSTEM_CLOCK(COUNT=IVAL)  ! Find the rate  
                              IF(IVAL > 0) EXIT
                      END DO
                      IF(IVAL.LE.0) CALL SYSTEM_CLOCK(COUNT=IVAL)
        END IF
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE START_SIMPLE_TIMER(TIMER)
    CLASS(SIMPLE_TIMER), INTENT(INOUT):: TIMER
    !
    IF(TIMER%ClockRate < 1.0E-250_DBL) CALL INIT_SIMPLE_TIMER(TIMER)
    !
    CALL GET_SYSTEM_CLOCK_COUNT(TIMER, TIMER%EPOCH)
    !
    TIMER%FINISH = TIMER%EPOCH
    !
  END SUBROUTINE
  !
  SUBROUTINE ELAPSED_SIMPLE_TIMER(TIMER, SEC)
    CLASS(SIMPLE_TIMER), INTENT(INOUT):: TIMER
    REAL(DBL),           INTENT(INOUT):: SEC
    !
    CALL GET_SYSTEM_CLOCK_COUNT(TIMER, TIMER%FINISH)
    !
    IF(TIMER%FINISH .LE. TIMER%EPOCH) THEN
        SEC = 0_DBL
    ELSE
        SEC = REAL( TIMER%FINISH-TIMER%EPOCH, DBL ) * TIMER%ClockRate
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE LAP_SIMPLE_TIMER(TIMER, SEC)
    CLASS(SIMPLE_TIMER), INTENT(INOUT):: TIMER
    REAL(DBL),           INTENT(INOUT):: SEC
    INTEGER:: LAP
    !
    CALL GET_SYSTEM_CLOCK_COUNT(TIMER, LAP)
    !
    IF(LAP .LE. TIMER%EPOCH) THEN
                SEC = 0_DBL
                TIMER%FINISH = TIMER%EPOCH
    ELSE
                SEC = REAL( LAP-TIMER%FINISH, DBL ) * TIMER%ClockRate
                TIMER%FINISH = LAP
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_LAP_SIMPLE_TIMER(TIMER, TXT)
    CLASS(SIMPLE_TIMER),           INTENT(INOUT):: TIMER
    CHARACTER(*),        OPTIONAL, INTENT(IN   ):: TXT
    REAL(DBL):: SEC
    !
    CALL LAP_SIMPLE_TIMER(TIMER, SEC)
    !
    IF(PRESENT(TXT)) THEN
                     WRITE(*,'(A,F16.3)') TXT, SEC
    ELSE
                     WRITE(*,'(F16.3)') SEC
    END IF
    !
  END SUBROUTINE
  !
END MODULE!
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
!
MODULE OPENSPEC_LOADER_SUBROUTINE
  !
  CONTAINS
  !
  PURE SUBROUTINE LOAD_OPENSPEC(ACCESS_OUT,FORM_OUT,ACTION_OUT)
  CHARACTER(*),               INTENT(INOUT):: ACCESS_OUT
  CHARACTER(*),               INTENT(INOUT):: FORM_OUT
  CHARACTER(*), DIMENSION(2), INTENT(INOUT):: ACTION_OUT
  !
  !
  ! INCLUDE "OPENSPEC.inc" forced in
  !
  CHARACTER(20):: ACCESS,FORM
  CHARACTER(20), DIMENSION(2):: ACTION(2)
  ACCESS = 'STREAM'
  FORM = 'UNFORMATTED'
  ACTION(1) = 'READ'
  ACTION(2) = 'READWRITE'
  !
  ACCESS_OUT= ACCESS
  FORM_OUT  = FORM
  ACTION_OUT= ACTION
  !
END SUBROUTINE
!
END MODULE
!
MODULE OPENSPEC
  ! ALLOWS FOR IMPORT OF FILE OPTIONS THAT ARE COMPILER FRIENDLY.
  ! THIS PROVIDES A MEANS OF ACCESSING INCLUDE "OPENSPEC.inc" FOR FREE FORMAT FILES (*.f90) VIA A GLOBAL VARIABLE.
  !
  IMPLICIT NONE
  !
  SAVE
  !
  CHARACTER(20),PROTECTED::              ACCESS = ' '  ! WHEN USING BINARY FORMAT THIS IS THE ACCESS ARGUMENT (eg 'STREAM')
  CHARACTER(20),PROTECTED::              FORM   = ' '  ! WHEN USING BINARY FORMAT THIS IS THE FORM   ARGUMENT (eg 'UNFORMATTED')
  CHARACTER(20),PROTECTED,DIMENSION(2):: ACTION = ' '  ! ACTION(1) = 'READ' and ACTION(2) = 'READWRITE'
  !
  CONTAINS
  !
  SUBROUTINE SET_OPENSPEC()
  USE OPENSPEC_LOADER_SUBROUTINE
  !
  CALL LOAD_OPENSPEC(ACCESS,FORM,ACTION)
  !
  END SUBROUTINE
  !
END MODULE
!! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
! MODULE LINKED_LIST_INSTRUCTION   ==>  USE LINKED_LIST_INSTRUCTION, ONLY: INTEGER_LINKED_LIST, CHARACTER_LINKED_LIST
!
!  PROVIDES TWO DATA TYPES THAT ALLOW LINKED LIST OPTIONS (SIMILAR TO PYTHON LIST)
!  LIST CAN BE EITHER COMPOSED OF CHARACTER STRINGS OF DIFFERENT LENGTHS OR INTEGERS.
!  CAN ARBITRARILY ADD VALUES TO LIST, REMOVE THEM AND JUMP TO DIFFERENT POSTIONS.
!     OPTION TO CONVERT LIST TO ALLOCATABLE ARRAY AND OPTIONALLY SORT THE RESULTING ARRAY FROM SMALLEST TO LARGEST    
!
!    --UNKNOWN LIMITATION:
!                        CHANGING A CHARACTER LIST VALUE SEEMS TO CAUSE A COMPILER BUG IF PASSED CHARACTER IS OF LENGTH 1 AND A SUBSET OF A CHARACTER VARIABLE > 1
!
!  VERSION 1.0 [4/23/2017] ORIGINAL VERSION THAT SUPPORTS INTEGER_LINKED_LIST AND CHARACTER_LINKED_LIST DATA TYPES
!                               BEFORE USING LIST YOU MUST "CALL LIST%INIT()" TO EMPTY ANY EXISTING CONTENTS AND INITIALIZE ITS POINTERS.
!
!                               SEE TYPE, EXTENDS(ABSTRACT_LINKED_LIST):: INTEGER_LINKED_LIST and 
!                                   TYPE, EXTENDS(ABSTRACT_LINKED_LIST):: CHARACTER_LINKED_LIST
!                                       FOR SPECIFIC SUBROUTINE OPTIONS
!
!                               SUBROUTINES AVAILIBLE TO BOTH ARE LISTED IN TYPE, ABSTRACT:: ABSTRACT_LINKED_LIST
!
MODULE LINKED_LIST_INSTRUCTION!, ONLY: INTEGER_LINKED_LIST, CHARACTER_LINKED_LIST
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: INTEGER_LINKED_LIST, CHARACTER_LINKED_LIST
  !
  TYPE LINK_ELEMENT
      CLASS(*), ALLOCATABLE:: I !VALUE
      INTEGER:: P=0             !POSITION
      TYPE(LINK_ELEMENT), POINTER:: NXT=>NULL()
      TYPE(LINK_ELEMENT), POINTER:: PRV=>NULL()
      CONTAINS
      FINAL:: DEALLOCATE_LINK_ELEMENT_FINAL
  END TYPE
  !
  TYPE, ABSTRACT:: ABSTRACT_LINKED_LIST
      PRIVATE
      INTEGER:: N=0
      TYPE(LINK_ELEMENT), POINTER:: BEG=>NULL()
      TYPE(LINK_ELEMENT), POINTER:: END=>NULL()
      TYPE(LINK_ELEMENT), POINTER:: CUR=>NULL()
      !
      CONTAINS
      !
      PROCEDURE, PASS(LST):: INIT         => INITIALIZE_LINKED_LIST    ! ()     INITIALIZES TO CREATE NEW LIST, MUST RUN BEFORE USING LIST. IT ALSO RESETS LIST TO INITIAL STATE IF HAS BE ALREADY USED.
      !
      GENERIC::              ADD          => EXTEND_LIST_FROM_ENDING, ADD_VALUE_AT, EXTEND_LIST_FROM_ENDING_VECTOR  ! (VAL,[POS]) PYTHON EQUIVALENT LIST.APPEND(VAL) and LIST.INSERT(VAL,POS)
      !
      PROCEDURE, PASS(LST):: CHANGE       => CHANGE_LIST_VALUE        ! (VAL,[POS],[ERROR]) SETS CURRENT VALUE/POINTER TO PASSED VALUE. IF INTEGER POS IS PROVIDED, THEN IT WILL SET THE VALUE LOCATED AT POSITION POS. IF LOGICAL ERROR IS PROVIDED THEN IT IS SET TO TRUE IF THERE IS AN ERROR WHEN SETTING THE VALUE.
      PROCEDURE, PASS(LST):: START        => MOVE_TO_FIRST_POS        ! ()     SETS CURRENT VALUE/POINTER TO START OF LIST
      PROCEDURE, PASS(LST):: LAST         => MOVE_TO_LAST_POS         ! ()     SETS CURRENT VALUE/POINTER TO END   OF LIST
      PROCEDURE, PASS(LST):: NEXT         => MOVE_TO_NEXT_POS         ! ()     MOVE TO NEXT     VALUE/POINTER WITHIN LIST
      PROCEDURE, PASS(LST):: BACK         => MOVE_TO_PREVIOUS_POS     ! ()     MOVE TO PREVIOUS VALUE/POINTER WITHIN LIST
      PROCEDURE, PASS(LST):: POS          => GOTO_POSITION            ! (P)    GO TO POSITION P WITHIN LIST
      PROCEDURE, PASS(LST):: LEN          => RETURN_LIST_LENGTH       ! ()     RETURNS INTEGER OF CURRENT LENGTH OF LIST
      PROCEDURE, PASS(LST):: GETPOS       => RETURN_LIST_POSITION     ! ()     RETURNS INTEGER OF CURRENT POSITION OF LIST
      PROCEDURE, PASS(LST):: IS_ASSOCIATED=> CUR_IS_ASSOCIATED        ! ()     RETURNS LOGICAL IF CURRENT POSITION IS ASSOCIATED WITH A TARGET. IF NOT ASSOCIATED WOULD INDICATE THAT THE POSITION IS EITHER BEYOND THE END OF THE LIST, BEFORE THE BEGINING OF THE LSIT, OR THE LIST HAS NO VALUES IN IT. -- USEFUL FOR WHILE LOOP WITH NEXT BECAUSE WHEN NEXT MOVES BEYOND THE END OF THE LIST, IT BECOMES NO LONGER ASSOCIATED
      PROCEDURE, PASS(LST):: AT_START     => POS_AT_START_OF_LIST     ! ()     RETURNS LOGICAL IF CURRENT POSITION IS AT START OF LIST. NOTE THAT IT WILL RETURN FALSE IF BEYOND THE BEGINING OF LIST
      PROCEDURE, PASS(LST):: AT_END       => POS_AT_END_OF_LIST       ! ()     RETURNS LOGICAL IF CURRENT POSITION IS AT END   OF LIST. NOTE THAT IT WILL RETURN FALSE IF BEYOND END OF LIST
      PROCEDURE, PASS(LST):: POP          => REMOVE_VAL_AT            !([POS]) REMOVES LAST VALUE IN LIST, "POS" IS OPTIONAL, IF POS IS PRESENT THEN THE VALUE LOCATED AT POSITION POS IS REMOVED. PYTHON LIST.POP([POS])
      PROCEDURE, PASS(LST):: DESTROY      => DELETE_ALL_LINKED_LIST_ENTRIES  !() DELETES ALL VALUES WITHIN THE LIST. THIS ROUTINE IS CALLED WHEN LIST IS DEALLOCATED OR WHEN INIT IS CALLED.
      PROCEDURE, PASS(LST):: EXTEND_LIST_FROM_ENDING                  ! (VAL)      ADDS "VAL" TO END OF LIST,                     PYTHON EQUIVALENT LIST.APPEND(VAL)
      PROCEDURE, PASS(LST):: EXTEND_LIST_FROM_ENDING_VECTOR           ! (VEC)      ADDS IN ORDER THE ITEMS IN VEC TO END OF LIST, PYTHON EQUIVALENT LIST+=VEC
      PROCEDURE, PASS(LST):: ADD_VALUE_AT                             ! (VAL,POS)  ADDS "VAL" TO POSITION POS OF LIST,            PYTHON EQUIVALENT LIST.INSERT(VAL,POS)
  END TYPE
  !
  TYPE, EXTENDS(ABSTRACT_LINKED_LIST):: INTEGER_LINKED_LIST
      CONTAINS
      PROCEDURE, PASS(LST):: INT             => INTEGER_RETURN_VALUE                 ! ([POS]) RETURNS CURRENT POSITIONS INTEGER VALUE, IF POS IS PROVIDED THEN RETURNS THE POS POSITION INTEGER
      GENERIC             :: ADD_UNIQUE      => INTEGER_ADD_UNIQUE_VALUE_TO_ENDING, &! (IVAL,[POS])  ADDS IVAL TO END OF LIST ONLY IF IT IS NOT CURRENTLY PRESENT WITHIN THE LIST. POS IS OPTIONAL AND SET TO ZERO IF NOT FOUND OTHERWISE IS THE NON-UNIQUE LOCATION
                                                INTEGER_ADD_UNIQUE_VALUE_TO_ENDING_VECTOR!(VEC)
      PROCEDURE, PASS(LST):: IS_UNIQUE       => INTEGER_VALUE_UNIQUE_IN_LIST         ! (IVAL)  RETURNS LOGICAL THAT CHECKS IF IVAL IS WITHIN THE LIST. RETURNS TRUE IF IT IS NO WITHIN LIST (VIZ ITS UNIQUE).
      PROCEDURE, PASS(LST):: NOT_UNIQUE      => INTEGER_VALUE_NOT_UNIQUE_IN_LIST     ! (IVAL)  OPPOSITE OF ABOVE
      PROCEDURE, PASS(LST):: SORT            => INTEGER_SORT_LIST                    ! ([REVERSE])
      PROCEDURE, PASS(LST):: MAX             => INTEGER_LIST_MAXVAL                  ! () RETURNS MAX THE VALUE WITHIN THE LIST
      PROCEDURE, PASS(LST):: MIN             => INTEGER_LIST_MINVAL                  ! () RETURNS MIN THE VALUE WITHIN THE LIST
      PROCEDURE, PASS(LST):: REVERSE         => INTEGER_REVERSE_LIST                 ! () REVERSE THE ORDER OF THE LIST
      PROCEDURE, PASS(LST):: DROP_DUPLICATES => INTEGER_LIST_DROP_DUPLICATES         ! () REMOVES ALL DUBLICATE VALUES WTIHIN THE LIST
      GENERIC::              TOARRAY         => INTEGER_LIST_TO_ARRAY_ALLOCATABLE, & ! (ARR,[SORT]) CONVERTS LIST TO ONE DIMENSIONAL ARRAY, ARR, WHICH MUST BE DECLARED AS "INTEGER, DIMENSION(:), ALLOCATABLE" OR "INTEGER, DIMENSION(:), POINTER". 
                                                 INTEGER_LIST_TO_ARRAY_POINTER       !              [SORT] IS OPTIONAL AND WHEN PROVIDED AND SET TO TRUE WILL CAUSE THE RESULTING ARRAY TO BE SORTED FROM SMALLEST TO LARGEST.
      PROCEDURE, PASS(LST):: STR             => INTEGER_LIST_RETURN_AS_STRING        !(DELIM, PAD)
      PROCEDURE, PASS(LST), PRIVATE:: INTEGER_LIST_TO_ARRAY_ALLOCATABLE
      PROCEDURE, PASS(LST), PRIVATE:: INTEGER_LIST_TO_ARRAY_POINTER
      PROCEDURE, PASS(LST), PRIVATE:: INTEGER_ADD_UNIQUE_VALUE_TO_ENDING
      PROCEDURE, PASS(LST), PRIVATE:: INTEGER_ADD_UNIQUE_VALUE_TO_ENDING_VECTOR
      FINAL:: INTEGER_LINKED_LIST_DEALLOCATE
  END TYPE
  !
  TYPE, EXTENDS(ABSTRACT_LINKED_LIST):: CHARACTER_LINKED_LIST  !NOTE THAT LIST ENTRIES MUST BE PASSED AS ENTIRE STRING. SUBSTRINGS SEEM TO CAUSE ALLOCATION ERRORS [ ie no CALL LIST%ADD( CHAR(3:6) ) ]
      !PUBLIC:: LN
      CHARACTER(:), POINTER:: ERR => NULL()
      CHARACTER(:), POINTER:: LN  => NULL()  !WHEN SET WITH SET_LN, HOLDS THE CURRENT POSITION STRING, LIST%LN. IT IS SET TO "ERROR" WHEN THE CURRENT POSITION IS NOT ASSOCIATED. IT IS A SHORT TO ACCESS STRING DIRECTLY.
      CONTAINS
      PROCEDURE, PASS(LST):: INIT         => CHAR_INITIALIZE_LINKED_LIST       ! ()      INITIALIZES TO CREATE NEW LIST, MUST RUN BEFORE USING LIST. IT ALSO RESETS LIST TO INITIAL STATE IF HAS BE ALREADY USED.
      PROCEDURE, PASS(LST):: FIRST_LINE   => CHAR_START_LINE                  ! ()      MOVES TO FIRST POSITION AND SETS LIST%LN TO IT
      PROCEDURE, PASS(LST):: NEXT_LINE    => CHAR_NEXT_LINE                   ! ()      MOVES TO NEXT LIST ENTRY AND SETS LIST%LN TO IT
      PROCEDURE, PASS(LST):: SET_LN       => CHAR_SET_LN                      ! ()      SETS LIST%LN TO CURRENT STRING. IF CURRENT POSITION IS NOT ALLOCATED LIST%LN ="ERROR" (VIZ. LIST%LN => LST%CUR%I)
      PROCEDURE, PASS(LST):: CHAR         => CHAR_RETURN_VALUE                ! ([POS]) RETURNS CURRENT STRING, IF CURRENT STRING IS NOT ALLOCATED THEN RETURNS "ERROR"
      PROCEDURE, PASS(LST):: FIND         => CHAR_FIND_VALUE                  ! (STR)   RETURN POS
      PROCEDURE, PASS(LST):: ADD_TRIM     => CHAR_ADD_TRIMMED_VALUE_TO_ENDING ! (STR,POS)  ADDS STR TO END OF LIST. LINE IS TRIMMED BEFORE ADDED.
      PROCEDURE, PASS(LST):: ADD_CORE     => CHAR_ADD_CORE_VALUE_TO_ENDING    ! (STR,POS)  ADDS STR TO END OF LIST. LINE IS ADJUSTL AND TRIMMED BEFORE ADDED.
      PROCEDURE, PASS(LST):: ADD_UNIQUE   => CHAR_ADD_UNIQUE_VALUE_TO_ENDING  ! (STR,POS)  ADDS STR TO END OF LIST ONLY IF IT IS NOT CURRENTLY PRESENT WITHIN THE LIST. POS IS OPTIONAL AND SET TO ZERO IF NOT FOUND OTHERWISE IS THE NON-UNIQUE LOCATION
      PROCEDURE, PASS(LST):: IS_UNIQUE    => CHAR_VALUE_UNIQUE_IN_LIST        ! (STR)  RETURNS LOGICAL THAT CHECKS IF STR IS WITHIN THE LIST. RETURNS TRUE IF IT IS NO WITHIN LIST (VIZ ITS UNIQUE).
      PROCEDURE, PASS(LST):: TOLINE       => RETURN_CHAR_LIST_TO_LINE         ! ([SEP], [EXT], [SEP2]) RETURN SINGLE LINE COMPOSED OF ALL LIST ENTIRIES SEPARATED BY SEP
      PROCEDURE, PASS(LST):: NBACK        => RETURN_CHAR_LIST_NBACK_LINES     ! (NBACK,[SEP])          RETURN SINGLE LINE COMPOSED OF NBACK LINES BEFORE CUR SEPARATED BY SEP
      GENERIC::              TOARRAY      => CHAR_LIST_TO_ARRAY_ALLOCATABLE, &! (ARR,[SORT],[DIM])  CONVERTS LIST TO ONE DIMENSIONAL CHARACTER ARRAY, ARR, WHICH MUST BE DECLARED AS "CHARACTER(:), DIMENSION(:), ALLOCATABLE" OR "CHARACTER(:), DIMENSION(:), POINTER"
                                             CHAR_LIST_TO_ARRAY_POINTER       !      [SORT] IS OPTIONAL AND WHEN PROVIDED AND SET TO TRUE WILL CAUSE THE RESULTING ARRAY TO BE SORTED ALPHABETICALLY.
                                                                              !      [DIM]  IS OPTINOAL AND WHEN PROVIDED WILL SET THE CHARACTER LENGTH, AS CHARACTER(DIM), OTHERWISE THE DIM IS SET TO THE LENGTH OF THE LONGEST STRING IN THE LIST.
      !
      GENERIC::              TOARRAY_ASSUM=> CHAR_LIST_TO_ARRAY_ASSUME_ALLOCATABLE, & ! (ARR,[SORT]) CONVERTS LIST TO ONE DIMENSIONAL CHARACTER ARRAY, ARR, WHICH MUST BE DECLARED AS "CHARACTER(DIM), DIMENSION(:), ALLOCATABLE" OR "CHARACTER(DIM), DIMENSION(:), POINTER". DIM IS SPECIFIED OUTSIDE OF SUBROUTINE AND IS THE FINAL CHARACTER LENGTH.
                                             CHAR_LIST_TO_ARRAY_ASSUME_POINTER        !      [SORT] IS OPTIONAL AND WHEN PROVIDED AND SET TO TRUE WILL CAUSE THE RESULTING ARRAY TO BE SORTED ALPHABETICALLY.
      PROCEDURE, PASS(LST):: MAKE_LINE       => CHAR_LIST_TO_LINE_ALLOCATABLE            ! (LINE,[SEP]) MERGES LIST INTO A SINGLE CHARACTER VARIABLE, LINE, WHICH MUST BE DEFINED AS "CHARACTER(:), ALLOCATABLE". SEP IS OPTINALL AND WHEN PRESENT IS PLACED BETWEEN EACH LIST ENTRY ON LINE. (eg SEP=', ' TO MAKE IT COMMA SEPARATED)
      PROCEDURE, PASS(LST):: MAKE_LINE_ASSUM => CHAR_LIST_TO_LINE_ASSUME                 ! (LINE,[SEP]) SEE ABOVE, BUT IS FOR NON-ALLOCATABLE CHARACTERS. LST WILL BE ADDED TO LINE UNTIL IT REACHES ITS END OR LIST ENDS...WHICH EVER HAPPENS FIRST
      PROCEDURE, PASS(LST):: DESTROY      => CHAR_LINKED_LIST_DEALLOCATE              ! ()   DELETES ALL VALUES WITHIN THE LIST. THIS ROUTINE IS CALLED WHEN LIST IS DEALLOCATED OR WHEN INIT IS CALLED.
      PROCEDURE, PASS(LST), PRIVATE:: CHAR_LIST_TO_ARRAY_ALLOCATABLE
      PROCEDURE, PASS(LST), PRIVATE:: CHAR_LIST_TO_ARRAY_POINTER
      PROCEDURE, PASS(LST), PRIVATE:: CHAR_LIST_TO_ARRAY_ASSUME_ALLOCATABLE
      PROCEDURE, PASS(LST), PRIVATE:: CHAR_LIST_TO_ARRAY_ASSUME_POINTER
      FINAL:: FINAL_CHARACTER_LINKED_LIST_DEALLOCATE
  END TYPE
  !
  CONTAINS
  !
  !#######################################################################
  !
  SUBROUTINE NULLIFY_LINK_ELEMENT(LNK)  !DOES NOT DEALLOCATE MEMORY, ONLY NULLIFIES!!!
     TYPE(LINK_ELEMENT), POINTER, INTENT(INOUT):: LNK
     !
     IF(ASSOCIATED(LNK)) THEN 
            NULLIFY(LNK%PRV)
            NULLIFY(LNK%NXT)
     END IF
     !
     NULLIFY(LNK)
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE INITIALIZE_LINKED_LIST(LST)
    CLASS(ABSTRACT_LINKED_LIST):: LST
    !
    IF(LST%N==0) THEN
       LST%CUR   => NULL()   
       LST%BEG   => NULL()                                             !BEGINING REFERENCE IS NOW LOST
       LST%END   => NULL()                                             !ENDING   REFERENCE IS NOW LOST - NOW ONLY REFERENCE IS WITH LST%CUR
    ELSE
       CALL DELETE_ALL_LINKED_LIST_ENTRIES(LST)
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE RENUMBER_LIST_POSITIONS(LST)
    CLASS(ABSTRACT_LINKED_LIST):: LST
    INTEGER:: I
    !        
    CALL MOVE_TO_FIRST_POS(LST)
    !
    IF(ASSOCIATED(LST%CUR)) THEN
        !
        I = 1
        LST%CUR%P = I
        !
        CALL MOVE_TO_NEXT_POS(LST)
        !
        DO WHILE(ASSOCIATED(LST%CUR))
              !
              I = I + 1
              LST%CUR%P = I
              !
              CALL MOVE_TO_NEXT_POS(LST)
        END DO
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE CHANGE_LIST_VALUE(LST,I,POS,ERROR)
    CLASS(ABSTRACT_LINKED_LIST):: LST
    CLASS(*),          INTENT(IN ):: I
    INTEGER, OPTIONAL, INTENT(IN ):: POS
    LOGICAL, OPTIONAL, INTENT(OUT):: ERROR
    !
    IF(PRESENT(ERROR)) ERROR = .TRUE.
    !.
    IF(LST%N > 0) THEN
      !
      IF(PRESENT(POS)) CALL GOTO_POSITION(LST, POS)
      !
      IF(ASSOCIATED(LST%CUR)) THEN
                                  IF(ALLOCATED(LST%CUR%I)) DEALLOCATE(LST%CUR%I)
                                  ALLOCATE( LST%CUR%I, SOURCE = I )
                                  !
                                  IF(PRESENT(ERROR)) ERROR = .FALSE.
      END IF
      !
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE EXTEND_LIST_FROM_ENDING(LST,I)
    CLASS(ABSTRACT_LINKED_LIST):: LST
    CLASS(*),        INTENT(IN):: I
    !
    TYPE(LINK_ELEMENT),POINTER::NEW_ELM                           !THIS WILL BE THE NEW ALLOCATED SPACE
    TYPE(LINK_ELEMENT),POINTER::CONNECTOR                         !THIS WILL HOLD IN MEMORY THE CURRENT LST%END
    !
    NULLIFY(NEW_ELM  )
    NULLIFY(CONNECTOR)
    ALLOCATE( LINK_ELEMENT::NEW_ELM )                             !ALLOCATE THE SPACE FOR THE NEW ELEMENT
    ALLOCATE( NEW_ELM%I, SOURCE = I )                             !SOMETIMES THIS FAILS WHEN YOU PASS IT A CHARACTER VARIABLE AS I(5:5) -- COMPILER BUG, FIX IS TO SET II = I(5:5) AND PASS II
    !
    LST%N = LST%N + 1
    IF(LST%N == 1) THEN                                           !THE LIST HAPPENS TO BE COMPLETELY EMPTY SO SET UP POINTERS AND RETURN
      NEW_ELM%P = 1                                               ! SET THE INITIAL POSITION
      LST%BEG => NEW_ELM
      LST%END => LST%BEG
      LST%CUR => LST%BEG
    ELSE
      !
      NEW_ELM%P = LST%END%P + 1                                   !GET THE NEW POSITION
      !
      CONNECTOR=>LST%END                                          !HOLD IN MEMORY THE CURRENT END VALUE AND POINTERS
      !
      CONNECTOR%NXT=>NEW_ELM                                      !THE CURRENT ENDING WHICH IS HELD IN MEMORY NOW POITNS TO THE NEXT VALUE
      !
      LST%END      =>NEW_ELM                                      !UPDATE THE ENDING TO THE NEW ENDING LOCATION
      !
      LST%END%PRV=>CONNECTOR                                      !NOW LINK NEW LAST VALUE PREVIOUS POINTER TO SECOND TO LAST
      !
      IF( .NOT. ASSOCIATED(LST%BEG%NXT) ) LST%BEG%NXT=>CONNECTOR  !IF NOT ASOCIATED THEN THIS IS THE SECOND ELEMENT TO BE ADDED SO LINK FIRST ELEMENT WITH LAST
      !
      LST%CUR => LST%END
      !
    END IF
    !
    NEW_ELM  => NULL()                                            ! CLEAN UP DANGLING POINTERS
    CONNECTOR=> NULL()                                            ! CLEAN UP DANGLING POINTERS
    !
  END SUBROUTINE
  !
  !
  SUBROUTINE EXTEND_LIST_FROM_ENDING_VECTOR(LST,VEC)
    CLASS(ABSTRACT_LINKED_LIST):: LST
    CLASS(*), DIMENSION(:), CONTIGUOUS, INTENT(IN):: VEC
    INTEGER:: I
    !
    DO I = 1, SIZE(VEC)
        CALL EXTEND_LIST_FROM_ENDING(LST,VEC(I))
    END DO
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE ADD_VALUE_AT(LST,I,POS)
    CLASS(ABSTRACT_LINKED_LIST):: LST
    CLASS(*),        INTENT(IN):: I
    INTEGER,         INTENT(IN):: POS
    INTEGER:: P
    !
    TYPE(LINK_ELEMENT),POINTER::NEW_ELM                           !THIS WILL BE THE NEW ALLOCATED SPACE
    TYPE(LINK_ELEMENT),POINTER::CONNECTOR                         !THIS WILL HOLD IN MEMORY THE CURRENT LST%END
    !
    IF(POS > LST%N .OR. LST%N == 0) THEN
        !
        CALL EXTEND_LIST_FROM_ENDING(LST,I)
        !
    ELSEIF(LST%N == 1) THEN                                       !ONLY OPTION IS TO UPDATE LST%BEG
        NULLIFY(NEW_ELM  )
        NULLIFY(CONNECTOR)
        ALLOCATE( LINK_ELEMENT::NEW_ELM )                             !ALLOCATE THE SPACE FOR THE NEW ELEMENT
        ALLOCATE( NEW_ELM%I, SOURCE = I )                             !SOMETIMES THIS FAILS WHEN YOU PASS IT A CHARACTER VARIABLE AS I(5:5) -- COMPILER BUG, FIX IS TO SET II = I(5:5) AND PASS II
        !
        CONNECTOR     => LST%BEG                                      !HOLD IN MEMORY THE CURRENT BEGINING VALUE AND POINTERS
        CONNECTOR%PRV => NEW_ELM                                      !CONNECT FIRST ENTRYT WIH NEW FIRST ENTRY
        NEW_ELM%NXT   => CONNECTOR                                    !MOVE FIRST ENTRY TO SECOND LOCATION
        NEW_ELM%PRV   => NULL()                                       !NEW START SO NULLIFY
        NEW_ELM%P     = 1
        CONNECTOR%P   = 2
        LST%BEG       => NEW_ELM
        LST%CUR       => NEW_ELM
    ELSE
        NULLIFY(NEW_ELM  )
        NULLIFY(CONNECTOR)
        ALLOCATE( LINK_ELEMENT::NEW_ELM )                             !ALLOCATE THE SPACE FOR THE NEW ELEMENT
        ALLOCATE( NEW_ELM%I, SOURCE = I )                             !SOMETIMES THIS FAILS WHEN YOU PASS IT A CHARACTER VARIABLE AS I(5:5) -- COMPILER BUG, FIX IS TO SET II = I(5:5) AND PASS II
        !
        CALL GOTO_POSITION(LST, POS)
        !
        NEW_ELM%P     =  LST%CUR%P
        !
        IF(LST%CUR%P == 1) THEN
                                      CONNECTOR     => LST%CUR          !HOLD IN MEMORY THE CURRENT BEGINING VALUE AND POINTERS
                                      CONNECTOR%PRV => NEW_ELM          !CONNECT FIRST ENTRYT WIH NEW FIRST ENTRY
                                      NEW_ELM%NXT   => CONNECTOR        !MOVE FIRST ENTRY TO SECOND LOCATION
                                      NEW_ELM%PRV   => NULL()           !NEW START SO NULLIFY
                                      LST%BEG       => NEW_ELM
        ELSE
                                      CONNECTOR     => LST%CUR%PRV      !CONNECT TO P-1 LOCATION
                                      CONNECTOR%NXT => NEW_ELM          !MAKE NEW NEXT LOCATION THE NEW_ELM
                                      NEW_ELM%PRV   => CONNECTOR        !NEW_ELM MUST POINT BACK TO P-1 LOCATION
                                      NEW_ELM%NXT   => LST%CUR          !CONNECT NEW_ELM WITH LST%CUR
                                      LST%CUR%PRV   => NEW_ELM          !      IN BOTH DIRECTIONS
        END IF
        !
        DO P=NEW_ELM%P, LST%N
                     LST%CUR%P = LST%CUR%P + 1
                     CALL LST%NEXT()
        END DO
        !
        LST%N = LST%N + 1
        LST%CUR => NEW_ELM
        !
    END IF
    !
    NEW_ELM  => NULL()                                            ! CLEAN UP DANGLING POINTERS
    CONNECTOR=> NULL()                                            ! CLEAN UP DANGLING POINTERS
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE MOVE_TO_NEXT_POS(LST)
    CLASS(ABSTRACT_LINKED_LIST) :: LST
    !
    IF(.NOT. ASSOCIATED(LST%CUR)) THEN             !EITHER LIST IS BEYOND ENDING, LIST IS EMPTY, OR BAD CUR POINTER
                                          CONTINUE
    ELSEIF(  ASSOCIATED(LST%CUR%NXT)) THEN
                                          LST%CUR=>LST%CUR%NXT
    ELSE
                                          LST%CUR=>NULL() !REACHED END OF LIST --LST%END
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE MOVE_TO_PREVIOUS_POS(LST)
    CLASS(ABSTRACT_LINKED_LIST) :: LST
    !
    IF(.NOT. ASSOCIATED(LST%CUR)) THEN             !EITHER LIST IS BEYOND ENDING, LIST IS EMPTY, OR BAD CUR POINTER
                                          CONTINUE
    ELSEIF(ASSOCIATED(LST%CUR%PRV)) THEN
                                          LST%CUR=>LST%CUR%PRV
    ELSE
                                          LST%CUR=>NULL() !LST%BEG
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE MOVE_TO_FIRST_POS(LST)
    CLASS(ABSTRACT_LINKED_LIST):: LST
    IF(ASSOCIATED(LST%BEG)) THEN
        LST%CUR=>LST%BEG
    ELSE
        LST%CUR=>NULL()
    END IF
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE MOVE_TO_LAST_POS(LST)
    CLASS(ABSTRACT_LINKED_LIST):: LST
    IF(ASSOCIATED(LST%BEG)) THEN
        LST%CUR=>LST%END
    ELSE
        LST%CUR=>NULL()
    END IF
  END SUBROUTINE
  !
  !#######################################################################
  !
  FUNCTION POS_AT_END_OF_LIST(LST) RESULT(AT_END)
    CLASS(ABSTRACT_LINKED_LIST):: LST
    LOGICAL:: AT_END
    !
    IF(ASSOCIATED(LST%CUR)) THEN
                                AT_END=LST%CUR%P == LST%N
    ELSE
                                AT_END=.FALSE.
    END IF
    !
  END FUNCTION
  !
  !#######################################################################
  !
  FUNCTION POS_AT_START_OF_LIST(LST) RESULT(AT_START)
    CLASS(ABSTRACT_LINKED_LIST):: LST
    LOGICAL:: AT_START
    !
    IF(ASSOCIATED(LST%CUR)) THEN
                                AT_START=LST%CUR%P == 1
    ELSE
                                AT_START=.FALSE.
    END IF
    !
  END FUNCTION
  !
  !#######################################################################
  !
  FUNCTION CUR_IS_ASSOCIATED(LST) RESULT(IS_ASSOCIATED)
    CLASS(ABSTRACT_LINKED_LIST):: LST
    LOGICAL:: IS_ASSOCIATED
    !
    IF(ASSOCIATED(LST%CUR)) THEN
                                IS_ASSOCIATED=.TRUE.
    ELSE
                                IS_ASSOCIATED=.FALSE.
    END IF
    !
  END FUNCTION
  !
  !#######################################################################
  !
  FUNCTION RETURN_LIST_LENGTH(LST)  RESULT(LENGTH)
    CLASS(ABSTRACT_LINKED_LIST) :: LST
    INTEGER                     :: LENGTH
    !
    LENGTH=LST%N
    !
  END FUNCTION
  !
  !#######################################################################
  !
  FUNCTION RETURN_LIST_POSITION(LST)  RESULT(POS)
    CLASS(ABSTRACT_LINKED_LIST) :: LST
    INTEGER                     :: POS
    !
    IF(ASSOCIATED(LST%CUR)) THEN
                                POS=LST%CUR%P
    ELSE
                                POS= LST%N+1  !MOVE TO BAD POSITION
    END IF
    !
  END FUNCTION
  !
  !#######################################################################
  !
  SUBROUTINE GOTO_POSITION(LST, POS)
    CLASS(ABSTRACT_LINKED_LIST) :: LST
    INTEGER, INTENT(IN)         :: POS
    INTEGER:: I, P
    !
    IF (.NOT. ASSOCIATED(LST%BEG)) RETURN
    !
    IF (POS == 0) RETURN ! GOING NO WHERE
    P = POS
    !
    IF (P <  0) P = LST%N + P + 1  !-1 IS THE END OF THE LIST
    IF (P <  1 .OR. LST%N < P) THEN
                                  LST%CUR => NULL() !REFERENCING OUTSIDE OF LIST LENGTH
                                  RETURN
    END IF
    !
    IF( ASSOCIATED(LST%CUR) ) THEN;  IF (P == LST%CUR%P) RETURN  ! ALREADY THERE
    END IF
    !
    IF    (P == 1) THEN 
                                 LST%CUR => LST%BEG 
    ELSEIF(P == LST%N) THEN
                                 LST%CUR => LST%END
    ELSEIF ( LST%N - P < P ) THEN                     !START SEARCH FROM BACK
                                 LST%CUR => LST%END      
                                 DO I=1, LST%N
                                              IF (P == LST%CUR%P) EXIT
                                              CALL LST%BACK()
                                 END DO
    ELSE
                                 LST%CUR => LST%BEG      
                                 DO I=1, LST%N
                                              IF (P == LST%CUR%P) EXIT
                                              CALL LST%NEXT()
                                 END DO
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE REMOVE_VAL_AT(LST,POS)
    CLASS(ABSTRACT_LINKED_LIST)  :: LST
    INTEGER, OPTIONAL, INTENT(IN):: POS
    !
    INTEGER::P
    !
    IF( LST%N < 2 ) THEN                         !LIST EITHER IS EMPTY OR CONTAINS ONE VALUE AND WILL BECOME EMPTY ONCE IT IS REMOVED
        CALL DELETE_ALL_LINKED_LIST_ENTRIES(LST)
        RETURN
    END IF
    !
    P = -1
    IF(PRESENT(POS)) P = POS
    !
    CALL GOTO_POSITION(LST, P)
    !
    P = RETURN_LIST_POSITION(LST)
    !
    CALL DISCONNECT_CUR_TO_MEMORY_LEAK(LST)
    !
    LST%N = LST%N - 1
    !
    !DEALLOCATE(LST%CUR%I)                                         !CLEAN UP THE DELETED MEMORY - DELETE STORED ARRAY TO CLEAR OUT MEMORY LEAK THAT RESULTED FROM "DISCONNECT_CUR_TO_MEMORY_LEAK"
    DEALLOCATE(LST%CUR)                                           !CLEAN UP THE DELETED MEMORY - DELETE DATA TYPE
    !
    IF(P > LST%N) P = LST%N
    CALL GOTO_POSITION(LST, P)
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE DISCONNECT_CUR_TO_MEMORY_LEAK(LST)
    CLASS(ABSTRACT_LINKED_LIST):: LST
    !
    TYPE(LINK_ELEMENT),POINTER:: CUR_PRV, CUR_NXT
    !
    IF(.NOT. ASSOCIATED(LST%CUR)) THEN;   RETURN
                                          !
    ELSEIF( ASSOCIATED(LST%BEG,LST%END) ) THEN 
                                          CALL NULLIFY_LINK_ELEMENT(LST%BEG)
                                          CALL NULLIFY_LINK_ELEMENT(LST%END)
                                          LST%CUR%NXT => NULL()              !THIS IS THE LAST VALUE IN THE LIST SO ALL POINTERS ARE NULL
                                          LST%CUR%PRV => NULL()
                                          RETURN
    ELSEIF( ASSOCIATED(LST%CUR,LST%BEG) ) THEN
                                          LST%BEG => LST%BEG%NXT                       !THIS CHECKS IF THE LOCATION FOUND IS ACTUALLY AT THE BEGINING OF THE LIST
                                          !
                                          IF( ASSOCIATED(LST%BEG) ) LST%BEG%PRV => NULL()
                                          !
                                          CUR_NXT => LST%BEG
                                          DO WHILE(ASSOCIATED(CUR_NXT))
                                              CUR_NXT%P = CUR_NXT%P - 1
                                              IF(  ASSOCIATED(CUR_NXT%NXT)) THEN
                                                                                CUR_NXT => CUR_NXT%NXT
                                              ELSE
                                                                                EXIT
                                              END IF
                                          END DO
                                          CUR_NXT => NULL()
                                          RETURN
    ELSEIF( ASSOCIATED(LST%CUR,LST%END) ) THEN
                                          LST%END => LST%END%PRV !THIS CHECKS IF THE LOCATION FOUND IS ACTUALLY AT THE END      OF THE LIST
                                          !
                                          IF( ASSOCIATED(LST%END) ) LST%END%NXT => NULL()
                                          RETURN
    END IF
    !
    IF( ASSOCIATED(LST%CUR%PRV) ) THEN 
        CUR_PRV => LST%CUR%PRV    !CONNECT TO ONE LIST ENTRY BEFORE THE CURRENT
    ELSE
        CUR_PRV => NULL()
    END IF
    IF( ASSOCIATED(LST%CUR%NXT) ) THEN 
        CUR_NXT => LST%CUR%NXT    !CONNECT TO ONE LIST ENTRY AFTER  THE CURRENT
    ELSE
        CUR_NXT=>NULL()
    END IF
    !
    IF    (      ASSOCIATED(CUR_PRV) .AND.       ASSOCIATED(CUR_NXT)) THEN!IN THEREY THIS SHOULD BE THE ONYL TRUE CASE
                                                                          !
                                                                          CUR_PRV%NXT => CUR_NXT !TO THE VALUE ONE BEYOND THE CURRENT
                                                                          CUR_NXT%PRV => CUR_PRV !TO THE VALUE ONE BEFORE THE CURRENT (SAME LOCATION AS LST%CUR%PRV)
    !
    ELSEIF(      ASSOCIATED(CUR_PRV) .AND. .NOT. ASSOCIATED(CUR_NXT)) THEN
                                                                          CUR_PRV%NXT => NULL()        !TO THE VALUE ONE BEYOND THE CURRENT
    !                                                                              
    ELSEIF(.NOT. ASSOCIATED(CUR_PRV) .AND.       ASSOCIATED(CUR_NXT)) THEN
                                                                          CUR_NXT%PRV => NULL()        !TO THE VALUE ONE BEYOND THE CURRENT
    ELSE
                                                                          CALL NULLIFY_LINK_ELEMENT(LST%BEG) !THIS IS THE LAST VALUE IN THE LIST SO ALL POINTERS ARE NULL
                                                                          CALL NULLIFY_LINK_ELEMENT(LST%END)
                                                                          LST%CUR%NXT => NULL()
                                                                          LST%CUR%PRV => NULL()
    END IF
    !
    DO WHILE(ASSOCIATED(CUR_NXT))
        CUR_NXT%P = CUR_NXT%P - 1
        IF(  ASSOCIATED(CUR_NXT%NXT)) THEN
                                          CUR_NXT => CUR_NXT%NXT
        ELSE
                                          EXIT
        END IF
    END DO
    !
    CUR_PRV =>NULL()
    CUR_NXT =>NULL()
    
    !CALL NULLIFY_LINK_ELEMENT(CUR_PRV)
    !CALL NULLIFY_LINK_ELEMENT(CUR_NXT)
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
!!!  SUBROUTINE REMOVE_VAL_AT(LST,POS)
!!!    CLASS(ABSTRACT_LINKED_LIST)  :: LST
!!!    INTEGER, OPTIONAL, INTENT(IN):: POS
!!!    !
!!!    TYPE(LINK_ELEMENT),POINTER::CONNECTOR_PRV
!!!    TYPE(LINK_ELEMENT),POINTER::CONNECTOR_NXT
!!!    !
!!!    INTEGER::I, P
!!!    LOGICAL::USE_CURRENT
!!!    !
!!!    IF( LST%N < 2 ) THEN                         !LIST EITHER IS EMPTY OR CONTAINS ONE VALUE AND WILL BECOME EMPTY ONCE IT IS REMOVED
!!!        CALL DELETE_ALL_LINKED_LIST_ENTRIES(LST)
!!!        RETURN
!!!    END IF
!!!    !
!!!    P = -1
!!!    IF(PRESENT(POS)) P = POS
!!!    IF(P == LST%N  ) P = -1
!!!    !
!!!    SELECT CASE (P)
!!!    CASE (0)
!!!         P = LST%GETPOS() 
!!!    CASE (-1)
!!!         P = LST%N                                                !NO NEED TO UPDATE POSITIONS 
!!!    CASE (1)     
!!!         LST%CUR => LST%BEG
!!!         LST%BEG => LST%BEG%NXT                                   !REMOVING FIRST TERM SO UPDATE THE LOCATION OF LST%BEG
!!!    CASE (:-2, 2:)
!!!         CALL LST%POS(P)
!!!         P = LST%GETPOS()                                         !SWTICH TO POSITIVE POSITION
!!!         IF( ASSOCIATED(LST%CUR,LST%BEG) ) LST%BEG => LST%BEG%NXT !THIS CHECKS IF THE LOCATION FOUND IS ACTUALLY AT THE BEGINING OF THE LIST
!!!         IF( ASSOCIATED(LST%CUR,LST%END) ) LST%END => LST%END%PRV !THIS CHECKS IF THE LOCATION FOUND IS ACTUALLY AT THE END      OF THE LIST
!!!    END SELECT
!!!    !
!!!    IF(P == LST%N) THEN            !REMOVING LAST TERM SO UPDATE THE LOCATION OF LST%END
!!!         LST%CUR => LST%END
!!!         LST%END => LST%END%PRV                                   
!!!    END IF
!!!    !
!!!    LST%N = LST%N - 1
!!!    !
!!!    IF( ASSOCIATED(LST%CUR%PRV) ) THEN 
!!!        CONNECTOR_PRV => LST%CUR%PRV    !CONNECT TO ONE LIST ENTRY BEFORE THE CURRENT
!!!    ELSE
!!!       CONNECTOR_PRV => NULL()
!!!    END IF
!!!    IF( ASSOCIATED(LST%CUR%NXT) ) THEN 
!!!        CONNECTOR_NXT => LST%CUR%NXT    !CONNECT TO ONE LIST ENTRY AFTER  THE CURRENT
!!!    ELSE
!!!        CONNECTOR_NXT=>NULL()
!!!    END IF
!!!    !
!!!    IF    (      ASSOCIATED(CONNECTOR_PRV) .AND.       ASSOCIATED(CONNECTOR_NXT)) THEN
!!!                                                                                 CONNECTOR_PRV%NXT => CONNECTOR_NXT !TO THE VALUE ONE BEYOND THE CURRENT
!!!                                                                                 CONNECTOR_NXT%PRV => CONNECTOR_PRV !TO THE VALUE ONE BEFORE THE CURRENT (SAME LOCATION AS LST%CUR%PRV)
!!!    !
!!!    ELSEIF(      ASSOCIATED(CONNECTOR_PRV) .AND. .NOT. ASSOCIATED(CONNECTOR_NXT)) THEN
!!!                                                                                 CONNECTOR_PRV%NXT => NULL()        !TO THE VALUE ONE BEYOND THE CURRENT
!!!    !                                                                              
!!!    ELSEIF(.NOT. ASSOCIATED(CONNECTOR_PRV) .AND.       ASSOCIATED(CONNECTOR_NXT)) THEN
!!!                                                                                 CONNECTOR_NXT%PRV => NULL()        !TO THE VALUE ONE BEYOND THE CURRENT
!!!    ELSE
!!!                                                                                 LST%CUR%NXT => NULL()              !THIS IS THE LAST VALUE IN THE LIST SO ALL POINTERS ARE NULL
!!!                                                                                 LST%CUR%PRV => NULL()
!!!                                                                                 LST%BEG     => NULL()
!!!                                                                                 LST%END     => NULL()
!!!    END IF                           
!!!    !
!!!    DEALLOCATE(LST%CUR%I)                                         !CLEAN UP THE DELETED MEMORY - DELETE STORED ARRAY
!!!    DEALLOCATE(LST%CUR)                                           !CLEAN UP THE DELETED MEMORY - DELETE DATA TYPE
!!!    IF( ASSOCIATED(LST%BEG) ) THEN
!!!        IF( ASSOCIATED(CONNECTOR_NXT) ) THEN
!!!            LST%CUR=>CONNECTOR_NXT                                !NOW POINT CURRENT TO THE ENTRY THAT FOLLOWS THE DELETED POINT OR IF THERE IS NO ENTRY AFTER POINT TO THE END OF THE LIST
!!!        ELSE
!!!            LST%CUR=>LST%END
!!!        END IF
!!!    ELSE
!!!        LST%CUR=>NULL()
!!!    END IF
!!!    !
!!!    IF (P <= LST%N) THEN
!!!                        DO I=P, LST%N                  !UPDATE LIST POSITION
!!!                                     LST%CUR%P = I
!!!                                     CALL LST%NEXT()
!!!                        END DO
!!!                        !
!!!                        CALL LST%POS(P)
!!!    END IF
!!!    !
!!!  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE DEALLOCATE_LINK_ELEMENT_FINAL(LST)
    TYPE(LINK_ELEMENT):: LST
    !
    LST%P=0
    IF( ALLOCATED(LST%I) ) DEALLOCATE(LST%I)
    LST%NXT=>NULL()
    LST%PRV=>NULL()
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE DELETE_ALL_LINKED_LIST_ENTRIES(LST)
    CLASS(ABSTRACT_LINKED_LIST):: LST
    !
    IF(LST%N==0) THEN      !NOTHING TO DEALLOCATE
        LST%CUR   => NULL()   
        LST%BEG   => NULL()
        LST%END   => NULL()
    ELSE
       !
       LST%CUR => LST%END                                            !POINT TO END OF LIST
       LST%BEG => NULL()                                             !BEGINING REFERENCE IS NOW LOST
       DO WHILE( LST%N > 0 )
           !
           LST%END    =>LST%CUR%PRV                                  !MOVE THE END POINTER UP ONE
           LST%CUR%PRV=>NULL()                                       !DELETE POSITIONAL POITNERS
           LST%CUR%NXT=>NULL()                                       !DELETE POSITIONAL POITNERS
           DEALLOCATE(LST%CUR)                                       !DELETE THE ENTIRE LOCATION
           LST%CUR=>LST%END                                          !POINT TO THE NEW ENDING
           LST%N = LST%N - 1
           !
       END DO
       !
       LST%END => NULL()
       LST%CUR => NULL()                                             !NULL THE FINAL POINTER OF THE LINKED LIST
    END IF
    !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !
  FUNCTION INTEGER_RETURN_VALUE(LST, POS)  RESULT(IVAL)
    CLASS(INTEGER_LINKED_LIST), INTENT(INOUT):: LST
    INTEGER, OPTIONAL,          INTENT(IN   ):: POS
    INTEGER                                  :: IVAL
    !
    IF (PRESENT(POS)) CALL GOTO_POSITION(LST, POS) 
    !
    SELECT TYPE (INT => LST%CUR%I)
    TYPE IS (INTEGER);            IVAL = INT
    END SELECT
    !
  END FUNCTION
  !
  !#######################################################################
  !
  SUBROUTINE INTEGER_LIST_TO_ARRAY_ALLOCATABLE(LST,ARR,SORT)
    CLASS(INTEGER_LINKED_LIST),      INTENT(INOUT):: LST
    INTEGER,DIMENSION(:),ALLOCATABLE,INTENT(INOUT):: ARR
    LOGICAL, OPTIONAL:: SORT
    LOGICAL:: SRT
    INTEGER:: VAL,IDX, I, J
    !
    IF(LST%N > 0) THEN
                     IF(ALLOCATED(ARR)) THEN
                          IF(SIZE(ARR).NE.LST%N) THEN
                                             DEALLOCATE(ARR)
                                               ALLOCATE(ARR(LST%N))
                          END IF
                     ELSE
                         ALLOCATE(ARR(LST%N))
                     END IF
                     !
                     SRT=.FALSE.
                     IF(PRESENT(SORT)) SRT=SORT
                     !
                     CALL MOVE_TO_FIRST_POS(LST)
                     DO IDX=1, LST%N
                           SELECT TYPE(INT => LST%CUR%I)
                                           TYPE IS (INTEGER)
                                                            ARR(IDX) = INT
                           END SELECT
                           CALL LST%NEXT()
                     END DO
                     !
                     IF (SRT) THEN                                   ! Rearrange array by insertion sort ascending order
                         DO I=2, LST%N
                             VAL=ARR(I)
                             J=I
                             DO WHILE ( J > 1 )
                                                IF (ARR(J-1) < VAL) EXIT
                                                ARR(J) = ARR(J-1)
                                                J=J-1
                             END DO
                             ARR(J) = VAL
                         END DO
                     END IF
    ELSEIF(ALLOCATED(ARR)) THEN 
         DEALLOCATE(ARR)
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE INTEGER_LIST_TO_ARRAY_POINTER(LST,ARR,SORT)
    CLASS(INTEGER_LINKED_LIST)      :: LST
    INTEGER,DIMENSION(:),POINTER:: ARR
    LOGICAL, OPTIONAL:: SORT
    LOGICAL:: SRT
    INTEGER:: VAL,IDX, I, J
    !
    DEALLOCATE(ARR, STAT=I) !AUTODEALLOCATE IN CASE MEMORY WAS ALREADY IN USE.
    ARR=>NULL()
    !
    IF(LST%N > 0) THEN
                     !
                     SRT=.FALSE.
                     IF(PRESENT(SORT)) SRT=SORT
                     !
                     !
                     ALLOCATE(ARR(LST%N))
                     !
                     CALL MOVE_TO_FIRST_POS(LST)
                     DO IDX=1, LST%N
                           SELECT TYPE(INT => LST%CUR%I)
                                           TYPE IS (INTEGER)
                                                            ARR(IDX) = INT
                           END SELECT
                           CALL LST%NEXT()
                     END DO
                     !
                     IF (SRT) THEN                                   ! Rearrange array by insertion sort ascending order
                         DO I=2, LST%N
                             VAL=ARR(I)
                             J=I
                             DO WHILE ( J > 1 )
                                                IF (ARR(J-1) < VAL) EXIT
                                                ARR(J) = ARR(J-1)
                                                J=J-1
                             END DO
                             ARR(J) = VAL
                         END DO
                     END IF
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE INTEGER_LIST_DROP_DUPLICATES(LST)
    CLASS(INTEGER_LINKED_LIST)      :: LST
    INTEGER:: POS, COMPARE_POS, IVAL
    !
    IF(LST%N > 0) THEN
                     !
                     COMPARE_POS = 1
                     DO WHILE (COMPARE_POS < LST%N)
                        !
                        CALL LST%POS(COMPARE_POS)
                        !
                        SELECT TYPE(INT => LST%CUR%I)
                        TYPE IS (INTEGER);            IVAL = INT
                        END SELECT
                        !
                        CALL LST%NEXT()
                        POS = LST%GETPOS()
                        DO WHILE (COMPARE_POS < POS .AND. POS <= LST%N)
                              !
                              SELECT TYPE(INT => LST%CUR%I)
                              TYPE IS (INTEGER)
                                               IF(IVAL == INT) THEN
                                                   CALL LST%POP(0)
                                               ELSE
                                                   CALL LST%NEXT()
                                               END IF    
                              END SELECT
                              !
                              POS = LST%GETPOS()
                        END DO
                        !
                        COMPARE_POS = COMPARE_POS + 1
                     END DO
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE INTEGER_SORT_LIST(LST, REVERSE)
    CLASS(INTEGER_LINKED_LIST):: LST
    LOGICAL, OPTIONAL, INTENT(IN):: REVERSE
    !
    TYPE(LINK_ELEMENT),POINTER::BEG, LNK, PRV
    !
    INTEGER:: I,P,IVAL
    !
    IF(LST%N > 2) THEN
                     NULLIFY(BEG)
                     NULLIFY(LNK)
                     NULLIFY(PRV)
                     !
                     CALL MOVE_TO_FIRST_POS(LST)
                     !
                     SELECT TYPE(INT => LST%CUR%I)
                     TYPE IS (INTEGER)
                                       IVAL = INT
                     END SELECT
                     !
                     P = 1
                     !
                     DO I=2, LST%N
                         !
                         CALL LST%NEXT()
                         !
                         SELECT TYPE(INT => LST%CUR%I)
                         TYPE IS (INTEGER)
                                           IF(INT < IVAL)  THEN
                                               IVAL = INT
                                               P = LST%GETPOS()
                                           END IF
                         END SELECT
                         !
                     END DO
                     !
                     CALL LST%POS(P)                         ! MOVE CUR TO P
                     CALL DISCONNECT_CUR_TO_MEMORY_LEAK(LST) ! CUR IS HELD IN MEMORY BY BEG DESPITE MEMORY LEAK
                     !
                     LST%CUR%PRV => NULL()
                     LST%CUR%NXT => NULL()
                     !
                     BEG => LST%CUR   !NEW BEGINING
                     LNK => LST%CUR   !CURRENT LINK IN LIST
                     !
                     LST%CUR  => NULL()
                     !
                     DO WHILE( ASSOCIATED(LST%BEG)) 
                           !
                           CALL MOVE_TO_FIRST_POS(LST)
                           !
                           SELECT TYPE(INT => LST%CUR%I)
                           TYPE IS (INTEGER)
                                             IVAL = INT
                           END SELECT
                           !
                           P = 1
                           CALL LST%NEXT()
                           !
                           DO WHILE(LST%IS_ASSOCIATED())
                               !
                               SELECT TYPE(INT => LST%CUR%I)
                               TYPE IS (INTEGER)
                                                 IF(INT < IVAL)  THEN
                                                     IVAL = INT
                                                     P = LST%GETPOS()
                                                 END IF
                               END SELECT
                               !
                               CALL LST%NEXT()
                           END DO
                           !
                           CALL LST%POS(P)
                           CALL DISCONNECT_CUR_TO_MEMORY_LEAK(LST) !CUR IS HELD IN MEMORY BY BEG DESPITE MEMORY LEAK
                           !
                           IF(ASSOCIATED(LST%CUR)) THEN
                               !
                               LNK%NXT => LST%CUR   !UPDATE NEXT CONNECTION
                               PRV     => LNK
                               LNK     => LNK%NXT  ! = LST%CUR -- MOVE FORWARD
                               LNK%NXT => NULL()
                               LNK%PRV => PRV
                               LST%CUR  => NULL()
                           END IF
                     END DO
                     !
                     ! REINITIALIZE THE LIST
                     LST%BEG => BEG
                     LST%END => LNK
                     LST%CUR => LST%BEG
                     !
                     BEG => NULL()
                     LNK => NULL()
                     PRV => NULL()
    END IF
    !
    IF(PRESENT(REVERSE)) THEN; IF(REVERSE) CALL INTEGER_REVERSE_LIST(LST)
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE INTEGER_REVERSE_LIST(LST)
    CLASS(INTEGER_LINKED_LIST):: LST
    !
    TYPE(LINK_ELEMENT),POINTER::BEG, LNK, PRV
    !
    IF(LST%N > 1) THEN
                     NULLIFY(BEG)
                     NULLIFY(LNK)
                     NULLIFY(PRV)
                     !
                     CALL MOVE_TO_LAST_POS(LST)
                     !
                     CALL DISCONNECT_CUR_TO_MEMORY_LEAK(LST) ! CUR IS HELD IN MEMORY BY BEG DESPITE MEMORY LEAK
                     !
                     LST%CUR%PRV => NULL()
                     LST%CUR%NXT => NULL()
                     !
                     BEG => LST%CUR   !NEW BEGINING
                     LNK => LST%CUR   !CURRENT LINK IN LIST
                     !
                     LST%CUR  => NULL()
                     !
                     DO WHILE( ASSOCIATED(LST%BEG)) 
                           !
                           CALL MOVE_TO_LAST_POS(LST)
                           !
                           CALL DISCONNECT_CUR_TO_MEMORY_LEAK(LST) !CUR IS HELD IN MEMORY BY BEG DESPITE MEMORY LEAK
                           !
                           IF(ASSOCIATED(LST%CUR)) THEN
                               !
                               LNK%NXT => LST%CUR   !UPDATE NEXT CONNECTION
                               PRV     => LNK
                               LNK     => LNK%NXT  ! = LST%CUR -- MOVE FORWARD
                               LNK%NXT => NULL()
                               LNK%PRV => PRV
                               LST%CUR  => NULL()
                           END IF
                     END DO
                     !
                     ! REINITIALIZE THE LIST
                     LST%BEG => BEG
                     LST%END => LNK
                     LST%CUR => LST%BEG
                     !
                     BEG => NULL()
                     LNK => NULL()
                     PRV => NULL()
                     !
                     CALL RENUMBER_LIST_POSITIONS(LST)
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE INTEGER_ADD_UNIQUE_VALUE_TO_ENDING(LST,IVAL,POS)
    CLASS(INTEGER_LINKED_LIST)    :: LST
    INTEGER, INTENT(IN )          :: IVAL
    INTEGER, INTENT(OUT), OPTIONAL:: POS
    INTEGER:: I
    LOGICAL:: NOT_FOUND
    !
    IF(LST%N > 0) THEN
                     IF(PRESENT(POS)) POS = 0
                     !
                     NOT_FOUND=.TRUE.
                     CALL MOVE_TO_FIRST_POS(LST)
                     DO I=1, LST%N
                                  SELECT TYPE(INT => LST%CUR%I)
                                  TYPE IS (INTEGER)
                                                   IF(IVAL == INT) THEN
                                                                        NOT_FOUND = .FALSE.
                                                                        IF(PRESENT(POS)) POS = I
                                                                        EXIT
                                                   END IF    
                                  END SELECT
                                  CALL MOVE_TO_NEXT_POS(LST)
                     END DO
                     IF(NOT_FOUND) CALL EXTEND_LIST_FROM_ENDING(LST,IVAL)
    ELSE
                                   CALL EXTEND_LIST_FROM_ENDING(LST,IVAL)
                                   IF(PRESENT(POS)) POS = 1
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE INTEGER_ADD_UNIQUE_VALUE_TO_ENDING_VECTOR(LST,VEC)
    CLASS(INTEGER_LINKED_LIST)    :: LST
    INTEGER, DIMENSION(:), INTENT(IN)          :: VEC
    INTEGER:: I
    !
    DO I = 1, SIZE(VEC)
        CALL INTEGER_ADD_UNIQUE_VALUE_TO_ENDING(LST,VEC(I))
    END DO
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  FUNCTION INTEGER_VALUE_UNIQUE_IN_LIST(LST,IVAL) RESULT(IS_UNIQUE)
    CLASS(INTEGER_LINKED_LIST)      :: LST
    INTEGER, INTENT(IN)             :: IVAL
    INTEGER:: I
    LOGICAL:: IS_UNIQUE
    !
    IS_UNIQUE = .TRUE.
    IF(LST%N > 0) THEN
                     !
                     CALL MOVE_TO_FIRST_POS(LST)
                     DO I=1, LST%N
                                  SELECT TYPE(INT => LST%CUR%I)
                                  TYPE IS (INTEGER)
                                                   IF(IVAL == INT) THEN
                                                                        IS_UNIQUE = .FALSE.
                                                                        EXIT
                                                   END IF    
                                  END SELECT
                                  CALL MOVE_TO_NEXT_POS(LST)
                     END DO
    END IF
    !
  END FUNCTION
  !
  FUNCTION INTEGER_VALUE_NOT_UNIQUE_IN_LIST(LST,IVAL) RESULT(NOT_UNIQUE)
    CLASS(INTEGER_LINKED_LIST)      :: LST
    INTEGER, INTENT(IN)             :: IVAL
    LOGICAL:: NOT_UNIQUE
    !
    NOT_UNIQUE = .NOT. INTEGER_VALUE_UNIQUE_IN_LIST(LST,IVAL)
    !
  END FUNCTION
  !
  !#######################################################################
  !
  FUNCTION INTEGER_LIST_MAXVAL(LST) RESULT(IVAL)
    CLASS(INTEGER_LINKED_LIST)      :: LST
    INTEGER:: IVAL
    INTEGER:: I
    !
    IF(LST%N > 0) THEN
                     !
                     CALL MOVE_TO_FIRST_POS(LST)
                     !
                     SELECT TYPE(INT => LST%CUR%I)
                     TYPE IS (INTEGER);            IVAL = INT   
                     END SELECT
                     !
                     DO I=2, LST%N
                                  CALL MOVE_TO_NEXT_POS(LST)
                                  SELECT TYPE(INT => LST%CUR%I)
                                  TYPE IS (INTEGER)
                                                   IF(IVAL < INT) IVAL = INT
                                  END SELECT
                     END DO
    END IF
    !
  END FUNCTION
  !
  !#######################################################################
  !
  FUNCTION INTEGER_LIST_MINVAL(LST) RESULT(IVAL)
    CLASS(INTEGER_LINKED_LIST)      :: LST
    INTEGER:: IVAL
    INTEGER:: I
    !
    IF(LST%N > 0) THEN
                     !
                     CALL MOVE_TO_FIRST_POS(LST)
                     !
                     SELECT TYPE(INT => LST%CUR%I)
                     TYPE IS (INTEGER);            IVAL = INT   
                     END SELECT
                     !
                     DO I=2, LST%N
                                  CALL MOVE_TO_NEXT_POS(LST)
                                  SELECT TYPE(INT => LST%CUR%I)
                                  TYPE IS (INTEGER)
                                                   IF(IVAL > INT) IVAL = INT
                                  END SELECT
                     END DO
    END IF
    !
  END FUNCTION
  !
  !#######################################################################
  !
  FUNCTION INTEGER_LIST_RETURN_AS_STRING(LST, DELIM, PAD) RESULT(STR)
    CLASS(INTEGER_LINKED_LIST)      :: LST
    CHARACTER(*),OPTIONAL,INTENT(IN):: DELIM
    INTEGER,     OPTIONAL,INTENT(IN):: PAD
    CHARACTER(:),ALLOCATABLE:: STR
    CHARACTER(:),ALLOCATABLE:: TXT
    CHARACTER(30)::NUM
    INTEGER:: I, J
    !
    IF    (LST%N == 0) THEN
                     STR = ' '
    ELSEIF(LST%N == 1) THEN
                     CALL MOVE_TO_FIRST_POS(LST)
                     SELECT TYPE(INT => LST%CUR%I)
                     TYPE IS (INTEGER)
                                      WRITE(NUM,'(I30)') INT 
                     END SELECT
                     !
                     STR = TRIM(ADJUSTL(NUM))
    ELSE
                     J = 0
                     !
                     IF(PRESENT(DELIM)) THEN
                         TXT=DELIM
                     ELSE
                         TXT = ' '
                     END IF
                     !
                     IF(PRESENT(PAD)) THEN
                           CALL MOVE_TO_FIRST_POS(LST)
                           DO I=1, LST%N
                                        SELECT TYPE(INT => LST%CUR%I)
                                        TYPE IS (INTEGER)
                                                         WRITE(NUM,'(I30)') INT 
                                                         NUM=ADJUSTL(NUM)
                                        END SELECT
                                        IF(LEN_TRIM(NUM) > J) J = LEN_TRIM(NUM)
                                        CALL MOVE_TO_NEXT_POS(LST)
                           END DO
                           IF(J>30) J=30
                     END IF
                     !
                     CALL MOVE_TO_FIRST_POS(LST)
                     SELECT TYPE(INT => LST%CUR%I)
                     TYPE IS (INTEGER)
                                      WRITE(NUM,'(I30)') INT 
                                      NUM=ADJUSTL(NUM)
                     END SELECT
                     !
                     IF(J > 0) THEN
                         STR = REPEAT(' ',J-LEN_TRIM(NUM))//TRIM(NUM)//TXT
                     ELSE
                         STR = TRIM(NUM)//TXT
                     END IF
                     CALL MOVE_TO_NEXT_POS(LST)
                     !
                     DO I=2, LST%N-1
                           SELECT TYPE(INT => LST%CUR%I)
                           TYPE IS (INTEGER)
                                            WRITE(NUM,'(I30)') INT 
                                            NUM=ADJUSTL(NUM)
                           END SELECT
                           !
                           IF(J > 0) THEN
                               STR = STR//REPEAT(' ',J-LEN_TRIM(NUM))//TRIM(NUM)//TXT
                           ELSE
                               STR = STR//TRIM(NUM)//TXT
                           END IF
                           CALL MOVE_TO_NEXT_POS(LST)
                     END DO
                     !
                     SELECT TYPE(INT => LST%CUR%I)
                     TYPE IS (INTEGER)
                                      WRITE(NUM,'(I30)') INT 
                                      NUM=ADJUSTL(NUM)
                     END SELECT
                     !
                     IF(J > 0) THEN
                         STR = STR//REPEAT(' ',J-LEN_TRIM(NUM))//TRIM(NUM)
                     ELSE
                         STR = STR//TRIM(NUM)
                     END IF
    END IF
    !
  END FUNCTION
  !
  !
  !##################################################################################################
  !
  SUBROUTINE INTEGER_LINKED_LIST_DEALLOCATE(LST)
     TYPE(INTEGER_LINKED_LIST):: LST
     !
     CALL DELETE_ALL_LINKED_LIST_ENTRIES(LST)
     !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !
  SUBROUTINE CHAR_START_LINE(LST)    !FUNCTION SEEMS TO FAIL IF LIST ENTRY WAS MADE BY A SUBSTRING (ie CHAR(4:8))
    CLASS(CHARACTER_LINKED_LIST):: LST
    CALL MOVE_TO_FIRST_POS(LST)
    CALL CHAR_SET_LN(LST)
    !
  END SUBROUTINE
  !
  SUBROUTINE CHAR_NEXT_LINE(LST)    !FUNCTION SEEMS TO FAIL IF LIST ENTRY WAS MADE BY A SUBSTRING (ie CHAR(4:8))
    CLASS(CHARACTER_LINKED_LIST):: LST
    CALL MOVE_TO_NEXT_POS(LST)
    CALL CHAR_SET_LN(LST)
    !
  END SUBROUTINE
  !
  SUBROUTINE CHAR_SET_LN(LST)    !FUNCTION SEEMS TO FAIL IF LIST ENTRY WAS MADE BY A SUBSTRING (ie CHAR(4:8))
    CLASS(CHARACTER_LINKED_LIST) :: LST
    CLASS(*), POINTER:: CHAR
    !
    IF(ASSOCIATED(LST%CUR)) THEN
       CHAR => LST%CUR%I
       SELECT TYPE (CHAR)
                             TYPE IS (CHARACTER(*))
                                              LST%LN => CHAR
                             CLASS DEFAULT
                                              LST%LN => LST%ERR
                             END SELECT
    ELSE
                                              LST%LN => LST%ERR
    END IF
    !
  END SUBROUTINE
  !
  FUNCTION CHAR_RETURN_VALUE(LST,POS)  RESULT(VAL)  !FUNCTION SEEMS TO FAIL IF LIST ENTRY WAS MADE BY A SUBSTRING (ie CHAR(4:8))
    CLASS(CHARACTER_LINKED_LIST), INTENT(INOUT):: LST
    INTEGER,      OPTIONAL,       INTENT(IN   ):: POS
    CHARACTER(:), ALLOCATABLE                  :: VAL
    !
    IF (PRESENT(POS)) CALL GOTO_POSITION(LST, POS) 
    !
    IF(ALLOCATED(VAL)) DEALLOCATE(VAL)
    !
    IF(ALLOCATED(LST%CUR%I)) THEN
       SELECT TYPE (CHAR => LST%CUR%I)
                             TYPE IS (CHARACTER(*))
                                              ALLOCATE(VAL, SOURCE = CHAR)
       END SELECT
    ELSE
       ALLOCATE(VAL, SOURCE = 'ERROR')
    END IF
    
    !
  END FUNCTION
  !
  !#######################################################################
  !
  !
  FUNCTION CHAR_FIND_VALUE(LST,STR)  RESULT(POS)  !FUNCTION SEEMS TO FAIL IF LIST ENTRY WAS MADE BY A SUBSTRING (ie CHAR(4:8))
    CLASS(CHARACTER_LINKED_LIST), INTENT(INOUT):: LST
    CHARACTER(*),                 INTENT(IN   ):: STR
    INTEGER:: POS
    INTEGER:: IDX
    !
    POS = 0
    IF(LST%N>0) THEN
                   CALL MOVE_TO_FIRST_POS(LST)
                   DO IDX=1, LST%N
                         SELECT TYPE(CHAR => LST%CUR%I)
                                         TYPE IS (CHARACTER(*))
                                                          IF(CHAR == STR) THEN
                                                              POS = IDX
                                                              EXIT
                                                          END IF
                         END SELECT
                         CALL LST%NEXT()
                   END DO
    END IF
    !
  END FUNCTION
  !
  !#######################################################################
  !
  SUBROUTINE CHAR_LIST_TO_ARRAY_ALLOCATABLE(LST,ARR,SORT,DIM)
    CLASS(CHARACTER_LINKED_LIST)      :: LST
    CHARACTER(:),DIMENSION(:),ALLOCATABLE:: ARR
    LOGICAL, OPTIONAL:: SORT
    INTEGER, OPTIONAL:: DIM
    LOGICAL:: SRT
    INTEGER:: IDX, I, J, SIZ
    CHARACTER(:), ALLOCATABLE:: VAL
    !
    IF(ALLOCATED(ARR)) DEALLOCATE(ARR)
    !
    IF(LST%N > 0) THEN
                     !
                     SRT=.FALSE.
                     IF(PRESENT(SORT)) SRT=SORT
                     !
                     IF (PRESENT(DIM)) THEN
                          SIZ=DIM
                     ELSE
                          SIZ=0
                          CALL MOVE_TO_FIRST_POS(LST)
                          DO IDX=1, LST%N
                                SELECT TYPE(CHAR => LST%CUR%I)
                                                TYPE IS (CHARACTER(*))
                                                                       IF ( LEN(CHAR) > SIZ) SIZ = LEN(CHAR)
                                END SELECT
                                CALL LST%NEXT()
                          END DO
                     END IF
                     !
                     ALLOCATE(CHARACTER(SIZ)::ARR(LST%N))
                     !
                     CALL MOVE_TO_FIRST_POS(LST)
                     DO IDX=1, LST%N
                           SELECT TYPE(CHAR => LST%CUR%I)
                                           TYPE IS (CHARACTER(*))
                                                            ARR(IDX) = CHAR
                           END SELECT
                           CALL LST%NEXT()
                     END DO
                     !
                     IF (SRT) THEN                                   ! Rearrange array by insertion sort ascending order
                         ALLOCATE(CHARACTER(SIZ)::VAL)
                         DO I=2, LST%N
                             VAL(:)=ARR(I)
                             J=I
                             DO WHILE ( J > 1 )
                                                IF (ARR(J-1) < VAL) EXIT
                                                ARR(J) = ARR(J-1)
                                                J=J-1
                             END DO
                             ARR(J) = VAL
                         END DO
                         DEALLOCATE(VAL)
                     END IF
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE CHAR_LIST_TO_ARRAY_POINTER(LST,ARR,SORT,DIM)
    CLASS(CHARACTER_LINKED_LIST)      :: LST
    CHARACTER(:),DIMENSION(:),POINTER:: ARR
    LOGICAL, OPTIONAL:: SORT
    INTEGER, OPTIONAL:: DIM
    LOGICAL:: SRT
    INTEGER:: IDX, I, J, SIZ
    CHARACTER(:), ALLOCATABLE:: VAL
    !
    DEALLOCATE(ARR, STAT=I)
    ARR => NULL()
    !
    IF(LST%N > 0) THEN
                     !
                     SRT=.FALSE.
                     IF(PRESENT(SORT)) SRT=SORT
                     !
                     IF (PRESENT(DIM)) THEN
                          SIZ=DIM
                     ELSE
                          SIZ=0
                          CALL MOVE_TO_FIRST_POS(LST)
                          DO IDX=1, LST%N
                                SELECT TYPE(CHAR => LST%CUR%I)
                                                TYPE IS (CHARACTER(*))
                                                                       IF ( LEN(CHAR) > SIZ) SIZ = LEN(CHAR)
                                END SELECT
                                CALL LST%NEXT()
                          END DO
                     END IF
                     !
                     ALLOCATE(CHARACTER(SIZ)::ARR(LST%N))
                     !
                     CALL MOVE_TO_FIRST_POS(LST)
                     DO IDX=1, LST%N
                           SELECT TYPE(CHAR => LST%CUR%I)
                                           TYPE IS (CHARACTER(*))
                                                            ARR(IDX) = CHAR
                           END SELECT
                           CALL LST%NEXT()
                     END DO
                     !
                     IF (SRT) THEN                                   ! Rearrange array by insertion sort ascending order
                         ALLOCATE(CHARACTER(SIZ)::VAL)
                         DO I=2, LST%N
                             VAL(:)=ARR(I)
                             J=I
                             DO WHILE ( J > 1 )
                                                IF (ARR(J-1) < VAL) EXIT
                                                ARR(J) = ARR(J-1)
                                                J=J-1
                             END DO
                             ARR(J) = VAL
                         END DO
                         DEALLOCATE(VAL)
                     END IF
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE CHAR_LIST_TO_ARRAY_ASSUME_ALLOCATABLE(LST,ARR,SORT)
    CLASS(CHARACTER_LINKED_LIST)      :: LST
    CHARACTER(*),DIMENSION(:),ALLOCATABLE:: ARR
    LOGICAL, OPTIONAL:: SORT
    LOGICAL:: SRT
    INTEGER:: IDX, I, J
    CHARACTER(:), ALLOCATABLE:: VAL
    !
    SRT=.FALSE.
    IF(PRESENT(SORT)) SRT=SORT
    !
    IF(ALLOCATED(ARR)) DEALLOCATE(ARR)
    ALLOCATE(ARR(LST%N))
    !
    CALL MOVE_TO_FIRST_POS(LST)
    DO IDX=1, LST%N
          SELECT TYPE(CHAR => LST%CUR%I)
                          TYPE IS (CHARACTER(*))
                                           ARR(IDX) = CHAR
          END SELECT
          CALL LST%NEXT()
    END DO
    !
    IF (SRT) THEN                                   ! Rearrange array by insertion sort ascending order
        ALLOCATE(CHARACTER(LEN(ARR))::VAL)
        DO I=2, LST%N
            VAL(:)=ARR(I)
            J=I
            DO WHILE ( J > 1 )
                               IF (ARR(J-1) < VAL) EXIT
                               ARR(J) = ARR(J-1)
                               J=J-1
            END DO
            ARR(J) = VAL
        END DO
        DEALLOCATE(VAL)
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE CHAR_LIST_TO_ARRAY_ASSUME_POINTER(LST,ARR,SORT)
    CLASS(CHARACTER_LINKED_LIST)      :: LST
    CHARACTER(*),DIMENSION(:),POINTER:: ARR
    LOGICAL, OPTIONAL:: SORT
    LOGICAL:: SRT
    INTEGER:: IDX, I, J
    CHARACTER(:), ALLOCATABLE:: VAL
    !
    SRT=.FALSE.
    IF(PRESENT(SORT)) SRT=SORT
    !
    DEALLOCATE(ARR, STAT=I)
    ALLOCATE(ARR(LST%N))
    !
    CALL MOVE_TO_FIRST_POS(LST)
    DO IDX=1, LST%N
          SELECT TYPE(CHAR => LST%CUR%I)
                          TYPE IS (CHARACTER(*))
                                           ARR(IDX) = CHAR
          END SELECT
          CALL LST%NEXT()
    END DO
    !
    IF (SRT) THEN                                   ! Rearrange array by insertion sort ascending order
        ALLOCATE(CHARACTER(LEN(ARR))::VAL)
        DO I=2, LST%N
            VAL(:)=ARR(I)
            J=I
            DO WHILE ( J > 1 )
                               IF (ARR(J-1) < VAL) EXIT
                               ARR(J) = ARR(J-1)
                               J=J-1
            END DO
            ARR(J) = VAL
        END DO
        DEALLOCATE(VAL)
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE CHAR_LIST_TO_LINE_ALLOCATABLE(LST,LINE,SEP)
    CLASS(CHARACTER_LINKED_LIST), INTENT(INOUT):: LST
    CHARACTER(:),ALLOCATABLE,     INTENT(  OUT):: LINE
    CHARACTER(*), OPTIONAL,       INTENT(IN   ):: SEP
    INTEGER:: IDX, I, J, SIZ, SEP_LEN
    !
    IF(ALLOCATED(LINE)) DEALLOCATE(LINE)
    !
    IF(LST%N > 0) THEN
                     !
                     IF(PRESENT(SEP)) THEN
                         SEP_LEN = LEN(SEP)
                     ELSE
                         SEP_LEN = 0
                     END IF
                     !
                     SIZ=0
                     CALL MOVE_TO_FIRST_POS(LST)
                     DO IDX=1, LST%N
                           SELECT TYPE(CHAR => LST%CUR%I)
                                           TYPE IS (CHARACTER(*))
                                                                  SIZ = SIZ + LEN(CHAR)
                                                                  
                           END SELECT
                           CALL LST%NEXT()
                     END DO
                     !
                     IF(SEP_LEN > 0) THEN
                           DO CONCURRENT (IDX=1:LST%N-1);  SIZ = SIZ + SEP_LEN
                           END DO
                     END IF
                     !
                     ALLOCATE(CHARACTER(SIZ)::LINE)
                     !
                     CALL MOVE_TO_FIRST_POS(LST)
                     I=1
                     DO IDX=1, LST%N
                           SELECT TYPE(CHAR => LST%CUR%I)
                                           TYPE IS (CHARACTER(*))
                                                            SIZ = LEN(CHAR)
                                                            J = I - 1 + SIZ
                                                            LINE(I:J) = CHAR
                                                            I = I + SIZ
                           END SELECT
                           CALL LST%NEXT()
                           !
                           IF(SEP_LEN > 0) THEN
                                     IF(IDX .NE. LST%N) THEN
                                                            J = I - 1 + SEP_LEN
                                                            LINE(I:J) = SEP
                                                            I = I + SEP_LEN
                                     END IF
                                     
                           END IF
                     END DO
                     !
    ELSE
                     ALLOCATE(LINE, SOURCE=' ')
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE CHAR_LIST_TO_LINE_ASSUME(LST,LINE,SEP)
    CLASS(CHARACTER_LINKED_LIST), INTENT(INOUT):: LST
    CHARACTER(*),                 INTENT(  OUT):: LINE
    CHARACTER(*), OPTIONAL,       INTENT(IN   ):: SEP
    INTEGER:: IDX, I, J, SIZ, LEN_LINE, SEP_LEN
    !
    LEN_LINE = LEN(LINE)
    IF(LST%N > 0) THEN
                     !
                     IF(PRESENT(SEP)) THEN
                         SEP_LEN = LEN(SEP)
                     ELSE
                         SEP_LEN = 0
                     END IF
                     !
                     CALL MOVE_TO_FIRST_POS(LST)
                     I=1
                     DO IDX=1, LST%N
                           SELECT TYPE(CHAR => LST%CUR%I)
                                           TYPE IS (CHARACTER(*))
                                                            SIZ = LEN(CHAR)
                                                            J = I - 1 + SIZ
                                                            !
                                                            IF( I > LEN_LINE ) EXIT
                                                            IF( J > LEN_LINE ) J = LEN_LINE
                                                            !
                                                            LINE(I:J) = CHAR
                                                            I = I + SIZ
                           END SELECT
                           CALL LST%NEXT()
                           !
                           IF(SEP_LEN > 0) THEN
                                     IF(IDX .NE. LST%N) THEN
                                                            J = I - 1 + SEP_LEN
                                                            !
                                                            IF( I > LEN_LINE ) EXIT
                                                            IF( J > LEN_LINE ) J = LEN_LINE
                                                            !
                                                            LINE(I:J) = SEP
                                                            I = I + SEP_LEN
                                     END IF
                           END IF
                     END DO
                     !
    ELSE
                     LINE = ''
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  FUNCTION RETURN_CHAR_LIST_TO_LINE(LST,SEP,EXT,SEP2)    RESULT(LINE)
    CLASS(CHARACTER_LINKED_LIST),          INTENT(INOUT):: LST
    CHARACTER(*),                OPTIONAL, INTENT(IN   ):: SEP, SEP2
    CLASS(CHARACTER_LINKED_LIST),OPTIONAL, INTENT(INOUT):: EXT  !IF SPECIFIED YOU MUST SPECIFY SEP2
    CHARACTER(:),                            ALLOCATABLE:: LINE
    INTEGER:: IDX, I, J, SIZ, SEP_LEN, SEP2_LEN
    !
    IF(LST%N > 0) THEN
                     !
                     IF(PRESENT(SEP)) THEN
                         SEP_LEN = LEN(SEP)
                     ELSE
                         SEP_LEN = 0
                     END IF
                     SEP2_LEN = 0
                     !
                     SIZ=0
                     CALL MOVE_TO_FIRST_POS(LST)
                     DO IDX=1, LST%N
                           SELECT TYPE(CHAR => LST%CUR%I)
                                           TYPE IS (CHARACTER(*))
                                                                  SIZ = SIZ + LEN(CHAR)
                           END SELECT
                           CALL LST%NEXT()
                     END DO
                     !
                     IF(SEP_LEN > 0) THEN
                           DO CONCURRENT (IDX=1:LST%N-1);  SIZ = SIZ + SEP_LEN
                           END DO
                     END IF
                     !
                     IF(PRESENT(EXT)) THEN
                           IF(PRESENT(SEP2)) THEN
                              SEP2_LEN = LEN(SEP2)
                              DO CONCURRENT (IDX=1:EXT%N-1);  SIZ = SIZ + SEP2_LEN
                              END DO
                           END IF
                           !
                           CALL EXT%START
                           DO IDX=1, EXT%N
                                 SELECT TYPE(CHAR => EXT%CUR%I)
                                                 TYPE IS (CHARACTER(*))
                                                                        SIZ = SIZ + LEN(CHAR) + 1
                                 END SELECT
                                 CALL EXT%NEXT()
                           END DO
                           CALL EXT%START
                     END IF
                     !
                     ALLOCATE(CHARACTER(SIZ)::LINE)
                     !
                     CALL MOVE_TO_FIRST_POS(LST)
                     I=1
                     DO IDX=1, LST%N
                           SELECT TYPE(CHAR => LST%CUR%I)
                                           TYPE IS (CHARACTER(*))
                                                            SIZ = LEN(CHAR)
                                                            J = I - 1 + SIZ
                                                            LINE(I:J) = CHAR
                                                            I = I + SIZ
                           END SELECT
                           CALL LST%NEXT()
                           !
                           IF(PRESENT(EXT)) THEN
                               IF(IDX <= EXT%N) THEN
                                         IF(SEP2_LEN > 0) THEN
                                                         J = I - 1 + SEP2_LEN
                                                         LINE(I:J) = SEP2
                                                         I = I + SEP2_LEN
                                         END IF
                                         SELECT TYPE(CHAR => EXT%CUR%I)
                                                         TYPE IS (CHARACTER(*))
                                                                          SIZ = LEN(CHAR)
                                                                          J = I - 1 + SIZ
                                                                          LINE(I:J) = CHAR
                                                                          I = I + SIZ
                                         END SELECT
                                         CALL EXT%NEXT()
                               END IF
                           END IF
                           !
                           IF(SEP_LEN > 0) THEN
                                     IF(IDX .NE. LST%N) THEN
                                                            J = I - 1 + SEP_LEN
                                                            LINE(I:J) = SEP
                                                            I = I + SEP_LEN
                                     END IF
                                     
                           END IF
                     END DO
                     !
    ELSE
                     ALLOCATE(LINE, SOURCE=' ')
    END IF
    !
  END 
  !
  !#######################################################################
  !
  FUNCTION RETURN_CHAR_LIST_NBACK_LINES(LST,NBACK,SEP)    RESULT(LINE)
    CLASS(CHARACTER_LINKED_LIST),          INTENT(INOUT):: LST
    INTEGER,                               INTENT(IN   ):: NBACK
    CHARACTER(*),                OPTIONAL, INTENT(IN   ):: SEP
    CHARACTER(:),                            ALLOCATABLE:: LINE
    INTEGER:: IDX, I, J, SIZ, SEP_LEN, NLINE
    !
    IF(LST%N > 0 .AND. ASSOCIATED(LST%CUR)) THEN
                     !
                     IF(PRESENT(SEP)) THEN
                         SEP_LEN = LEN(SEP)
                     ELSE
                         SEP_LEN = 0
                     END IF
                     !
                     NLINE = 1
                     SELECT TYPE(CHAR => LST%CUR%I)
                                     TYPE IS (CHARACTER(*))
                                                            SIZ = LEN(CHAR)
                     END SELECT
                     !
                     DO IDX=1, NBACK
                           IF(ASSOCIATED(LST%CUR%PRV)) THEN
                                                                 LST%CUR=>LST%CUR%PRV
                                                                 NLINE = NLINE + 1
                                                                 SELECT TYPE(CHAR => LST%CUR%I)
                                                                                 TYPE IS (CHARACTER(*))
                                                                                                        SIZ = SIZ + LEN(CHAR)
                                                                 END SELECT
                           ELSE
                                                                 EXIT
                           END IF
                     END DO
                     !
                     IF(SEP_LEN > 0) THEN
                           DO CONCURRENT (IDX=1:NLINE-1);  SIZ = SIZ + SEP_LEN
                           END DO
                     END IF
                     !
                     ALLOCATE(CHARACTER(SIZ)::LINE)
                     !
                     I=1
                     DO IDX=1, NLINE
                           SELECT TYPE(CHAR => LST%CUR%I)
                                           TYPE IS (CHARACTER(*))
                                                            SIZ = LEN(CHAR)
                                                            J = I - 1 + SIZ
                                                            LINE(I:J) = CHAR
                                                            I = I + SIZ
                           END SELECT
                           CALL LST%NEXT()
                           !
                           !
                           IF(SEP_LEN > 0) THEN
                                     IF(IDX .NE. NLINE) THEN
                                                            J = I - 1 + SEP_LEN
                                                            LINE(I:J) = SEP
                                                            I = I + SEP_LEN
                                     END IF
                                     
                           END IF
                     END DO
                     !
    ELSE
                     ALLOCATE(LINE, SOURCE=' ')
    END IF
    !
  END FUNCTION
  !
  !#######################################################################
  !
  SUBROUTINE CHAR_ADD_TRIMMED_VALUE_TO_ENDING(LST,STR,POS)
    CLASS(CHARACTER_LINKED_LIST), INTENT(INOUT):: LST
    CHARACTER(*),                 INTENT(IN   ):: STR
    INTEGER, OPTIONAL,            INTENT(IN   ):: POS
    !
    IF(PRESENT(POS)) THEN
        CALL ADD_VALUE_AT(LST,TRIM(STR),POS)
    ELSE
        CALL EXTEND_LIST_FROM_ENDING(LST,TRIM(STR))
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE CHAR_ADD_CORE_VALUE_TO_ENDING(LST,STR,POS)
    CLASS(CHARACTER_LINKED_LIST), INTENT(INOUT):: LST
    CHARACTER(*),                 INTENT(IN   ):: STR
    INTEGER, OPTIONAL,            INTENT(IN   ):: POS
    !
    IF(PRESENT(POS)) THEN
        CALL ADD_VALUE_AT(LST,TRIM(ADJUSTL(STR)),POS)
    ELSE
        CALL EXTEND_LIST_FROM_ENDING(LST,TRIM(ADJUSTL(STR)))
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  SUBROUTINE CHAR_ADD_UNIQUE_VALUE_TO_ENDING(LST,STR,POS)
    CLASS(CHARACTER_LINKED_LIST), INTENT(INOUT):: LST
    CHARACTER(*),                 INTENT(IN   ):: STR
    INTEGER, INTENT(OUT), OPTIONAL:: POS
    INTEGER:: I
    LOGICAL:: NOT_FOUND
    !
    IF(LST%N > 0) THEN
                     IF(PRESENT(POS)) POS = 0
                     !
                     NOT_FOUND=.TRUE.
                     CALL MOVE_TO_FIRST_POS(LST)
                     DO I=1, LST%N
                                  SELECT TYPE(CHAR => LST%CUR%I)
                                  TYPE IS (CHARACTER(*))
                                                   IF(STR == CHAR) THEN
                                                                        NOT_FOUND = .FALSE.
                                                                        IF(PRESENT(POS)) POS = I
                                                                        EXIT
                                                   END IF    
                                  END SELECT
                                  CALL MOVE_TO_NEXT_POS(LST)
                     END DO
                     IF(NOT_FOUND) CALL EXTEND_LIST_FROM_ENDING(LST,STR)
    ELSE
                                   CALL EXTEND_LIST_FROM_ENDING(LST,STR)
                                   IF(PRESENT(POS)) POS = 0
    END IF
    !
  END SUBROUTINE
  !
  !#######################################################################
  !
  FUNCTION CHAR_VALUE_UNIQUE_IN_LIST(LST,STR) RESULT(IS_UNIQUE)
    CLASS(CHARACTER_LINKED_LIST), INTENT(INOUT):: LST
    CHARACTER(*),                 INTENT(IN   ):: STR
    INTEGER:: I
    LOGICAL:: IS_UNIQUE
    !
    IS_UNIQUE = .TRUE.
    IF(LST%N > 0) THEN
                     !
                     CALL MOVE_TO_FIRST_POS(LST)
                     DO I=1, LST%N
                                  SELECT TYPE(CHAR => LST%CUR%I)
                                  TYPE IS (CHARACTER(*))
                                                   IF(STR == CHAR) THEN
                                                                        IS_UNIQUE = .FALSE.
                                                                        EXIT
                                                   END IF    
                                  END SELECT
                                  CALL MOVE_TO_NEXT_POS(LST)
                     END DO
    END IF
    !
  END FUNCTION
  !
  !##################################################################################################
  !
  SUBROUTINE CHAR_INITIALIZE_LINKED_LIST(LST)
     CLASS(CHARACTER_LINKED_LIST):: LST
     !
     CALL CHAR_LINKED_LIST_DEALLOCATE(LST)
     CALL INITIALIZE_LINKED_LIST(LST)
     !
     ALLOCATE(LST%ERR, SOURCE='ERROR')
     !
  END SUBROUTINE
  !
  !##################################################################################################
  !
  SUBROUTINE CHAR_LINKED_LIST_DEALLOCATE(LST)
     CLASS(CHARACTER_LINKED_LIST):: LST
     !
     LST%LN => NULL()
     IF(ASSOCIATED(LST%ERR)) DEALLOCATE(LST%ERR)
     CALL DELETE_ALL_LINKED_LIST_ENTRIES(LST)
     !
  END SUBROUTINE
  !
  !##################################################################################################
  !
  SUBROUTINE FINAL_CHARACTER_LINKED_LIST_DEALLOCATE(LST)
     TYPE(CHARACTER_LINKED_LIST):: LST
     !
     CALL CHAR_LINKED_LIST_DEALLOCATE(LST)
     !
  END SUBROUTINE
  !
END MODULE
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!    
!
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
!
MODULE INTEGER_QUEUE_INSTRUCTION
  IMPLICIT NONE
  !
  PUBLIC:: INTEGER_QUEUE
  PRIVATE
  !
  TYPE QUEUE
      INTEGER:: I
      TYPE(QUEUE), ALLOCATABLE:: NXT
  END TYPE
  !
  TYPE INTEGER_QUEUE
      INTEGER:: SIZ = 0
      TYPE(QUEUE):: DAT
      TYPE(QUEUE), POINTER:: CUR => NULL()
      TYPE(QUEUE), POINTER:: STP => NULL()
      !
      CONTAINS
      !
      PROCEDURE, PASS(P):: INIT     !([IVAL]) - WILL RESET QUEUE
      PROCEDURE, PASS(P):: PUSH     !(IVAL)
      PROCEDURE, PASS(P):: PULL     !()     - FUNCTION
      PROCEDURE, PASS(P):: PEEK     !()     - FUNCTION
      PROCEDURE, PASS(P):: PEEK_MIN !(P2)   - FUNCTION
      PROCEDURE, PASS(P):: SIZE     !()     - FUNCTION
      FINAL:: DEALLOCATE_QUEUE
  END TYPE
  !
  CONTAINS
  !
  SUBROUTINE INIT(P, IVAL)                 !Optional to call - Defaults will auto-append - Can use to reset size
    CLASS(INTEGER_QUEUE), INTENT(INOUT):: P
    INTEGER,   OPTIONAL, INTENT(IN   ):: IVAL
    !
    IF(PRESENT(IVAL)) THEN
                      P%SIZ      = 1
                      P%DAT%I    = IVAL
                      CALL SET_PNT(P%CUR,P%DAT)
                      CALL SET_PNT(P%STP,P%DAT)
    ELSE
                      P%SIZ      = 0
    END IF
  END SUBROUTINE
  !
  SUBROUTINE PUSH(P, IVAL)
    CLASS(INTEGER_QUEUE), INTENT(INOUT):: P
    INTEGER,                    INTENT(IN   ):: IVAL
    !
    IF( P%SIZ < 1 ) THEN
        P%SIZ   = 1
        P%DAT%I = IVAL
        CALL SET_PNT(P%CUR,P%DAT)
        CALL SET_PNT(P%STP,P%DAT)
    ELSE
        IF(.NOT. ALLOCATED(P%STP%NXT)) ALLOCATE(P%STP%NXT)
        !
        P%SIZ   =  P%SIZ + 1
        P%STP   => P%STP%NXT
        P%STP%I =  IVAL
    END IF
  END SUBROUTINE
  !
  FUNCTION PULL(P) RESULT(VAL)
    CLASS(INTEGER_QUEUE), INTENT(INOUT):: P
    INTEGER:: VAL
    IF( P%SIZ < 1 ) THEN
        VAL = HUGE(0)
    ELSE
        P%SIZ = P%SIZ - 1
        VAL   = P%CUR%I
        IF(P%SIZ > 0) P%CUR => P%CUR%NXT
    END IF
  END FUNCTION
  !
  FUNCTION PEEK(P) RESULT(VAL)
    CLASS(INTEGER_QUEUE), INTENT(INOUT):: P
    INTEGER:: VAL
    IF( P%SIZ < 1 ) THEN
        VAL = HUGE(0)
    ELSE
        VAL   = P%CUR%I
    END IF
  END FUNCTION
  !
  FUNCTION SIZE(P) RESULT(SIZ)
    CLASS(INTEGER_QUEUE), INTENT(INOUT):: P
    INTEGER:: SIZ
    SIZ = P%SIZ
  END FUNCTION
  !
  SUBROUTINE DEALLOCATE_QUEUE(P)
    TYPE(INTEGER_QUEUE), INTENT(INOUT):: P
    !
    P%SIZ =  0
    P%CUR => NULL()
    P%STP => NULL()
    !
    IF(ALLOCATED(P%DAT%NXT)) DEALLOCATE(P%DAT%NXT)
    !
  END SUBROUTINE
  !
  FUNCTION PEEK_MIN(P,P2) RESULT(VAL)
    CLASS(INTEGER_QUEUE), INTENT(IN):: P,P2
    INTEGER:: VAL
    IF( P%SIZ < 1 .AND. P2%SIZ < 1) THEN
                                        VAL = HUGE(0)
    ELSEIF( P%SIZ > 0 .AND. P2%SIZ < 1) THEN
                                        VAL = P%CUR%I
    ELSEIF( P%SIZ < 1 .AND. P2%SIZ > 0) THEN
                                        VAL = P2%CUR%I        
    ELSE
        IF( P%CUR%I < P2%CUR%I ) THEN
            VAL = P%CUR%I
        ELSE
            VAL = P2%CUR%I 
        END IF
    END IF
  END FUNCTION
  !
  SUBROUTINE SET_PNT(PNT, TARG)
    TYPE(QUEUE), POINTER, INTENT(INOUT):: PNT
    TYPE(QUEUE), TARGET , INTENT(IN   ):: TARG
    PNT => TARG
  END SUBROUTINE
  !
END MODULE
!
!!
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
MODULE CAST_TO_STRING
  USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: INT8, INT16, INT32, INT64, REAL32, REAL64 !CHARACTER_STORAGE_SIZE   !NO REAL128 SUPPORT
  ! ASSUMES CHARACTER(1) IS 1 BYTE (viz. CHARACTER_STORAGE_SIZE = 8)
  !
  IMPLICIT NONE
  PRIVATE
  PUBLIC::  CAST2STR
  !
  INTERFACE CAST2STR
                    MODULE PROCEDURE CAST_INT_TO_STRING
                    MODULE PROCEDURE CAST_FLOAT_TO_STRING
                    MODULE PROCEDURE CAST_DBLE_TO_STRING
                    MODULE PROCEDURE CAST_SUPERSHORT_TO_STRING
                    MODULE PROCEDURE CAST_SHORT_TO_STRING
                    MODULE PROCEDURE CAST_LONG_TO_STRING
  END INTERFACE
  !
  CONTAINS
  !
  IMPURE ELEMENTAL FUNCTION CAST_FLOAT_TO_STRING(X, SIZE) RESULT(STR)
  REAL(REAL32),         INTENT(IN ):: X
  INTEGER,     OPTIONAL,INTENT(OUT):: SIZE
  CHARACTER(4):: STR
  !
  IF(PRESENT(SIZE)) SIZE = 4
  !
  STR = TRANSFER(X,STR)
  !
  END FUNCTION
  !
  IMPURE ELEMENTAL FUNCTION CAST_DBLE_TO_STRING(X, SIZE) RESULT(STR)
  REAL(REAL64),         INTENT(IN ):: X
  INTEGER,     OPTIONAL,INTENT(OUT):: SIZE
  CHARACTER(8):: STR
  !
  IF(PRESENT(SIZE)) SIZE = 8
  !
  STR = TRANSFER(X,STR)
  !
  END FUNCTION
  !
  IMPURE ELEMENTAL FUNCTION CAST_SUPERSHORT_TO_STRING(X, SIZE) RESULT(STR)
  INTEGER(INT8),        INTENT(IN ):: X
  INTEGER,     OPTIONAL,INTENT(OUT):: SIZE
  CHARACTER(1):: STR
  !
  IF(PRESENT(SIZE)) SIZE = 1
  !
  STR = TRANSFER(X,STR)
  !
  END FUNCTION
  !
  IMPURE ELEMENTAL FUNCTION CAST_SHORT_TO_STRING(X, SIZE) RESULT(STR)
  INTEGER(INT16),       INTENT(IN ):: X
  INTEGER,     OPTIONAL,INTENT(OUT):: SIZE
  CHARACTER(2):: STR
  !
  IF(PRESENT(SIZE)) SIZE = 2
  !
  STR = TRANSFER(X,STR)
  !
  END FUNCTION
  !
  IMPURE ELEMENTAL FUNCTION CAST_INT_TO_STRING(X, SIZE) RESULT(STR)
  INTEGER(INT32),       INTENT(IN ):: X
  INTEGER,     OPTIONAL,INTENT(OUT):: SIZE
  CHARACTER(4):: STR
  !
  IF(PRESENT(SIZE)) SIZE = 4
  !
  STR = TRANSFER(X,STR)
  !
  END FUNCTION
  !
  IMPURE ELEMENTAL FUNCTION CAST_LONG_TO_STRING(X, SIZE) RESULT(STR)
  INTEGER(INT64),       INTENT(IN ):: X
  INTEGER,     OPTIONAL,INTENT(OUT):: SIZE
  CHARACTER(8):: STR
  !
  IF(PRESENT(SIZE)) SIZE = 8
  !
  STR = TRANSFER(X,STR)
  !
  END FUNCTION
END MODULE
!
!! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
!      CODE THAT PROVIDES FUNCTIONS FOR CALENDAR DATES, DECIMAL YEARS, AND JULIAN DAY NUMBERS
!
! COMMON VARIABLE NAMES
!    JDN  = Julian Date Number from 1 to 365 or 366
!    DYEAR= Decimal year where the mantissa is the JDN divided by either 365 or 366
!    FRAC = Fraction of a day; 0.0 <= FRAC < 1.0
!    mm   = String reprsentation of the month (e.g. for January '01/15/2015' or '1/15/2015'
!    dd   = String reprsentation of the day of month (e.g. for January 5th '01/05/2015' or '1/5/2015'
!    YYYY = String reprsentation of the year with four digits
!
!    DAY, MONTH, YEAR = SAME AS MEANING in mm/dd/YYYY
!
!
! FUNCTION LISTING:
!    
!    FUNCTION   ISLEAPYEAR(YEAR)                                              # TEST IF YEAR IS LEAP YEAR, RETURNS TRUE/FALSE
!    FUNCTION   MONTHDAYS(MONTH,YEAR,[LEAP])                                  # RETURNS NUMBER OF DAYS IN MONTH GIVEN YEAR, IF LEAP IS PROVIDED THEN YEAR IS IGNORED AND RETURNS THE NUMEBR OF DAYS FOR A LEAP/NONLEAP
!    FUNCTION   JULIANDAY(DAY, MONTH, YEAR)                                   # RETURNS NUMBER OF JULIAN DAY NUMBER (JDN=1 is January 1st)
!    SUBROUTINE JULIANDAY_TO_DATE(JDN_IN, YEAR_IN, DAY, MONTH, YEAR, [JDN])   # GET DATE GIVEN A JULIAN DAY NUMBER AND YEAR. JDN_IN CAN BE <1 and >366. 
!    SUBROUTINE DYEAR_TO_DATE(DYEAR, DAY, MONTH, YEAR, [FRAC], [JDN])         # GET DATE GIVEN DECIMAL YEAR
!    FUNCTION   DATE_TO_DYEAR(DAY, MONTH, YEAR, FRAC)                         # RETURNS DECIMAL YEAR GIVEN DATE
!    FUNCTION   JDN_TO_DYEAR(JDN, YEAR, [FRAC])                               # RETURNS DECIMAL YEAR GIVEN JULIAN DATE
!    
!
!
! MODULE CALENDAR_FUNCTIONS
!    FUNCTIONS THAT HANDLE BASIC CALENDER OPERATIONS
!                                                 VERSION 1.0 [3/20/2015] ORIGINAL VERSION
!
MODULE CALENDAR_FUNCTIONS
  USE, INTRINSIC:: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN
  USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: REAL32, REAL64               ! REAL32 = SINGLE PRECISION, REAL64 = DOUBLE PRECISION
  IMPLICIT NONE
  PRIVATE:: IEEE_VALUE, IEEE_QUIET_NAN, REAL32, REAL64
  !PRIVATE:: TRUE, FALSE, Z, ONE, DZ, UNO, IDIFF
  PRIVATE:: LEAP_CHECK
  !
  LOGICAL,      PARAMETER:: TRUE  = .TRUE.
  LOGICAL,      PARAMETER:: FALSE = .FALSE.
  INTEGER,      PARAMETER:: IDIFF=ICHAR('a')-ICHAR('A')
  INTEGER,      PARAMETER:: Z     = 0
  INTEGER,      PARAMETER:: ONE   = 1
  REAL(REAL64), PARAMETER:: DZ  = 0.0_REAL64 
  REAL(REAL64), PARAMETER:: UNO = 1.0_REAL64 
  !
  REAL(REAL64), PARAMETER:: DAY2SEC = 86400D0  ! ~ 1 day in seconds
  REAL(REAL64), PARAMETER:: DAY2MIN =  1440D0  ! ~ 1 day in minutes
  REAL(REAL64), PARAMETER:: DAY2HR  =    24D0  ! ~ 1 day in hour hours
  !
  REAL(REAL64), PARAMETER:: SEC2DAY = 1.1574074074074074074D-5  ! ~ 1 second in days
  REAL(REAL64), PARAMETER:: MIN2DAY = 6.9444444444444444444D-4  ! ~ 1 minute in days
  REAL(REAL64), PARAMETER::  HR2DAY = 0.0416666666666666666D0   ! ~ 1 hour   in days 
  !
  INTERFACE YEAR_FRACTION
    MODULE PROCEDURE YEAR_FRACTION_DYEAR
    MODULE PROCEDURE YEAR_FRACTION_DMY
  END INTERFACE
  !
  INTERFACE TIME_TO_DAY_FRACTION ! (HOUR, MIN, SEC)
     MODULE PROCEDURE TIME_TO_DAY_FRACTION_INT_INT_INT
     MODULE PROCEDURE TIME_TO_DAY_FRACTION_INT_INT_DBL
     MODULE PROCEDURE TIME_TO_DAY_FRACTION_INT_DBL_DBL
     MODULE PROCEDURE TIME_TO_DAY_FRACTION_DBL_DBL_DBL
     MODULE PROCEDURE STR_TIME_TO_DAY_FRACTION       !(STR)
  END INTERFACE
  !
  CONTAINS
  !
  ELEMENTAL PURE FUNCTION ISLEAPYEAR(YEAR) 
    INTEGER, INTENT(IN):: YEAR
    LOGICAL::ISLEAPYEAR
    !
    IF(   (MOD(YEAR,4).EQ.Z .AND. MOD(YEAR,100).NE.Z) .OR. MOD(YEAR,400).EQ.Z )THEN  !LEAP YEAR IF YEAR IS DIVISABLE BY 4 AND NOT 100 OR IF YEAR IS DIVISABLE BY 400
        ISLEAPYEAR=TRUE
    ELSE
        ISLEAPYEAR=FALSE
    END IF     
    !
  END FUNCTION
  !  
  ELEMENTAL PURE FUNCTION LEAP_CHECK(YEAR, LEAP) RESULT(LEAPYEAR)  !NECESSARY FOR SUBROUTINES THAT MAY NOT INCLUDE YEAR BUT SPECIFY LEAP VARIABLE
    INTEGER, INTENT(IN), OPTIONAL:: YEAR
    LOGICAL, INTENT(IN), OPTIONAL:: LEAP
    LOGICAL:: LEAPYEAR
    !
    IF(PRESENT(YEAR)) THEN
        IF(YEAR.NE.Z) THEN
                      LEAPYEAR = ISLEAPYEAR(YEAR)
        ELSEIF(PRESENT(LEAP)) THEN
                      LEAPYEAR = LEAP   ! YEAR=0, YES LEAP
        ELSE
                      LEAPYEAR = TRUE   ! YEAR=0, NO LEAP
        END IF
    ELSE
        IF(PRESENT(LEAP)) THEN
                      LEAPYEAR = LEAP   ! NO YEAR, YES LEAP
        ELSE
                      LEAPYEAR = FALSE  ! NO YEAR, NO LEAP
        END IF
    END IF
    !
  END FUNCTION
  !  
  ELEMENTAL PURE FUNCTION MONTHDAYS(MONTH, YEAR, LEAP) 
    INTEGER, INTENT(IN):: MONTH
    INTEGER, INTENT(IN), OPTIONAL:: YEAR
    LOGICAL, INTENT(IN), OPTIONAL:: LEAP
    INTEGER:: MONTHDAYS
    !
    MONTHDAYS = Z
    !
    IF(MONTH==1 .OR. MONTH==3 .OR. MONTH==5 .OR. MONTH==7 .OR. MONTH==8 .OR. MONTH==10 .OR. MONTH==12) THEN
        MONTHDAYS = 31
    ELSEIF(MONTH==4 .OR. MONTH==6 .OR. MONTH==9 .OR. MONTH==11) THEN
        MONTHDAYS = 30
    ELSEIF( LEAP_CHECK(YEAR, LEAP) ) THEN !MONTH = 2
        MONTHDAYS = 29
    ELSE                                  !MONTH = 2
        MONTHDAYS = 28
    END IF
    !
  END FUNCTION
  !  
  ELEMENTAL PURE FUNCTION JULIANDAY(DAY, MONTH, YEAR, LEAP) 
    !
    INTEGER, INTENT(IN):: DAY, MONTH 
    INTEGER, INTENT(IN), OPTIONAL:: YEAR
    LOGICAL, INTENT(IN), OPTIONAL:: LEAP
    INTEGER:: JULIANDAY
    !
    IF( MONTH > 2 ) THEN
        IF(LEAP_CHECK(YEAR, LEAP)) THEN
            JULIANDAY = DAY + ONE
        ELSE
            JULIANDAY = DAY
        END IF
    ELSE
            JULIANDAY = DAY
    END IF
    !
    IF    (MONTH == 2) THEN
        JULIANDAY = JULIANDAY + 31
    ELSEIF(MONTH == 3) THEN
        JULIANDAY = JULIANDAY + 59
    ELSEIF(MONTH == 4) THEN
        JULIANDAY = JULIANDAY + 90
    ELSEIF(MONTH == 5) THEN
        JULIANDAY = JULIANDAY + 120
    ELSEIF(MONTH == 6) THEN
        JULIANDAY = JULIANDAY + 151
    ELSEIF(MONTH == 7) THEN
        JULIANDAY = JULIANDAY + 181
    ELSEIF(MONTH == 8) THEN
        JULIANDAY = JULIANDAY + 212
    ELSEIF(MONTH == 9) THEN
        JULIANDAY = JULIANDAY + 243
    ELSEIF(MONTH == 10) THEN
        JULIANDAY = JULIANDAY + 273
    ELSEIF(MONTH == 11) THEN
        JULIANDAY = JULIANDAY + 304
    ELSEIF(MONTH == 12) THEN
        JULIANDAY = JULIANDAY + 334
    END IF
    !
  END FUNCTION
  !  
!!!  ELEMENTAL PURE FUNCTION MONTHDAYS(MONTH, YEAR, LEAP) 
!!!    INTEGER, INTENT(IN):: MONTH
!!!    INTEGER, INTENT(IN), OPTIONAL:: YEAR
!!!    LOGICAL, INTENT(IN), OPTIONAL:: LEAP
!!!    INTEGER:: MONTHDAYS
!!!    !
!!!    MONTHDAYS = Z
!!!    !
!!!    SELECT CASE (MONTH)
!!!    CASE (1, 3, 5, 7, 8, 10, 12)
!!!        MONTHDAYS = 31
!!!    CASE (4, 6, 9, 11)
!!!        MONTHDAYS = 30
!!!    CASE (2)
!!!        IF( LEAP_CHECK(YEAR, LEAP) ) THEN
!!!            MONTHDAYS = 29
!!!        ELSE
!!!            MONTHDAYS = 28
!!!        END IF
!!!    END SELECT
!!!    !
!!!  END FUNCTION
!!!  !  
!!!  ELEMENTAL PURE FUNCTION JULIANDAY(DAY, MONTH, YEAR, LEAP) 
!!!    !
!!!    INTEGER, INTENT(IN):: DAY, MONTH 
!!!    INTEGER, INTENT(IN), OPTIONAL:: YEAR
!!!    LOGICAL, INTENT(IN), OPTIONAL:: LEAP
!!!    INTEGER:: JULIANDAY
!!!    INTEGER:: M
!!!    !
!!!    JULIANDAY = Z
!!!    !
!!!    DO M=1, MONTH - 1
!!!        JULIANDAY = JULIANDAY + MONTHDAYS(M,YEAR,LEAP)
!!!    END DO
!!!    !
!!!    JULIANDAY = JULIANDAY + DAY
!!!    !
!!!  END FUNCTION
  !  
!  ELEMENTAL PURE FUNCTION JULIANDAY(DAY, MONTH, YEAR) 
!    ! https://en.wikipedia.org/wiki/Julian_day#Converting_Julian_or_Gregorian_calendar_date_to_Julian_day_number
!    INTEGER, INTENT(IN):: DAY, MONTH, YEAR
!    INTEGER:: JULIANDAY
!    INTEGER:: A, Y, M
!    !
!    A = (14 - MONTH)/12
!    Y = YEAR + 4800 - A
!    M = MONTH + 12*A - 3
!    !
!    IF ( YEAR<=1582 .AND. MONTH<=10 .AND. DAY<=15) THEN         !IF TRUE THEN CAN NOT CALCULATE RETURN FLAG
!        JULIANDAY=-1 
!    ELSE
!        JULIANDAY = DAY + (153*M+2)/5 + 365*Y + Y/4 - Y/100 + Y/400 - 32045
!    END IF
!    !
!  END FUNCTION
  !  
  ELEMENTAL PURE SUBROUTINE JULIANDAY_TO_DATE(JDN_IN, YEAR_IN, DAY, MONTH, YEAR, JDN, LEAP) 
    INTEGER, INTENT(IN):: JDN_IN, YEAR_IN
    INTEGER, INTENT(OUT):: DAY, MONTH, YEAR
    INTEGER, INTENT(OUT), OPTIONAL:: JDN
    LOGICAL, INTENT(IN ), OPTIONAL:: LEAP
    INTEGER:: DOY, MDAY
    LOGICAL:: LEAPYEAR, ZERO_YEAR
    !
    DOY  = JDN_IN
    YEAR = YEAR_IN
    !
    ZERO_YEAR = YEAR == Z
    !
    LEAPYEAR = LEAP_CHECK(YEAR, LEAP)
    !
    DO
       IF     ( DOY > 366 .AND.      LEAPYEAR ) THEN
                                                            DOY  = DOY - 366
                                                            YEAR = YEAR + 1
       ELSEIF ( DOY > 365 .AND. .NOT.LEAPYEAR ) THEN     
                                                            DOY  = DOY - 365
                                                            YEAR = YEAR + 1
       ELSEIF ( DOY < 1   .AND.      LEAPYEAR) THEN
                                                            DOY  = DOY + 366
                                                            YEAR = YEAR - 1
       ELSEIF ( DOY < 1) THEN       
                                                            DOY  = DOY + 365
                                                            YEAR = YEAR - 1
       ELSE
           EXIT
       END IF
    END DO
    !
    IF(ZERO_YEAR) THEN
                      IF(PRESENT(LEAP)) YEAR = Z !PREVENT INCREMENT OF YEAR BECAUSE IT IS BEING TREATED AS A FRACTOIN OF YEAR
    END IF
    !
    IF(PRESENT(JDN)) JDN = DOY
    !
    DO MONTH=1, 12
        MDAY= MONTHDAYS(MONTH,YEAR,LEAP)
        DOY = DOY - MDAY
        IF (DOY < 1) THEN
            DOY = DOY + MDAY
            EXIT
        END IF
    END DO
    !
    DAY = DOY
    !
  END SUBROUTINE  
  !  
  ELEMENTAL PURE SUBROUTINE DYEAR_TO_DATE(DYEAR, DAY, MONTH, YEAR, FRAC, JDN, LEAP) 
    REAL(REAL64), INTENT(IN ):: DYEAR
    INTEGER,      INTENT(OUT):: DAY, MONTH, YEAR
    REAL(REAL64), INTENT(OUT), OPTIONAL:: FRAC
    INTEGER,      INTENT(OUT), OPTIONAL:: JDN
    LOGICAL,      INTENT(IN ), OPTIONAL:: LEAP
    INTEGER:: DOY, YR
    REAL(REAL64)::TEMP
    LOGICAL:: LEAPYEAR
    !
    YR = INT(DYEAR)
    !
    LEAPYEAR = LEAP_CHECK(YR, LEAP)
    !
    TEMP = DYEAR - DBLE(YR)
    IF ( LEAPYEAR ) THEN
      DOY = INT(366D0*TEMP)
      TEMP=     366D0*TEMP
    ELSE
      DOY = INT(365D0*TEMP)
      TEMP=     365D0*TEMP
    END IF
    !
    TEMP = TEMP - DBLE(DOY)  !FRACTION OF DAY REMAINING
    !
    IF(UNO - TEMP < 0.5D-8) THEN  !MUST BE WITHIN 0.5 milisecond
        TEMP = DZ
        DOY = DOY + ONE
    END IF
    !
    IF (PRESENT(FRAC)) FRAC = TEMP
    !
    DOY = DOY + ONE                   !MOVE FROM ZERO START TO 1 START
    IF  (PRESENT(JDN)) JDN = DOY
    !
    CALL JULIANDAY_TO_DATE(DOY, YR, DAY, MONTH, YEAR, LEAP=LEAP)
    !
  END SUBROUTINE
  !  
  ELEMENTAL PURE FUNCTION DATE_TO_DYEAR(DAY, MONTH, YEAR, FRAC, LEAP) 
    INTEGER, INTENT(IN):: DAY, MONTH, YEAR
    REAL(REAL64), INTENT(IN), OPTIONAL:: FRAC
    LOGICAL,      INTENT(IN), OPTIONAL:: LEAP
    REAL(REAL64):: DATE_TO_DYEAR
    INTEGER:: JDN
    !
    JDN = JULIANDAY(DAY, MONTH, YEAR, LEAP) 
    !
    DATE_TO_DYEAR = JDN_TO_DYEAR(JDN, YEAR, FRAC, LEAP) 
    !
  END FUNCTION
  !  
  ELEMENTAL PURE FUNCTION JDN_TO_DYEAR(JDN, YEAR, FRAC, LEAP) 
    INTEGER, INTENT(IN):: JDN
    INTEGER,      INTENT(IN), OPTIONAL:: YEAR
    REAL(REAL64), INTENT(IN), OPTIONAL:: FRAC
    LOGICAL,      INTENT(IN), OPTIONAL:: LEAP
    REAL(REAL64):: JDN_TO_DYEAR
    REAL(REAL64):: YR, DOY
    LOGICAL:: LEAPYEAR
    !
    IF(PRESENT(YEAR)) THEN
                          YR = DBLE(YEAR)
    ELSE
                          YR = Z
    END IF
    !
    DOY=DBLE(JDN) - UNO            !MOVE TO MIDNIGHT WHEN THE DAY FIRST STARTS   !  <=========================
    !
    LEAPYEAR = LEAP_CHECK(YEAR, LEAP)
    !
    IF ( LEAPYEAR ) THEN
      JDN_TO_DYEAR = YR + DOY/366D0
    ELSE
      JDN_TO_DYEAR = YR + DOY/365D0 
    END IF
    !
    IF(PRESENT(FRAC)) THEN
      IF(LEAPYEAR) THEN
        JDN_TO_DYEAR = JDN_TO_DYEAR + FRAC/366D0
      ELSE
        JDN_TO_DYEAR = JDN_TO_DYEAR + FRAC/365D0
      END IF
    END IF    
    !
  END FUNCTION
  !  
  ELEMENTAL PURE FUNCTION YEAR_DAY_COUNT(YEAR, LEAP) 
    INTEGER, INTENT(IN), OPTIONAL:: YEAR
    LOGICAL, INTENT(IN), OPTIONAL:: LEAP
    INTEGER:: YEAR_DAY_COUNT
    !
    IF(LEAP_CHECK(YEAR, LEAP))THEN
        YEAR_DAY_COUNT = 366
    ELSE
        YEAR_DAY_COUNT = 365
    END IF
    !
  END FUNCTION
  !  
  ELEMENTAL PURE FUNCTION YEAR_DAY_COUNT_DBLE(YEAR, LEAP) 
    INTEGER, INTENT(IN), OPTIONAL:: YEAR
    LOGICAL, INTENT(IN), OPTIONAL:: LEAP
    REAL(REAL64):: YEAR_DAY_COUNT_DBLE
    !
    IF(LEAP_CHECK(YEAR, LEAP))THEN
        YEAR_DAY_COUNT_DBLE = 366D0
    ELSE
        YEAR_DAY_COUNT_DBLE = 365D0
    END IF
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION YEAR_FRACTION_DYEAR(DYEAR) RESULT(YFRAC)
    REAL(REAL64), INTENT(IN):: DYEAR
    REAL(REAL64):: YFRAC
    INTEGER:: YEAR
    !
    YEAR = INT(DYEAR)
    IF(YEAR.NE.Z) THEN
        YFRAC = DYEAR - DBLE(YEAR)
    ELSE
        YFRAC = DYEAR
    END IF
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION YEAR_FRACTION_DMY(DAY, MONTH, YEAR, FRAC, LEAP) RESULT(YFRAC)
    INTEGER,                INTENT(IN):: YEAR, MONTH, DAY
    REAL(REAL64), OPTIONAL, INTENT(IN):: FRAC
    LOGICAL,      OPTIONAL, INTENT(IN):: LEAP
    REAL(REAL64):: YFRAC
    REAL(REAL64):: JDN
    !
    IF(PRESENT(LEAP)) THEN
        JDN = DBLE( JULIANDAY(DAY, MONTH, Z, LEAP) - ONE )
        IF(LEAP) THEN
            YFRAC = JDN/366D0
            IF(PRESENT(FRAC)) YFRAC = YFRAC + FRAC/366D0
        ELSE
            YFRAC = JDN/365D0
            IF(PRESENT(FRAC)) YFRAC = YFRAC + FRAC/365D0
        END IF
    ELSE
        JDN = DBLE( JULIANDAY(DAY, MONTH, YEAR) - ONE )
        !
        IF(ISLEAPYEAR(YEAR)) THEN
            YFRAC = JDN/366D0
            IF(PRESENT(FRAC)) YFRAC = YFRAC + FRAC/366D0
        ELSE
            YFRAC = JDN/365D0
            IF(PRESENT(FRAC)) YFRAC = YFRAC + FRAC/365D0
        END IF
    END IF
    !
  END FUNCTION
  !
  PURE FUNCTION MONTHNAME(MONTHNUM,FULLNAME)  RESULT(MON)
    INTEGER,           INTENT(IN):: MONTHNUM
    LOGICAL, OPTIONAL, INTENT(IN):: FULLNAME
    CHARACTER(:), ALLOCATABLE:: MON
    LOGICAL::FULL
    !
    FULL = FALSE
    IF(PRESENT(FULLNAME)) THEN; FULL = FULLNAME
    END IF
    !
    SELECT CASE(MONTHNUM)
    CASE( 1)
            IF(FULL) THEN
                        MON = 'January'
            ELSE
                        MON = 'JAN'
            END IF
    CASE( 2)
            IF(FULL) THEN
                        MON = 'February'
            ELSE
                        MON = 'FEB'
            END IF
    CASE( 3)
            IF(FULL) THEN
                        MON = 'March'
            ELSE
                        MON = 'MAR'
            END IF
    CASE( 4)
            IF(FULL) THEN
                        MON = 'April'
            ELSE
                        MON = 'APR'
            END IF
    CASE( 5)
            IF(FULL) THEN
                        MON = 'May'
            ELSE
                        MON = 'MAY'
            END IF
    CASE( 6)
            IF(FULL) THEN
                        MON = 'June'
            ELSE
                        MON = 'JUN'
            END IF
    CASE( 7)
            IF(FULL) THEN
                        MON = 'July'
            ELSE
                        MON = 'JUL'
            END IF
    CASE( 8)
            IF(FULL) THEN
                        MON = 'August'
            ELSE
                        MON = 'AUG'
            END IF
    CASE( 9)
            IF(FULL) THEN
                        MON = 'September'
            ELSE
                        MON = 'SEP'
            END IF
    CASE(10)
            IF(FULL) THEN
                        MON = 'October'
            ELSE
                        MON = 'OCT'
            END IF
    CASE(11)
            IF(FULL) THEN
                        MON = 'November'
            ELSE
                        MON = 'NOV'
            END IF
    CASE(12)
            IF(FULL) THEN
                        MON = 'December'
            ELSE
                        MON = 'DEC'
            END IF
    CASE DEFAULT
                        MON = '???'
    END SELECT
    !
  END FUNCTION
  !
  PURE FUNCTION MONTHNUM(MONTHNAME)  RESULT(MON) !RETURN MONTHNUMBER OF -1
    CHARACTER(*),  INTENT(IN):: MONTHNAME
    INTEGER:: MON
    CHARACTER(3):: NAM
    !
    NAM = ADJUSTL(MONTHNAME)
    !
    IF(NAM(1:1).GE.'a' .AND. NAM(1:1).LE.'z') NAM(1:1) = CHAR(ICHAR(NAM(1:1))-IDIFF)
    IF(NAM(2:2).GE.'a' .AND. NAM(2:2).LE.'z') NAM(2:2) = CHAR(ICHAR(NAM(2:2))-IDIFF)
    IF(NAM(3:3).GE.'a' .AND. NAM(3:3).LE.'z') NAM(3:3) = CHAR(ICHAR(NAM(3:3))-IDIFF)
    !
    SELECT CASE(NAM)
    CASE('JAN'); MON = 1 !NOTE THIS WILL ALSO WORK FOR January
    CASE('FEB'); MON = 2 
    CASE('MAR'); MON = 3 
    CASE('APR'); MON = 4 
    CASE('MAY'); MON = 5 
    CASE('JUN'); MON = 6 
    CASE('JUL'); MON = 7 
    CASE('AUG'); MON = 8 
    CASE('SEP'); MON = 9 
    CASE('OCT'); MON = 10
    CASE('NOV'); MON = 11
    CASE('DEC'); MON = 12
    CASE DEFAULT
                 MON = -1
    END SELECT
    !
  END FUNCTION
  !
  PURE ELEMENTAL FUNCTION TIME_TO_DAY_FRACTION_INT_INT_INT(HOUR, MIN, SEC) RESULT(FRAC)
    INTEGER, INTENT(IN):: HOUR, MIN, SEC
    REAL(REAL64):: FRAC
    !
    FRAC = DBLE(HOUR)*HR2DAY + DBLE(MIN)*MIN2DAY + DBLE(SEC)*SEC2DAY
    !FRAC = DBLE(HOUR)/24D0  + DBLE(MIN)/1440D0  + DBLE(SEC)/86400D0
    !
  END FUNCTION
  !
  PURE ELEMENTAL FUNCTION TIME_TO_DAY_FRACTION_INT_INT_DBL(HOUR, MIN, SEC) RESULT(FRAC)
    INTEGER,      INTENT(IN):: HOUR, MIN
    REAL(REAL64), INTENT(IN):: SEC
    REAL(REAL64):: FRAC
    !
    FRAC = DBLE(HOUR)*HR2DAY + DBLE(MIN)*MIN2DAY + SEC*SEC2DAY
    !FRAC = DBLE(HOUR)/24D0  + DBLE(MIN)/1440D0  + SEC/86400D0
    !
  END FUNCTION
  !
  PURE ELEMENTAL FUNCTION TIME_TO_DAY_FRACTION_INT_DBL_DBL(HOUR, MIN, SEC) RESULT(FRAC)
    INTEGER,      INTENT(IN):: HOUR
    REAL(REAL64), INTENT(IN):: SEC, MIN
    REAL(REAL64):: FRAC
    !
    FRAC = DBLE(HOUR)*HR2DAY + MIN*MIN2DAY + SEC*SEC2DAY
    !FRAC = DBLE(HOUR)/24D0  + MIN/1440D0  + SEC/86400D0
    !
  END FUNCTION
  !
  PURE ELEMENTAL FUNCTION TIME_TO_DAY_FRACTION_DBL_DBL_DBL(HOUR, MIN, SEC) RESULT(FRAC)
    REAL(REAL64), INTENT(IN):: HOUR, SEC, MIN
    REAL(REAL64):: FRAC
    !
    FRAC = HOUR*HR2DAY + MIN*MIN2DAY + SEC*SEC2DAY
    !FRAC = HOUR/24D0  + MIN/1440D0  + SEC/86400D0
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION STR_TIME_TO_DAY_FRACTION(TIME) RESULT(FRAC)
    CHARACTER(*), INTENT(IN):: TIME
    REAL(REAL64):: FRAC
    INTEGER:: I,A,B,C,IERR
    INTEGER:: HOUR, MIN, SEC
    !
    I = SCAN(TIME,'Tt') + ONE
    A = INDEX(TIME,':')
    B = INDEX(TIME,':',TRUE)
    C = LEN_TRIM(TIME)
    !
    IF(C > B + 2) C = B + 2
    IF( A == B  ) B = C
    !
    READ(TIME(I:A-1), *, IOSTAT=IERR) HOUR
    !
    IF(IERR == Z) READ(TIME(A+1:B-1),*, IOSTAT=IERR) MIN
    !
    IF( B == C ) THEN
                          SEC = Z
    ELSEIF(IERR == Z) THEN
                          READ(TIME(B+1:C)  ,*, IOSTAT=IERR) SEC
    END IF
    !
    IF(IERR.NE.Z) THEN
        FRAC = IEEE_VALUE(FRAC, IEEE_QUIET_NAN)
    ELSE
        FRAC = DBLE(HOUR)*HR2DAY + DBLE(MIN)*MIN2DAY + DBLE(SEC)*SEC2DAY
        !FRAC = DBLE(HOUR)/24D0 + DBLE(MIN)/1440D0 + DBLE(SEC)/86400D0
    END IF
    !
  END FUNCTION
  !
END MODULE
!
!! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
!      CODE THAT PROVIDES A DATE DATA TYPE THAT SUPPORTS DATE OPERATIONS, COMPARISONS, AND INTERPOLATION
!
!                         INCLUDES OPERATIONS FOR CALENDAR DATES, DECIMAL YEARS, AND JULIAN DAY NUMBERS
!
! COMMON VARIABLE NAMES
!    JDN  = Julian Date Number from 1 to 365 or 366
!    DYEAR= Decimal year where the mantissa is the JDN divided by either 365 or 366
!    FRAC = Fraction of a day; 0.0 <= FRAC < 1.0
!    mm   = String reprsentation of the month (e.g. for January '01/15/2015' or '1/15/2015'
!    dd   = String reprsentation of the day of month (e.g. for January 5th '01/05/2015' or '1/5/2015'
!    YYYY = String reprsentation of the year with four digits
!
!    DAY, MONTH, YEAR = SAME AS MEANING in mm/dd/YYYY
!
! MODULE DATE_OPERATOR_INSTRUCTION
!    DERIVED DATE TYPE, DATE_OPERATOR,
!    AND ASSOCIATED FUNBCTIONS THAT HANDLE DATE OPERATIONS
!                                                 VERSION 1.0 [3/20/2015] ORIGINAL VERSION
!
!    EXAMPLE:
!             TYPE(DATE_OPERATOR):: DT
!
!    TO INITIALIZE THE DATE_OPERATOR EITHER IT AS A FUNCTION OR ITS BUILT IN INIT ROUTINE.
!
!    DT = DATE_OPERATOR(INPUT)   OR   CALL DT%INIT(INPUT)
!
!    WHERE (INPUT) CAN BE ONE OF THE FOLLOWING OPTIONS:
!
!       ('mm/dd/YYYY')   or   (DAY, MONTH, YEAR)   or   (JDN, YEAR)   or   (DYEAR)
!       ('yyyy-mm-dd')   or   (DAY, MONTH, YEAR, HOUR, MIN, SEC)
! 
!    SUPPORTED OPERATIONS 
!                        DT+5.0            # ADD      FIVE DAYS TO DT
!                        DT-5.0            # SUBTRACT FIVE DAYS TO DT
!                        DT-DT2            # RETURN NUMBER OF DAYS BETWEEN DT AND DT2
!                        DT=DT2            # SET DT EQUAL TO DT2
!                        DT==DT2           # LOGICAL EQUIVALENCE
!                        DT<DT2; DT<=DT2   # LOGICAL COMPARISONS
!                        DT>DT2; DT>=DT2   # LOGICAL COMPARISONS
!                        WRITE(*,*) DT     # WRITES TO COMMAND PROMPT A PRITTY PRINT OF THE DATE
! 
! FUNCTION LISTING:
!
!     DT%INTERPOLATE(DT1,DT2,DAT1,DAT2)    # LINEAR INTERPOLATE TO DATE, DT, USING (DATE, VALUE) => (DT1, DAT1) and (DT2,DAT2)
!    
!     DT%CONTAIN_MD(M,D,DT2,[INCLUSIVE])   # RETURN TRUE IF MONTH M and DAY D IS STRICTLY BETWEEN DT and DT2; IF INCLUSE IS SET TO TRUE, THEN IT IS AN INCLUSIVE COMPARISION
!     DT%CONTAIN_MD(DT3,DT2,[INCLUSIVE])   # RETURN TRUE IF MONTH AND DAY WITHIN DT3 IS STRICTLY BETWEEN DT and DT2; IF INCLUSE IS SET TO TRUE, THEN IT IS AN INCLUSIVE COMPARISION
!
!     DT%DAYS_TO_MD(M, D)                  # RETURN NUMBER OF DAYS FROM DT TO GIVEN MONTH M AND DAY D
!     DT%DAYS_TO_MD(MD)                    # RETURN NUMBER OF DAYS FROM DT TO GIVEN DATE STORED IN MD
!     
!     DT%STR([SEP],[ISO])                  # RETURN DATE AS A STRING. IF CHAR: SEP IS PRESENT THEN INCLUDES TIME WITH SEP BEING THE SEPARTING BETWEEN DATE AND TIME. ISO IS SET TO TRUE FOR ISO FORMAT OR FALSE FOR AMERICAN
!     DT%STR_MONTHYEAR([FULLNAME])         # RETURN DATE AS THE FORM MMM-YYYY, IF FULLNAME IS SET TO TRUE THEN PRINT AS MMMMMMMM-YYYY (JANAURY-2015) 
!     DT%STR_YEARMONTH([SEP])              # RETURN DATE AS YYYY_MM; IF CHAR: SEP IS SPECIFIED, THEN IT REPLACES THE _ WITH WHATEVER IS PASSED IN 
!     DT%PRETTYPRINT                        # RETURN FULL DATE AS STRING IN THE FORM OF "APRIL 23, 1979"
!     
!     DT%DIFF(DT2)                         # RETURN NUMBER OF DAYS BETWEEN DT AND DT2, EQUIVALENT TO DT-DT2
!     DT%TIME()                            # RETURN CHARACTER(8) THAT CONTAINS THE 24HR CLOCK TIME IN DT IN THE FORM "HH:MM:SS"  --THIS CONVERTS DT%FRAC TO CLOCK TIME
!     DT%ISLEAPYEAR()                      # RETURN TRUE/FALSE IF DT IS IN A LEAP YEAR
!     DT%MONTHDAYS()                       # RETURN THE TOTAL NUMBER OF DAYS FOR MONTH IN DT
!     DT%IS_SET()                          # RETURN TRUE IF DATE HAS BEEN SET
!     DT%NOT_SET()
!     DT%NO_YEAR()
!     DT%YEAR_DAY_COUNT(Y)                 # RETURN NUMBEROF DAYS IN YEAR
!     DT%YEAR_FRACTION()                   # RETURN FRACTION OF YEAR FROM 0 to 1, with 0 BEING Jan 1 at midnight
!
! SUBROUTINE LISTING:
!     DT%NOW()                             # SET DT TO CURRENT DATE AND TIME
!    
!     DT%ADD_DAY(DAY,[FRAC])               # NEW DATE_OPERATOR WITH ADDED DAYS AND OPTIONALLY ADDED FRAC
!     DT%ADD_MONTH                         # NEW DATE_OPERATOR WITH ADDED MONTHS
!     DT%ADD_YEAR                          # NEW DATE_OPERATOR WITH ADDED YEARS
!     DT%SET_YEAR (Y)                      # CHANGE DATES YEAR  TO Y
!     DT%SET_MONTH(M)                      # CHANGE DATES MONTH TO M
!     DT%SET_DAY  (D)                      # CHANGE DATES DAY   TO D
!     DT%ZERO_YEAR()                       # REMOVE YEAR FROM DATE AND MAKE IT SO IT JUST IS A MONTH-DAY DATE
!     DT%DESTROY()                         # DEALLOCATE AND RESET DATE (SETS TO -999)
!     DT%SET_DATE_STRING()                 # REBUILD INTERNAL DATE STRING
!  
MODULE DATE_OPERATOR_INSTRUCTION!, ONLY: DATE_OPERATOR
  USE CALENDAR_FUNCTIONS
  USE, INTRINSIC:: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN
  USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: REAL32, REAL64
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: DATE_OPERATOR, DATE_STR_TO_DYEAR!(DATE_STRING)
  !
  ! Date input strings accepted:
  ! yyyy-mm                  mm/yyyy
  ! yyyy-mm-dd               mm/dd/yyyy
  ! yyyy-mm-ddThh:MM:ss      mm/dd/yyyyThh:MM:ss
  ! 
  ! For loading only month and day and set year to zero
  !
  ! mm\dd
  ! mmm    --Three letter month or full month name viz. FEB or Feburary
  ! mmm-dd
  ! mmm/dd
  !
  ! Main Functions for TYPE(DATE_OPERATOR):: DT, DT2
  !
  !   Assignment      DT2 = DT1  or DT2 = DATE_OPERATOR(...)   see INTERFACE DATE_OPERATOR
  !
  !   Arrithmatic     DT2 = DT1 + 5 or DT2 = DT1 - 5   ==> Add/Subrtract 5 days
  !
  !                   DIFF = DT%DIFF(DT2) => DT-DT2 in days
  !                   DIFF = DT - DT2     => DT-DT2 in days
  !                   SUMA = DT + DT2     => DT+DT2 in days
  !
  !   Basic Logical   DT == DT2, DT <= DT2, DT >= DT2, DT > DT2, DT < DT2
  !
  !   Increment 
  !              CALL DT%ADD_DAY  (...)  => Adjust date by specified number of days  , fraction of days   are prorated appropiately
  !              CALL DT%ADD_MONTH(...)  => Adjust date by specified number of months, fraction of months are prorated appropiately
  !              CALL DT%ADD_YEAR (...)  => Adjust date by specified number of years , fraction of years  are prorated appropiately
  !   Functions
  !             DT%CONTAIN_MD(MON,DAY,DT2,[INCLUSIVE])  return true if Month and Day are within date range DT : DT2, INCLUSIVE=True means that if MON\DAY == DT2 then return true
  !             DT%CONTAIN_MD(DT3,    DT2,[INCLUSIVE])  same as above, but use Month and Day stored in DT3
  !
  !             DT%INTERPOLATE(DT1,DT2,Y1,Y2)  Return result of interpolating to DT given dates DT1 and DT2 and correspondign values
  !
  !             DT%STR([SEP], [ISO]) Return string representation of date. If SEP provided then it will include time and be separated by SEP. If ISO=False then it will print American style
  !             DT%PRETTYPRINT()      Return full date as string in the form of "April 23, 1979"
  !
  ! Inherited from USE CALENDAR_FUNCTIONS:
  !
  !LOGICAL,      PARAMETER:: TRUE  = .TRUE.
  !LOGICAL,      PARAMETER:: FALSE = .FALSE.
  !INTEGER,      PARAMETER:: IDIFF=ICHAR('a')-ICHAR('A')
  !INTEGER,      PARAMETER:: Z     = 0
  !INTEGER,      PARAMETER:: ONE   = 1
  !REAL(REAL64), PARAMETER:: DZ  = 0.0_REAL64 
  !REAL(REAL64), PARAMETER:: UNO = 1.0_REAL64 
  !
  INTEGER,      PARAMETER:: NINER   = -999
  CHARACTER(7), PARAMETER:: NO_DATE ='NO_DATE'
  !
  CHARACTER,    PARAMETER:: BLNK   = ' '
  CHARACTER,    PARAMETER:: SLASH  = '/'
  CHARACTER,    PARAMETER:: BSLASH = '\'
  CHARACTER,    PARAMETER:: TAB    =  CHAR(9)
  CHARACTER,    PARAMETER:: MINUS  = '-'
  CHARACTER,    PARAMETER:: COL    = ':'
  INTEGER,      PARAMETER:: NEG    = -1
  INTEGER,      PARAMETER:: TWO    = 2
  INTEGER,      PARAMETER:: FIVE   = 5
  REAL(REAL64), PARAMETER:: DNEG   = -1.0_REAL64
  !
  REAL(REAL64), PARAMETER:: YEARTOL = 3.50000E-8_REAL64  ! ~ 1.1 seconds in years
  REAL(REAL64), PARAMETER:: DAYTOL  = 1.27315E-5_REAL64  ! ~ 1.1 seconds in days
  REAL(REAL64), PARAMETER:: HALFSEC = 5.78704E-6_REAL64  ! ~ 0.5 seconds in days
  !
  TYPE DATE_OPERATOR
     CHARACTER(10):: DATE = NO_DATE
     INTEGER:: YEAR  = NINER
     INTEGER:: MONTH = NINER
     INTEGER:: DAY   = NINER
     INTEGER:: JDN   = NINER
     REAL(REAL64):: FRAC  = DZ
     REAL(REAL64):: DYEAR = DZ  
     LOGICAL:: MONTH_DAY = FALSE    !TODO CHANGE YR==Z CHECK TO MONTH_DAY
     !
     CONTAINS
     !
     GENERIC            :: INIT         => INITIALIZE_DATE_OPERATOR_STR,        & !(DATE_STR, [FRAC], [LEAP], [FOUND_DATE], [ONLY_DYEAR], [TIME_SPACE])
                                           INITIALIZE_DATE_OPERATOR_DMY,        & !(DAY, MONTH, YEAR, [FRAC])
                                           INITIALIZE_DATE_OPERATOR_DMYHMS,     & !(DAY, MONTH, YEAR, HOUR, MIN, SEC) HMS int
                                           INITIALIZE_DATE_OPERATOR_DMYHMSdbl,  & !(DAY, MONTH, YEAR, HOUR, MIN, SEC) S is dble
                                           INITIALIZE_DATE_OPERATOR_JY,         & !(JDN, YEAR, [FRAC])
                                           INITIALIZE_DATE_OPERATOR_JYdbl,      & !(JDN, YEAR,       )  JDN is dbl
                                           INITIALIZE_DATE_OPERATOR_DYEAR_DBLE, & !(DYEAR)
                                           INITIALIZE_DATE_OPERATOR_DYEAR_SNGL, & !(DYEAR)
                                           DESTROY_DATE_OPERATOR
     PROCEDURE, PASS(DT):: NOW          => INITIALIZE_DATE_OPERATOR_CURRENT    !()
     PROCEDURE, PASS(DT):: INIT_STR     => INITIALIZE_DATE_OPERATOR_STR        !(DT, DATE_STRING,      [FRAC])
     GENERIC            :: INIT_DMY     => INITIALIZE_DATE_OPERATOR_DMY, INITIALIZE_DATE_OPERATOR_DMYHMS, INITIALIZE_DATE_OPERATOR_DMYHMSdbl
     GENERIC            :: INIT_JY      => INITIALIZE_DATE_OPERATOR_JY, INITIALIZE_DATE_OPERATOR_JYdbl
     GENERIC            :: INIT_DYEAR   => INITIALIZE_DATE_OPERATOR_DYEAR_DBLE, INITIALIZE_DATE_OPERATOR_DYEAR_SNGL 
     GENERIC            :: INTERPOLATE  => DATE_OPERATOR_INTERPOLATE_DBLE, DATE_OPERATOR_INTERPOLATE_SNGL
     PROCEDURE, PASS(DT):: DYEAR_MAKE_DATE !([DYEAR]) --useful if date is only holding dyear and not full date properties, otherwise rebuilds date with passed DYEAR
     PROCEDURE, PASS(DT):: ONLY_DYEAR      !Return true if date only holds DYEAR and nothing else
     PROCEDURE, PASS(DT):: IS_SET       => DATE_HAS_BEEN_SET
     PROCEDURE, PASS(DT):: NOT_SET      => DATE_HAS_NOT_BEEN_SET
     PROCEDURE, PASS(DT):: NO_YEAR      => DATE_HAS_ZERO_YEAR
     GENERIC            :: CONTAIN_MD   => DATE_CONTAINS_MD, DATE_CONTAINS_DATE_MD           !(DT, M, D, DT2, INCLUSIVE); (DT, MD, DT2, INCLUSIVE)  --MD is DATE_OPERATOR
     !
     GENERIC            :: ADD_DAY      => ADD_DAY_INT,   ADD_DAY_DBLE  !(DAY,  FRAC, LEAP)
     GENERIC            :: ADD_MONTH    => ADD_MONTH_INT, ADD_MONTH_DBL !(MON,  LEAP)
     GENERIC            :: ADD_YEAR     => ADD_YEAR_INT,  ADD_YEAR_DBL  !(YEAR, LEAP)
     GENERIC            :: ADD_SEC      => ADD_SEC_INT, ADD_SEC_DBLE    !(SEC,  LEAP)
     GENERIC            :: ADD_MIN      => ADD_MIN_INT, ADD_MIN_DBLE    !(MIN,  LEAP)
     GENERIC            :: ADD_HOUR     => ADD_HOUR_INT, ADD_HOUR_DBLE  !(HOUR, LEAP)
     !
     GENERIC            :: DAYS_TO_MD   => DATE_DAY_COUNT_DATE_TO_MD,   DATE_DAY_COUNT_TO_MD   !(DT, M, D); (DT, MD)  --MD is DATE_OPERATOR
     GENERIC            :: DAYS_FROM_MD => DATE_DAY_COUNT_DATE_FROM_MD, DATE_DAY_COUNT_FROM_MD !(DT, M, D); (DT, MD)  --MD is DATE_OPERATOR
     GENERIC            :: DAY_COUNT_MD => DATE_DAY_COUNT_DATE_MD,      DATE_DAY_COUNT_MD      !(DT, M, D, LOOK_FORWARD); (DT, MD, LOOK_FORWARD)  --MD is DATE_OPERATOR
     !
     PROCEDURE, PASS(DT):: SET_YEAR
     PROCEDURE, PASS(DT):: SET_MONTH
     PROCEDURE, PASS(DT):: SET_DAY
     PROCEDURE, PASS(DT):: ZERO_YEAR
     PROCEDURE, PASS(DT):: MD                 => DATE_MD_COMPARE !(DT, OP, DT2) => DT op DT2 where op = ">", ">=", "<", "<=", or  "=="
     PROCEDURE, PASS(DT):: YEAR_DAY_COUNT     => DATE_YEAR_DAY_COUNT
     PROCEDURE, PASS(DT):: YEAR_DAY_COUNT_DBLE=> DATE_YEAR_DAY_COUNT_DBLE
     PROCEDURE, PASS(DT):: YEAR_FRACTION      => DATE_YEAR_FRACTION
     PROCEDURE, PASS(DT):: DYEAR_FRACTION     => DATE_DYEAR_FRACTION
     PROCEDURE, PASS(DT):: TIME         => DATE_OPERATOR_FRAC_TO_TIME
     PROCEDURE,   NOPASS:: TIME_TO_FRAC => DATE_OPERATOR_TIME_TO_FRAC
     PROCEDURE, PASS(DT):: STR          => DATE_OPERATOR_STRING_REPRESENTATION
     PROCEDURE, PASS(DT):: STR_MONTHYEAR=> DATE_OPERATOR_PRINT_MONTHYEAR
     PROCEDURE, PASS(DT):: STR_YEARMONTH=> DATE_OPERATOR_PRINT_YEAR_MONTH
     PROCEDURE, PASS(DT):: STR_DYEAR    => DATE_OPERATOR_PRINT_DYEAR
     PROCEDURE, PASS(DT):: STR_ELAPSED  => DATE_OPERATOR_PRINT_DIF !(DT, DT2, [UNIT])  UNIT => 0 = all units, 1 = sec, 2 = min, 3 = hour, 4 = day, 5 = largest Unit
     PROCEDURE, PASS(DT):: PRETTYPRINT   => DATE_OPERATOR_PRETTYPRINT
     PROCEDURE, PASS(DT):: ISLEAPYEAR   => ISLEAPYEAR_DATE_OPERATOR  
     GENERIC            :: MONTHDAYS    => MONTHDAYS_DATE_OPERATOR, MONTHDAYS_OPERATOR! ([LEAP]) or (MONTH, YEAR, [LEAP]) => Number of days in date's month or specified MONTH/YEAR
     PROCEDURE, PASS(DT):: DIFF         => DATE_OPERATOR_DAY_DIFFERENCE!(DT, DT2) => DIFF = DT-DT2, result in days
     PROCEDURE, PASS(DT):: DYEAR_IS_YEAR=> DATE_DYEAR_IS_YEAR
     PROCEDURE, PASS(DT):: DESTROY      => DESTROY_DATE_OPERATOR
     PROCEDURE, PASS(DT):: SET_DATE_STRING
     !
     GENERIC            :: READ(FORMATTED)  => DATE_OPERATOR_FMTREAD                                                !fortran User-Defined Derived-Type I/O
     GENERIC            :: READ(UNFORMATTED)=> DATE_OPERATOR_BINREAD
     GENERIC            :: WRITE(FORMATTED) => DATE_OPERATOR_FMTWRITE
     GENERIC            :: OPERATOR(+)      => DATE_OPERATOR_ADD_INT, DATE_OPERATOR_ADD_DBLE, DATE_OPERATOR_ADD_SNGL
     GENERIC            :: OPERATOR(-)      => DATE_OPERATOR_SUB_INT, DATE_OPERATOR_SUB_DBLE, DATE_OPERATOR_SUB_SNGL, DATE_OPERATOR_SUB
     GENERIC            :: ASSIGNMENT(=)    => COPY_DATE_OPERATOR, STR_TO_DATE_OPERATOR
     GENERIC            :: OPERATOR(==)     => DATE_OPERATOR_EQUALITY
     GENERIC            :: OPERATOR(<)      => DATE_OPERATOR_LESS_THAN
     GENERIC            :: OPERATOR(<=)     => DATE_OPERATOR_LESS_THAN_EQUAL
     GENERIC            :: OPERATOR(>)      => DATE_OPERATOR_GREATER_THAN
     GENERIC            :: OPERATOR(>=)     => DATE_OPERATOR_GREATER_THAN_EQUAL
     !
     PROCEDURE, PASS(DT),PRIVATE:: INITIALIZE_DATE_OPERATOR_CURRENT
     PROCEDURE, PASS(DT),PRIVATE:: INITIALIZE_DATE_OPERATOR_STR        !(DATE_STR,         [FRAC], [LEAP], [FOUND_DATE], [ONLY_DYEAR], [TIME_SPACE])
     PROCEDURE, PASS(DT),PRIVATE:: INITIALIZE_DATE_OPERATOR_DMY        !(DAY, MONTH, YEAR, [FRAC])
     PROCEDURE, PASS(DT),PRIVATE:: INITIALIZE_DATE_OPERATOR_DMYHMS     !(DAY, MONTH, YEAR, HOUR, MIN, SEC, [LEAP]) HMS int
     PROCEDURE, PASS(DT),PRIVATE:: INITIALIZE_DATE_OPERATOR_DMYHMSdbl  !(DAY, MONTH, YEAR, HOUR, MIN, SEC, [LEAP]) S is dble
     PROCEDURE, PASS(DT),PRIVATE:: INITIALIZE_DATE_OPERATOR_JY         !(JDN,        YEAR, [FRAC],         [LEAP])
     PROCEDURE, PASS(DT),PRIVATE:: INITIALIZE_DATE_OPERATOR_JYdbl      !(JDN,        YEAR,                 [LEAP]) JDN is double
     PROCEDURE, PASS(DT),PRIVATE:: INITIALIZE_DATE_OPERATOR_DYEAR_DBLE !(DYEAR)
     PROCEDURE, PASS(DT),PRIVATE:: INITIALIZE_DATE_OPERATOR_DYEAR_SNGL !(DYEAR)
     PROCEDURE, PASS(DT),PRIVATE:: ADD_DAY_INT                        !(DAY,  FRAC, LEAP)
     PROCEDURE, PASS(DT),PRIVATE:: ADD_DAY_DBLE                       !(DAY,  FRAC, LEAP)
     PROCEDURE, PASS(DT),PRIVATE:: ADD_MONTH_INT                      !(MON,  LEAP)
     PROCEDURE, PASS(DT),PRIVATE:: ADD_MONTH_DBL                      !(MON,  LEAP)
     PROCEDURE, PASS(DT),PRIVATE:: ADD_YEAR_INT                       !(YEAR, LEAP)
     PROCEDURE, PASS(DT),PRIVATE:: ADD_YEAR_DBL                       !(YEAR, LEAP)
     PROCEDURE, PASS(DT),PRIVATE:: ADD_SEC_INT                        !(SEC,  LEAP)
     PROCEDURE, PASS(DT),PRIVATE:: ADD_SEC_DBLE                       !(SEC,  LEAP)
     PROCEDURE, PASS(DT),PRIVATE:: ADD_MIN_INT                        !(MIN,  LEAP)
     PROCEDURE, PASS(DT),PRIVATE:: ADD_MIN_DBLE                       !(MIN,  LEAP)
     PROCEDURE, PASS(DT),PRIVATE:: ADD_HOUR_INT                       !(HOUR, LEAP)
     PROCEDURE, PASS(DT),PRIVATE:: ADD_HOUR_DBLE                      !(HOUR, LEAP)
     PROCEDURE, PASS(DT),PRIVATE:: DATE_OPERATOR_INTERPOLATE_DBLE     !(DT1, DT2, DAT1, DAT2)
     PROCEDURE, PASS(DT),PRIVATE:: DATE_OPERATOR_INTERPOLATE_SNGL     !(DT1, DT2, DAT1, DAT2)
     PROCEDURE, PASS(DT),PRIVATE:: DATE_CONTAINS_DATE_MD              !(MD, DT2, INCLUSIVE)  --MD is DATE_OPERATOR
     PROCEDURE, PASS(DT),PRIVATE:: DATE_CONTAINS_MD                   !(M, D, DT2, INCLUSIVE)
     PROCEDURE, PASS(DT),PRIVATE:: DATE_DAY_COUNT_DATE_MD             !(MD,   LOOK_FORWARD)  --MD is DATE_OPERATOR, LOOK_FORWARD = TRUE indicates date MD is ahead of DATE, FALSE, default then MD is behind DATE
     PROCEDURE, PASS(DT),PRIVATE:: DATE_DAY_COUNT_MD                  !(M, D, LOOK_FORWARD)
     PROCEDURE, PASS(DT),PRIVATE:: DATE_DAY_COUNT_DATE_TO_MD          !(MD)  --MD is DATE_OPERATOR
     PROCEDURE, PASS(DT),PRIVATE:: DATE_DAY_COUNT_TO_MD               !(M, D)
     PROCEDURE, PASS(DT),PRIVATE:: DATE_DAY_COUNT_DATE_FROM_MD        !(MD)  --MD is DATE_OPERATOR
     PROCEDURE, PASS(DT),PRIVATE:: DATE_DAY_COUNT_FROM_MD             !(M, D)
     PROCEDURE, PASS(DT),PRIVATE:: DATE_OPERATOR_STRING_REPRESENTATION
     PROCEDURE,          PRIVATE:: DATE_OPERATOR_ADD_DBLE
     PROCEDURE,          PRIVATE:: DATE_OPERATOR_ADD_SNGL
     PROCEDURE,          PRIVATE:: DATE_OPERATOR_FMTREAD
     PROCEDURE,          PRIVATE:: DATE_OPERATOR_BINREAD
     PROCEDURE,          PRIVATE:: DATE_OPERATOR_FMTWRITE
     PROCEDURE,          PRIVATE:: DATE_OPERATOR_ADD_INT
     PROCEDURE,          PRIVATE:: DATE_OPERATOR_SUB_DBLE
     PROCEDURE,          PRIVATE:: DATE_OPERATOR_SUB_SNGL
     PROCEDURE,          PRIVATE:: DATE_OPERATOR_SUB_INT
     PROCEDURE,          PRIVATE:: DATE_OPERATOR_SUB
     PROCEDURE,          PRIVATE:: COPY_DATE_OPERATOR
     PROCEDURE,          PRIVATE:: STR_TO_DATE_OPERATOR
     PROCEDURE,          PRIVATE:: DATE_OPERATOR_EQUALITY
     PROCEDURE,          PRIVATE:: DATE_OPERATOR_LESS_THAN
     PROCEDURE,          PRIVATE:: DATE_OPERATOR_LESS_THAN_EQUAL
     PROCEDURE,          PRIVATE:: DATE_OPERATOR_GREATER_THAN
     PROCEDURE,          PRIVATE:: DATE_OPERATOR_GREATER_THAN_EQUAL
     PROCEDURE, PASS(DT),PRIVATE:: DATE_HAS_BEEN_SET
     PROCEDURE, PASS(DT),PRIVATE:: DATE_HAS_NOT_BEEN_SET
     PROCEDURE, PASS(DT),PRIVATE:: DATE_HAS_ZERO_YEAR
     PROCEDURE, PASS(DT),PRIVATE:: DATE_YEAR_FRACTION
     PROCEDURE, PASS(DT),PRIVATE:: DATE_DYEAR_FRACTION
     PROCEDURE, PASS(DT),PRIVATE:: DATE_OPERATOR_FRAC_TO_TIME
     PROCEDURE, NOPASS,  PRIVATE:: DATE_OPERATOR_TIME_TO_FRAC
     PROCEDURE, PASS(DT),PRIVATE:: ISLEAPYEAR_DATE_OPERATOR  
     PROCEDURE, PASS(DT),PRIVATE:: MONTHDAYS_DATE_OPERATOR 
     PROCEDURE, NOPASS,  PRIVATE:: MONTHDAYS_OPERATOR
     PROCEDURE, PASS(DT),PRIVATE:: DATE_OPERATOR_DAY_DIFFERENCE
     PROCEDURE, PASS(DT),PRIVATE:: DESTROY_DATE_OPERATOR
  END TYPE
  !
  INTERFACE DATE_OPERATOR
         MODULE PROCEDURE START_OBJECT_DATE_OPERATOR_STR        !(DATE_STRING,      [FRAC])
         MODULE PROCEDURE START_OBJECT_DATE_OPERATOR_DMY        !(DAY, MONTH, YEAR, [FRAC])
         MODULE PROCEDURE START_OBJECT_DATE_OPERATOR_DMYHMS     !(DAY, MONTH, YEAR, HOUR, MIN, SEC, [LEAP])
         MODULE PROCEDURE START_OBJECT_DATE_OPERATOR_DMYHMSdbl  !(DAY, MONTH, YEAR, HOUR, MIN, SEC, [LEAP])
         MODULE PROCEDURE START_OBJECT_DATE_OPERATOR_JY         !(JDN,        YEAR, [FRAC])
         MODULE PROCEDURE START_OBJECT_DATE_OPERATOR_JYdbl      !(JDN,        YEAR)
         MODULE PROCEDURE START_OBJECT_DATE_OPERATOR_DYEAR_DBLE !(DYEAR)
         MODULE PROCEDURE START_OBJECT_DATE_OPERATOR_DYEAR_SNGL !(DYEAR)
         MODULE PROCEDURE START_OBJECT_DATE_OPERATOR_CURRENT    !()
  END INTERFACE
  !
  CONTAINS
  !
  PURE FUNCTION DATE_STR_TO_DYEAR(DATE_STRING) RESULT(DYEAR)
    CHARACTER(*), INTENT(IN):: DATE_STRING
    TYPE(DATE_OPERATOR):: DT
    REAL(REAL64):: DYEAR
    !
    CALL INITIALIZE_DATE_OPERATOR_STR(DT, DATE_STRING, ONLY_DYEAR = TRUE)
    !
    DYEAR = DT%DYEAR
    !
  END FUNCTION
  !
  ELEMENTAL PURE SUBROUTINE DESTROY_DATE_OPERATOR(DT)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT    
    DT%DATE  = NO_DATE
    DT%YEAR  = NINER
    DT%MONTH = NINER
    DT%DAY   = NINER
    DT%JDN   = NINER
    DT%FRAC  = DZ
    DT%DYEAR = DZ !IEEE_VALUE(DT%DYEAR, IEEE_QUIET_NAN)
  END SUBROUTINE
  !
  !ELEMENTAL PURE SUBROUTINE FINALIZE_DATE_OPERATOR(DT) --NOT REALLY NEEDED
  !  TYPE(DATE_OPERATOR):: DT    
  !  DT%DATE = 'NO_DATE'
  !  DT%YEAR  = NINER
  !  DT%MONTH = NINER
  !  DT%DAY   = NINER
  !  DT%JDN   = NINER
  !  DT%FRAC  = DZ
  !  DT%DYEAR = DZ
  !END SUBROUTINE
  !
  ELEMENTAL PURE FUNCTION START_OBJECT_DATE_OPERATOR_STR(DATE_STRING, FRAC, LEAP) RESULT(DT)
    CHARACTER(*), INTENT(IN):: DATE_STRING
    REAL(REAL64), INTENT(IN), OPTIONAL:: FRAC
    LOGICAL,      INTENT(IN), OPTIONAL:: LEAP
    TYPE(DATE_OPERATOR):: DT
    !
    CALL INITIALIZE_DATE_OPERATOR_STR(DT, DATE_STRING, FRAC, LEAP)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION START_OBJECT_DATE_OPERATOR_DMY(DAY, MONTH, YEAR, FRAC, LEAP) RESULT(DT)
    INTEGER,      INTENT(IN):: DAY, MONTH, YEAR
    REAL(REAL64), INTENT(IN), OPTIONAL:: FRAC
    LOGICAL,      INTENT(IN), OPTIONAL:: LEAP
    TYPE(DATE_OPERATOR):: DT
    !
    CALL INITIALIZE_DATE_OPERATOR_DMY(DT, DAY, MONTH, YEAR, FRAC, LEAP)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION START_OBJECT_DATE_OPERATOR_DMYHMS(DAY, MONTH, YEAR, HOUR, MIN, SEC, LEAP) RESULT(DT)
    INTEGER,              INTENT(IN):: DAY, MONTH, YEAR, HOUR, MIN, SEC
    LOGICAL,              INTENT(IN), OPTIONAL:: LEAP
    TYPE(DATE_OPERATOR):: DT
    REAL(REAL64):: FRAC
    
    FRAC = TIME_TO_DAY_FRACTION(HOUR, MIN, SEC)
    !
    CALL INITIALIZE_DATE_OPERATOR_DMY(DT, DAY, MONTH, YEAR, FRAC, LEAP)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION START_OBJECT_DATE_OPERATOR_DMYHMSdbl(DAY, MONTH, YEAR, HOUR, MIN, SEC, LEAP) RESULT(DT)
    INTEGER,      INTENT(IN):: DAY, MONTH, YEAR, HOUR, MIN
    REAL(REAL64), INTENT(IN):: SEC
    LOGICAL,      INTENT(IN), OPTIONAL:: LEAP
    TYPE(DATE_OPERATOR):: DT
    REAL(REAL64):: FRAC
    
    FRAC = TIME_TO_DAY_FRACTION(HOUR, MIN, SEC)
    !
    CALL INITIALIZE_DATE_OPERATOR_DMY(DT, DAY, MONTH, YEAR, FRAC, LEAP)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION START_OBJECT_DATE_OPERATOR_JY(JDN, YEAR, FRAC, LEAP) RESULT(DT)
    INTEGER,      INTENT(IN   ):: JDN, YEAR
    REAL(REAL64), INTENT(IN   ), OPTIONAL:: FRAC
    LOGICAL,      INTENT(IN), OPTIONAL:: LEAP
    TYPE(DATE_OPERATOR):: DT
    !
    CALL INITIALIZE_DATE_OPERATOR_JY(DT, JDN, YEAR, FRAC, LEAP)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION START_OBJECT_DATE_OPERATOR_JYdbl(JDN, YEAR, LEAP) RESULT(DT)
    REAL(REAL64), INTENT(IN   ):: JDN 
    INTEGER,      INTENT(IN   ):: YEAR
    LOGICAL,      INTENT(IN), OPTIONAL:: LEAP
    TYPE(DATE_OPERATOR):: DT
    INTEGER:: JD
    REAL(REAL64):: FRAC
    !
    JD = INT(JDN)
    FRAC = JDN - DBLE(JD)
    IF(ABS(FRAC) < DAYTOL*0.01D0) FRAC = DZ  !less then 0.01 sec
    !
    CALL INITIALIZE_DATE_OPERATOR_JY(DT, JD, YEAR, FRAC, LEAP)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION START_OBJECT_DATE_OPERATOR_DYEAR_DBLE(DYEAR, LEAP) RESULT(DT)
    REAL(REAL64),      INTENT(IN):: DYEAR
    LOGICAL, OPTIONAL, INTENT(IN):: LEAP
    TYPE(DATE_OPERATOR):: DT
    !
    CALL INITIALIZE_DATE_OPERATOR_DYEAR_DBLE(DT, DYEAR, LEAP)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION START_OBJECT_DATE_OPERATOR_DYEAR_SNGL(DYEAR, LEAP) RESULT(DT)
    REAL(REAL32),         INTENT(IN):: DYEAR
    LOGICAL, OPTIONAL,    INTENT(IN):: LEAP
    TYPE(DATE_OPERATOR):: DT
    !
    CALL INITIALIZE_DATE_OPERATOR_DYEAR_SNGL(DT, DYEAR, LEAP)
    !
  END FUNCTION
  !
  ELEMENTAL IMPURE FUNCTION START_OBJECT_DATE_OPERATOR_CURRENT() RESULT(DT)
    TYPE(DATE_OPERATOR):: DT
    !
    CALL INITIALIZE_DATE_OPERATOR_CURRENT(DT)
    !
  END FUNCTION
  !
  !!!PURE FUNCTION REMOVEBLANK(LN) RESULT(RES)
  !!!  CHARACTER(*),INTENT(IN)::LN
  !!!  CHARACTER(LEN(LN)):: T
  !!!  CHARACTER(:), ALLOCATABLE:: RES
  !!!  INTEGER::I, J
  !!!  !
  !!!  T=BLNK
  !!!  J=1
  !!!  DO I=1, LEN_TRIM(LN)
  !!!     IF(LN(I:I).NE.' ' .AND. LN(I:I).NE.TAB) THEN   !IF NOT BLANK AND NOT TAB THEN ADD CHARACTER
  !!!        T(J:J)=LN(I:I)  
  !!!        J=J+1
  !!!     END IF
  !!!  END DO
  !!!  !
  !!!  ALLOCATE(RES,SOURCE=TRIM(T))
  !!!  !
  !!!END FUNCTION
  !
  !
  ELEMENTAL IMPURE SUBROUTINE INITIALIZE_DATE_OPERATOR_CURRENT(DT, UTC)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    LOGICAL, OPTIONAL,    INTENT(IN   ):: UTC
    INTEGER, DIMENSION(8):: I
    REAL(REAL64):: FRAC
    !
    CALL DATE_AND_TIME(VALUES = I)  !GET CURRENT TIME VALUES
    !
    !           HOUR                MIN                  SEC                  MS
    FRAC = DBLE(I(5))*HR2DAY + DBLE(I(6))*MIN2DAY + DBLE(I(7))*SEC2DAY + DBLE(I(8))/8.64D7
    !
    IF(PRESENT(UTC)) THEN; IF(UTC) FRAC = FRAC - DBLE(I(4))*MIN2DAY  !Transform from current to UTC
    END IF
    !
    CALL INITIALIZE_DATE_OPERATOR_DMY(DT, I(3), I(2), I(1), FRAC)
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE INITIALIZE_DATE_OPERATOR_STR(DT, DATE_STR, FRAC, LEAP, FOUND_DATE, ONLY_DYEAR)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    CHARACTER(*),         INTENT(IN   ):: DATE_STR
    REAL(REAL64),         INTENT(IN   ), OPTIONAL:: FRAC
    LOGICAL,              INTENT(IN   ), OPTIONAL:: LEAP
    LOGICAL,              INTENT(  OUT), OPTIONAL:: FOUND_DATE ! Returns true if a date was found -- no decimal year or bad dates
    LOGICAL,              INTENT(IN   ), OPTIONAL:: ONLY_DYEAR ! IF TRUE then if found only decimal year input only store that rather then full date --speed purposes
    !
    INTEGER:: I,J,A,B,C,D, YEAR, MONTH, DAY, IERR
    LOGICAL:: ISO, MONTH_STR, HAS_TIME
    !
    ! I = START OF DATE STRING
    ! A = LOCATION OF 1st  / or - or \     --SET TO ZERO IF DECIMAL YEAR
    ! B = LOCATION OF 2nd  / or -          --SET TO ZERO IF NOT FOUND
    ! C = LOCATION OF END OF CALENDAR DATE --e.g. last  d in yyyy-mm-dd or last yyyy-mm-ddThh:MM:ss
    ! D = LOCATION OF START OF WALL CLOCK  --e.g. first h in hh:MM:ss   or first h in yyyy-mm-ddThh:MM:ss; SET TO END OF DATE STRING IF NO CLOCK
    ! J = END OF DATE STRING
    !
    IF(PRESENT(FOUND_DATE)) FOUND_DATE = FALSE
    !
    IF(DATE_STR==NO_DATE) THEN
                              DT%DATE  = NO_DATE
                              DT%YEAR  = Z
                              DT%MONTH = NEG
                              DT%DAY   = NEG
                              DT%JDN   = Z
                              DT%DYEAR = IEEE_VALUE(DT%DYEAR, IEEE_QUIET_NAN)
                              RETURN
    END IF
    !
    IF(EMPTY_STRING(DATE_STR)) THEN
                         DT%DATE  = NO_DATE
                         DT%YEAR  = NINER
                         DT%MONTH = NINER
                         DT%DAY   = NINER
                         DT%JDN   = NINER
                         DT%DYEAR = IEEE_VALUE(DT%DYEAR, IEEE_QUIET_NAN)
                         RETURN
    END IF
    !
    I = INDEX(DATE_STR,'{')
    IF(I > Z) THEN
        I = I + ONE
        J = INDEX(DATE_STR,'}') - ONE
        IF(J < ONE) THEN                             !ERROR FINDING MATCHING { }
                         DT%DATE  = TRIM(DATE_STR)
                         DT%YEAR  = NINER
                         DT%MONTH = NINER
                         DT%DAY   = NINER
                         DT%JDN   = NINER
                         DT%DYEAR = IEEE_VALUE(DT%DYEAR, IEEE_QUIET_NAN)
                         RETURN
        END IF
    ELSE
        I = ONE
        J = LEN_TRIM(DATE_STR)
    END IF
    !
    YEAR  = NEG
    MONTH = NEG
    DAY   = NEG
    !
    A = INDEX(DATE_STR,BSLASH)
    DT%MONTH_DAY = A > Z
    !
    IF(DT%MONTH_DAY) THEN
        B = Z
    ELSE
        A = INDEX(DATE_STR,SLASH)
        !
        IF(A==Z) THEN
            A=INDEX(DATE_STR,MINUS)
            IF(I == A .OR. A == Z) THEN                ! MINUS IS LOCATED AT START OF STRING SO IT MUST BE A NUMBER
                         A = Z
                         B = Z
            ELSE
                         B=INDEX(DATE_STR,MINUS,TRUE)
            END IF
            !
            IF(A > ONE) THEN  !CHECK TO MAKE SURE IT IS NOT A NUMBER OF THE FORM 1E-1 OR 1D-1
                  IF(INDEX("EeDe",DATE_STR(A-1:A-1)) > Z) THEN
                      A = Z
                      B = Z
                  END IF
            END IF
            ISO = TRUE
        ELSE
            B=INDEX(DATE_STR,SLASH,TRUE)
            ISO = FALSE
        END IF
    END IF
    !
    MONTH     = MONTHNUM(DATE_STR(I:J))  !CHECK IF USIGN MONTHNAME e.g. "JAN"
    MONTH_STR = MONTH > Z
    !
    IF(MONTH_STR .OR. A > Z) THEN !IT IS --NOT-- A DECIMAL YEAR
        !
        D = INDEX(DATE_STR,':')  !DERMINE IF THERE IS A WALL CLOCK
        !
        IF( D > Z ) THEN
            HAS_TIME = TRUE  ! Thh:mm:ss  D = first : adjust to first h or T
            D = D - TWO
        ELSE
            HAS_TIME = FALSE
            D = J
        END IF
        !
        IF (A < B) THEN  ! C IS THE END OF THE CALENDAR DATE PART --e.g last y in mm/dd/yyyy
            C = B + ONE
        ELSE
            C = A + ONE
        END IF
        !
        DO WHILE (C < D)
            IF(DATE_STR(C:C).NE.BLNK .AND. DATE_STR(C:C).NE.TAB) EXIT     !FIND FIRST NONBLANK 
            C = C + ONE
        END DO
        !
        DO WHILE (C < D)
            IF(DATE_STR(C:C)==BLNK .OR. DATE_STR(C:C)==TAB) EXIT        !FIND FIRST BLNK
            C = C + ONE
        END DO
        IF(C < J) C = C - ONE
        !
        IF(HAS_TIME) THEN; IF(DATE_STR(C:C)=='T' .OR. DATE_STR(C:C)=='t') C = C - ONE
        END IF
    END IF
    !
    IF(MONTH_STR) THEN                                                               ! mmm or mmm-dd or mmm-dd-yyyy
                ! 
                IF    (A==Z) THEN
                                  DT%MONTH_DAY = TRUE
                                  DAY  = ONE
                                  YEAR = Z
                                  IERR = Z
                ELSEIF(A==B) THEN
                                  DT%MONTH_DAY = TRUE
                                  READ(DATE_STR(A+1:C  ),*, IOSTAT=IERR) DAY
                                  YEAR  = Z
                ELSE
                                  READ(DATE_STR(A+1:B-1),*, IOSTAT=IERR) DAY
                    IF(IERR == Z) READ(DATE_STR(B+1:C  ),*, IOSTAT=IERR) YEAR
                END IF
                !
    ELSEIF(A==Z) THEN  !ASSUME ITS A DECIMAL YEAR
                !
                READ(DATE_STR(I:J),*, IOSTAT=IERR) DT%DYEAR
                IF(IERR==Z) THEN
                               !
                               IF(PRESENT(ONLY_DYEAR)) THEN
                                   ISO = .NOT. ONLY_DYEAR
                               ELSE
                                   ISO = TRUE
                               END IF
                               !
                               IF(DT%DYEAR.NE.DT%DYEAR) THEN
                                      DT%DATE  = TRIM(DATE_STR)
                                      DT%YEAR  = NINER
                                      DT%MONTH = NINER
                                      DT%DAY   = NINER
                                      DT%JDN   = NINER
                                      !DT%DYEAR = IEEE_VALUE(DT%DYEAR, IEEE_QUIET_NAN)
                               ELSEIF(ISO) THEN !BUILD DATE FROM DYEAR
                                           CALL DYEAR_TO_DATE(DT%DYEAR, DT%DAY, DT%MONTH, DT%YEAR, DT%FRAC, DT%JDN, LEAP) 
                                           CALL DT%SET_DATE_STRING(DT%DAY, DT%MONTH, DT%YEAR)   !SET DT%DATE
                               ELSE !ONYL STORE DYEAR
                                      DT%DATE  = 'DYEAR'
                                      DT%YEAR  = Z
                                      DT%MONTH = NEG
                                      DT%DAY   = NEG
                                      DT%JDN   = Z
                               END IF
                               !
                               RETURN
                END IF
                !
    ELSEIF(DT%MONTH_DAY) THEN                                                                !mm\dd
                YEAR  = Z
                MONTH = NEG
                DAY   = NEG
                !
                READ(DATE_STR(  I:A-1),*, IOSTAT=IERR) MONTH
                !
                IF(IERR == Z) READ(DATE_STR(A+1:C),*, IOSTAT=IERR) DAY
                !
                IF( DAY > MONTHDAYS(MONTH, YEAR, TRUE) ) IERR = ONE  !BAD DAY OF MONTH
                !
    ELSEIF(ISO) THEN                                                                         !yyyy-mm-dd
                READ(                               DATE_STR(  I:A-1),*, IOSTAT=IERR) YEAR
                !
                IF(IERR == Z                 ) READ(DATE_STR(A+1:B-1),*, IOSTAT=IERR) MONTH
                !
                IF(A==B) THEN
                             DAY = ONE
                ELSEIF(IERR == Z .AND. DAY == NEG) THEN
                                               READ(DATE_STR(B+1:C  ),*, IOSTAT=IERR) DAY
                END IF
    ELSEIF(A==B) THEN                                                                        !mm/yyyy
                READ(                               DATE_STR(  I:A-1),*, IOSTAT=IERR) MONTH
                !
                DAY = ONE
                !
                IF(IERR == Z                 ) READ(DATE_STR(B+1:C  ),*, IOSTAT=IERR) YEAR
    ELSE                                                                                     !mm/dd/yyyy
                READ(                               DATE_STR(  I:A-1),*, IOSTAT=IERR) MONTH
                !
                IF(IERR == Z .AND. DAY == NEG) READ(DATE_STR(A+1:B-1),*, IOSTAT=IERR) DAY
                !
                IF(IERR == Z                 ) READ(DATE_STR(B+1:C  ),*, IOSTAT=IERR) YEAR
    END IF
    !
    IF(     IERR.NE.Z                                                     &  !BAD DATE FOUND --NOTE IF DATE_STR='' THEN DAY AND MONTH WILL EQUAL ZER0
       .OR. MONTH< ONE .OR. MONTH > 12                                    &
       .OR. DAY  < ONE                                                    &
       .OR. (DAY > MONTHDAYS(MONTH, YEAR, LEAP) .AND. .NOT. DT%MONTH_DAY) &
      ) THEN  
       DT%DATE  = TRIM(DATE_STR)
       DT%YEAR  = NINER
       DT%MONTH = NINER
       DT%DAY   = NINER
       DT%JDN   = NINER
       DT%DYEAR = IEEE_VALUE(DT%DYEAR, IEEE_QUIET_NAN)
       RETURN
    END IF
    !
    DT%DAY   = DAY
    DT%MONTH = MONTH
    DT%YEAR  = YEAR
    !
    IF(HAS_TIME) THEN
        !
        DT%FRAC = TIME_TO_DAY_FRACTION(DATE_STR(D:J))
        !
        IF(DT%FRAC.NE.DT%FRAC) THEN
                                 DT%DATE  = TRIM(DATE_STR)
                                 DT%YEAR  = NINER
                                 DT%MONTH = NINER
                                 DT%DAY   = NINER
                                 DT%JDN   = NINER
                                 DT%DYEAR = IEEE_VALUE(DT%DYEAR, IEEE_QUIET_NAN)
                                 RETURN
        END IF
    ELSE
        DT%FRAC = DZ
    END IF
    !
    IF(PRESENT(FRAC))  DT%FRAC = DT%FRAC + FRAC
    !
    DT%JDN = JULIANDAY(DAY, MONTH, YEAR, LEAP)
    !
    IF(DT%FRAC > UNO .OR. DT%FRAC < DZ) THEN
        CALL ADD_DAY_INT(DT, LEAP=LEAP)  !NOTE THIS WILL JUST NORMALIZE FRAC CAUSE THERE IS NO ADDED DAY NOR FRAC --NOTE AUTO SETS DYEAR AND STRING
    ELSE
        DT%DYEAR = JDN_TO_DYEAR(DT%JDN, YEAR, DT%FRAC, LEAP) 
        !
        CALL DT%SET_DATE_STRING(DAY, MONTH, YEAR)   !SET DT%DATE
    END IF
    !
    IF(PRESENT(FOUND_DATE)) FOUND_DATE = TRUE
    !
  END SUBROUTINE
  !
!  ELEMENTAL PURE SUBROUTINE INITIALIZE_DATE_OPERATOR_STR(DT, DATE_STRING, FRAC, LEAP, FOUND_DATE, ONLY_DYEAR)
!    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
!    CHARACTER(*),         INTENT(IN   ):: DATE_STRING
!    REAL(REAL64),     INTENT(IN   ), OPTIONAL:: FRAC
!    LOGICAL,              INTENT(IN   ), OPTIONAL:: LEAP
!    LOGICAL,              INTENT(  OUT), OPTIONAL:: FOUND_DATE
!    LOGICAL,              INTENT(IN   ), OPTIONAL:: ONLY_DYEAR
!    CHARACTER(:),ALLOCATABLE:: DATE_STR
!    INTEGER:: I,J,A,B,C, YEAR, MONTH, DAY, IERR
!    LOGICAL:: ISO, MONTH_DAY
!    !
!    IF(PRESENT(FOUND_DATE)) FOUND_DATE = FALSE
!    !
!    IF(DATE_STRING==NO_DATE) THEN
!                              DT%DATE  = NO_DATE
!                              DT%YEAR  = 0
!                              DT%MONTH = 1
!                              DT%DAY   = 1
!                              DT%JDN   = 1
!                              DT%DYEAR = DZ
!                              RETURN
!    END IF
!    !
!    ALLOCATE(DATE_STR, SOURCE = REMOVEBLANK(DATE_STRING))
!    !
!    A = INDEX(DATE_STR,BSLASH)
!    MONTH_DAY = A > Z
!    !
!    IF(.NOT. MONTH_DAY) THEN
!                            A=INDEX(DATE_STR,SLASH)
!                            B=INDEX(DATE_STR,SLASH, TRUE)
!                            !
!                            IF(A==Z .AND. B==Z) THEN
!                                A=INDEX(DATE_STR,MINUS)
!                                B=INDEX(DATE_STR,MINUS,TRUE)
!                                ISO = TRUE
!                            ELSE
!                                ISO = FALSE
!                            END IF
!                            !
!                            IF(A==B) THEN
!                                DAY = ONE
!                            ELSE
!                                DAY = NEG
!                            END IF
!                            !
!                            MONTH = NEG
!    END IF
!    !
!    C=SCAN(DATE_STR,"Tt",TRUE)  !CHECK IF THERE IS A 24 HOUR CLOCK
!    !
!    IF(C==Z) C = LEN(DATE_STR)+ONE
!    !
!    IF(A==Z.AND.B==Z) THEN  !ASSUME ITS A DECIMAL YEAR
!                !
!                READ(DATE_STR,*, IOSTAT=IERR) DT%DYEAR
!                IF(IERR==Z) THEN
!                               !
!                               IF(PRESENT(ONLY_DYEAR)) THEN
!                                   ISO = .NOT. ONLY_DYEAR
!                               ELSE
!                                   ISO = TRUE
!                               END IF
!                               !
!                               IF(ISO) THEN !BUILD DATE FROM DYEAR
!                                           CALL DYEAR_TO_DATE(DT%DYEAR, DT%DAY, DT%MONTH, DT%YEAR, DT%FRAC, DT%JDN, LEAP) 
!                                           CALL DT%SET_DATE_STRING(DT%DAY, DT%MONTH, DT%YEAR)   !SET DT%DATE
!                               ELSE !ONYL STORE DYEAR
!                                      DT%DATE  = TRIM(DATE_STRING)
!                                      DT%YEAR  = Z
!                                      DT%MONTH = NEG
!                                      DT%DAY   = NEG
!                                      DT%JDN   = Z
!                               END IF
!                               !
!                               RETURN
!                END IF
!                !
!    ELSEIF(MONTH_DAY) THEN
!                YEAR  = Z
!                MONTH = NEG
!                DAY   = NEG
!                !
!                READ(DATE_STR(   :A-1),*, IOSTAT=IERR) MONTH
!                !
!                IF(IERR == Z) READ(DATE_STR(A+1:C-1),*, IOSTAT=IERR) DAY
!                !
!    ELSEIF(ISO) THEN
!                READ(                               DATE_STR(   :A-1),*, IOSTAT=IERR) YEAR
!                !
!                IF(IERR == Z                 ) READ(DATE_STR(A+1:B-1),*, IOSTAT=IERR) MONTH
!                !
!                IF(IERR == Z .AND. DAY == NEG) READ(DATE_STR(B+1:C-1),*, IOSTAT=IERR) DAY
!    ELSE
!                READ(                               DATE_STR(   :A-1),*, IOSTAT=IERR) MONTH
!                !
!                IF(IERR == Z .AND. DAY == NEG) READ(DATE_STR(A+1:B-1),*, IOSTAT=IERR) DAY
!                !
!                IF(IERR == Z                 ) READ(DATE_STR(B+1:C-1),*, IOSTAT=IERR) YEAR
!    END IF
!    !
!    IF(IERR .NE. Z .OR. DAY < ONE .OR. MONTH < ONE .OR. MONTH>12) THEN  !BAD DATE FOUND --NOTE IF DATE_STR='' THEN DAY AND MONTH WILL EQUAL ZER0
!       DT%DATE  = TRIM(DATE_STRING)
!       DT%YEAR  = NINER
!       DT%MONTH = NINER
!       DT%DAY   = NINER
!       DT%JDN   = NINER
!       DT%DYEAR = IEEE_VALUE(DT%DYEAR, IEEE_QUIET_NAN)
!       RETURN
!    END IF
!    !
!    DT%DAY   = DAY
!    DT%MONTH = MONTH
!    DT%YEAR  = YEAR
!    IF(PRESENT(FRAC)) THEN
!        DT%FRAC = FRAC
!    ELSE
!        DT%FRAC = DT%TIME_TO_FRAC(DATE_STR)
!        !
!        IF(.NOT. DT%FRAC==DT%FRAC) DT%FRAC = DZ
!    END IF
!    !
!    DT%JDN = JULIANDAY(DAY, MONTH, YEAR, LEAP)
!    !
!    DT%DYEAR = JDN_TO_DYEAR(DT%JDN, YEAR, DT%FRAC, LEAP)
!    !
!    CALL DT%SET_DATE_STRING(DAY, MONTH, YEAR)   !SET DT%DATE
!    !
!    IF(PRESENT(FOUND_DATE)) FOUND_DATE = TRUE
!    !
!  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE INITIALIZE_DATE_OPERATOR_DMYHMS(DT, DAY, MONTH, YEAR, HOUR, MIN, SEC, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    INTEGER,              INTENT(IN   ):: DAY, MONTH, YEAR, HOUR, MIN, SEC
    LOGICAL,              INTENT(IN   ), OPTIONAL:: LEAP
    REAL(REAL64):: FRAC
    !
    FRAC = TIME_TO_DAY_FRACTION(HOUR, MIN, SEC)
    CALL INITIALIZE_DATE_OPERATOR_DMY(DT, DAY, MONTH, YEAR, FRAC, LEAP)
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE INITIALIZE_DATE_OPERATOR_DMYHMSdbl(DT, DAY, MONTH, YEAR, HOUR, MIN, SEC, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    INTEGER,              INTENT(IN   ):: DAY, MONTH, YEAR, HOUR, MIN
    REAL(REAL64),         INTENT(IN   ):: SEC
    LOGICAL,              INTENT(IN   ), OPTIONAL:: LEAP
    REAL(REAL64):: FRAC
    !
    FRAC = TIME_TO_DAY_FRACTION(HOUR, MIN, SEC)
    CALL INITIALIZE_DATE_OPERATOR_DMY(DT, DAY, MONTH, YEAR, FRAC, LEAP)
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE INITIALIZE_DATE_OPERATOR_DMY(DT, DAY, MONTH, YEAR, FRAC, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    INTEGER,              INTENT(IN   ):: DAY, MONTH, YEAR
    REAL(REAL64),         INTENT(IN   ), OPTIONAL:: FRAC
    LOGICAL,              INTENT(IN   ), OPTIONAL:: LEAP
    !
    IF(DAY < ONE .OR. MONTH < ONE .OR. MONTH>12) THEN  !BAD DATE FOUND
       CALL DT%SET_DATE_STRING(DAY, MONTH, YEAR)   !SET DT%DATE
       DT%YEAR  = NINER
       DT%MONTH = NINER
       DT%DAY   = NINER
       DT%DYEAR = IEEE_VALUE(DT%DYEAR, IEEE_QUIET_NAN)
       DT%FRAC  = DZ
       RETURN
    END IF
    !
    DT%DAY   = DAY
    DT%MONTH = MONTH
    DT%YEAR  = YEAR
    IF(PRESENT(FRAC)) THEN
        DT%FRAC = FRAC
    ELSE
        DT%FRAC = DZ
    END IF
    !
    DT%JDN = JULIANDAY(DAY, MONTH, YEAR, LEAP)
    !
    IF(DT%FRAC > UNO .OR. DT%FRAC < DZ) THEN
        CALL ADD_DAY_INT(DT, LEAP=LEAP)  !NOTE THIS WILL JUST NORMALIZE FRAC CAUSE THERE IS NO ADDED DAY NOR FRAC --NOTE AUTO SETS DYEAR AND STRING
    ELSE
        DT%DYEAR = JDN_TO_DYEAR(DT%JDN, YEAR, DT%FRAC, LEAP) 
        !
        CALL DT%SET_DATE_STRING(DAY, MONTH, YEAR)   !SET DT%DATE
    END IF
    !
    END SUBROUTINE
    !
  SUBROUTINE INITIALIZE_DATE_OPERATOR_JYdbl(DT, JDN, YEAR, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    REAL(REAL64),         INTENT(IN   ):: JDN
    INTEGER,              INTENT(IN   ):: YEAR
    LOGICAL,              INTENT(IN   ), OPTIONAL:: LEAP
    INTEGER:: JD
    REAL(REAL64):: FRAC
    !
    JD = INT(JDN)
    FRAC = JDN - DBLE(JD)
    IF(ABS(FRAC) < DAYTOL*0.01D0) FRAC = DZ  !less then 0.01 sec
    !
    CALL INITIALIZE_DATE_OPERATOR_JY(DT, JD, YEAR, FRAC, LEAP)
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE INITIALIZE_DATE_OPERATOR_JY(DT, JDN, YEAR, FRAC, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    INTEGER,              INTENT(IN   ):: JDN, YEAR
    REAL(REAL64),         INTENT(IN   ), OPTIONAL:: FRAC
    LOGICAL,              INTENT(IN   ), OPTIONAL:: LEAP
    INTEGER:: JD
    !
    JD = JDN
    !
    IF( PRESENT(FRAC) ) THEN
        DT%FRAC = FRAC
        IF ( DT%FRAC > UNO .OR. DT%FRAC < DZ ) THEN
                                                     JD  = JD  + INT(DT%FRAC)     
                                                     DT%FRAC = DT%FRAC - INT(DT%FRAC)
        END IF
        !
        IF ( DT%FRAC < DZ ) THEN
                                                     JD  = JD  - ONE    
                                                     DT%FRAC = DT%FRAC + UNO
        END IF
        !
        IF ( DT%FRAC == UNO ) THEN
                                                     JD  = JD  + ONE     
                                                     DT%FRAC = DZ
        END IF
    ELSE
        DT%FRAC = DZ
    END IF
    !
    CALL JULIANDAY_TO_DATE(JD, YEAR, DT%DAY, DT%MONTH, DT%YEAR, DT%JDN, LEAP)
    !
    DT%MONTH_DAY = YEAR == Z
    !
    DT%DYEAR = JDN_TO_DYEAR(DT%JDN, DT%YEAR, DT%FRAC, LEAP) 
    !
    CALL DT%SET_DATE_STRING(DT%DAY, DT%MONTH, DT%YEAR)   !SET DT%DATE
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE INITIALIZE_DATE_OPERATOR_DYEAR_DBLE(DT, DYEAR, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    REAL(REAL64),         INTENT(IN   ):: DYEAR
    LOGICAL, OPTIONAL,    INTENT(IN   ):: LEAP
    !
    DT%DYEAR = DYEAR
    !
    IF(DT%DYEAR.NE.DT%DYEAR) THEN
           DT%DATE  = NO_DATE
           DT%YEAR  = NINER
           DT%MONTH = NINER
           DT%DAY   = NINER
           DT%JDN   = NINER
           !DT%DYEAR = IEEE_VALUE(DT%DYEAR, IEEE_QUIET_NAN)
           DT%MONTH_DAY = FALSE
    ELSE
        CALL DYEAR_TO_DATE(DT%DYEAR, DT%DAY, DT%MONTH, DT%YEAR, DT%FRAC, DT%JDN, LEAP) 
        !
        CALL DT%SET_DATE_STRING(DT%DAY, DT%MONTH, DT%YEAR)   !SET DT%DATE
        !
        DT%MONTH_DAY = DT%YEAR == Z
    END IF
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE INITIALIZE_DATE_OPERATOR_DYEAR_SNGL(DT, DYEAR, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    REAL(REAL32),         INTENT(IN   ):: DYEAR
    LOGICAL, OPTIONAL,    INTENT(IN   ):: LEAP
    !
    DT%DYEAR = DBLE(DYEAR)
    !
    IF(DT%DYEAR.NE.DT%DYEAR) THEN
        DT%DATE  = NO_DATE
        DT%YEAR  = NINER
        DT%MONTH = NINER
        DT%DAY   = NINER
        DT%JDN   = NINER
        !DT%DYEAR = IEEE_VALUE(DT%DYEAR, IEEE_QUIET_NAN)
        DT%MONTH_DAY = FALSE
    ELSE
        CALL DYEAR_TO_DATE(DT%DYEAR, DT%DAY, DT%MONTH, DT%YEAR, DT%FRAC, DT%JDN, LEAP) 
        !
        CALL DT%SET_DATE_STRING(DT%DAY, DT%MONTH, DT%YEAR)   !SET DT%DATE
        !
        DT%MONTH_DAY = DT%YEAR == Z
    END IF
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE SET_DATE_STRING(DT, DAY, MONTH, YEAR, ISO) 
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    INTEGER,              INTENT(IN   ):: DAY, MONTH, YEAR
    LOGICAL, OPTIONAL,    INTENT(IN   ):: ISO
    !
    IF(PRESENT(ISO)) THEN
         IF(ISO) THEN
                     WRITE(DT%DATE,'(I4.4, A ,I2.2, A ,I2.2)') YEAR, MINUS, MONTH, MINUS, DAY   !ISO STANDARD
         ELSE
                     WRITE(DT%DATE,'(I2.2, A ,I2.2, A ,I4.4)') MONTH, SLASH, DAY, SLASH, YEAR  !USA Standard
         END IF
    ELSE
                     WRITE(DT%DATE,'(I4.4, A ,I2.2, A ,I2.2)') YEAR, MINUS, MONTH, MINUS, DAY   !ISO STANDARD
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE DATE_OPERATOR_FMTREAD(DT, UNIT, IOTYPE, V_LIST, IOSTAT, IOMSG)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    INTEGER,              INTENT(IN   ):: UNIT
    CHARACTER(*),         INTENT(IN   ):: IOTYPE
    INTEGER,              INTENT(IN   ):: V_LIST (:)
    INTEGER,              INTENT(OUT  ):: IOSTAT
    CHARACTER(*),         INTENT(INOUT):: IOMSG
    CHARACTER(19):: DATE_TIME
    !
    ! This is the child I/O that gets performed when the procedure
    ! is called from a parent I/O  it uses list-directed input to read
    ! the array K
    !
    READ (UNIT, FMT='(A)', IOSTAT=IOSTAT, IOMSG=IOMSG) DATE_TIME   !SCOTT MAY HAVE TO CHANGE '(A)' TO *
    !
    IF(IOSTAT==Z) THEN
        CALL DT%INIT( DATE_TIME )
        IF( DT%NOT_SET() ) THEN
            IOSTAT=123
            IOMSG='DATE_OPERATOR_ERROR'
        END IF
    END IF
    !
  END SUBROUTINE 
  !
  SUBROUTINE DATE_OPERATOR_BINREAD(DT, UNIT, IOSTAT, IOMSG)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    INTEGER,              INTENT(IN   ):: UNIT
    INTEGER,              INTENT(OUT  ):: IOSTAT
    CHARACTER(*),         INTENT(INOUT):: IOMSG
    INTEGER:: POS
    CHARACTER(19):: DATE_TIME
    !
    ! This is the child I/O that gets performed when the procedure
    ! is called from a parent I/O  it uses list-directed input to read
    ! the array K
    !
    INQUIRE(UNIT=UNIT, POS=POS, ACCESS=DATE_TIME)
    !
    IF(DATE_TIME=='STREAM') THEN
        DATE_TIME=BLNK
        READ (UNIT, IOSTAT=IOSTAT, IOMSG=IOMSG, POS=POS) DATE_TIME !yyyy-mm-ddThh:mm:ss
        IF(IOSTAT.NE.Z .OR. SCAN(DATE_TIME,'Tt')==Z) THEN
            DATE_TIME=BLNK
            READ (UNIT, IOSTAT=IOSTAT, IOMSG=IOMSG, POS=POS) DATE_TIME(:10)  !yyyy-mm-dd
        END IF
    ELSE
            IOSTAT=666
            IF(LEN(IOMSG)>FIVE) IOMSG='STREAM_BINARY_ONLY'
    END IF
    !
    IF(IOSTAT==Z) THEN
        CALL DT%INIT( DATE_TIME )
        IF( DT%NOT_SET() ) THEN
            IOSTAT=123
            IOMSG='DATE_OPERATOR_ERROR'
        END IF
    END IF
    !
  END SUBROUTINE 
  !
  SUBROUTINE DATE_OPERATOR_FMTWRITE(DT, UNIT, IOTYPE, V_LIST, IOSTAT, IOMSG)  !* or '(DT"IOTYPE")' or '(DT)'
    CLASS(DATE_OPERATOR), INTENT(IN   ):: DT
    INTEGER,              INTENT(IN   ):: UNIT
    CHARACTER(*),         INTENT(IN   ):: IOTYPE
    INTEGER,              INTENT(IN   ):: V_LIST (:)
    INTEGER,              INTENT(OUT  ):: IOSTAT
    CHARACTER(*),         INTENT(INOUT):: IOMSG
    INTEGER:: N, M
    !
    ! This is the child I/O that gets performed when the procedure
    ! is called from a parent I/O  it uses list-directed input to read
    ! the array K
    !
    N = LEN_TRIM(IOTYPE)
    M = N
    IF(N>=7) M = 7
    !
    SELECT CASE(IOTYPE(:M))
    CASE('DTDYEAR','DTdyear','DTDYear','DTDyear') ! "DTDYEAR F15.4"
                M=M+1
                IF(N>=7 .AND. N-M > ONE) THEN
                    WRITE(UNIT, FMT='('//IOTYPE(M:N)//')', IOSTAT=IOSTAT, IOMSG=IOMSG) DT%DYEAR
                ELSE
                    WRITE(UNIT, FMT='(F17.12)', IOSTAT=IOSTAT, IOMSG=IOMSG) DT%DYEAR
                END IF
    CASE DEFAULT
         !
         SELECT CASE(IOTYPE)
         CASE('DTISO','DTiso','DTIso')
                     WRITE(UNIT, FMT='(A)', IOSTAT=IOSTAT, IOMSG=IOMSG) DT%STR('T')   !SCOTT MAY HAVE TO CHANGE '(A)' TO *
         CASE('DTNOISO','DTnoiso','DTNoiso','DTNoIso')
                     WRITE(UNIT, FMT='(A)', IOSTAT=IOSTAT, IOMSG=IOMSG) DT%STR('T',FALSE)
         CASE('DTNOTIME','DTnotime','DTNotime','DTNoTime')
                     WRITE(UNIT, FMT='(A)', IOSTAT=IOSTAT, IOMSG=IOMSG) DT%STR()
         CASE('LISTDIRECTED')
                     WRITE(UNIT, FMT=*,     IOSTAT=IOSTAT, IOMSG=IOMSG) DT%STR('T')   
         CASE('NAMELIST')
                     WRITE(UNIT, FMT='(A)', IOSTAT=IOSTAT, IOMSG=IOMSG) DT%STR('T')
         CASE DEFAULT
              IF(LEN(IOTYPE) > TWO) THEN
                    WRITE(UNIT, FMT='(A)', IOSTAT=IOSTAT, IOMSG=IOMSG) DT%STR(IOTYPE(3:))   
              ELSE
                     WRITE(UNIT, FMT='(A)', IOSTAT=IOSTAT, IOMSG=IOMSG) DT%STR('T')   
              END IF
         END SELECT
    END SELECT
    !
  END SUBROUTINE 
  !
  ELEMENTAL PURE SUBROUTINE DYEAR_MAKE_DATE(DT, DYEAR) 
    CLASS(DATE_OPERATOR),       INTENT(INOUT):: DT
    REAL(REAL64),     OPTIONAL, INTENT(IN   ):: DYEAR
    !
    IF(DT%DATE .NE. NO_DATE .AND. DT%DYEAR==DT%DYEAR) THEN
        !
        !BUILD DATE FROM DYEAR
        CALL DYEAR_TO_DATE(DT%DYEAR, DT%DAY, DT%MONTH, DT%YEAR, DT%FRAC, DT%JDN) 
        CALL DT%SET_DATE_STRING(DT%DAY, DT%MONTH, DT%YEAR)   !SET DT%DATE
        !
    ELSEIF(PRESENT(DYEAR)) THEN
        !
        CALL INITIALIZE_DATE_OPERATOR_DYEAR_DBLE(DT,DYEAR) 
        !
    ELSEIF(DT%DAY == NINER .OR. DT%DATE == NO_DATE) THEN
         DT%DATE  = NO_DATE
         DT%YEAR  = NINER
         DT%MONTH = NINER
         DT%DAY   = NINER
         DT%JDN   = NINER
         !DT%DYEAR = DZ
         DT%DYEAR = IEEE_VALUE(DT%DYEAR, IEEE_QUIET_NAN)
    END IF
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE FUNCTION ISLEAPYEAR_DATE_OPERATOR(DT) 
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    LOGICAL::ISLEAPYEAR_DATE_OPERATOR
    !
    ISLEAPYEAR_DATE_OPERATOR = ISLEAPYEAR(DT%YEAR) 
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION MONTHDAYS_DATE_OPERATOR(DT,LEAP) 
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    LOGICAL,              INTENT(IN), OPTIONAL:: LEAP
    INTEGER::MONTHDAYS_DATE_OPERATOR
    !
    MONTHDAYS_DATE_OPERATOR = MONTHDAYS(DT%MONTH,DT%YEAR,LEAP) 
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION MONTHDAYS_OPERATOR(MONTH,YEAR,LEAP) 
    INTEGER,  INTENT(IN):: MONTH, YEAR
    LOGICAL,  INTENT(IN), OPTIONAL:: LEAP
    INTEGER:: MONTHDAYS_OPERATOR
    !
    MONTHDAYS_OPERATOR = MONTHDAYS(MONTH,YEAR,LEAP) 
    !
  END FUNCTION
  !
  ELEMENTAL PURE SUBROUTINE ADD_DAY_DBLE(DT, DAY, FRAC, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    REAL(REAL64),         INTENT(IN   ):: DAY
    REAL(REAL64),         INTENT(IN   ), OPTIONAL:: FRAC
    LOGICAL,              INTENT(IN   ), OPTIONAL:: LEAP
    INTEGER:: IDAY
    REAL(REAL64):: FFRAC
    !
    IDAY = INT(DAY)
    FFRAC= DAY - DBLE(IDAY)
    !
    IF( PRESENT(FRAC) ) FFRAC = FFRAC + FRAC
    !
    CALL ADD_DAY_INT(DT, IDAY, FFRAC, LEAP)
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE ADD_DAY_INT(DT, DAY, FRAC, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    INTEGER,              INTENT(IN   ), OPTIONAL:: DAY
    REAL(REAL64),         INTENT(IN   ), OPTIONAL:: FRAC
    LOGICAL,              INTENT(IN   ), OPTIONAL:: LEAP
    INTEGER:: DOY, YEAR
    !
    IF(PRESENT(DAY)) THEN
        DOY= DT%JDN + DAY
    ELSE
        DOY= DT%JDN
    END IF
    !
    YEAR = DT%YEAR
    !
    IF( PRESENT(FRAC) ) DT%FRAC = DT%FRAC + FRAC
    !
    IF ( DT%FRAC > UNO .OR. DT%FRAC < DZ ) THEN
                                                 DOY     = DOY  + INT(DT%FRAC)     
                                                 DT%FRAC = DT%FRAC - INT(DT%FRAC)
    END IF
    !
    IF ( DT%FRAC < DZ ) THEN
                                                 DOY     = DOY  - ONE    
                                                 DT%FRAC = DT%FRAC + UNO
    END IF
    !
    IF ( DT%FRAC == UNO ) THEN
                                                 DOY     = DOY  + ONE     
                                                 DT%FRAC = DZ
    END IF
    !
    CALL JULIANDAY_TO_DATE(DOY, YEAR, DT%DAY, DT%MONTH, DT%YEAR, DT%JDN, LEAP)
    !
    DT%DYEAR = JDN_TO_DYEAR(DT%JDN, DT%YEAR, DT%FRAC, LEAP) 
    !
    CALL DT%SET_DATE_STRING(DT%DAY, DT%MONTH, DT%YEAR)   !SET DT%DATE
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE ADD_MONTH_INT(DT, MONTH, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    INTEGER,              INTENT(IN   ):: MONTH
    LOGICAL, OPTIONAL,    INTENT(IN   ):: LEAP
    LOGICAL:: ZERO_YEAR
    !
    ZERO_YEAR = DT%YEAR == Z
    !
    DT%MONTH = DT%MONTH + MONTH
    DO
      IF (DT%MONTH > 12) THEN
          DT%MONTH = DT%MONTH - 12
          DT%YEAR = DT%YEAR + ONE
      ELSEIF (DT%MONTH < ONE) THEN
          DT%MONTH = DT%MONTH + 12
          DT%YEAR = DT%YEAR - ONE
      ELSE
          EXIT
      END IF
    END DO
    !
    IF(ZERO_YEAR) THEN
                      IF(PRESENT(LEAP)) DT%YEAR = Z !PREVENT INCREMENT OF YEAR BECAUSE IT IS BEING TREATED AS A FRACTOIN OF YEAR
    END IF
    !
    DT%JDN= JULIANDAY(DT%DAY, DT%MONTH, DT%YEAR, LEAP) 
    !
    DT%DYEAR = JDN_TO_DYEAR(DT%JDN, DT%YEAR, DT%FRAC, LEAP) 
    !
    CALL DT%SET_DATE_STRING(DT%DAY, DT%MONTH, DT%YEAR)   !SET DT%DATE
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE ADD_MONTH_DBL(DT, MONTH, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    REAL(REAL64),         INTENT(IN   ):: MONTH
    LOGICAL, OPTIONAL,    INTENT(IN   ):: LEAP
    INTEGER:: MON
    REAL(REAL64):: MFRAC
    LOGICAL:: ZERO_YEAR
    !
    ZERO_YEAR = DT%YEAR == Z
    !
    MON = INT(MONTH)
    MFRAC = MONTH - DBLE(MON)
    !
    DT%MONTH = DT%MONTH + MON
    DO
      IF (DT%MONTH > 12) THEN
          DT%MONTH = DT%MONTH - 12
          DT%YEAR = DT%YEAR + ONE
      ELSEIF (DT%MONTH < ONE) THEN
          DT%MONTH = DT%MONTH + 12
          DT%YEAR = DT%YEAR - ONE
      ELSE
          EXIT
      END IF
    END DO
    !
    IF(ABS(MFRAC) > YEARTOL) THEN !NOTE USING YEAR TOLERANCE RATHER THEN "YEARTOL*0.08" ~ YEARTOL/12 --MONTHS HAVE MORE ERRORS SO HAVE LOOSER TOLERANCE
                                  !
                                  MON = MONTHDAYS(DT%MONTH,DT%YEAR)
                                  MFRAC = MFRAC * DBLE(MON)
                                  CALL ADD_DAY_INT(DT, FRAC=MFRAC, LEAP = LEAP)
    END IF
    !
    IF(ZERO_YEAR) THEN
                      IF(PRESENT(LEAP)) DT%YEAR = Z !PREVENT INCREMENT OF YEAR BECAUSE IT IS BEING TREATED AS A FRACTOIN OF YEAR
    END IF
    !
    DT%JDN= JULIANDAY(DT%DAY, DT%MONTH, DT%YEAR, LEAP) 
    !
    DT%DYEAR = JDN_TO_DYEAR(DT%JDN, DT%YEAR, DT%FRAC, LEAP) 
    !
    CALL DT%SET_DATE_STRING(DT%DAY, DT%MONTH, DT%YEAR)   !SET DT%DATE
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE ADD_YEAR_INT(DT, YEAR, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    INTEGER,              INTENT(IN   ):: YEAR
    LOGICAL, OPTIONAL,    INTENT(IN   ):: LEAP
    !
    IF(.NOT. PRESENT(LEAP)) THEN
         !
         DT%YEAR = DT%YEAR + YEAR
         !
         DT%JDN= JULIANDAY(DT%DAY, DT%MONTH, DT%YEAR) 
         !
         DT%DYEAR = JDN_TO_DYEAR(DT%JDN, DT%YEAR, DT%FRAC) 
         !
         CALL DT%SET_DATE_STRING(DT%DAY, DT%MONTH, DT%YEAR)   !SET DT%DATE
         !
    END IF
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE ADD_YEAR_DBL(DT, YEAR, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    REAL(REAL64),         INTENT(IN   ):: YEAR
    LOGICAL, OPTIONAL,    INTENT(IN   ):: LEAP
    REAL(REAL64):: YFRAC
    INTEGER:: YR
    !
    IF(.NOT. PRESENT(LEAP)) THEN
         !
         YR = INT(YEAR)
         YFRAC = YEAR - DBLE(YR)
         !
         IF(ABS(YFRAC) <= YEARTOL) THEN
                                       CALL ADD_YEAR_INT(DT, YR)
         ELSE
                                       DT%YEAR  = DT%YEAR + YR
                                       DT%JDN   = JULIANDAY(DT%DAY, DT%MONTH, DT%YEAR) 
                                       !
                                       IF(ISLEAPYEAR(DT%YEAR)) THEN
                                           YFRAC = YFRAC * 366D0
                                       ELSE
                                           YFRAC = YFRAC * 365D0
                                       END IF
                                       !
                                       CALL ADD_DAY_INT(DT, FRAC=YFRAC)
         END IF
         !
    END IF
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE ADD_SEC_DBLE(DT, SEC, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    REAL(REAL64),         INTENT(IN   ):: SEC
    LOGICAL,              INTENT(IN   ), OPTIONAL:: LEAP
    !
    DT%FRAC = DT%FRAC + SEC*SEC2DAY
    !
    IF ( DT%FRAC > UNO .OR. DT%FRAC < DZ ) THEN
         CALL ADD_DAY_INT(DT, LEAP=LEAP)
    ELSE
         DT%DYEAR = JDN_TO_DYEAR(DT%JDN, DT%YEAR, DT%FRAC, LEAP)
    END IF
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE ADD_SEC_INT(DT, SEC, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    INTEGER,              INTENT(IN   ):: SEC
    LOGICAL,              INTENT(IN   ), OPTIONAL:: LEAP
    !
    DT%FRAC = DT%FRAC + DBLE(SEC)*SEC2DAY
    !
    IF ( DT%FRAC > UNO .OR. DT%FRAC < DZ ) THEN
         CALL ADD_DAY_INT(DT, LEAP=LEAP)
    ELSE
         DT%DYEAR = JDN_TO_DYEAR(DT%JDN, DT%YEAR, DT%FRAC, LEAP)
    END IF
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE ADD_MIN_DBLE(DT, MIN, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    REAL(REAL64),         INTENT(IN   ):: MIN
    LOGICAL,              INTENT(IN   ), OPTIONAL:: LEAP
    !
    DT%FRAC = DT%FRAC + MIN*MIN2DAY
    !
    IF ( DT%FRAC > UNO .OR. DT%FRAC < DZ ) THEN
         CALL ADD_DAY_INT(DT, LEAP=LEAP)
    ELSE
         DT%DYEAR = JDN_TO_DYEAR(DT%JDN, DT%YEAR, DT%FRAC, LEAP)
    END IF
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE ADD_MIN_INT(DT, MIN, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    INTEGER,              INTENT(IN   ):: MIN
    LOGICAL,              INTENT(IN   ), OPTIONAL:: LEAP
    !
    DT%FRAC = DT%FRAC + DBLE(MIN)*MIN2DAY
    !
    IF ( DT%FRAC > UNO .OR. DT%FRAC < DZ ) THEN
         CALL ADD_DAY_INT(DT, LEAP=LEAP)
    ELSE
         DT%DYEAR = JDN_TO_DYEAR(DT%JDN, DT%YEAR, DT%FRAC, LEAP)
    END IF
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE ADD_HOUR_DBLE(DT, HOUR, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    REAL(REAL64),         INTENT(IN   ):: HOUR
    LOGICAL,              INTENT(IN   ), OPTIONAL:: LEAP
    !
    DT%FRAC = DT%FRAC + HOUR*HR2DAY
    !
    IF ( DT%FRAC > UNO .OR. DT%FRAC < DZ ) THEN
         CALL ADD_DAY_INT(DT, LEAP=LEAP)
    ELSE
         DT%DYEAR = JDN_TO_DYEAR(DT%JDN, DT%YEAR, DT%FRAC, LEAP)
    END IF
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE ADD_HOUR_INT(DT, HOUR, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    INTEGER,              INTENT(IN   ):: HOUR
    LOGICAL,              INTENT(IN   ), OPTIONAL:: LEAP
    !
    DT%FRAC = DT%FRAC + DBLE(HOUR)*HR2DAY
    !
    IF ( DT%FRAC > UNO .OR. DT%FRAC < DZ ) THEN
         CALL ADD_DAY_INT(DT, LEAP=LEAP)
    ELSE
         DT%DYEAR = JDN_TO_DYEAR(DT%JDN, DT%YEAR, DT%FRAC, LEAP)
    END IF
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE ZERO_YEAR(DT, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    LOGICAL, INTENT(IN), OPTIONAL:: LEAP
    !
    IF(DT%YEAR.NE.Z) THEN
       !
       DT%YEAR = Z
       !
       DT%JDN= JULIANDAY(DT%DAY, DT%MONTH, DT%YEAR, LEAP) 
       !
       DT%DYEAR = JDN_TO_DYEAR(DT%JDN, DT%YEAR, DT%FRAC, LEAP) 
       !
       CALL DT%SET_DATE_STRING(DT%DAY, DT%MONTH, DT%YEAR)   !SET DT%DATE
       !
       DT%DATE = 'ZERO_YEAR'
    END IF
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE FUNCTION DATE_MD_COMPARE(DT, OP, DT2) RESULT(RES) !DT op DT2 where op = ">", ">=", "<", "<=", or  "=="
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    CHARACTER(*),         INTENT(IN):: OP
    TYPE(DATE_OPERATOR),  INTENT(IN):: DT2
    LOGICAL:: RES
    !
    SELECT CASE(OP)
    CASE('>' ); RES = DT%MONTH >  DT2%MONTH .AND. DT%DAY >  DT2%DAY
    CASE('>='); RES = DT%MONTH >= DT2%MONTH .AND. DT%DAY >= DT2%DAY
    CASE('<' ); RES = DT%MONTH <  DT2%MONTH .AND. DT%DAY <  DT2%DAY
    CASE('<='); RES = DT%MONTH <= DT2%MONTH .AND. DT%DAY <= DT2%DAY
    CASE('=='); RES = DT%MONTH == DT2%MONTH .AND. DT%DAY == DT2%DAY
    CASE DEFAULT
                RES = FALSE
    END SELECT
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_CONTAINS_MD(DT, M, D, DT2, INCLUSIVE) RESULT(RES)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    INTEGER,              INTENT(IN):: M,D
    TYPE(DATE_OPERATOR),  INTENT(IN):: DT2
    LOGICAL, OPTIONAL,    INTENT(IN):: INCLUSIVE
    LOGICAL:: RES
    !
    INTEGER:: JD
    LOGICAL:: INCL
    !
    INCL = FALSE
    IF(PRESENT(INCLUSIVE)) INCL = INCLUSIVE
    !
    IF(DT%DYEAR.NE.DT%DYEAR .OR. DT2%DYEAR.NE.DT2%DYEAR) THEN
        RES = FALSE
    ELSEIF(DT%DYEAR > DT2%DYEAR) THEN
        RES = FALSE
    ELSEIF(DT2%YEAR - DT%YEAR > ONE) THEN
        RES = TRUE
    ELSEIF(DT%YEAR == DT2%YEAR) THEN
        JD = JULIANDAY(D, M, DT%YEAR)
        IF(INCL) THEN
                     RES = DT%JDN <= JD .AND. JD <= DT2%JDN
        ELSE
                     RES = DT%JDN <= JD .AND. JD <  DT2%JDN
        END IF
    ELSE
        IF(INCL) THEN
                     RES = JULIANDAY(D, M, DT%YEAR) >= DT%JDN .OR. JULIANDAY(D, M, DT2%YEAR) <= DT2%JDN
        ELSE
                     RES = JULIANDAY(D, M, DT%YEAR) >= DT%JDN .OR. JULIANDAY(D, M, DT2%YEAR) <  DT2%JDN
        END IF
    END IF
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_CONTAINS_DATE_MD(DT, MD, DT2, INCLUSIVE) RESULT(RES)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    TYPE(DATE_OPERATOR),  INTENT(IN):: MD
    TYPE(DATE_OPERATOR),  INTENT(IN):: DT2
    LOGICAL, OPTIONAL,    INTENT(IN):: INCLUSIVE
    LOGICAL:: RES
    !
    RES = DATE_CONTAINS_MD(DT, MD%MONTH, MD%DAY, DT2, INCLUSIVE)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_DAY_COUNT_MD(DT, M, D, LOOK_FORWARD) RESULT(NDAY)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    INTEGER,              INTENT(IN):: M,D
    LOGICAL, OPTIONAL,    INTENT(IN):: LOOK_FORWARD
    TYPE(DATE_OPERATOR):: DT2
    REAL(REAL64):: DAYDIFF
    INTEGER:: NDAY
    INTEGER:: YR
    LOGICAL:: LOOK_BACK
    !
    IF(PRESENT(LOOK_FORWARD)) THEN
                       LOOK_BACK = .NOT. LOOK_FORWARD
    ELSE
                       LOOK_BACK = TRUE
    END IF
    !
    IF(LOOK_BACK) THEN
        IF( M <= DT%MONTH .AND. D <= DT%DAY ) THEN  !Same YR
            YR = DT%YEAR
        ELSE
            YR = DT%YEAR - ONE
        END IF
    ELSE
        IF( M <= DT%MONTH .AND. D < DT%DAY ) THEN  !Same YR
            YR = DT%YEAR + ONE
        ELSE
            YR = DT%YEAR
        END IF
    END IF
    !
    CALL INITIALIZE_DATE_OPERATOR_DMY(DT2, D, M, YR)
    !
    IF(LOOK_BACK) THEN
                  DAYDIFF = DATE_OPERATOR_DAY_DIFFERENCE(DT, DT2)
    ELSE
                  DAYDIFF = DATE_OPERATOR_DAY_DIFFERENCE(DT2, DT)
    END IF
    !
    NDAY = INT(DAYDIFF)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_DAY_COUNT_DATE_MD(DT, MD, LOOK_FORWARD) RESULT(NDAY)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    TYPE(DATE_OPERATOR),  INTENT(IN):: MD
    LOGICAL, OPTIONAL,    INTENT(IN):: LOOK_FORWARD
    INTEGER:: NDAY
    !
    NDAY = DATE_DAY_COUNT_MD(DT, DT%MONTH, MD%DAY, LOOK_FORWARD)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_DAY_COUNT_DATE_TO_MD(DT, MD) RESULT(NDAY)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    TYPE(DATE_OPERATOR),  INTENT(IN):: MD
    INTEGER:: NDAY
    !
    NDAY = DATE_DAY_COUNT_MD(DT, DT%MONTH, MD%DAY, TRUE)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_DAY_COUNT_TO_MD(DT, M, D) RESULT(NDAY)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    INTEGER,              INTENT(IN):: M, D
    INTEGER:: NDAY
    !
    NDAY = DATE_DAY_COUNT_MD(DT, M, D, TRUE)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_DAY_COUNT_DATE_FROM_MD(DT, MD) RESULT(NDAY)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    TYPE(DATE_OPERATOR),  INTENT(IN):: MD
    INTEGER:: NDAY
    !
    NDAY = DATE_DAY_COUNT_MD(DT, DT%MONTH, MD%DAY, FALSE)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_DAY_COUNT_FROM_MD(DT, M, D) RESULT(NDAY)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    INTEGER,              INTENT(IN):: M, D
    INTEGER:: NDAY
    !
    NDAY = DATE_DAY_COUNT_MD(DT, M, D, FALSE)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_YEAR_DAY_COUNT(DT, YEAR, LEAP) RESULT(NDAY)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    INTEGER, OPTIONAL,    INTENT(IN):: YEAR
    LOGICAL, OPTIONAL,    INTENT(IN):: LEAP
    INTEGER:: NDAY
    !
    IF   (PRESENT(YEAR))     THEN
                                 NDAY = YEAR_DAY_COUNT(YEAR, LEAP)
    ELSEIF(DT%YEAR.NE.NINER) THEN
                                 NDAY = YEAR_DAY_COUNT(DT%YEAR, LEAP)
    ELSE
                                 NDAY = 365
    END IF
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_YEAR_DAY_COUNT_DBLE(DT, YEAR, LEAP) RESULT(NDAY)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    INTEGER, OPTIONAL,    INTENT(IN):: YEAR
    LOGICAL, OPTIONAL,    INTENT(IN):: LEAP
    REAL(REAL64):: NDAY
    !
    IF   (PRESENT(YEAR))     THEN
                                 NDAY = YEAR_DAY_COUNT_DBLE(YEAR, LEAP)
    ELSEIF(DT%YEAR.NE.NINER) THEN
                                 NDAY = YEAR_DAY_COUNT_DBLE(DT%YEAR, LEAP)
    ELSE
                                 NDAY = 365D0
    END IF
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_YEAR_FRACTION(DT, LEAP) RESULT(YFRAC)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    LOGICAL,    OPTIONAL, INTENT(IN):: LEAP
    REAL(REAL64):: YFRAC
    !
    YFRAC = YEAR_FRACTION_DMY(DT%DAY, DT%MONTH, DT%YEAR, DT%FRAC, LEAP)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_DYEAR_FRACTION(DT) RESULT(YFRAC)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    REAL(REAL64):: YFRAC
    !
    IF(DT%DYEAR==DT%DYEAR) THEN
        YFRAC = YEAR_FRACTION_DYEAR(DT%DYEAR)
    ELSE
        YFRAC = DT%DYEAR
    END IF
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_DYEAR_IS_YEAR(DT) RESULT(DYEAR_IS_YEAR)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    LOGICAL:: DYEAR_IS_YEAR
    !
    IF(DT%DYEAR==DT%DYEAR) THEN
        DYEAR_IS_YEAR = DT%DYEAR - DBLE(DT%YEAR) < YEARTOL
    ELSE
        DYEAR_IS_YEAR = FALSE
    END IF
    
    !
  END FUNCTION
  !
  ELEMENTAL PURE SUBROUTINE SET_YEAR(DT, YEAR, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    INTEGER, INTENT(IN):: YEAR
    LOGICAL, INTENT(IN), OPTIONAL:: LEAP
    !
    DT%YEAR = YEAR
    !
    DT%JDN= JULIANDAY(DT%DAY, DT%MONTH, DT%YEAR, LEAP) 
    !
    DT%DYEAR = JDN_TO_DYEAR(DT%JDN, DT%YEAR, DT%FRAC, LEAP) 
    !
    CALL DT%SET_DATE_STRING(DT%DAY, DT%MONTH, DT%YEAR)   !SET DT%DATE
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE SET_MONTH(DT, MONTH, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    LOGICAL, OPTIONAL,    INTENT(IN   ):: LEAP
    INTEGER, INTENT(IN):: MONTH
    !
    DT%MONTH = MONTH
    !
    DT%JDN= JULIANDAY(DT%DAY, DT%MONTH, DT%YEAR, LEAP) 
    !
    DT%DYEAR = JDN_TO_DYEAR(DT%JDN, DT%YEAR, DT%FRAC, LEAP) 
    !
    CALL DT%SET_DATE_STRING(DT%DAY, DT%MONTH, DT%YEAR)   !SET DT%DATE
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE SET_DAY(DT, DAY, LEAP)
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    LOGICAL, OPTIONAL,    INTENT(IN   ):: LEAP
    INTEGER, INTENT(IN):: DAY
    !
    DT%DAY = DAY
    !
    DT%JDN= JULIANDAY(DT%DAY, DT%MONTH, DT%YEAR, LEAP) 
    !
    DT%DYEAR = JDN_TO_DYEAR(DT%JDN, DT%YEAR, DT%FRAC, LEAP) 
    !
    CALL DT%SET_DATE_STRING(DT%DAY, DT%MONTH, DT%YEAR)   !SET DT%DATE
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE COPY_DATE_OPERATOR(DT_OUT,DT_IN)
    CLASS(DATE_OPERATOR), INTENT(IN   ):: DT_IN
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT_OUT
    !
    DT_OUT%DATE  = DT_IN%DATE
    DT_OUT%DAY   = DT_IN%DAY
    DT_OUT%MONTH = DT_IN%MONTH
    DT_OUT%YEAR  = DT_IN%YEAR
    DT_OUT%JDN   = DT_IN%JDN
    DT_OUT%FRAC  = DT_IN%FRAC
    DT_OUT%DYEAR = DT_IN%DYEAR
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE STR_TO_DATE_OPERATOR(DT,STR)
    CHARACTER(*),         INTENT(IN   ):: STR
    CLASS(DATE_OPERATOR), INTENT(INOUT):: DT
    !
    CALL INITIALIZE_DATE_OPERATOR_STR(DT, STR)
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE FUNCTION DATE_OPERATOR_ADD_DBLE(DT_IN, DAY) RESULT(DT)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT_IN
    REAL(REAL64),         INTENT(IN):: DAY
    TYPE(DATE_OPERATOR)             :: DT
    REAL(REAL64):: FRAC
    INTEGER:: IDAY
    !
    IDAY = INT(DAY)
    FRAC = DAY - DBLE(IDAY)
    !
    DT%JDN = DT_IN%JDN
    DT%YEAR= DT_IN%YEAR
    DT%FRAC= DT_IN%FRAC
    !
    CALL ADD_DAY_INT(DT,IDAY,FRAC)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_OPERATOR_ADD_SNGL(DT_IN, DAY) RESULT(DT)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT_IN
    REAL(REAL32),         INTENT(IN):: DAY
    TYPE(DATE_OPERATOR)             :: DT
    REAL(REAL64):: FRAC
    INTEGER:: IDAY
    !
    IDAY = INT(DAY)
    FRAC = DBLE(DAY - REAL(IDAY,REAL32))
    FRAC = DBLE(INT(FRAC*1D7))/1D7                !ENSURE TRAILING ZEROS ARE ZERO
    !
    DT%JDN = DT_IN%JDN
    DT%YEAR= DT_IN%YEAR
    DT%FRAC= DT_IN%FRAC
    !
    CALL ADD_DAY_INT(DT,IDAY,FRAC)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_OPERATOR_ADD_INT(DT_IN, DAY) RESULT(DT)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT_IN
    INTEGER,              INTENT(IN):: DAY
    TYPE(DATE_OPERATOR)             :: DT
    !
    DT%JDN = DT_IN%JDN
    DT%YEAR= DT_IN%YEAR
    DT%FRAC= DT_IN%FRAC
    !
    CALL ADD_DAY_INT(DT,DAY)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_OPERATOR_SUB_DBLE(DT_IN, DAY) RESULT(DT)  !DAY INCOMING IS POSITIVE
    CLASS(DATE_OPERATOR), INTENT(IN):: DT_IN
    REAL(REAL64),         INTENT(IN):: DAY
    TYPE(DATE_OPERATOR)             :: DT
    REAL(REAL64):: FRAC
    INTEGER:: IDAY
    !
    IDAY =  NEG * INT(DAY)
    FRAC = DNEG * ( DAY + DBLE(IDAY) )  ! DAY + (-INT(DAY))  
    !
    DT%JDN = DT_IN%JDN
    DT%YEAR= DT_IN%YEAR
    DT%FRAC= DT_IN%FRAC
    !
    CALL ADD_DAY_INT(DT,IDAY,FRAC)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_OPERATOR_SUB_SNGL(DT_IN, DAY) RESULT(DT)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT_IN
    REAL(REAL32),         INTENT(IN):: DAY
    TYPE(DATE_OPERATOR)             :: DT
    REAL(REAL64):: FRAC
    INTEGER:: IDAY
    !
    IDAY = NEG  * INT(DAY)
    FRAC = DBLE( -1. * ( DAY + REAL(IDAY,REAL32) ) )
    FRAC = DBLE(INT(FRAC*1D7))/1D7                !ENSURE TRAILING ZEROS ARE ZERO
    !
    DT%JDN = DT_IN%JDN
    DT%YEAR= DT_IN%YEAR
    DT%FRAC= DT_IN%FRAC
    !
    CALL ADD_DAY_INT(DT,IDAY,FRAC)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_OPERATOR_SUB_INT(DT_IN, DAY) RESULT(DT)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT_IN
    INTEGER,              INTENT(IN):: DAY
    TYPE(DATE_OPERATOR)             :: DT
    INTEGER:: DAY_SUB
    !
    DAY_SUB = NEG * DAY
    !
    DT%JDN = DT_IN%JDN
    DT%YEAR= DT_IN%YEAR
    DT%FRAC= DT_IN%FRAC
    !
    CALL ADD_DAY_INT(DT,DAY_SUB)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_OPERATOR_SUB(DT1, DT2) RESULT(DAYDIFF)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT1, DT2
    REAL(REAL64):: DAYDIFF
    !
    DAYDIFF = DATE_OPERATOR_DAY_DIFFERENCE(DT1, DT2)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_OPERATOR_DAY_DIFFERENCE(DT, DT2) RESULT(DIFF)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT, DT2
    REAL(REAL64):: DIFF
    INTEGER:: YEAR
    !
    DIFF = DBLE(DT%JDN - DT2%JDN) + DT%FRAC - DT2%FRAC
    !
    IF (DT%YEAR < DT2%YEAR) THEN
        !DIFF= DBLE(DT%JDN - DT2%JDN) + DT%FRAC - DT2%FRAC
        YEAR = DT2%YEAR - ONE
        DO WHILE (YEAR >= DT%YEAR)
            IF ( ISLEAPYEAR(YEAR) ) THEN
                DIFF=DIFF-366D0
            ELSE
                DIFF=DIFF-365D0
            END IF
            YEAR = YEAR - ONE
        END DO
    ELSEIF (DT%YEAR > DT2%YEAR) THEN
        !DIFF= -1D0*DBLE(DT2%JDN) - DT2%FRAC
        YEAR = DT2%YEAR 
        DO WHILE (YEAR <  DT%YEAR)
            IF ( ISLEAPYEAR(YEAR) ) THEN
                DIFF=DIFF+366D0
            ELSE
                DIFF=DIFF+365D0
            END IF
            YEAR = YEAR + ONE
        END DO
    END IF
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_OPERATOR_INTERPOLATE_DBLE(DT,DT1,DT2,DAT1,DAT2) RESULT (RES)
  CLASS(DATE_OPERATOR), INTENT(IN):: DT
  CLASS(DATE_OPERATOR), INTENT(IN):: DT1,  DT2
  REAL(REAL64),         INTENT(IN):: DAT1, DAT2
  REAL(REAL64):: RES
  
  IF (ABS(DT2%DYEAR - DT1%DYEAR) < YEARTOL) THEN
      RES = DAT1
  ELSE
      !RES = (DT%DYEAR - DT1%DYEAR)/(DT2%DYEAR - DT1%DYEAR)
      !RES = DAT1 + (DAT2-DAT1)*RES
      RES = DAT1 + (DAT2-DAT1)*( DT%DIFF(DT1) / DT2%DIFF(DT1) )
  END IF
  !  
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_OPERATOR_INTERPOLATE_SNGL(DT,DT1,DT2,DAT1,DAT2) RESULT (RES)
  CLASS(DATE_OPERATOR), INTENT(IN):: DT
  CLASS(DATE_OPERATOR), INTENT(IN):: DT1,  DT2
  REAL(REAL32),         INTENT(IN):: DAT1, DAT2
  REAL(REAL32):: RES
  
  IF (ABS(DT2%DYEAR - DT1%DYEAR) < YEARTOL) THEN
      RES = DAT1
  ELSE
      !RES = (DT%DYEAR - DT1%DYEAR)/(DT2%DYEAR - DT1%DYEAR)
      !RES = DAT1 + (DAT2-DAT1)*RES
      RES = DAT1 + (DAT2-DAT1)*REAL( DT%DIFF(DT1) / DT2%DIFF(DT1) , REAL32)
  END IF
  !  
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_OPERATOR_EQUALITY(DT1, DT2) RESULT(EQ)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT1, DT2
    LOGICAL:: EQ
    !
    EQ = ABS(DT1%DYEAR-DT2%DYEAR) < YEARTOL   !within 1.1 second of each other   --- EQ = ( DT1%YEAR == DT2%YEAR ) .AND. ( DT1%JDN == DT2%JDN ) .AND. ( ABS(DT1%FRAC - DT2%FRAC) < DAYTOL )
    !
    END FUNCTION
    !
  ELEMENTAL PURE FUNCTION DATE_OPERATOR_LESS_THAN(DT1, DT2) RESULT(LT)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT1, DT2
    LOGICAL:: LT
    !
    LT = DT1%DYEAR < DT2%DYEAR .AND. ABS(DT1%DYEAR-DT2%DYEAR) > YEARTOL
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_OPERATOR_LESS_THAN_EQUAL(DT1, DT2) RESULT(LE)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT1, DT2
    LOGICAL:: LE
    !
    LE = DT1%DYEAR <= DT2%DYEAR .OR. ABS(DT1%DYEAR-DT2%DYEAR) < YEARTOL   !CHECK IF WITHIN 1.1 second of each other
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_OPERATOR_GREATER_THAN(DT1, DT2) RESULT(GT)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT1, DT2
    LOGICAL:: GT
    !
    GT = DT1%DYEAR > DT2%DYEAR .AND. ABS(DT1%DYEAR-DT2%DYEAR) > YEARTOL
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_OPERATOR_GREATER_THAN_EQUAL(DT1, DT2) RESULT(GE)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT1, DT2
    LOGICAL:: GE
    !
    GE = DT1%DYEAR >= DT2%DYEAR .OR. ABS(DT1%DYEAR-DT2%DYEAR) < YEARTOL   !CHECK IF WITHIN 1.1 second of each other
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_OPERATOR_FRAC_TO_TIME(DT) RESULT(TIME)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    CHARACTER(8):: TIME
    INTEGER:: HOUR, MIN, SEC
    REAL(REAL64):: TEMP
    !
    IF(ABS(DT%FRAC-UNO) <= HALFSEC ) THEN
        TIME = "24:00:00"
    ELSEIF(ABS(DT%FRAC) <= HALFSEC ) THEN
        TIME = "00:00:00"
    ELSEIF(ABS(DT%FRAC-0.5D0) <= HALFSEC ) THEN
        TIME = "12:00:00"
    ELSE
        HOUR= INT( 24D0 * DT%FRAC)
        !
        TEMP = (24D0 * DT%FRAC) - DBLE(HOUR)
        MIN =INT( 60D0*TEMP )
        !
        TEMP = 60D0*TEMP - DBLE(MIN)
        SEC = INT( 60D0*TEMP )
        IF(SEC < Z) SEC = Z
        !
        IF( SEC==60) THEN
            SEC = 0
            MIN = MIN + ONE
        END IF
        !
        IF( MIN==60) THEN
            MIN = 0
            HOUR = HOUR + ONE
        END IF
        !
        WRITE(TIME,'(I2.2, A ,I2.2, A ,I2.2)') HOUR, COL, MIN, COL, SEC
    END IF
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_OPERATOR_TIME_TO_FRAC(TIME) RESULT(FRAC)
    CHARACTER(*), INTENT(IN):: TIME
    REAL(REAL64):: FRAC
    INTEGER:: I,A,B,C,IERR
    INTEGER:: HOUR, MIN, SEC
    !
    I = SCAN(TIME,'Tt') + ONE
    A = INDEX(TIME,':')
    B = INDEX(TIME,':',TRUE)
    C = LEN_TRIM(TIME)
    !
    IF(C > B + TWO) C = B + TWO
    !
    READ(TIME(I:A-1), *, IOSTAT=IERR) HOUR
    !
    IF(IERR == Z) READ(TIME(A+1:B-1),*, IOSTAT=IERR) MIN
    !
    IF(IERR == Z) READ(TIME(B+1:C)  ,*, IOSTAT=IERR) SEC
    !
    IF(IERR.NE.Z) THEN
        FRAC = IEEE_VALUE(FRAC, IEEE_QUIET_NAN)
    ELSE
        FRAC = DBLE(HOUR)*HR2DAY + DBLE(MIN)*MIN2DAY + DBLE(SEC)*SEC2DAY
    END IF
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION ONLY_DYEAR(DT) 
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    LOGICAL:: ONLY_DYEAR
    !
    ONLY_DYEAR = DT%DATE == 'DYEAR'
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_HAS_BEEN_SET(DT) RESULT(DATE_SET)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    LOGICAL:: DATE_SET
    !
    DATE_SET = DT%DAY .NE. NINER .AND. DT%DATE .NE. NO_DATE
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_HAS_NOT_BEEN_SET(DT) RESULT(DATE_NOT_SET)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    LOGICAL:: DATE_NOT_SET
    !
    DATE_NOT_SET = DT%DAY == NINER .OR. DT%DATE == NO_DATE
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DATE_HAS_ZERO_YEAR(DT) RESULT(ZERO_YEAR)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    LOGICAL:: ZERO_YEAR
    !
    ZERO_YEAR = DT%YEAR == Z
    !
  END FUNCTION
  !  
  !FUNCTION DATE_OPERATOR_STRING_REPRESENTATION(DT,SEP) RESULT(DATETIME)
  !  CLASS(DATE_OPERATOR), INTENT(IN):: DT
  !  CHARACTER, OPTIONAL,  INTENT(IN):: SEP
  !  CHARACTER(19):: DATETIME
  !  !
  !  IF(PRESENT(SEP)) THEN
  !      DATETIME=DT%DATE//SEP //DT%TIME()
  !  ELSE
  !      DATETIME=DT%DATE//BLNK//DT%TIME()
  !  END IF
  !  !
  !END FUNCTION
  !
  PURE FUNCTION DATE_OPERATOR_STRING_REPRESENTATION(DT, SEP, ISO) RESULT (DATE)
    CLASS(DATE_OPERATOR),   INTENT(IN):: DT
    CHARACTER(*), OPTIONAL, INTENT(IN):: SEP  !IF PROVIDED THEN THE CLOCK IS INCLUDED
    LOGICAL,      OPTIONAL, INTENT(IN):: ISO
    CHARACTER(:), ALLOCATABLE:: DATE
    !
    IF(PRESENT(SEP)) THEN
                         ALLOCATE(CHARACTER(18+LEN(SEP)):: DATE)  !mm/dd/yyyyThh:mm:ss
                         DATE(11:)=SEP//DATE_OPERATOR_FRAC_TO_TIME(DT)
    ELSE
                         ALLOCATE(CHARACTER(10):: DATE)  !mm/dd/yyyy
    END IF
    !
    IF(PRESENT(ISO)) THEN
         IF(ISO) THEN
                     WRITE(DATE(:10),'(I4.4, A ,I2.2, A ,I2.2)') DT%YEAR, MINUS, DT%MONTH, MINUS, DT%DAY  !ISO STANDARD
         ELSE
                     WRITE(DATE(:10),'(I2.2, A ,I2.2, A ,I4.4)') DT%MONTH, SLASH, DT%DAY, SLASH, DT%YEAR  !USA Standard
         END IF
    ELSE
                     WRITE(DATE(:10),'(I4.4, A ,I2.2, A ,I2.2)') DT%YEAR, MINUS, DT%MONTH, MINUS, DT%DAY  !ISO STANDARD
    END IF
    !
  END FUNCTION
  !
  PURE FUNCTION DATE_OPERATOR_PRINT_MONTHYEAR(DT, FULLNAME) RESULT (MONTHYEAR)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    LOGICAL,  OPTIONAL,   INTENT(IN):: FULLNAME
    CHARACTER(:), ALLOCATABLE:: MONTHYEAR
    CHARACTER(4):: YEAR
    !
    WRITE(YEAR,'(I4.4)') DT%YEAR
    !
    MONTHYEAR = MONTHNAME(DT%MONTH,FULLNAME)//'-'//YEAR
    !
  END FUNCTION
  !
  PURE FUNCTION DATE_OPERATOR_PRINT_YEAR_MONTH(DT,SEP) RESULT (MONTHYEAR)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    CHARACTER(1), OPTIONAL, INTENT(IN):: SEP  !IF PROVIDED THEN THE CLOCK IS INCLUDED
    CHARACTER(:),ALLOCATABLE:: MONTHYEAR
    INTEGER:: N
    !
    IF(PRESENT(SEP)) THEN
        N = 6 + LEN(SEP)
        ALLOCATE(CHARACTER(N)::MONTHYEAR)
        WRITE(MONTHYEAR,'(I4.4,A,I2.2)') DT%YEAR,SEP,DT%MONTH
    ELSE
        ALLOCATE(CHARACTER(7)::MONTHYEAR)
        WRITE(MONTHYEAR,'(I4.4,A1,I2.2)') DT%YEAR,'_',DT%MONTH
    END IF
    !
  END FUNCTION
  !
  PURE FUNCTION DATE_OPERATOR_PRINT_DYEAR(DT, NDEC) RESULT (DYEAR)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT
    INTEGER,  OPTIONAL,   INTENT(IN):: NDEC
    CHARACTER(:),ALLOCATABLE:: DYEAR
    CHARACTER(10):: FMT !(F10.10)
    INTEGER:: DIM
    !
    IF(PRESENT(NDEC)) THEN
        !
        DIM = NDEC
        IF(DIM>9) DIM = 9
        !
        ALLOCATE(CHARACTER(DIM+5):: DYEAR)
        IF(DIM+5 > 10) THEN
             WRITE(FMT,'("(F",I2,".",I1)') DIM+5,DIM
        ELSE
             WRITE(FMT,'("(F",I1,".",I1)') DIM+5,DIM
        END IF
        WRITE(DYEAR, FMT) DT%DYEAR
    ELSE
        ALLOCATE(CHARACTER(9):: DYEAR) 
        WRITE(DYEAR,'(F9.4)') DT%DYEAR
    END IF
    !
  END FUNCTION
  !
  PURE FUNCTION DATE_OPERATOR_PRINT_DIF(DT, DT2, UNIT) RESULT (PPRINT)
    CLASS(DATE_OPERATOR), INTENT(IN):: DT, DT2
    INTEGER, OPTIONAL,    INTENT(IN):: UNIT  != 1 => sec
    CHARACTER(:), ALLOCATABLE:: PPRINT
    !
    ! UNIT DEFINES OUTPUT STRUCTURE
    ! UNIT =
    !       0 => units as needed
    !       1 => seconds
    !       2 => minutes
    !       3 => hours
    !       4 => days
    !       5 => largest whole unit
    !
    CHARACTER(15):: NUM 
    INTEGER:: IPRT
    REAL(REAL64):: DIFF
    !
    DIFF = DATE_OPERATOR_DAY_DIFFERENCE(DT, DT2)
    !
    IF(DIFF < DZ) DIFF = DNEG*DIFF
    !
    IPRT = Z
    IF(PRESENT(UNIT)) IPRT = UNIT
    !
    IF(IPRT == 5) THEN            !Find the largest unit 
        IF    (DIFF > UNO) THEN
                                   IPRT = 4
        ELSEIF(DIFF > HR2DAY ) THEN        !HR2DAY = 1/24
                                   IPRT = 3
        ELSEIF(DIFF > MIN2DAY) THEN        !MIN2DAY = 1/1440
                                   IPRT = 2
        ELSE
                                   IPRT = 1
        END IF
    END IF
    !
    IF    (IPRT  < ONE .OR. 5 < IPRT) THEN  !Build using all time values. Note IPRT is now TMP variable
                    !
                    IF(DIFF > UNO) THEN
                            !
                            IPRT    = INT(DIFF)
                            DIFF = DIFF - DBLE(IPRT)
                            !
                            WRITE(NUM,'(I14)') IPRT
                            NUM = ADJUSTL(NUM)
                            !
                            IF(IPRT==ONE) THEN
                                PPRINT = TRIM(NUM)//' day, '
                            ELSE
                                PPRINT = TRIM(NUM)//' days, '
                            END IF
                    ELSE
                            PPRINT = ''
                            NUM = BLNK  !Flag to indicate that number has not been written
                    END IF
                    !
                    DIFF = DIFF * DAY2HR  !Now in Hours
                    !
                    IF(DIFF > UNO) THEN
                            !
                            IPRT    = INT(DIFF)
                            DIFF = DIFF - DBLE(IPRT)
                            !
                            WRITE(NUM,'(I14)') IPRT
                            NUM = ADJUSTL(NUM)
                            !
                            IF(IPRT==ONE) THEN
                                PPRINT = PPRINT//TRIM(NUM)//' hour, '
                            ELSE
                                PPRINT = PPRINT//TRIM(NUM)//' hours, '
                            END IF
                            !
                    ELSEIF(NUM .NE. BLNK) THEN
                            PPRINT = PPRINT//TRIM('0')//' hours, '
                    END IF
                    !
                    DIFF = DIFF * 60D0  !Now in minutes
                    !
                    IF(DIFF > UNO) THEN
                            !
                            IPRT    = INT(DIFF)
                            DIFF = DIFF - DBLE(IPRT)
                            !
                            WRITE(NUM,'(I14)') IPRT
                            NUM = ADJUSTL(NUM)
                            !
                            IF(IPRT==ONE) THEN
                                PPRINT = PPRINT//TRIM(NUM)//' minute, '
                            ELSE
                                PPRINT = PPRINT//TRIM(NUM)//' minutes, '
                            END IF
                            !
                    ELSEIF(NUM .NE. BLNK) THEN
                            PPRINT = PPRINT//TRIM('0')//' minutes, '
                    END IF
                    !
                    DIFF = DIFF * 60D0  !Now in seconds
                    !
                    IF(DIFF > UNO .AND. NUM .NE. BLNK ) THEN !>1sec and have written a previous time unit
                            !
                            IPRT    = NINT(DIFF)
                            !
                            WRITE(NUM,'(I14)') IPRT
                            NUM = ADJUSTL(NUM)
                            !
                            IF(IPRT==ONE) THEN
                                PPRINT = PPRINT//TRIM(NUM)//' second'
                            ELSE
                                PPRINT = PPRINT//TRIM(NUM)//' seconds'
                            END IF
                            !
                    ELSEIF(DIFF > 0.0005D0) THEN  !No previous time units written and >1ms
                            !
                            WRITE(NUM,'(F14.3)') DIFF
                            NUM = ADJUSTL(NUM)
                            !
                            PPRINT = PPRINT//TRIM(NUM)//' seconds'
                    ELSE
                            PPRINT = PPRINT//TRIM('0')//' seconds'
                    END IF
                    !
    ELSEIF(IPRT == ONE) THEN
                            DIFF = DIFF*DAY2SEC
                            !
                            IF(DIFF > 10000D0) THEN
                                  WRITE(NUM,'(F15.0)') DIFF
                            ELSE
                                  WRITE(NUM,'(F15.3)') DIFF
                            END IF
                            NUM = ADJUSTL(NUM)
                            !
                            PPRINT = TRIM(NUM)//' seconds'
    ELSEIF(IPRT == TWO) THEN
                            DIFF = DIFF*DAY2MIN
                            !
                            IF(DIFF > 10000D0) THEN
                                  WRITE(NUM,'(F15.0)') DIFF
                            ELSE
                                  WRITE(NUM,'(F15.3)') DIFF
                            END IF
                            WRITE(NUM,'(F15.3)') DIFF
                            NUM = ADJUSTL(NUM)
                            !
                            PPRINT = TRIM(NUM)//' minutes'
    ELSEIF(IPRT ==   3) THEN
                            DIFF = DIFF*DAY2HR
                            !
                            !
                            IF(DIFF > 10000D0) THEN
                                  WRITE(NUM,'(F15.1)') DIFF
                            ELSE
                                  WRITE(NUM,'(F15.5)') DIFF
                            END IF
                            !
                            NUM = ADJUSTL(NUM)
                            PPRINT = TRIM(NUM)//' hours'
    ELSEIF(IPRT ==   4) THEN
                            !
                            IF(DIFF > 10000D0) THEN
                                  WRITE(NUM,'(F15.2)') DIFF
                            ELSE
                                  WRITE(NUM,'(F15.5)') DIFF
                            END IF
                            NUM = ADJUSTL(NUM)
                            PPRINT = TRIM(NUM)//' days'
    END IF
    !
  END FUNCTION
  !
  PURE FUNCTION DATE_OPERATOR_PRETTYPRINT(DT, SEP) RESULT (PPRINT)
    CLASS(DATE_OPERATOR),   INTENT(IN):: DT
    CHARACTER(*), OPTIONAL, INTENT(IN):: SEP  !IF PROVIDED THEN THE CLOCK IS INCLUDED
    CHARACTER(:), ALLOCATABLE:: PPRINT
    CHARACTER(4):: YEAR
    CHARACTER(2):: DAY
    !
    WRITE(YEAR,'(I4.4)') DT%YEAR
    WRITE(DAY, '(I2.2)') DT%DAY
    !
    IF(PRESENT(SEP)) THEN
        PPRINT = MONTHNAME(DT%MONTH,TRUE)//' '//DAY//', '//YEAR//SEP//DATE_OPERATOR_FRAC_TO_TIME(DT)
    ELSE
        PPRINT = MONTHNAME(DT%MONTH,TRUE)//' '//DAY//', '//YEAR
    END IF
    !
  END FUNCTION
  !
  PURE FUNCTION EMPTY_STRING(LN) RESULT(EMPTY)
    CHARACTER(*),      INTENT(IN):: LN
    LOGICAL:: EMPTY
    INTEGER:: I
    !
    EMPTY = TRUE
    DO I=ONE, LEN_TRIM(LN)
        IF(LN(I:I).NE.BLNK .AND. LN(I:I).NE.TAB ) THEN
            EMPTY = FALSE
            EXIT
        END IF
    END DO
    !
  END FUNCTION
  !  
END MODULE
!
!! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
!
! MODULE XY_GRID_COORDINATE_INTERFACE
!  MODULE CREATES A DATA TYPE THAT HOLDES SPACIAL X, Y CARTESIAN COORDINATE INFORMATION. 
!  IT IS MODEL/GRID INDEPENDENT AND JUST REQUIRES AN ORIGIN X,Y POINT, NROW, NCOL, AND THEIR LENGTHS/WIDTHS
!  VERSION 1.2 [10/01/2014] ADDED SUBROUTINE XYCOORD2CELL THAT RETURNS THE CELL FOR A QUIERIED XY COORDINATE
!  VERSION 1.1 [6/01/2014] NEW OPTIONS FOR POINT OF ORIGIN, NEW DEFAULT POINT OF ORIGIN LOCATION [LOWER LEFT CORNER IS (0,0) TO COFORM WITH A NORMAL AXIS], 
!                          ADDED NEW ARRAYS THAT STORE THE MODEL CELL CORNERS X,Y LOCATION,
!                          REMOVED DEPENDENCE ON BAS MODULE GLOBAL
!  VERSION 1.0 [8/14/2013] ORIGINAL VERSION THAT CALCULATES THE X, Y CARTESIAN COORDINATE OF THE AREAL MODEL CELL CENTERS (ROW/COL)
!
MODULE XY_GRID_COORDINATE_INTERFACE
  USE, INTRINSIC:: IEEE_ARITHMETIC, ONLY: IEEE_VALUE,IEEE_QUIET_NAN
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: XY_GRID_COODINATES
  !
  DOUBLE PRECISION,PARAMETER::EPS=1D-5                              !TOLERANCE FOR APPROXIMATING SINE/COSINE TO EXACT VALUE WHEN NEARBY 0, 90, 180, and 270 degrees
  DOUBLE PRECISION,PARAMETER::RAD= 1.74532925199432958D-2           !CONVERSION FACTOR FROM DEGREES TO RADIANS --  3.1415926535897932D0/180D0 = 0.0174532925199432958D0
  DOUBLE PRECISION,PARAMETER::MINBOT = 1D-30                        !USED TO DETERMINE SLOPE OF GRID. IF RUN IS LESS THAN THIS THE VALUE IS USED INSTEAD. PREVENTS DIV/0 ERROR
  DOUBLE PRECISION,PARAMETER::nMINBOT=-1D-30
  !
  TYPE XY_GRID_COODINATES
     INTEGER::NROW,NCOL                                             ! CURRENT MODEL GRID # OF ROWS AND COLUMNS (COPIES OF WHAT IS STORED IN GLOBAL MODULE, THIS PREVENTS ANY LINK TO GLOBAL)
     DOUBLE PRECISION:: ROTDEG, ROTRAD, MAXDEL                      ! ROTDEG=GRID ROTATION IN DEGREES, ROTRAD=IN RADIANS, MAXDEL=LARGEST CELL WIDTH OR LENGTH MAX([DELR(:),DELC(:)]); MAXDEL IS USED TO DETRMINE A MINIMUM RADIUS AROUND A SEARCH POINT FOR LOCATING A REQUESTED XY COORDINATE.
     DOUBLE PRECISION:: SINROT, COSROT, SIN90ROT, COS90ROT          !TRIG FUNCTIONS CALCULATED BASED ON ANGLE
     !DOUBLE PRECISION:: SIN_NROT,COS_NROT                           !
     DOUBLE PRECISION,DIMENSION(:,:)  ,ALLOCATABLE::XCENT,YCENT     ! XCENT(NCOL,NROW)=CELL CENTER X COORDINATE,      YCENT(NCOL,NROW)=CELL CENTER Y COORDINATE 
     DOUBLE PRECISION,DIMENSION(:,:)  ,ALLOCATABLE::XCORN,YCORN     ! XCORN(0:NCOL,0:NROW)= CELL CORNER X COORDINATE, YCORN(0:NCOL,0:NROW)=CELL CORNER X COORDINATE; WHERE XCORN(0,0) IS THE X-COORDINATE OF THE OUTERMOST CORNER [WITH RESPECT TO THE MODEL GRID] OF ROW 1 COL 1 AND XCORN(1,1) IS THE INNER MOST CORNER OF ROW 1 COL 1
     DOUBLE PRECISION,DIMENSION(:,:,:),ALLOCATABLE::GRDSLP          ! GRDSLP(4,NCOL,NROW)=SLOPE OF A LINE DERIVED BY TWO POINTS DEFINED BY XCORN AND YCOR (USED TO IMPROVE SPEED OF CALCULATING AN XY COORDINATE LOCATION WITHIN A MODEL GRID) THE MEANING BEHIND THE FIRST DIMENSION IS GRDSLP(I,:,:) WHERE THE VALUE OF I REPRESENTS A CORNER POINT AS FOLLOWS:   1  4   WHERE GRDSLP(1,:,:)=THE SLOPE BETWEEN PNT 1 AND 2, AND GRDSLP(2,:,:)=THE SLOPE BETWEEN PNT 2 AND 3
     LOGICAL,         DIMENSION(:,:,:),ALLOCATABLE::SIGN            ! SIGN=FOLLOWS SAME STRUCTURE AS GRDSLP AND INDICATES IF THE THIRD POINT IS TO THE LEFT OR RIGHT OF THE SLOPE (SAY FOR PNT 1 AND 2 MAKE A LINE THEN IT IS TRUE WHEN PNT 3 IS TO THE RIGHT AND FALSE WHEN TO THE LEFT OF THAT LINE)                                                              2  3
     !
     CONTAINS
     ! 
     PROCEDURE, PASS(XY):: INIT  => ALLOC_XYCOORD_FROM_INITIAL_POINT!CALL XY%BUILD(Xin,Yin,ROT,LLCOODRINATE,CORNERCOORD,DELR,DELC) TO BUILD XY COORDINATE SYSTEM
     PROCEDURE, PASS(XY):: BUILD => BUILD_XYCOORD_FROM_INITIAL_POINT!CALL XY%BUILD(Xin,Yin,ROT,LLCOODRINATE,CORNERCOORD,DELR,DELC) TO BUILD XY COORDINATE SYSTEM
     PROCEDURE, PASS(XY):: XY2RC => XYCOORD2CELL                    !CALL XY%XY2RC(X,Y,ROW,COL) RECIEVES X AND Y COORDINATE AND RETURNS THE ROW AND COL THAT THE POINT RESIDES IN
     PROCEDURE, PASS(XY):: LOCAL => XYCOORD2LOCALCELLCOORD
     PROCEDURE, PASS(XY):: CENTER_OFFSET => XYCOORD2CENTOFFSET
     PROCEDURE, PASS(XY):: PRINT => PRINT_XY_GRID                   !CALL XY%PRINT(IOUT) PRINTS XCENT,YCENT,XCORN,YCORN TO FILE WITH UNIT # IOUT. 
     PROCEDURE, PASS(XY):: DESTROY => DEALLOCATE_XY_GRID_COODINATES
     FINAL:: FINAL_DEALLOCATE_XY_GRID_COODINATES                    !DEALLOCATE(XY) PROVIDES CLEAN DEALLOCATION OF DATA TYPE XY_GRID_COODINATES
  END TYPE
  !
  INTERFACE XY_GRID_COODINATES
    MODULE PROCEDURE ALLOCATE_XY_DTYPE                              !CONSTRUCTOR FUNCTION THAT RETURNS AN ALLOCATED XY_GRID_COODINATES POINTER. INVOKED AS: XY => XY_GRID_COODINATES(NROW,NCOL)
  END INTERFACE
  !
  CONTAINS
  !
  !################################################################
  !
  FUNCTION ALLOCATE_XY_DTYPE(NROW,NCOL) RESULT(XY)
    TYPE(XY_GRID_COODINATES),POINTER:: XY
    INTEGER,INTENT(IN)::NROW,NCOL
    !
    XY=>NULL()
    ALLOCATE(XY)
    !
    XY%NROW=NROW
    XY%NCOL=NCOL
    !
    ALLOCATE( XY%XCENT(  NCOL,  NROW), XY%YCENT(  NCOL,  NROW) )
    ALLOCATE( XY%XCORN(0:NCOL,0:NROW), XY%YCORN(0:NCOL,0:NROW) )
    !
    ALLOCATE( XY%GRDSLP(4,NCOL,NROW) )
    ALLOCATE( XY%SIGN  (4,NCOL,NROW) )
    !
  END FUNCTION
  !
  SUBROUTINE ALLOC_XYCOORD_FROM_INITIAL_POINT(XY,NROW,NCOL,Xin,Yin,ROT,LLCOODRINATE,CORNERCOORD,DELR,DELC)
    CLASS(XY_GRID_COODINATES),  INTENT(INOUT):: XY
    INTEGER,                    INTENT(IN)::NROW,NCOL
    DOUBLE PRECISION, OPTIONAL, INTENT(IN)::Xin,Yin,ROT                         !Xin=X POINT OF REFERENCE,Yin=Y POINT OF REFERENCE,ROT=ROTATION OF MODEL GRID IN DEGREES
    LOGICAL,          OPTIONAL, INTENT(IN)::LLCOODRINATE,CORNERCOORD            !LLCOODRINATE=TRUE MEANSPOINT OF REFFERENCE IS AT ROW 1 COL NCOL, FALSE MEANS THAT ITS AT ROW 1 COL 1; CORNERCOORD=TRUE MEAND REFERENCE IS ON THE OUTER MOST CORNER, FALSE MEANS THAT IT IS A CELL CENTER
    REAL,DIMENSION(:),OPTIONAL, INTENT(IN)::DELR                                !DEFINED BY BAS/GLOBAL AND REPRESENTS THE MODEL SPACING. THIS CAN NOT BE CALLED FROM USE "GLOBAL, ONLY" BECAUSE IT WOULD CREATE A CIRCULAR DEPENDENCY.
    REAL,DIMENSION(:),OPTIONAL, INTENT(IN)::DELC    
    !
    XY%NROW=NROW
    XY%NCOL=NCOL
    !
    ALLOCATE( XY%XCENT(  NCOL,  NROW), XY%YCENT(  NCOL,  NROW) )
    ALLOCATE( XY%XCORN(0:NCOL,0:NROW), XY%YCORN(0:NCOL,0:NROW) )
    !
    ALLOCATE( XY%GRDSLP(4,NCOL,NROW) )
    ALLOCATE( XY%SIGN  (4,NCOL,NROW) )
    !
    IF(PRESENT(Xin)) THEN
        CALL BUILD_XYCOORD_FROM_INITIAL_POINT(XY,Xin,Yin,ROT,LLCOODRINATE,CORNERCOORD,DELR,DELC)
    END IF
    !
  END SUBROUTINE
  !
  !################################################################
  !
  SUBROUTINE DEALLOCATE_XY_GRID_COODINATES(XY)
    CLASS(XY_GRID_COODINATES),INTENT(INOUT)::XY
    !
    IF(ALLOCATED(XY%XCENT))  DEALLOCATE( XY%XCENT, XY%YCENT )
    IF(ALLOCATED(XY%XCORN))  DEALLOCATE( XY%XCORN, XY%YCORN )
    !
    IF(ALLOCATED(XY%GRDSLP)) DEALLOCATE( XY%GRDSLP )
    IF(ALLOCATED(XY%SIGN)  ) DEALLOCATE( XY%SIGN   )
    !
    END SUBROUTINE
    !
    SUBROUTINE FINAL_DEALLOCATE_XY_GRID_COODINATES(XY)
    TYPE(XY_GRID_COODINATES),INTENT(INOUT)::XY
    !
    IF(ALLOCATED(XY%XCENT))  DEALLOCATE( XY%XCENT, XY%YCENT )
    IF(ALLOCATED(XY%XCORN))  DEALLOCATE( XY%XCORN, XY%YCORN )
    !
    IF(ALLOCATED(XY%GRDSLP)) DEALLOCATE( XY%GRDSLP )
    IF(ALLOCATED(XY%SIGN)  ) DEALLOCATE( XY%SIGN   )
    !
  END SUBROUTINE
  !
  !################################################################
  !      
  SUBROUTINE BUILD_XYCOORD_FROM_INITIAL_POINT(XY,Xin,Yin,ROT,LLCOODRINATE,CORNERCOORD,DELR,DELC)
    !SUBROUTINE TO PROCESS CELL CENTER COORDINATE FOR ENTIRE MODEL
    !NEW FEATURES INCLUDE PROCESSING CELL CORNERS AND CONVERSION OF MAIN ROUTINES TO TYPE-BOUND PROCEDURES FOR INCLUSION IN NEW DATA TYPE XY_GRID_COODINATES
    !CORDINATE SYSTEM IS CARTESIAN WITH A GRID ROTATION THAT STARTS AT 0 DEGREES ALONG THE POSITIVE X-AXIS AND INCREASES COUNTER CLOCWISE (POLAR ANGLE)
    !DEVELOPED BY SCOTT E BOYCE 8/14/2013
    CLASS(XY_GRID_COODINATES):: XY
    DOUBLE PRECISION, INTENT(IN)::Xin,Yin,ROT                         !Xin=X POINT OF REFERENCE,Yin=Y POINT OF REFERENCE,ROT=ROTATION OF MODEL GRID IN DEGREES
    LOGICAL,          INTENT(IN)::LLCOODRINATE,CORNERCOORD            !LLCOODRINATE=TRUE MEANSPOINT OF REFFERENCE IS AT ROW 1 COL NCOL, FALSE MEANS THAT ITS AT ROW 1 COL 1; CORNERCOORD=TRUE MEAND REFERENCE IS ON THE OUTER MOST CORNER, FALSE MEANS THAT IT IS A CELL CENTER
    REAL,DIMENSION(:),INTENT(IN)::DELR                                !DEFINED BY BAS/GLOBAL AND REPRESENTS THE MODEL SPACING. THIS CAN NOT BE CALLED FROM USE "GLOBAL, ONLY" BECAUSE IT WOULD CREATE A CIRCULAR DEPENDENCY.
    REAL,DIMENSION(:),INTENT(IN)::DELC                                !DEFINED BY BAS/GLOBAL AND REPRESENTS THE MODEL SPACING. THIS CAN NOT BE CALLED FROM USE "GLOBAL, ONLY" BECAUSE IT WOULD CREATE A CIRCULAR DEPENDENCY.
    CONTIGUOUS:: DELR, DELC
    DOUBLE PRECISION:: DISTR,DISTC,SINROT,COSROT,SIN90ROT,COS90ROT
    DOUBLE PRECISION:: X,Y,XCOL1,YCOL1                                !X,Y ARE COORD OF ROW 1, COL 1 CELL and XCOL1, YCOL1 HOLDS CELL CENTER COL 1 WHEN PROCESSING A ROW
    !DOUBLE PRECISION,PARAMETER::ANG= 57.295779513082321D0          !CONVERSION FACTOR FROM RADIANS TO DEGREES --  180D0/3.1415926535897932D0
    !DOUBLE PRECISION,DIMENSION(:,:),POINTER,CONTIGUOUS:: XCORD,YCORD,XPCORD,YPCORD
    DOUBLE PRECISION,DIMENSION(4)::XP,YP,SLOPE,RISE,RUNN,SGN
    DOUBLE PRECISION,DIMENSION(XY%NROW)::DC
    DOUBLE PRECISION,DIMENSION(XY%NCOL)::DR
    INTEGER::I,J,K,NROW,NCOL
    !
    NROW=XY%NROW
    NCOL=XY%NCOL
    DR=DBLE(DELR)                                                     !SETTING LOCAL DP NAMES TO GLOBAL DELR AND DELC WHICH ARE RENAMED AS DR AND DC, RESPECTIVELY
    DC=DBLE(DELC)
    !
    XY%ROTDEG=ROT
    XY%ROTRAD=ROT*RAD
    !MX    =>XY%MAXDEL
    !XCORD =>XY%XCENT                                              !SET UP LOCAL POINTERS
    !YCORD =>XY%YCENT
    !XPCORD=>XY%XCORN
    !YPCORD=>XY%YCORN
    !
    IF(ABS(ROT)<EPS .OR. ABS(360D0-ROT)<EPS)THEN                      !TO PREVENT NUMERICAL ERRORS SET OBVIOUS SINE/COSINE VALUES
      SINROT  =0D0
      COSROT  =1D0
      SIN90ROT=-1D0
      COS90ROT=0D0
    ELSEIF(ABS(90D0 -ROT)<EPS)THEN
      SINROT  =1D0
      COSROT  =0D0
      SIN90ROT=0D0
      COS90ROT=1D0
    ELSEIF(ABS(180D0-ROT)<EPS)THEN
      SINROT  =0D0
      COSROT  =-1D0
      SIN90ROT=1D0
      COS90ROT=0D0
    ELSEIF(ABS(270D0-ROT)<EPS)THEN
      SINROT  =-1D0
      COSROT  =0D0
      SIN90ROT=0D0
      COS90ROT=-1D0
    ELSE
      SINROT  =SIN(ROT*RAD)
      COSROT  =COS(ROT*RAD)
      SIN90ROT=SIN((ROT-90D0)*RAD)
      COS90ROT=COS((ROT-90D0)*RAD)
    END IF
    !
    XY%SINROT   = SINROT  
    XY%COSROT   = COSROT  
    XY%SIN90ROT = SIN90ROT
    XY%COS90ROT = COS90ROT
    !XY%SIN_NROT = SIN_NROT
    !XY%COS_NROT = COS_NROT
    !
    IF      (LLCOODRINATE       .AND.       CORNERCOORD) THEN
       !
       DISTC=0.5D0*DC(NROW)                                           !DISTANCE TO CENTER OF ROW NROW AND SIDE OF COL 1
       X=Xin - (DISTC*COS90ROT)                                       !X COORDINATE OF ROW NROW, COL 1
       Y=Yin - (DISTC*SIN90ROT)                                       !Y COORDINATE OF ROW NROW, COL 1
       !
       DISTR=0.5D0*DR(1)                                              !DISTANCE TO CENTER OF ROW NROW, COL 1
       X=X + (DISTR*COSROT)                                           !X COORDINATE OF ROW NROW, COL 1
       Y=Y + (DISTR*SINROT)                                           !Y COORDINATE OF ROW NROW, COL 1
       !
       DISTC=0.5D0*(DC(1)+DC(NROW)) + SUM(DC(2:NROW-1))               !DISTANCE TO ROW 1, COL 1
       X=X - (DISTC*COS90ROT)                                         !X COORDINATE OF ROW 1, COL 1
       Y=Y - (DISTC*SIN90ROT)                                         !Y COORDINATE OF ROW 1, COL 1
       !
    ELSE IF (LLCOODRINATE       .AND. .NOT. CORNERCOORD) THEN
       ! 
       DISTC=0.5D0*(DC(1)+DC(NROW)) + SUM(DC(2:NROW-1))               !DISTANCE TO ROW 1, COL 1
       X=Xin - (DISTC*COS90ROT)                                       !X COORDINATE OF ROW 1, COL 1
       Y=Yin - (DISTC*SIN90ROT)                                       !Y COORDINATE OF ROW 1, COL 1
       !
    ELSE IF (.NOT. LLCOODRINATE .AND.       CORNERCOORD) THEN
       !
       DISTC=0.5D0*DC(NROW)                                           !DISTANCE TO CENTER OF ROW NROW AND SIDE OF COL 1
       X=Xin + (DISTC*COS90ROT)                                       !X COORDINATE OF ROW NROW, COL 1
       Y=Yin + (DISTC*SIN90ROT)                                       !Y COORDINATE OF ROW NROW, COL 1
       !
       DISTR=0.5D0*DR(1)                                              !DISTANCE TO CENTER OF ROW NROW, COL 1
       X=X + (DISTR*COSROT)                                           !X COORDINATE OF ROW NROW, COL 1
       Y=Y + (DISTR*SINROT)                                           !Y COORDINATE OF ROW NROW, COL 1
       !
    ELSE
      X=Xin
      Y=Yin
    END IF
    !IF(LLCOODRINATE) THEN                                             !USING LOWER LEFT CORNER AS CORNER, SO CALCULATE ROW 1, COL 1 COORD
    !   DISTC=0.5D0*(DC(1)+DC(NROW)) + SUM(DC(2:NROW-1))               !DISTANCE TO ROW 1, COL 1
    !   X=Xin - (DISTC*COS90ROT)                                       !X COORDINATE OF ROW 1, COL 1
    !   Y=Yin - (DISTC*SIN90ROT)                                       !Y COORDINATE OF ROW 1, COL 1
    !ELSE
    !  X=Xin
    !  Y=Yin
    !END IF
    !
    XCOL1=X                                                           !STARTING X COORDINATE IS ROW 1, COL 1
    YCOL1=Y                                                           !STARTING Y COORDINATE IS ROW 1, COL 1   
    !
    DISTC=0D0
    DO I=1,NROW
      IF(I>1) THEN                                                    !MOVE DOWN 1 ROW AND PROCESS ALL COLUMNS
        DISTC=DISTC + 0.5D0*(DC(I-1)+DC(I))                           !DISTANCE TO NEXT ROW
        XCOL1=X + (DISTC*COS90ROT)                                    !NEXT ROW'S COLUMN 1's X COORDINATE
        YCOL1=Y + (DISTC*SIN90ROT)                                    !NEXT ROW'S COLUMN 1's Y COORDINATE
      END IF
      DISTR=0D0
      XY%XCENT (1,I)=XCOL1
      XY%YCENT (1,I)=YCOL1
      DO J=2,NCOL
        DISTR=DISTR + 0.5D0*(DR(J-1)+DR(J))
        XY%XCENT (J,I)=XCOL1 + (DISTR*COSROT)
        XY%YCENT (J,I)=YCOL1 + (DISTR*SINROT)
      END DO
    END DO
    !
    !BUILD CORNER POINT ARRAYS
    DO I=1,NROW                                                       !SOLVES FOR UPPER LEFT CORNER FOR EVERY CELL
       DISTC=0.5D0*DC(I)
    DO J=1,NCOL
       DISTR=0.5D0*DR(J)
       XY%XCORN(J-1,I-1)=XY%XCENT(J,I)-(DISTC*COS90ROT)-(DISTR*COSROT)
       XY%YCORN(J-1,I-1)=XY%YCENT(J,I)-(DISTC*SIN90ROT)-(DISTR*SINROT)
      END DO    
    END DO
    !
    I=NROW                                                            !SOLVE FOR THE BOTTOM LEFT CORNER OF THE LAST ROW
    DISTC=0.5D0*DC(I)
    DO J=1,NCOL
       DISTR=0.5D0*DR(J)
       XY%XCORN(J-1,I)=XY%XCENT(J,I)+(DISTC*COS90ROT) - (DISTR*COSROT)
       XY%YCORN(J-1,I)=XY%YCENT(J,I)+(DISTC*SIN90ROT) - (DISTR*SINROT)
    END DO
    !
    J=NCOL                                                            !SOLVE FOR THE UPPER RIGHT OF THE LAST COLUMN
    DISTR=0.5D0*DR(J)
    DO I=1,NROW
       DISTC=0.5D0*DC(I)
       XY%XCORN(J,I-1)=XY%XCENT(J,I)-(DISTC*COS90ROT) + (DISTR*COSROT)
       XY%YCORN(J,I-1)=XY%YCENT(J,I)-(DISTC*SIN90ROT) + (DISTR*SINROT)
    END DO
    !
    I=NROW                                                            !SOLVE FOR BOTTOM RIGHT CORNER OF MODEL
    J=NCOL
    XY%XCORN(J,I)=XY%XCENT(J,I) + (DISTC*COS90ROT) + (DISTR*COSROT)   !NOTE DISTR WAS SOLVED BEFORE AT I=NROW
    XY%YCORN(J,I)=XY%YCENT(J,I) + (DISTC*SIN90ROT) + (DISTR*SINROT)       
    !
    XY%MAXDEL=MAX(MAXVAL(DR),MAXVAL(DC))
    !
    !SET UP LOGICAL ARRAY REQUIRED TO DETERMINE A POINT LOCATION IN THE GRID
    DO I=1, NROW
    DO J=1, NCOL
        XP(1) = XY%XCORN(J-1,I-1)
        XP(2) = XY%XCORN(J-1,I  )
        XP(3) = XY%XCORN(J  ,I  )
        XP(4) = XY%XCORN(J  ,I-1)
        YP(1) = XY%YCORN(J-1,I-1)
        YP(2) = XY%YCORN(J-1,I  )
        YP(3) = XY%YCORN(J  ,I  )
        YP(4) = XY%YCORN(J  ,I-1)
        !
        RISE(1)=(YP(2)-YP(1))
        RISE(2)=(YP(3)-YP(2))
        RISE(3)=(YP(4)-YP(3))
        RISE(4)=(YP(1)-YP(4))
        !
        RUNN(1)=(XP(2)-XP(1))
        RUNN(2)=(XP(3)-XP(2))
        RUNN(3)=(XP(4)-XP(3))
        RUNN(4)=(XP(1)-XP(4))
        !
        DO CONCURRENT(K=1:4)
            IF(nMINBOT < RISE(K) .AND. RISE(K) < MINBOT) THEN
                SLOPE(K) = 0D0
            ELSEIF(nMINBOT < RUNN(K) .AND. RUNN(K) < MINBOT) THEN
                SLOPE(K) = 1D100 !ASSUM INF
            ELSE
                SLOPE(K) = RISE(K)/RUNN(K)
            END IF
        END DO
        !
        XY%GRDSLP(:,J,I)=SLOPE
        !
        SGN(1) = YP(3) - YP(1) - SLOPE(1)*( XP(3)-XP(1) )
        SGN(2) = YP(4) - YP(2) - SLOPE(2)*( XP(4)-XP(2) )
        SGN(3) = YP(1) - YP(3) - SLOPE(3)*( XP(1)-XP(3) )
        SGN(4) = YP(2) - YP(4) - SLOPE(4)*( XP(2)-XP(4) )
        !
        XY%SIGN(:,J,I) = (SGN.GE.0D0)
        !
    END DO
    END DO
    !
    !NULLIFY( XCORD, YCORD, XPCORD, YPCORD, MX )
    !DEALLOCATE(DR,DC)
    !
  END SUBROUTINE
  !
  !################################################################
  !
  ELEMENTAL SUBROUTINE XYCOORD2CELL(XY,X,Y,ROW,COL)                 !RETURN THE ROW AND COL OF THE COORDINATE SPECIFIED IN X AND Y
    CLASS (XY_GRID_COODINATES),INTENT(IN):: XY
    DOUBLE PRECISION,          INTENT(IN )::X,Y                        ! X AND Y COORDINATE TO LOOK UP AND RETURN ROW AND COL
    INTEGER,                   INTENT(OUT):: ROW,COL
    !
    DOUBLE PRECISION::XX,YY, DELX, DELY
    DOUBLE PRECISION,DIMENSION(4)::XP,YP,SLOPE
    LOGICAL,DIMENSION(4):: SIGN
    INTEGER::NROW,NCOL
    !
    NROW=XY%NROW
    NCOL=XY%NCOL
    !
    ROW=0
    COL=0
    !
    CALL XY_FIND_CELL(XY,X,Y,ROW,COL,NROW,NCOL,XP,YP,SLOPE,SIGN)
    !
    IF(ROW==0) THEN
        IF(ABS(X) > 1D-20) THEN
            DELX = X*1D-10
        ELSE
            DELX = 1D-20
        END IF
        !
        XX = X + DELX
        YY = Y
        CALL XY_FIND_CELL(XY,XX,YY,ROW,COL,NROW,NCOL,XP,YP,SLOPE,SIGN)
    END IF
    !
    IF(ROW==0) THEN
        IF(ABS(Y) > 1D-20) THEN
            DELY = Y*1D-10
        ELSE
            DELY = 1D-20
        END IF
        !
        XX = X
        YY = Y + DELY
        CALL XY_FIND_CELL(XY,XX,YY,ROW,COL,NROW,NCOL,XP,YP,SLOPE,SIGN)
    END IF
    !
    IF(ROW==0) THEN
        XX = X - DELX
        YY = Y
        CALL XY_FIND_CELL(XY,XX,YY,ROW,COL,NROW,NCOL,XP,YP,SLOPE,SIGN)
    END IF
    !
    IF(ROW==0) THEN
        XX = X
        YY = Y - DELY
        CALL XY_FIND_CELL(XY,XX,YY,ROW,COL,NROW,NCOL,XP,YP,SLOPE,SIGN)
    END IF
    !
    IF(ROW==0) THEN
        XX = X + DELX
        YY = Y + DELY
        CALL XY_FIND_CELL(XY,XX,YY,ROW,COL,NROW,NCOL,XP,YP,SLOPE,SIGN)
    END IF
    !
    IF(ROW==0) THEN
        XX = X - DELX
        YY = Y - DELY
        CALL XY_FIND_CELL(XY,XX,YY,ROW,COL,NROW,NCOL,XP,YP,SLOPE,SIGN)
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE XY_FIND_CELL(XY,X,Y,ROW,COL,NROW,NCOL,XP,YP,SLOPE,SIGN)
    CLASS (XY_GRID_COODINATES),INTENT(IN  ):: XY
    DOUBLE PRECISION,         INTENT(IN   ):: X,Y                        ! X AND Y COORDINATE TO LOOK UP AND RETURN ROW AND COL
    INTEGER,                  INTENT(INOUT):: ROW,COL
    INTEGER,                  INTENT(IN   ):: NROW,NCOL
    !
    DOUBLE PRECISION,DIMENSION(4),INTENT(INOUT)::XP,YP,SLOPE
    LOGICAL,         DIMENSION(4),INTENT(INOUT):: SIGN
    DOUBLE PRECISION::XC,YC,XMIN,XMAX,YMIN,YMAX,MXDEL
    INTEGER:: I, J
    !
    MXDEL = XY%MAXDEL * 5D0
    XMIN=X - MXDEL                                 !DROP ANY POINTS THAT ARE FARTHER THAN 5 TIMES THE MAX DISTANCE
    XMAX=X + MXDEL
    YMIN=Y - MXDEL
    YMAX=Y + MXDEL
    !
    LP:DO I=1, NROW
       DO J=1, NCOL
        XC=XY%XCENT(J,I)
        YC=XY%YCENT(J,I)
        IF(XC<XMIN.OR.XC>XMAX.OR.YC<YMIN.OR.YC>YMAX) CYCLE
        XP(1) = XY%XCORN(J-1,I-1)
        XP(2) = XY%XCORN(J-1,I  )
        XP(3) = XY%XCORN(J  ,I  )
        XP(4) = XY%XCORN(J  ,I-1)
        YP(1) = XY%YCORN(J-1,I-1)
        YP(2) = XY%YCORN(J-1,I  )
        YP(3) = XY%YCORN(J  ,I  )
        YP(4) = XY%YCORN(J  ,I-1)
        !
        SLOPE = XY%GRDSLP(:,J,I)
        !
        SIGN = ( Y-YP-SLOPE*(X-XP) ) >= 0D0
    
        !SIGN(1) = Y - YP(1) - SLOPE*( X - XP(1) )
        !SIGN(2) = Y - YP(2) - SLOPE*( X - XP(2) )
        !SIGN(3) = Y - YP(3) - SLOPE*( X - XP(3) )
        !SIGN(4) = Y - YP(4) - SLOPE*( X - XP(4) )
        !
        IF (ALL(  SIGN .EQV. XY%SIGN(:,J,I) )) THEN
            ROW=I
            COL=J
            EXIT LP
        END IF
       END DO
       END DO LP
  END SUBROUTINE
  !
  !################################################################
  !
  ELEMENTAL PURE SUBROUTINE XYCOORD2LOCALCELLCOORD(XY,X,Y,XL,YL,ROW,COL)   !RETURN THE ROW AND COL OF THE COORDINATE SPECIFIED IN X AND Y
    CLASS (XY_GRID_COODINATES),INTENT(IN):: XY
    DOUBLE PRECISION,          INTENT(IN ):: X, Y                     ! X AND Y COORDINATE TO LOOK UP AND RETURN LOCAL COORDINATE FOR CELL THAT CONTAINS X, Y
    DOUBLE PRECISION,          INTENT(OUT):: XL, YL
    INTEGER, OPTIONAL,         INTENT(IN ):: ROW,COL
    !
    DOUBLE PRECISION::XC,YC
    INTEGER:: I,J
    !
    IF(PRESENT(ROW)) THEN
         I = ROW
         J = COL
    ELSE
        CALL XYCOORD2CELL(XY,X,Y,I,J)
    END IF
    !
    IF (I==0 .OR. J==0) THEN
        XL = IEEE_VALUE(XL, IEEE_QUIET_NAN)
        YL = XL
    ELSE
       !
       XC = X - XY%XCENT(J,I)
       YC = Y - XY%YCENT(J,I)
       !
       !XL = XC * XY%COS_NROT  -   YC * XY%SIN_NROT             !NORMAL ROTATION IS FOR COUNTER-CLOCKWISE, BUT WANT TO ROTATE BACKWARDS, SO MOVE IN COCKWISE DIRECTION
       !                                                        !INSTEAD OF USING NORMAL ROTATION MATRIX, USE NEGATIVE VERSION
       !YL = XC * XY%SIN_NROT  +   YC * XY%COS_NROT
       !   
       XL = XC * XY%COSROT  +  YC * XY%SINROT                   !R(-THETA) from https://en.wikipedia.org/wiki/Rotation_matrix#In_two_dimensions
       !
       YL = YC * XY%COSROT  -  XC * XY%SINROT
       !
    END IF
    !
  END SUBROUTINE
  !
  !################################################################
  !
  ELEMENTAL PURE SUBROUTINE XYCOORD2CENTOFFSET(XY,X,Y,XL,YL,ROW,COL)   !RETURN THE ROW AND COL OF THE COORDINATE SPECIFIED IN X AND Y
    CLASS (XY_GRID_COODINATES),INTENT(IN):: XY
    DOUBLE PRECISION,          INTENT(IN ):: X, Y                     ! X AND Y COORDINATE TO LOOK UP AND RETURN LOCAL COORDINATE FOR CELL THAT CONTAINS X, Y
    DOUBLE PRECISION,          INTENT(OUT):: XL, YL
    INTEGER, OPTIONAL,         INTENT(IN ):: ROW,COL
    !
    DOUBLE PRECISION::XC,YC,DX,DY
    INTEGER:: I,J
    !
    IF(PRESENT(ROW)) THEN
         I = ROW
         J = COL
    ELSE
        CALL XYCOORD2CELL(XY,X,Y,I,J)
    END IF
    !
    IF (I==0 .OR. J==0) THEN
        XL = IEEE_VALUE(XL, IEEE_QUIET_NAN)
        YL = XL
    ELSE
       !
       DX = ABS(XY%XCORN(J-1,I) - XY%XCORN(J,I))
       DY = ABS(XY%YCORN(J,I-1) - XY%YCORN(J,I))
       !
       XC = X - XY%XCENT(J,I)
       YC = Y - XY%YCENT(J,I)
       !
       XL = XC * XY%COSROT  +  YC * XY%SINROT                   !R(-THETA) from https://en.wikipedia.org/wiki/Rotation_matrix#In_two_dimensions
       YL = YC * XY%COSROT  -  XC * XY%SINROT
       !
       XL =        XL  / DX
       YL = (-1D0* YL) / DY
       !
    END IF
    !
  END SUBROUTINE
  !
  !################################################################
  !
  SUBROUTINE PRINT_XY_GRID(XY,IOUT)
          !PRINT OUR GRID IF REQUESTED
    CLASS (XY_GRID_COODINATES):: XY
    INTEGER,INTENT(IN)::IOUT
    INTEGER::I
    CHARACTER(8):: NUM
    
    WRITE(NUM,'(F8.4)') XY%ROTDEG
    WRITE(IOUT,'(/,/ 4A,/,3A)')'X, Y CELL CENTER COORDINATES ',       &
         'WITH ROTATION = ',TRIM(ADJUSTL(NUM)), '',                  &
         'CORDINATE SYSTEM IS CARTESIAN WITH A GRID ROTATION THAT ',  &
         'STARTS AT 0 ALONG THE POSITIVE X-AXIS AND INCREASES ',     &
         'COUNTER CLOCKWISE (POLAR ANGLE)'
    WRITE(IOUT,'(/A)')'X-COORDINATES'
    DO I=1,XY%NROW
      WRITE(IOUT,'(*(G20.10))') XY%XCENT(:,I)
    END DO
    !
    WRITE(IOUT,'(/A)')'Y-COORDINATES'
    DO I=1,XY%NROW
      WRITE(IOUT,'(*(G20.10))') XY%YCENT(:,I)
    END DO
    !
    !
    WRITE(IOUT,'(/,/ 2A)')'X, Y COORDINATES OF THE MODEL CELL ','CORNERS.'
    WRITE(IOUT,'(/A)')'X-COORDINATES'
    DO I=0,XY%NROW
      WRITE(IOUT,'(*(G20.10))') XY%XCORN(:,I)
    END DO
    !
    WRITE(IOUT,'(/A)')'Y-COORDINATES'
    DO I=0,XY%NROW
      WRITE(IOUT,'(*(G20.10))') XY%YCORN(:,I)
    END DO
    !
  END SUBROUTINE
  !
  !################################################################
  !
END MODULE XY_GRID_COORDINATE_INTERFACE
!!
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
MODULE OBS_GROUP_INTERPOLATOR  !Mimcs Hob interpoation
    !
    USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: DBL => REAL64
    USE CONSTANTS
    USE DATE_OPERATOR_INSTRUCTION,    ONLY: DATE_OPERATOR
    USE XY_GRID_COORDINATE_INTERFACE, ONLY: XY_GRID_COODINATES
    IMPLICIT NONE
    PRIVATE
    PUBLIC:: OBS_POINTS, OBS_POINT
    !
    REAL(DBL), PARAMETER:: OFF_TOL = 0.0001_dbl
    !
    TYPE OBS_POINT
        CHARACTER(:),ALLOCATABLE:: NAM
        DOUBLE PRECISION:: X, Y
        DOUBLE PRECISION:: ROFF,COFF
        DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE:: RINT
        INTEGER:: LAY, ROW, COL, ID
        INTEGER:: I1, J1, IOFF, JOFF !I1,J1 ARE ADJACENT, IOFF/JOFF are off diagonal cell
        LOGICAL:: XY_INTERP
        LOGICAL:: DO_INTERP = FALSE
        LOGICAL:: ALL_TIME
        LOGICAL:: IB_ROW=FALSE, IB_COL=FALSE, IB_OFF=FALSE
        DOUBLE PRECISION:: SIM
        !DOUBLE PRECISION:: OBS
        !TYPE(DATE_OPERATOR):: DT
        !
        CONTAINS
        ! 
        PROCEDURE, PASS(OP):: INIT  => INITALIZE_OBS_POINT!(XY,NAM,X,Y,LAY,NLAY,XY_INTERP,NCHAR,ROW,COL)
        PROCEDURE, PASS(OP):: BASIS_BUILDER!(NROW,NCOL,NLAY,IBOUND,DELC,DELR)
        GENERIC::             INTERP => INTERP_3D,INTERP_2D,INTERP_1D
        PROCEDURE, PASS(OP):: INTERP_SUB!(NROW,NCOL,NDIM,SIM)
        PROCEDURE, PASS(OP):: DESTROY_OBS_POINT
        !
        PROCEDURE, PASS(OP), PRIVATE:: INTERP_3D!(NROW,NCOL,NLAY,SIM) 
        PROCEDURE, PASS(OP), PRIVATE:: INTERP_2D!(NROW,NCOL,SIM) 
        PROCEDURE, PASS(OP), PRIVATE:: INTERP_1D!(IDX,SIM)
        FINAL:: FINAL_OBS_POINT
    END TYPE
    !
    TYPE OBS_POINTS
        !
        INTEGER:: N   = Z
        INTEGER:: DIM = Z
        !
        TYPE(OBS_POINT),DIMENSION(:),ALLOCATABLE:: OP
        !
        CONTAINS
        ! 
        PROCEDURE, PASS(OBS):: INIT    => INITALIZE_OBS_POINTS!(NPOINT)
        PROCEDURE, PASS(OBS):: DESTROY => DESTROY_OBS_POINTS
        FINAL:: FINAL_OBS_POINTS
    END TYPE
  !
  CONTAINS
  !
  SUBROUTINE FINAL_OBS_POINTS(OBS)
    TYPE(OBS_POINTS), INTENT(INOUT):: OBS
    !
    CALL DESTROY_OBS_POINTS(OBS)
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE DESTROY_OBS_POINTS(OBS)
    CLASS(OBS_POINTS), INTENT(INOUT):: OBS
    !
    IF(ALLOCATED(OBS%OP)) DEALLOCATE(OBS%OP)
    !
    OBS%N   = Z
    OBS%DIM = Z
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE INITALIZE_OBS_POINTS(OBS,NPOINT)
    CLASS(OBS_POINTS), INTENT(INOUT):: OBS
    INTEGER,           INTENT(IN   ):: NPOINT
    !
    IF(NPOINT > Z) THEN
       !
       OBS%N   = NPOINT
       !
       IF(OBS%DIM == Z) THEN
           OBS%DIM = NPOINT
           ALLOCATE(OBS%OP(NPOINT))
       ELSEIF(OBS%DIM < NPOINT) THEN
           OBS%DIM = NPOINT
           DEALLOCATE(OBS%OP)
           ALLOCATE(OBS%OP(NPOINT))
       END IF
    ELSE
       OBS%N   = Z
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE FINAL_OBS_POINT(OP)
    TYPE(OBS_POINT), INTENT(INOUT):: OP
    !
    CALL DESTROY_OBS_POINT(OP)
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE DESTROY_OBS_POINT(OP)
    CLASS(OBS_POINT), INTENT(INOUT):: OP
    !
    IF(ALLOCATED(OP%NAM )) DEALLOCATE(OP%NAM)
    IF(ALLOCATED(OP%RINT)) DEALLOCATE(OP%RINT)
    !
    OP%ROW = Z
    OP%COL = Z
    OP%ID  = Z
    OP%IB_ROW=FALSE
    OP%IB_COL=FALSE
    OP%IB_OFF=FALSE
    OP%DO_INTERP = FALSE
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE INITALIZE_OBS_POINT(OP,XY,NAM,X,Y,LAY,XY_INTERP,NCHAR,ROW,COL,ID)
    CLASS(OBS_POINT),                       INTENT(INOUT):: OP
    TYPE(XY_GRID_COODINATES),               INTENT(IN   ):: XY  !MODEL COORDINATES
    CHARACTER(*),                           INTENT(IN   ):: NAM
    DOUBLE PRECISION,                       INTENT(IN   ):: X,Y
    INTEGER,                                INTENT(IN   ):: LAY
    LOGICAL,                                INTENT(IN   ):: XY_INTERP
    INTEGER, OPTIONAL,                      INTENT(IN   ):: ID, NCHAR, ROW, COL
    !
    IF(ALLOCATED(OP%NAM)) DEALLOCATE(OP%NAM)
    IF(PRESENT(NCHAR)) THEN
        IF(NCHAR > Z) THEN
            ALLOCATE(CHARACTER(NCHAR):: OP%NAM)
            OP%NAM = NAM
        END IF
    ELSE
        ALLOCATE(OP%NAM, SOURCE = NAM)
    END IF
    !
    OP%X = X
    OP%Y = Y
    OP%LAY = LAY
    OP%XY_INTERP=XY_INTERP
    OP%DO_INTERP = FALSE
    !
    IF(PRESENT(ID)) THEN
        OP%ID = ID
    ELSE
        OP%ID = Z
    END IF
    !
    IF(PRESENT(ROW)) THEN
        OP%ROW = ROW
        OP%COL = COL
    ELSE
        CALL XY%XY2RC(X,Y,OP%ROW,OP%COL)
    END IF
    !
    IF(OP%ROW > Z) THEN
      !
      IF(XY_INTERP) THEN
          CALL XY%CENTER_OFFSET(X,Y,OP%COFF,OP%ROFF,OP%ROW,OP%COL)  !GET ROFF AND COFF AND ROW/COL
          ALLOCATE(OP%RINT(FOUR))
      ELSE
          OP%ROFF = DZ
          OP%COFF = DZ
      END IF
      !
      ASSOCIATE(I=>OP%ROW, J=>OP%COL, K=>OP%LAY,                      &
                I1=>OP%I1, J1=>OP%J1, IOFF=>OP%IOFF, JOFF=>OP%JOFF,  &
                ROFF=>OP%ROFF, COFF=>OP%COFF,                          &
                IB_ROW=>OP%IB_ROW, IB_COL=>OP%IB_COL, IB_OFF=>OP%IB_OFF)
                !
          IF (ROFF.LT.DZ) THEN
              I1   = I - ONE
              IOFF = NEG
          ELSE
              I1   = I + ONE
              IOFF = ONE
          ENDIF
          IF (COFF.LT.DZ) THEN
              J1 = J - 1
              JOFF = NEG
          ELSE
              J1   = J + ONE
              JOFF = ONE
          ENDIF
          !
          IB_ROW = FALSE
          IB_COL = FALSE
          IB_OFF = FALSE
          !
          OP%DO_INTERP = FALSE
      END ASSOCIATE
    ELSE
      CALL DESTROY_OBS_POINT(OP)  !FAILED TO FIND POINT!!!
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE BASIS_BUILDER(OP,NROW,NCOL,NLAY,IBOUND,DELC,DELR,HCHK,BOTM,LBOTM,LAYHDT)
    CLASS(OBS_POINT),                     INTENT(INOUT):: OP
    INTEGER,                              INTENT(IN   ):: NROW,NCOL,NLAY
    INTEGER,   DIMENSION(NCOL,NROW,NLAY), INTENT(IN   ):: IBOUND
    REAL,      DIMENSION(NCOL),           INTENT(IN   ):: DELR
    REAL,      DIMENSION(NROW),           INTENT(IN   ):: DELC
    !
    DOUBLE PRECISION, DIMENSION(NCOL,NROW,NLAY),     OPTIONAL, INTENT(IN):: HCHK  !IF PRESENT THEN INCLUDES HNEW<BOTM CHECK
    DOUBLE PRECISION, DIMENSION(:,:,0:), CONTIGUOUS, OPTIONAL, INTENT(IN):: BOTM
    INTEGER, DIMENSION(NLAY),                        OPTIONAL, INTENT(IN):: LBOTM, LAYHDT
    LOGICAL:: UPDATE
    !
    IF(OP%XY_INTERP .AND. OP%ROW > Z) THEN
       ASSOCIATE(I=>OP%ROW, J=>OP%COL, K=>OP%LAY,                      &
                 I1=>OP%I1, J1=>OP%J1, IOFF=>OP%IOFF, JOFF=>OP%JOFF,  &
                 ROFF=>OP%ROFF, COFF=>OP%COFF,                          &
                 IB_ROW=>OP%IB_ROW, IB_COL=>OP%IB_COL, IB_OFF=>OP%IB_OFF)
                 !
         UPDATE = FALSE
         !
         !----- IBOUND CHK -------------------------------------------------
         IF (I1.GE.ONE .AND. I1.LE.NROW) THEN
             !
             IF(IB_ROW .NEQV. IBOUND(J,I1,K).NE.Z) THEN
                 IB_ROW   =   IBOUND(J,I1,K).NE.Z
                 UPDATE   = TRUE
             END IF
         END IF
         !
         IF (J1.GE.ONE .AND. J1.LE.NCOL) THEN
             !
             IF(IB_COL .NEQV. IBOUND(J1,I,K).NE.Z) THEN
                 IB_COL   =   IBOUND(J1,I,K).NE.Z
                 UPDATE   = TRUE
             END IF
         END IF
         !
         IF (I1.GE.ONE .AND. I1.LE.NROW .AND. J1.GE.1 .AND. J1.LE.NCOL) THEN
             !
             IF(IB_OFF .NEQV. IBOUND(J1,I1,K).NE.Z) THEN
                 IB_OFF   =   IBOUND(J1,I1,K).NE.Z
                 UPDATE   = TRUE
             END IF
         END IF
         !
         !----- HCKH -------------------------------------------------
         IF(PRESENT(HCHK)) THEN
            !
           IF(LAYHDT(K).NE.Z) THEN  
            IF (IB_ROW .AND. I1.GE.ONE .AND. I1.LE.NROW) THEN
                !
                IF(IB_ROW .NEQV. HCHK(J,I1,K) > BOTM(J,I1,LBOTM(K))) THEN
                    IB_ROW   =   HCHK(J,I1,K) > BOTM(J,I1,LBOTM(K))
                    UPDATE   = TRUE
                END IF
            END IF
            !
            IF (IB_COL .AND. J1.GE.ONE .AND. J1.LE.NCOL) THEN
                !
                IF(IB_COL .NEQV. HCHK(J1,I,K) > BOTM(J1,I,LBOTM(K))) THEN
                    IB_COL   =   HCHK(J1,I,K) > BOTM(J1,I,LBOTM(K))
                    UPDATE   = TRUE
                END IF
            END IF
            !
            IF (IB_OFF .AND. I1.GE.ONE .AND. I1.LE.NROW .AND. J1.GE.1 .AND. J1.LE.NCOL) THEN
                !
                IF(IB_OFF .NEQV. HCHK(J1,I1,K) > BOTM(J1,I1,LBOTM(K))) THEN
                    IB_OFF   =   HCHK(J1,I1,K) > BOTM(J1,I1,LBOTM(K))
                    UPDATE   = TRUE
                END IF
            END IF
           END IF !( LAYHDT(K).NE.Z ) 
         END IF   !( PRESENT(HCHK)  ) 
         !----- END CHECKS -------------------------------------------------
         !
         IF (I1.LT.1 .OR. I1.GT.NROW) IB_ROW = FALSE
         IF (J1.LT.1 .OR. J1.GT.NCOL) IB_COL = FALSE
         IF (I1.LT.1 .OR. I1.GT.NROW .OR. J1.LT.1 .OR. J1.GT.NCOL) IB_OFF = FALSE
         !
         IF(UPDATE) THEN
           IF (     (ABS(ROFF) < OFF_TOL .AND. ABS(COFF) < OFF_TOL)  &
               .OR. (ABS(ROFF) < OFF_TOL .AND. .NOT. IB_ROW)       &
               .OR. (ABS(COFF) < OFF_TOL .AND. .NOT. IB_COL)       &
               .OR. (.NOT. IB_ROW      .AND. .NOT. IB_COL)        ) THEN
               ! 
               OP%DO_INTERP = FALSE
               IOFF = Z
               JOFF = Z
               OP%RINT(1) = FOURTH
               OP%RINT(2) = FOURTH
               OP%RINT(3) = FOURTH
               OP%RINT(4) = FOURTH
           ELSE
               OP%DO_INTERP = TRUE
           ENDIF
           !       
           IF (OP%DO_INTERP) THEN
               !
               IF (ROFF.LT.DZ) THEN
                   I1   = I - ONE
                   IOFF = NEG
               ELSE
                   I1   = I + ONE
                   IOFF = ONE
               ENDIF
               IF (COFF.LT.DZ) THEN
                   J1 = J - 1
                   JOFF = NEG
               ELSE
                   J1   = J + ONE
                   JOFF = ONE
               ENDIF
               !
               CALL BASIS_COEFFIENT_BUILDER(OP,NROW,NCOL,NLAY,IBOUND,DELC,DELR)
           END IF
           !
         END IF
         !
       END ASSOCIATE
    END IF     
  END SUBROUTINE 
  !
  PURE SUBROUTINE BASIS_COEFFIENT_BUILDER(OP,NROW,NCOL,NLAY,IBOUND,DELC,DELR)
    CLASS(OBS_POINT),                     INTENT(INOUT):: OP
    INTEGER,                              INTENT(IN   ):: NROW,NCOL,NLAY
    INTEGER,   DIMENSION(NCOL,NROW,NLAY), INTENT(IN   ):: IBOUND
    REAL,      DIMENSION(NCOL),           INTENT(IN   ):: DELR
    REAL,      DIMENSION(NROW),           INTENT(IN   ):: DELC
    DOUBLE PRECISION:: A, DC, DCF, DR, DRF, ROFF_A, COFF_A
    !
    IF( OP%ROW > Z ) THEN
      ASSOCIATE(I=>OP%ROW, J=>OP%COL, K=>OP%LAY,                      &
              I1=>OP%I1, J1=>OP%J1, IOFF=>OP%IOFF, JOFF=>OP%JOFF,   &
              ROFF=>OP%ROFF, COFF=>OP%COFF,         RINT=>OP%RINT,  &
              IB_ROW=>OP%IB_ROW, IB_COL=>OP%IB_COL, IB_OFF=>OP%IB_OFF)
              !
        ROFF_A = ABS(ROFF)
        COFF_A = ABS(COFF)
        !
        DRF = DZ
        DCF = DZ
        IF (ROFF_A > OFF_TOL) DCF = ROFF_A*DELC(I)
        IF (COFF_A > OFF_TOL) DRF = COFF_A*DELR(J)
        !
        IF (IB_ROW) THEN
                      DC = (DELC(I)+DELC(I1)) * HALF
        ELSE
                      DC = DELC(I) * HALF
        END IF
        IF (IB_COL) THEN
                      DR = (DELR(J)+DELR(J1)) * HALF
        ELSE
                      DR = DELR(J) * HALF
        END IF
        !
        IF (ROFF_A > OFF_TOL .AND. COFF_A > OFF_TOL) THEN
            A = UNO/(DC*DR)
        ELSE
            A = DZ
        END IF
        !
        !!!IF (ROFF_A > OFF_TOL) THEN
        !!!                        DC = (DELC(I)+DELC(I1)) * HALF
        !!!                        DCF = ROFF_A*DELC(I)
        !!!ENDIF
        !!!IF (COFF_A > OFF_TOL) THEN
        !!!                        DR = (DELR(J)+DELR(J1)) * HALF
        !!!                        DRF = COFF_A*DELR(J)
        !!!ENDIF
        !
        IF (ROFF_A > OFF_TOL .AND. COFF_A > OFF_TOL) THEN
            A = UNO/(DC*DR)
        ELSE
            A = DZ
        END IF
        ! 
        ! LINEAR INTERPOLATION
        IF (ROFF_A < OFF_TOL .OR. (.NOT. IB_ROW .AND. .NOT. IB_OFF)) THEN
            !
            IOFF = 0
            RINT(1) = 0.5*(1.-DRF/DR)
            RINT(2) = 0.5*DRF/DR
            RINT(3) = RINT(1)
            RINT(4) = RINT(2)
            !
        ELSEIF (COFF_A < OFF_TOL .OR. (.NOT. IB_COL .AND. .NOT. IB_OFF)) THEN
            !
            JOFF = 0
            RINT(1) = 0.5*(1.-DCF/DC)
            RINT(2) = RINT(1)
            RINT(3) = 0.5*DCF/DC
            RINT(4) = RINT(3)
            !
        ! CALCULATE BASIS FUNCTIONS FOR INTERPOLATION ON A RECTANGLE
        ELSEIF (IB_ROW .AND. IB_COL .AND. IB_OFF) THEN
            !
            RINT(3) = A*(DR-DRF)*DCF
            RINT(4) = A*DRF*DCF
            RINT(2) = A*DRF*(DC-DCF)
            RINT(1) = A*(DR-DRF)*(DC-DCF)
            ! 
        ! CALCULATE BASIS FUNCTIONS FOR INTERPOLATION ON A TRIANGLE
        ELSEIF (.NOT. IB_COL) THEN
            !
            RINT(1) = A*(DR*DC-DR*DCF)
            RINT(2) = 0.0
            RINT(3) = A*(DR*DCF-DC*DRF)
            RINT(4) = A*(DC*DRF)
            !
        ELSEIF (.NOT. IB_ROW) THEN
            !
            RINT(1) = A*(DR*DC-DC*DRF)
            RINT(4) = A*(DR*DCF)
            RINT(2) = A*(DC*DRF-DR*DCF)
            RINT(3) = 0.0
            !
        ELSEIF (.NOT. IB_OFF) THEN
            !
            RINT(1) = A*(DR*DC-DC*DRF-DR*DCF)
            RINT(3) = A*(DR*DCF)
            RINT(2) = A*(DC*DRF)
            RINT(4) = 0.0
        ELSE
          IOFF = Z    !SHOULD NEVER GO HERE, BUT CATCH ALL STATEMENT
          JOFF = Z
          RINT(1) = FOURTH
          RINT(2) = FOURTH
          RINT(3) = FOURTH
          RINT(4) = FOURTH
        ENDIF
      END ASSOCIATE
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE INTERP_3D(OP,NROW,NCOL,NLAY,SIM)
    CLASS(OBS_POINT),                            INTENT(INOUT):: OP
    INTEGER,                                     INTENT(IN   ):: NROW,NCOL,NLAY
    DOUBLE PRECISION, DIMENSION(NCOL,NROW,NLAY), INTENT(IN   ):: SIM
    !
    ASSOCIATE(I=>OP%ROW,     J=>OP%COL,     K=>OP%LAY,    &
              IOFF=>OP%IOFF, JOFF=>OP%JOFF, RINT=>OP%RINT  )
              !
       IF(OP%DO_INTERP) THEN
           !
           OP%SIM = RINT(1)*SIM(J,     I,     K) +  &
                    RINT(2)*SIM(J+JOFF,I,     K) +  &
                    RINT(3)*SIM(J,     I+IOFF,K) +  &
                    RINT(4)*SIM(J+JOFF,I+IOFF,K)
       ELSE
           OP%SIM = SIM(J,I,K)
       END IF
       !
    END ASSOCIATE
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE INTERP_2D(OP,NROW,NCOL,SIM) 
    CLASS(OBS_POINT),                       INTENT(INOUT):: OP
    INTEGER,                                INTENT(IN   ):: NROW,NCOL
    DOUBLE PRECISION, DIMENSION(NCOL,NROW), INTENT(IN   ):: SIM
    !
    ASSOCIATE(I=>OP%ROW,     J=>OP%COL,                   &
              IOFF=>OP%IOFF, JOFF=>OP%JOFF, RINT=>OP%RINT  )
              !
       IF(OP%DO_INTERP) THEN
           !
           OP%SIM = RINT(1)*SIM(J,     I     ) +  &
                    RINT(2)*SIM(J+JOFF,I     ) +  &
                    RINT(3)*SIM(J,     I+IOFF) +  &
                    RINT(4)*SIM(J+JOFF,I+IOFF)
       ELSE
           OP%SIM = SIM(J,I)
       END IF
       !
    END ASSOCIATE
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE INTERP_1D(OP,IDX,SIM)
    CLASS(OBS_POINT),               INTENT(INOUT):: OP
    INTEGER,          DIMENSION(:), INTENT(IN   ):: IDX
    DOUBLE PRECISION, DIMENSION(:), INTENT(IN   ):: SIM
    !
    ASSOCIATE(I=>OP%ROW,     J=>OP%COL,                   &
              IOFF=>OP%IOFF, JOFF=>OP%JOFF, RINT=>OP%RINT  )
              !
       IF(OP%DO_INTERP) THEN
           !
           OP%SIM = RINT(1)*SIM(IDX(1)) +  &
                    RINT(2)*SIM(IDX(2)) +  &
                    RINT(3)*SIM(IDX(3)) +  &
                    RINT(4)*SIM(IDX(4))
       ELSE
           OP%SIM = SIM(IDX(1))
       END IF
       !
    END ASSOCIATE
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE INTERP_SUB(OP,NROW,NCOL,NDIM,SIM)    !NDIM = NROW*NCOL*NNDB
    CLASS(OBS_POINT),                  INTENT(INOUT):: OP
    INTEGER,                           INTENT(IN   ):: NROW,NCOL,NDIM
    DOUBLE PRECISION, DIMENSION(NDIM), INTENT(IN   ):: SIM
    INTEGER:: II, KQ
    !
    ASSOCIATE(I=>OP%ROW,     J=>OP%COL,     K=>OP%ID,      &
              IOFF=>OP%IOFF, JOFF=>OP%JOFF, RINT=>OP%RINT   )
              !
       KQ = (K-1)*NROW*NCOL
       !
       IF(OP%DO_INTERP) THEN
           !
           II = NCOL*(I-1) + J + KQ;       OP%SIM =          RINT(1)*SIM(II)
           II = II + JOFF;                 OP%SIM = OP%SIM + RINT(2)*SIM(II)   ! II = NCOL*(I-1) + J+JOFF + KQ
           II = NCOL*(I-1+IOFF) + J + KQ;  OP%SIM = OP%SIM + RINT(3)*SIM(II) 
           II = II + JOFF;                 OP%SIM = OP%SIM + RINT(4)*SIM(II)   ! II = NCOL*(I-1+IOFF) + J+JOFF + KQ
       ELSE
           OP%SIM = SIM( NCOL*(I-1) + J + KQ )
       END IF
       !
    END ASSOCIATE
    !
  END SUBROUTINE
  !  
END MODULE
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
! !
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
MODULE BINARY_HEAP_INSTRUCTION!, ONLY:BINARY_HEAP
  !
  !   Max or Min Binary Heap
  !  
  ! Usage:
  !   TYPE(BINARY_HEAP):: BIN
  !
  !   CALL BIN%INIT(DIM, [MIN_HEAP])        DIM = Maximum size of binary heap. MIN_HEAP = True, then Min Heap (which is the default). MIN_HEAP = False is Max Heap
  !
  !   CALL BIN%ADD(ID, VAL)                 Add to Binary Heap a new ID-Val entry. If Heap is full (SIZE=DIM) then an entry is removed to make room.
  !
  !   CALL BIN%POP(ID, VAL)                 Remove to top of the Binary Heap and return its ID and VAL
  !
  !   CALL BIN%GET(ID,VAL,POS)              Search heap for ID, return its position, POS, and value VAL.
  !
  !   CALL BIN%SIZE()                       Returns the current size of the heap (BIN%N)
  !
  !   CALL BIN%GET_DIM()                    Returns the maximum size of the heap (BIN%DIM)
  !
  !   CALL BIN%DIJKSTRA_INIT(ID, [MAX_ID])  Auto-builds heap with IDs from 1 to MAX_ID with the passed ID being at the top of the heap
  !                                            This is necessary for the Dijkstra Algorithm for vertex "ID"
  !                                            If MAX_ID is not included then it will automatically use DIM
  !                                            If MAX_ID > DIM, then the binary heap will reallocate so that DIM = MAX_ID
  !                                            Note this is equivalent to:
  !                                                                       CALL BIN%INIT(MAX_ID)
  !                                                                       CALL BIN%ADD(ID, 0.0)
  !                                                                       DO I=1, MAX_ID
  !                                                                                  IF(I .NE. ID) CALL BIN%ADD(I, 1D300)
  !                                                                       END DO
  USE CONSTANTS
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: BINARY_HEAP
  !
  TYPE BINARY_DATA
      INTEGER         :: I  
      DOUBLE PRECISION:: X 
  END TYPE
  !
  TYPE BINARY_CHILD
      TYPE(BINARY_DATA), POINTER:: PNT => NULL()  !Must explicitly deallocate/nullify
  END TYPE
  !
  TYPE BINARY_HEAP
      PRIVATE
      INTEGER:: DIM = Z  !Max Number of Children
      INTEGER:: N = Z    !Number of Childen in use
      LOGICAL:: MIN_HEAP = TRUE
      TYPE(BINARY_CHILD), DIMENSION(:), POINTER:: CHILD => NULL()
      !
      CONTAINS
      !
      PROCEDURE, PASS(BIN):: INIT         => ALLOCATE_BINARY_HEAP       !(DIM, [MIN_HEAP])
      PROCEDURE, PASS(BIN):: ADD          => INSERT_BINARY_HEAP         !(ID,VAL)
      PROCEDURE, PASS(BIN):: POP          => POP_TOP_BINARY_HEAP        !(ID,VAL)
      PROCEDURE, PASS(BIN):: GET          => GET_BY_ID_BINARY_HEAP      !(ID,VAL,POS)
      PROCEDURE, PASS(BIN):: SET_BUBBLE   => SET_BUBBLE_BINARY_HEAP     !(POS,ID, VAL, [NO_CHECK])
      PROCEDURE, PASS(BIN):: SET_X        => SET_X_BINARY_HEAP          !(POS,    VAL, [NO_CHECK])
      PROCEDURE, PASS(BIN):: SET_BY_ID    => SET_BY_ID_BINARY_HEAP      !(    ID, VAL, [NO_CHECK])
      PROCEDURE, PASS(BIN):: SWOP         => SWOP_BUBBLES_BINARY_HEAP   !(P1,P2)
      PROCEDURE, PASS(BIN):: SIZE         => ACTIVE_SIZE_BINARY_HEAP    !()  Returns BIN%N
      PROCEDURE, PASS(BIN):: GET_DIM      => GET_DIM_BINARY_HEAP       !()  Returns BIN%DIM
      !
      PROCEDURE, PASS(BIN):: DIJKSTRA_INIT => DIJKSTRA_INIT_BINARY_HEAP !(ID)
      !
      PROCEDURE, PASS(BIN):: DESTROY  => DEALLOCATE_BINARY_HEAP
      FINAL:: FINAL_DEALLOCATE_BINARY_HEAP
  END TYPE
  !
  CONTAINS
  !
  PURE FUNCTION ACTIVE_SIZE_BINARY_HEAP(BIN) RESULT(N)
                                 CLASS(BINARY_HEAP), INTENT(IN):: BIN
                                 INTEGER:: N
                                 N = BIN%N
  END FUNCTION
  !
  PURE FUNCTION GET_DIM_BINARY_HEAP(BIN) RESULT(DIM)
                                 CLASS(BINARY_HEAP), INTENT(IN):: BIN
                                 INTEGER:: DIM
                                 DIM = BIN%DIM
  END FUNCTION
  !
  PURE SUBROUTINE ALLOCATE_BINARY_HEAP(BIN, DIM, MIN_HEAP)
     CLASS(BINARY_HEAP),INTENT(INOUT):: BIN
     INTEGER,           INTENT(IN   ):: DIM
     LOGICAL, OPTIONAL, INTENT(IN   ):: MIN_HEAP
     INTEGER:: I
     !
     IF(BIN%DIM .NE. DIM) THEN  !Start with fresh HEAP since dimension is different
         !
         CALL BIN%DESTROY()
         !
         BIN%DIM = DIM
         !
         ALLOCATE(BIN%CHILD(DIM))
         !
         DO I=ONE, DIM
                      ALLOCATE(BIN%CHILD(I)%PNT)
                      BIN%CHILD(I)%PNT%I =  Z
                      BIN%CHILD(I)%PNT%X = DZ
         END DO
         !
     END IF
     !
     BIN%N = Z
     !
     IF(PRESENT(MIN_HEAP)) THEN
         BIN%MIN_HEAP = MIN_HEAP
     ELSE
         BIN%MIN_HEAP = TRUE
     END IF
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE POP_TOP_BINARY_HEAP(BIN,ID,VAL)
     CLASS(BINARY_HEAP),INTENT(INOUT):: BIN
     INTEGER,           INTENT(  OUT):: ID
     DOUBLE PRECISION,  INTENT(  OUT):: VAL
     !
     INTEGER:: I
     !
     IF( BIN%N > Z ) THEN
         !
         I = ONE
         ID  = BIN%CHILD(I)%PNT%I
         VAL = BIN%CHILD(I)%PNT%X
         !
         CALL BIN%SWOP(I,BIN%N)  !Move bottom most position to top
         !
         BIN%N = BIN%N - ONE     !Drop new bottom
         !
         IF( BIN%N > ONE ) CALL SINK_DOWN_BINARY_HEAP(BIN,I)  !Move top position downward
     ELSE
         ID  = NEG
         VAL = inf
     END IF
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE INSERT_BINARY_HEAP(BIN,ID,VAL)
     CLASS(BINARY_HEAP),INTENT(INOUT):: BIN
     INTEGER,           INTENT(IN   ):: ID
     DOUBLE PRECISION,  INTENT(IN   ):: VAL
     !
     INTEGER:: I
     !
     I = Z
     IF( BIN%N < BIN%DIM ) THEN
         BIN%N = BIN%N + ONE
         I = BIN%N
         !
         BIN%CHILD(I)%PNT%I =  ID
         BIN%CHILD(I)%PNT%X = VAL
     END IF
     !
     IF(I == Z) THEN  !FULL LIST DROP LOWEST LEVEL
        I = BIN%DIM
        !
        IF(BIN%MIN_HEAP) THEN
                        IF(BIN%CHILD(I)%PNT%X > VAL) THEN
                           BIN%CHILD(I)%PNT%I =  ID
                           BIN%CHILD(I)%PNT%X = VAL
                        ELSE
                            I = Z
                        END IF
        ELSE
                        IF(BIN%CHILD(I)%PNT%X < VAL) THEN
                           BIN%CHILD(I)%PNT%I =  ID
                           BIN%CHILD(I)%PNT%X = VAL
                        ELSE
                            I = Z
                        END IF
        END IF
     END IF
     !
     IF(I > ONE) CALL BUBBLE_UP_BINARY_HEAP(BIN,I)  !TRUE IF NEW ENTRY ADDED
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE DIJKSTRA_INIT_BINARY_HEAP(BIN, ID, MAX_ID)  !HEAP from 1 to MAX_ID, with ID at the top
     !
     CLASS(BINARY_HEAP),INTENT(INOUT):: BIN
     INTEGER,           INTENT(IN   ):: ID
     INTEGER, OPTIONAL, INTENT(IN   ):: MAX_ID
     INTEGER::I,K,DIM
     !
     IF(PRESENT(MAX_ID)) THEN
                              DIM = MAX_ID
                              IF( DIM > BIN%DIM ) THEN
                                                  BLOCK
                                                      LOGICAL:: MIN_HEAP
                                                      MIN_HEAP = BIN%MIN_HEAP
                                                      CALL BIN%INIT(DIM, MIN_HEAP)
                                                  END BLOCK
                              END IF
     ELSE
                              DIM = BIN%DIM
     END IF
     
     !
     BIN%CHILD(ONE)%PNT%I = ID  !Head node is recieved ID
     BIN%CHILD(ONE)%PNT%X = DZ
     !
     K = ONE
     DO I=ONE, DIM
         IF ( I.NE.ID ) THEN
                           K = K + ONE
                           BIN%CHILD(K)%PNT%I = I
                           BIN%CHILD(K)%PNT%X = inf
         END IF
     END DO
     !
     BIN%N = DIM
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE BUBBLE_UP_OR_SINK_BINARY_HEAP(BIN,POS)
     !
     CLASS(BINARY_HEAP),INTENT(INOUT):: BIN
     INTEGER,           INTENT(INOUT):: POS
     !
     INTEGER:: P, I
     LOGICAL:: MOVE_UP
     !
     IF(BIN%N > ONE) THEN
           I = POS          !Bubble to check
           !
           P = I/2          !Parent Position relative to check
           !
           IF    (I == ONE) THEN
                                    MOVE_UP = FALSE
           ELSEIF(I == BIN%N) THEN
                                    MOVE_UP = TRUE
           ELSEIF(BIN%MIN_HEAP) THEN
               IF(BIN%CHILD(P)%PNT%X > BIN%CHILD(I)%PNT%X) THEN
                                                           MOVE_UP = TRUE
               ELSE
                                                           MOVE_UP = FALSE
               END IF
           ELSE
               IF(BIN%CHILD(P)%PNT%X < BIN%CHILD(I)%PNT%X) THEN
                                                           MOVE_UP = TRUE
               ELSE
                                                           MOVE_UP = FALSE
               END IF
           END IF
           !
           IF(MOVE_UP) THEN
                       CALL BUBBLE_UP_BINARY_HEAP(BIN,POS)
           ELSE
                       CALL SINK_DOWN_BINARY_HEAP(BIN,POS)
           END IF
     END IF
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_BUBBLE_BINARY_HEAP(BIN,POS,ID,VAL,NO_CHECK)
     !
     CLASS(BINARY_HEAP),INTENT(INOUT):: BIN
     INTEGER,           INTENT(IN   ):: POS,ID
     DOUBLE PRECISION,  INTENT(IN   ):: VAL
     LOGICAL, OPTIONAL, INTENT(IN   ):: NO_CHECK
     LOGICAL:: CHECK
     !
     IF( Z < POS .AND. POS <= BIN%DIM ) THEN
                           !
                           BIN%CHILD(POS)%PNT%I =  ID
                           BIN%CHILD(POS)%PNT%X = VAL
                           !
                           IF(BIN%N < POS) BIN%N = POS
     END IF
     !
     CHECK = TRUE
     IF(PRESENT(NO_CHECK)) CHECK = .NOT. NO_CHECK
     !
     IF(CHECK) CALL BUBBLE_UP_OR_SINK_BINARY_HEAP(BIN,POS)
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_X_BINARY_HEAP(BIN,POS,VAL,NO_CHECK)
     !
     CLASS(BINARY_HEAP),INTENT(INOUT):: BIN
     INTEGER,           INTENT(IN   ):: POS
     DOUBLE PRECISION,  INTENT(IN   ):: VAL
     LOGICAL, OPTIONAL, INTENT(IN   ):: NO_CHECK
     LOGICAL:: CHECK
     !
     IF( Z < POS .AND. POS <= BIN%DIM ) THEN
                           !
                           BIN%CHILD(POS)%PNT%X = VAL
                           !
                           IF(BIN%N < POS) BIN%N = POS
     END IF
     !
     CHECK = TRUE
     IF(PRESENT(NO_CHECK)) CHECK = .NOT. NO_CHECK
     !
     IF(CHECK) CALL BUBBLE_UP_OR_SINK_BINARY_HEAP(BIN,POS)
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE SORT_BY_VAL_BINARY_HEAP(BIN,FULL_TREE)
     !
     CLASS(BINARY_HEAP),INTENT(INOUT):: BIN
     LOGICAL, OPTIONAL, INTENT(IN   ):: FULL_TREE
     INTEGER:: I, J, N
     !
     N = BIN%N
     IF(PRESENT(FULL_TREE)) THEN;  IF(FULL_TREE) N = BIN%DIM
     END IF
     !
     IF(BIN%MIN_HEAP) THEN
         !
         DO I=ONE, N-ONE
             DO J=I+ONE, N
                 IF( BIN%CHILD(I)%PNT%X > BIN%CHILD(J)%PNT%X) CALL BIN%SWOP(I,J)
             END DO
         END DO
     ELSE
         DO I=ONE, N-ONE
             DO J=I+ONE, N
                 IF( BIN%CHILD(I)%PNT%X < BIN%CHILD(J)%PNT%X) CALL BIN%SWOP(I,J)
             END DO
         END DO
     END IF
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE SORT_BY_ID_BINARY_HEAP(BIN,FULL_TREE, REVERSE)
     !
     CLASS(BINARY_HEAP),INTENT(INOUT):: BIN
     LOGICAL, OPTIONAL, INTENT(IN   ):: FULL_TREE, REVERSE
     INTEGER:: I, J, N
     LOGICAL:: MIN_DIR
     !
     N = BIN%N
     IF(PRESENT(FULL_TREE)) THEN;  IF(FULL_TREE) N = BIN%DIM
     END IF
     !
     MIN_DIR = TRUE
     IF(PRESENT(REVERSE)) MIN_DIR = .NOT. REVERSE
     !
     IF(MIN_DIR) THEN
         !
         DO I=ONE, N-ONE
             DO J=I+ONE, N
                 IF( BIN%CHILD(I)%PNT%I > BIN%CHILD(J)%PNT%I) CALL BIN%SWOP(I,J)
             END DO
         END DO
     ELSE
         DO I=ONE, N-ONE
             DO J=I+ONE, N
                 IF( BIN%CHILD(I)%PNT%I < BIN%CHILD(J)%PNT%I) CALL BIN%SWOP(I,J)
             END DO
         END DO
     END IF
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_BY_ID_BINARY_HEAP(BIN,ID,VAL,NO_CHECK)
     !
     CLASS(BINARY_HEAP),INTENT(INOUT):: BIN
     INTEGER,           INTENT(IN   ):: ID
     DOUBLE PRECISION,  INTENT(IN   ):: VAL
     LOGICAL, OPTIONAL, INTENT(IN   ):: NO_CHECK
     INTEGER:: I, P
     LOGICAL:: CHECK
     !
     DO I=ONE, BIN%N
         IF(ID == BIN%CHILD(I)%PNT%I)THEN
             BIN%CHILD(I)%PNT%X = VAL
             P = I
             EXIT
         END IF
     END DO
     !
     CHECK = TRUE
     IF(PRESENT(NO_CHECK)) CHECK = .NOT. NO_CHECK
     !
     IF(CHECK) CALL BUBBLE_UP_OR_SINK_BINARY_HEAP(BIN,P)
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE GET_BY_ID_BINARY_HEAP(BIN,ID,VAL,POS)
     !
     CLASS(BINARY_HEAP),INTENT(INOUT):: BIN
     INTEGER,           INTENT(IN   ):: ID
     DOUBLE PRECISION,  INTENT(  OUT):: VAL
     INTEGER,           INTENT(  OUT):: POS
     INTEGER:: I
     !
     DO I=ONE, BIN%N
         IF( ID == BIN%CHILD(I)%PNT%I)THEN
             VAL = BIN%CHILD(I)%PNT%X
             POS = I
             EXIT
         END IF
     END DO
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE SWOP_BUBBLES_BINARY_HEAP(BIN,P1,P2)
     !
     CLASS(BINARY_HEAP),INTENT(INOUT):: BIN
     INTEGER,           INTENT(IN   ):: P1,P2
     !
     TYPE(BINARY_DATA), POINTER:: PNT
     !
     PNT               => BIN%CHILD(P1)%PNT
     BIN%CHILD(P1)%PNT => BIN%CHILD(P2)%PNT
     BIN%CHILD(P2)%PNT => PNT              
     PNT => NULL()
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE BUBBLE_UP_BINARY_HEAP(BIN,POS)
     !
     CLASS(BINARY_HEAP),INTENT(INOUT):: BIN
     INTEGER,           INTENT(IN   ):: POS
     !
     TYPE(BINARY_DATA), POINTER:: PNT
     INTEGER:: P, I
     !
     I = POS !Child  Position
     P = I/2 !Parent Position
     IF(BIN%MIN_HEAP) THEN
          DO WHILE ( P > Z )
             IF(BIN%CHILD(P)%PNT%X > BIN%CHILD(I)%PNT%X) THEN
                !
                PNT              => BIN%CHILD(P)%PNT   !Parent-Child Swap
                BIN%CHILD(P)%PNT => BIN%CHILD(I)%PNT   !Parent points to Child
                BIN%CHILD(I)%PNT => PNT                !Child poitns to Parent
                PNT => NULL()
                I = P
                P = I/2
             ELSE
                P = Z  !For stop on next itertation
             END IF
          END DO
     ELSE
          DO WHILE ( P > Z )
             IF(BIN%CHILD(P)%PNT%X < BIN%CHILD(I)%PNT%X) THEN
                !
                PNT              => BIN%CHILD(P)%PNT
                BIN%CHILD(I)%PNT => BIN%CHILD(P)%PNT
                BIN%CHILD(P)%PNT => PNT
                PNT => NULL()
                I = P
                P = I/2
             ELSE
                P = Z  !For stop on next itertation
             END IF
          END DO
     END IF
  END SUBROUTINE   
  !
  PURE SUBROUTINE SINK_DOWN_BINARY_HEAP(BIN,POS)
     !
     CLASS(BINARY_HEAP),INTENT(INOUT):: BIN
     INTEGER,           INTENT(IN   ):: POS
     !
     TYPE(BINARY_DATA), POINTER:: PNT
     INTEGER:: P, C1, C2
     !
     P  = POS         !Parent Position
     C1 = TWO*P       !Left  Child Position
     C2 = TWO*P + ONE !Right Child Position
     !
     IF(BIN%MIN_HEAP) THEN
          DO WHILE ( C1 <= BIN%N )
             !
             IF(C2 > BIN%N) C2 = BIN%N  !Ensures that Child 2 exists, if not only check Child 1
             !
             IF(BIN%CHILD(P)%PNT%X > BIN%CHILD(C1)%PNT%X .OR. BIN%CHILD(P)%PNT%X > BIN%CHILD(C2)%PNT%X) THEN    !Parent is Larger than Children, move upward smallest child
                 IF(BIN%CHILD(C1)%PNT%X < BIN%CHILD(C2)%PNT%X) THEN !Swap with Child 1, which is the smallest child
                    !
                    PNT               => BIN%CHILD(P)%PNT   !Parent-Child Swap
                    BIN%CHILD(P )%PNT => BIN%CHILD(C1)%PNT  !Parent  points to Child 1
                    BIN%CHILD(C1)%PNT => PNT                !Child 1 poitns to Parent
                    PNT => NULL()
                    P = C1
                    C1 = TWO*P 
                    C2 = TWO*P + ONE
                 ELSE                                       !Swap with Child 2, which is the smallest child
                    PNT               => BIN%CHILD(P)%PNT   !Parent-Child Swap
                    BIN%CHILD(P )%PNT => BIN%CHILD(C2)%PNT  !Parent  points to Child 1
                    BIN%CHILD(C2)%PNT => PNT                !Child 1 poitns to Parent
                    PNT => NULL()
                    P = C2
                    C1 = TWO*P 
                    C2 = TWO*P + ONE
                 END IF
             ELSE
                 C1 = BIN%N + ONE  !Force Exit on next iteration
             END IF
          END DO
     ELSE
          DO WHILE ( C1 <= BIN%N )
             !
             IF(C2 > BIN%N) C2 = C1  !Ensures that Child 2 exists, if not only check Child 1
             !
             IF(BIN%CHILD(P)%PNT%X < BIN%CHILD(C1)%PNT%X .OR. BIN%CHILD(P)%PNT%X < BIN%CHILD(C2)%PNT%X) THEN  !Parent is Smaller than Children, move upward largest child
                 IF(BIN%CHILD(C1)%PNT%X > BIN%CHILD(C2)%PNT%X) THEN !Swap with Child 1, which is the biggest child
                    !
                    PNT               => BIN%CHILD(P)%PNT   !Parent-Child Swap
                    BIN%CHILD(P )%PNT => BIN%CHILD(C1)%PNT  !Parent  points to Child 1
                    BIN%CHILD(C1)%PNT => PNT                !Child 1 poitns to Parent
                    PNT => NULL()
                    P = C1
                    C1 = TWO*P 
                    C2 = TWO*P + ONE
                 ELSE                                       !Swap with Child 2, which is the smallest child
                    PNT               => BIN%CHILD(P)%PNT   !Parent-Child Swap
                    BIN%CHILD(P )%PNT => BIN%CHILD(C2)%PNT  !Parent  points to Child 1
                    BIN%CHILD(C2)%PNT => PNT                !Child 1 poitns to Parent
                    PNT => NULL()
                    P = C2
                    C1 = TWO*P 
                    C2 = TWO*P + ONE
                 END IF
             ELSE
                 EXIT
             END IF
          END DO
     END IF
  END SUBROUTINE 
  !
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_BINARY_HEAP(BIN)
    CLASS(BINARY_HEAP), INTENT(INOUT):: BIN
    INTEGER:: I, J
    !
    IF(BIN%DIM > Z) THEN
       DO I=ONE, BIN%DIM
                        DEALLOCATE(BIN%CHILD(I)%PNT, STAT=J)
                        BIN%CHILD(I)%PNT => NULL()
       END DO
       !
       DEALLOCATE(BIN%CHILD)
    END IF
    !
    BIN%DIM = Z
    BIN%N   = Z
    BIN%MIN_HEAP = TRUE
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_BINARY_HEAP(BIN)
    TYPE(BINARY_HEAP), INTENT(INOUT):: BIN
    !
    CALL DEALLOCATE_BINARY_HEAP(BIN)
  END SUBROUTINE
  !
END MODULE
!
!!
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
MODULE ARRAY_DATA_TYPES!, ONLY: INTEGER_VECTOR, DOUBLE_VECTOR, INTEGER_MATRIX, DOUBLE_MATRIX, LOGICAL_VECTOR, CHARACTER_TYPE, CHARACTER_ARRAY, COMPRESSED_VALUE_STORAGE
  USE, INTRINSIC:: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN
  USE CONSTANTS
  IMPLICIT NONE
  !
  PUBLIC:: CHARACTER_TYPE, CHARACTER_ARRAY
  PUBLIC:: INTEGER_VECTOR, DOUBLE_VECTOR, LOGICAL_VECTOR
  PUBLIC:: INTEGER_MATRIX, DOUBLE_MATRIX
  PUBLIC:: COMPRESSED_VALUE_STORAGE
  PUBLIC:: COMPRESSED_LOCATION_STORAGE
  PUBLIC:: RAT_VOL_TYPE, RAT_VOL_BASE
  PUBLIC:: ID_VAL_TYPE            ! ADD, SET_, GET_
  PUBLIC:: ID_RAT_VOL_TYPE        ! ADD, SET_, GET_, CALC_
  PUBLIC:: ID1_ID2_RAT_VOL_TYPE   ! ADD, SET_, GET_, CALC_
  !
  PRIVATE
  !
  TYPE CHARACTER_TYPE
      INTEGER:: N=Z
      CHARACTER(:), ALLOCATABLE::STR
      !
      CONTAINS
      !
      PROCEDURE, PASS(CH):: SET     => ALLOCATE_CHARACTER_TYPE !(LINE)
      PROCEDURE, PASS(CH):: GET     => GET_CHARACTER_TYPE !()
      PROCEDURE, PASS(CH):: ADD     => ADD_TO_ENDING_CHARACTER_TYPE!(LINE)
      PROCEDURE, PASS(CH):: ADD_TRIM=> TRIM_ADD_TO_ENDING_CHARACTER_TYPE!(LINE)
      PROCEDURE, PASS(CH):: ADD_BEGIN=> ADD_TO_BEGIN_CHARACTER_TYPE!(LINE)
      GENERIC::             POP => REMOVE_SPECIFIED_CHARACTER, REMOVE_SPECIFIED_RANGE_CHARACTER, REMOVE_LAST_CHARACTER
      
      PROCEDURE, PASS(CH):: WRITE   => WRITE_CHARACTER_TYPE!(IU,FMT)
      PROCEDURE, PASS(CH):: MOVE    => MOVE_CHARACTER_TYPE!(CH_OUT)
      PROCEDURE, PASS(CH):: DESTROY => DEALLOCATE_CHARACTER_TYPE!(CH_OUT)
      GENERIC            :: ASSIGNMENT(=) => COPY_CHARACTER_TYPE_OPERATOR, SET_CHARACTER_TYPE_OPERATOR
      GENERIC            :: OPERATOR(==)  => COMPARE_CHARACTER_TYPE, COMPARE_CHARACTER_TYPE_STR
      !
      PROCEDURE, PRIVATE :: COPY_CHARACTER_TYPE_OPERATOR
      PROCEDURE, PRIVATE :: SET_CHARACTER_TYPE_OPERATOR
      PROCEDURE, PRIVATE :: COMPARE_CHARACTER_TYPE
      PROCEDURE, PRIVATE :: COMPARE_CHARACTER_TYPE_STR
      !
      PROCEDURE, PASS(CH),PRIVATE:: REMOVE_SPECIFIED_CHARACTER!(POS) 
      PROCEDURE, PASS(CH),PRIVATE:: REMOVE_SPECIFIED_RANGE_CHARACTER!(P1,P2)
      PROCEDURE, PASS(CH),PRIVATE:: REMOVE_LAST_CHARACTER
      FINAL:: FINAL_DEALLOCATE_CHARACTER_TYPE
  END TYPE
  !
  TYPE CHARACTER_ARRAY
      INTEGER:: N=Z
      CHARACTER(:),DIMENSION(:), ALLOCATABLE::STR
      !
      CONTAINS
      !                                   (MAX_LEN,DIM) or (STR,[MAX_LEN],[DIM])
      PROCEDURE, PASS(CH):: INIT       => ALLOCATE_CHARACTER_ARRAY, ALLOCATE_CHARACTER_ARRAY_STR
      PROCEDURE, PASS(CH):: ADD        => ADD_ROW_CHARACTER_ARRAY!(STR)
      PROCEDURE, PASS(CH):: ADD_UNIQUE => ADD_UNIQUE_ROW_CHARACTER_ARRAY !(STR,[POS])
      PROCEDURE, PASS(CH):: POS        => GET_CHARACTER_POSITION!(STR)
      PROCEDURE, PASS(CH):: GET        => GET_CHARACTER_ROW!(POS)
      PROCEDURE, PASS(CH):: MOVE       => MOVE_CHARACTER_ARRAY!(CH_OUT)
      PROCEDURE, PASS(CH):: DESTROY    => DEALLOCATE_CHARACTER_ARRAY
      GENERIC            :: ASSIGNMENT(=) => COPY_CHARACTER_ARRAY_OPERATOR
      PROCEDURE, PRIVATE :: COPY_CHARACTER_ARRAY_OPERATOR
      FINAL::FINAL_DEALLOCATE_CHARACTER_ARRAY
  END TYPE
  !
  TYPE INTEGER_VECTOR
      INTEGER:: N=Z
      INTEGER, DIMENSION(:),ALLOCATABLE:: VEC
      !
  CONTAINS
      !
      GENERIC            :: INIT         =>INIT_INTEGER_VECTOR, DEALLOCATE_INTEGER_VECTOR !([VEC])
      PROCEDURE, PASS(IT):: ALLOC        =>ALLOCATE_INTEGER_VECTOR         !(DIM [IVAL])  --IVAL IS A SCALER THAT WHEN PRESENT IS WHAT THE VECTOR IS SET TOO
      PROCEDURE, PASS(IT):: SET          =>SET_INTEGER_VECTOR_VALUE        !(POS,VAL)
      PROCEDURE, PASS(IT):: ADD          =>ADD_VAL_INTEGER_VECTOR          !(IVAL,POS)
      PROCEDURE, PASS(IT):: ADD_UNIQUE   =>ADD_UNIQUE_VAL_INTEGER_VECTOR   !(IVAL)
      PROCEDURE, PASS(IT):: IS_UNIQUE    =>  IS_UNIQUE_INTEGER_VECTOR      !(I)
      PROCEDURE, PASS(IT):: NOT_UNIQUE   => NOT_UNIQUE_INTEGER_VECTOR      !(I)
      PROCEDURE, PASS(IT):: POP          => REMOVE_LOCATION_INTEGER_VECTOR !(POS)
      PROCEDURE, PASS(IT):: COPY         =>TRANSFER_INTEGER_VECTOR         !(DB_OUT)
      PROCEDURE, PASS(IT):: MOVE         =>MOVE_INTEGER_VECTOR             !(DB_OUT)
      PROCEDURE, PASS(IT):: GET          =>GET_INTEGER_BY_INDEX            !(DB_OUT)
      PROCEDURE, PASS(IT):: FIND         =>FIND_INT_POS_INTEGER_VECTOR     !(IVAL)
      GENERIC            :: DESTROY      => DEALLOCATE_INTEGER_VECTOR
      GENERIC            :: ASSIGNMENT(=) => COPY_INTEGER_VECTOR_OPERATOR, SET_INTEGER_VECTOR_OPERATOR
      PROCEDURE,           PRIVATE :: COPY_INTEGER_VECTOR_OPERATOR
      PROCEDURE,           PRIVATE :: SET_INTEGER_VECTOR_OPERATOR
      PROCEDURE, PASS(IT), PRIVATE:: INIT_INTEGER_VECTOR
      PROCEDURE, PASS(IT), PRIVATE:: DEALLOCATE_INTEGER_VECTOR
      FINAL::FINAL_DEALLOCATE_INTEGER_VECTOR
  END TYPE
  !
  TYPE INTEGER_MATRIX
      INTEGER:: N=Z, M=Z
      INTEGER, DIMENSION(:,:), ALLOCATABLE:: MAT
      !
      CONTAINS
      !
      PROCEDURE, PASS(IT):: INIT => INIT_INTEGER_MATRIX_OPERATOR!(MAT)
      PROCEDURE, PASS(IT):: ALLOC=> ALLOCATE_INTEGER_MATRIX, ALLOCATE_INTEGER_MATRIX_SRC !(DIM1,DIM2,SRC)
      PROCEDURE, PASS(IT):: MOVE => MOVE_INTEGER_MATRIX!(DB_OUT)
      PROCEDURE, PASS(IT):: GET  => GET_INTEGER_MAT_BY_INDEX!(POS1,POS2)
      PROCEDURE, PASS(IT):: SET  => SET_INTEGER_MAT_BY_2_INDEX, SET_INTEGER_MAT_BY_1_INDEX, INIT_INTEGER_MATRIX_OPERATOR!(POS1,POS2,IVAL) or (POS,VEC,[DIMSET])
      PROCEDURE, PASS(IT):: DESTROY => DEALLOCATE_INTEGER_MATRIX
      GENERIC            :: ASSIGNMENT(=) => COPY_INTEGER_MATRIX_OPERATOR, SET_INTEGER_MATRIX_OPERATOR
      PROCEDURE, PRIVATE :: COPY_INTEGER_MATRIX_OPERATOR
      PROCEDURE, PRIVATE :: SET_INTEGER_MATRIX_OPERATOR
      !PROCEDURE, PRIVATE, PASS(DB):: ALLOCATE_INTEGER_MATRIX
      !PROCEDURE, PRIVATE, PASS(DB):: ALLOCATE_INTEGER_MATRIX_SRC
      FINAL::FINAL_DEALLOCATE_INTEGER_MATRIX
  END TYPE
  !
  TYPE DOUBLE_VECTOR
      INTEGER:: N=Z
      DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE:: VEC
      !
      CONTAINS
      !
      PROCEDURE, PASS(DB):: ALLOC=>ALLOCATE_DOUBLE_VECTOR!(DIM,[VAL])
      PROCEDURE, PASS(DB):: MOVE =>MOVE_DOUBLE_VECTOR!(DB_OUT)
      PROCEDURE, PASS(DB):: GET  =>GET_DOUBLE_VEC_BY_INDEX!(DB_OUT)
      PROCEDURE, PASS(DB):: DESTROY =>DEALLOCATE_DOUBLE_VECTOR
      GENERIC            :: ASSIGNMENT(=) => COPY_DOUBLE_VECTOR_OPERATOR, SET_DOUBLE_VECTOR_OPERATOR
      PROCEDURE, PRIVATE :: COPY_DOUBLE_VECTOR_OPERATOR
      PROCEDURE, PRIVATE :: SET_DOUBLE_VECTOR_OPERATOR
      FINAL::FINAL_DEALLOCATE_DOUBLE_VECTOR
  END TYPE
  !
  TYPE DOUBLE_MATRIX
      INTEGER:: N=Z, M=Z
      DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE:: MAT
      !
      CONTAINS
      ! 
      PROCEDURE, PASS(DB):: INIT => INIT_DOUBLE_MATRIX_OPERATOR
      PROCEDURE, PASS(DB):: ALLOC=> ALLOCATE_DOUBLE_MATRIX, ALLOCATE_DOUBLE_MATRIX_SRC !(DIM1,DIM2,SRC)
      PROCEDURE, PASS(DB):: MOVE => MOVE_DOUBLE_MATRIX!(DB_OUT)
      PROCEDURE, PASS(DB):: GET  => GET_DOUBLE_MAT_BY_INDEX!(DB_OUT)
      PROCEDURE, PASS(DB):: SET  => SET_DOUBLE_MAT_BY_2_INDEX, SET_DOUBLE_MAT_BY_1_INDEX, INIT_DOUBLE_MATRIX_OPERATOR !(POS1,POS2,VAL) or (POS,VEC,[DIMSET])
      PROCEDURE, PASS(DB):: DESTROY => DEALLOCATE_DOUBLE_MATRIX
      GENERIC            :: ASSIGNMENT(=) => COPY_DOUBLE_MATRIX_OPERATOR, SET_DOUBLE_MATRIX_OPERATOR
      PROCEDURE, PRIVATE :: COPY_DOUBLE_MATRIX_OPERATOR
      PROCEDURE, PRIVATE :: SET_DOUBLE_MATRIX_OPERATOR
      !PROCEDURE, PRIVATE, PASS(DB):: ALLOCATE_DOUBLE_MATRIX
      !PROCEDURE, PRIVATE, PASS(DB):: ALLOCATE_DOUBLE_MATRIX_SRC
      FINAL::FINAL_DEALLOCATE_DOUBLE_MATRIX
  END TYPE
  !
  TYPE LOGICAL_VECTOR
      INTEGER:: N=Z
      LOGICAL, DIMENSION(:),ALLOCATABLE:: VEC
      !
      CONTAINS
      !
      PROCEDURE, PASS(TF):: ALLOC=>ALLOCATE_LOGICAL_VECTOR
      PROCEDURE, PASS(TF):: ADD  =>ADD_VAL_LOGICAL_VECTOR
      PROCEDURE, PASS(TF):: MOVE =>MOVE_LOGICAL_VECTOR!(DB_OUT)
      PROCEDURE, PASS(TF):: GET  =>GET_LOGICAL_BY_INDEX!(DB_OUT)
      PROCEDURE, PASS(TF):: DESTROY =>DEALLOCATE_LOGICAL_VECTOR
      GENERIC            :: ASSIGNMENT(=) => COPY_LOGICAL_VECTOR_OPERATOR
      PROCEDURE, PRIVATE :: COPY_LOGICAL_VECTOR_OPERATOR
      FINAL::FINAL_DEALLOCATE_LOGICAL_VECTOR
  END TYPE
  !
  TYPE COMPRESSED_VALUE_STORAGE
      INTEGER:: N = Z      !Size of VAL and DIM(2)
      INTEGER:: M = Z      !Size of DIM(1)
      LOGICAL:: IS_CONSTANT = FALSE                      !If true then N = ONE and all entries hold the same value
      INTEGER,          DIMENSION(:,:), ALLOCATABLE:: DIM
      DOUBLE PRECISION, DIMENSION(:),   ALLOCATABLE:: VAL
      CONTAINS
      PROCEDURE, PASS(CVS):: ALLOC         => ALLOCATE_CVS      !ALLOC(N, NDIM, [NEW_ALLOC])
      PROCEDURE, PASS(CVS):: BUILD_NONZERO => BUILD_NONZERO_CVS
      PROCEDURE, PASS(CVS):: DESTROY       => DEALLCOATE_COMPRESSED_VALUE_STORAGE
      FINAL:: DEALLCOATE_COMPRESSED_VALUE_STORAGE_FINAL
  END TYPE
  !
  TYPE COMPRESSED_LOCATION_STORAGE
      INTEGER:: N = Z    !Size in use of DIM(2); N <= SIZ
      INTEGER:: M = Z    !Size of DIM(1)
      INTEGER:: SIZ = Z  !Size of DIM(2)
      INTEGER:: ID=NEG   !ID whose locations are stored in DIM(1)
      LOGICAL:: IS_CONSTANT = FALSE  ! If true then DIM is meaningless and ID is entire array
      INTEGER, DIMENSION(:,:), ALLOCATABLE:: DIM
      CONTAINS
      PROCEDURE, PASS(LAC):: ALLOC   => ALLOCATE_LAC                              !(N, NDIM, NEW_ALLOC)  -- Should use BUILD instead
      GENERIC             :: BUILD   => BUILD_COMPRESSED_LOCATION_STORAGE_DIM2, & !(ID, ARR)  ARR is DIM(:,:)
                                        BUILD_COMPRESSED_LOCATION_STORAGE_DIM3    !(ID, ARR)  ARR is DIM(:,:,:)
      PROCEDURE, PASS(LAC):: DESTROY => DEALLCOATE_COMPRESSED_LOCATION_STORAGE
      !
      PROCEDURE, PASS(LAC), PRIVATE:: BUILD_COMPRESSED_LOCATION_STORAGE_DIM2  !(ID, ARR)  ARR is DIM(:,:)
      PROCEDURE, PASS(LAC), PRIVATE:: BUILD_COMPRESSED_LOCATION_STORAGE_DIM3  !(ID, ARR)  ARR is DIM(:,:,:)
      !
      FINAL:: DEALLCOATE_COMPRESSED_LOCATION_STORAGE_FINAL
  END TYPE
  !
  !!!INTERFACE COMPRESSED_LOCATION_STORAGE
  !!!            MODULE PROCEDURE BUILD_COMPRESSED_LOCATION_STORAGE_ALOC
  !!!END INTERFACE
  !
  TYPE ID1_ID2_RAT_VOL_BASE
      INTEGER:: ID1, ID2
      DOUBLE PRECISION:: RAT
      DOUBLE PRECISION:: VOL
      !
      CONTAINS
      !
      GENERIC:: ASSIGNMENT(=) => COPY_ID1_ID2_RAT_VOL_BASE
      PROCEDURE, PRIVATE:: COPY_ID1_ID2_RAT_VOL_BASE
  END TYPE
  !
  TYPE ID_RAT_VOL_BASE
      INTEGER:: ID
      DOUBLE PRECISION:: RAT
      DOUBLE PRECISION:: VOL
      !
      CONTAINS
      !
      GENERIC:: ASSIGNMENT(=) => COPY_ID_RAT_VOL_BASE
      PROCEDURE, PRIVATE:: COPY_ID_RAT_VOL_BASE
  END TYPE
  !
  TYPE ID_VAL_BASE
      INTEGER:: ID
      DOUBLE PRECISION:: VAL
      !
      CONTAINS
      !
      GENERIC:: ASSIGNMENT(=) => COPY_ID_VAL_BASE
      PROCEDURE, PRIVATE:: COPY_ID_VAL_BASE
  END TYPE
  !
  TYPE RAT_VOL_BASE
      DOUBLE PRECISION:: RAT
      DOUBLE PRECISION:: VOL
      !
      CONTAINS
      !
      PROCEDURE, PASS(TYP):: SET_RAT  =>  SET_RAT_RAT_VOL_BASE  !(POS, RAT)
      PROCEDURE, PASS(TYP):: SET_VOL  =>  SET_VOL_RAT_VOL_BASE  !(POS, VOL)
      PROCEDURE, PASS(TYP):: CALC_RAT => CALC_RAT_RAT_VOL_BASE  !(DELT)
      PROCEDURE, PASS(TYP):: CALC_VOL => CALC_VOL_RAT_VOL_BASE  !(DELT)
      PROCEDURE, PASS(TYP):: GET_RAT  =>  GET_RAT_RAT_VOL_BASE  !(POS, [EVAL])
      PROCEDURE, PASS(TYP):: GET_VOL  =>  GET_VOL_RAT_VOL_BASE  !(POS, [EVAL])
      GENERIC:: ASSIGNMENT(=) => COPY_RAT_VOL_BASE
      PROCEDURE, PRIVATE:: COPY_RAT_VOL_BASE
  END TYPE
  !
  TYPE RAT_VOL_TYPE
      LOGICAL:: INUSE = FALSE
      INTEGER:: N = Z
      TYPE(RAT_VOL_BASE), DIMENSION(:), ALLOCATABLE:: PT
      !
      CONTAINS
      !
      GENERIC             :: ALLOC   =>    ALLOC_RAT_VOL_TYPE,          & !(DIM,[INIT])
                                           ALLOC_RAT_VOL_TYPE_INIT_SCA, & 
                                           ALLOC_RAT_VOL_TYPE_INIT_VEC   
      PROCEDURE, PASS(TYP):: ADD      =>      EXTEND_RAT_VOL_TYPE  !(RAT, VOL)
      PROCEDURE, PASS(TYP):: SET_RAT  => SET_RAT_POS_RAT_VOL_TYPE  !(POS, RAT)
      PROCEDURE, PASS(TYP):: SET_VOL  => SET_VOL_POS_RAT_VOL_TYPE  !(POS, VOL)
      PROCEDURE, PASS(TYP):: CALC_RAT =>    CALC_RAT_RAT_VOL_TYPE  !(DELT)
      PROCEDURE, PASS(TYP):: CALC_VOL =>    CALC_VOL_RAT_VOL_TYPE  !(DELT)
      PROCEDURE, PASS(TYP):: GET_RAT  => GET_RAT_POS_RAT_VOL_TYPE  !(POS, [EVAL])
      PROCEDURE, PASS(TYP):: GET_VOL  => GET_VOL_POS_RAT_VOL_TYPE  !(POS, [EVAL])
      PROCEDURE, PASS(TYP), PRIVATE:: ALLOC_RAT_VOL_TYPE
      PROCEDURE, PASS(TYP), PRIVATE:: ALLOC_RAT_VOL_TYPE_INIT_SCA
      PROCEDURE, PASS(TYP), PRIVATE:: ALLOC_RAT_VOL_TYPE_INIT_VEC
  END TYPE
  !
  TYPE ID1_ID2_RAT_VOL_TYPE
      LOGICAL:: INUSE = FALSE
      INTEGER:: N = Z
      TYPE(ID1_ID2_RAT_VOL_BASE), DIMENSION(:), ALLOCATABLE:: PT
      !
      CONTAINS
      !
      PROCEDURE, PASS(TYP):: ALLOC   =>     ALLOC_ID1_ID2_RAT_VOL_TYPE  !(DIM)
      PROCEDURE, PASS(TYP):: ADD      =>   EXTEND_ID1_ID2_RAT_VOL_TYPE  !(ID1, ID2, RAT, VOL)
      PROCEDURE, PASS(TYP):: SET_RAT  =>  SET_RAT_ID1_ID2_RAT_VOL_TYPE  !(ID1, ID2, RAT)
      PROCEDURE, PASS(TYP):: SET_VOL  =>  SET_VOL_ID1_ID2_RAT_VOL_TYPE  !(ID1, ID2, VOL)
      PROCEDURE, PASS(TYP):: CALC_RAT => CALC_RAT_ID1_ID2_RAT_VOL_TYPE  !(DELT)
      PROCEDURE, PASS(TYP):: CALC_VOL => CALC_VOL_ID1_ID2_RAT_VOL_TYPE  !(DELT)
      PROCEDURE, PASS(TYP):: GET_RAT  =>  GET_RAT_ID1_ID2_RAT_VOL_TYPE  !(ID, [EVAL])
      PROCEDURE, PASS(TYP):: GET_VOL  =>  GET_VOL_ID1_ID2_RAT_VOL_TYPE  !(ID, [EVAL])
  END TYPE
  !
  TYPE ID_RAT_VOL_TYPE
      LOGICAL:: INUSE = FALSE
      INTEGER:: N = Z
      TYPE(ID_RAT_VOL_BASE), DIMENSION(:), ALLOCATABLE:: PT
      !
      CONTAINS
      !
      GENERIC             :: ALLOC   =>     ALLOC_ID_RAT_VOL_TYPE,          & !(DIM,[INIT])
                                            ALLOC_ID_RAT_VOL_TYPE_INIT_SCA, & 
                                            ALLOC_ID_RAT_VOL_TYPE_INIT_VEC   
      PROCEDURE, PASS(TYP):: ADD      =>   EXTEND_ID_RAT_VOL_TYPE  !(ID, RAT, VOL)
      PROCEDURE, PASS(TYP):: SET_RAT  =>  SET_RAT_ID_RAT_VOL_TYPE  !(ID, RAT)
      PROCEDURE, PASS(TYP):: SET_VOL  =>  SET_VOL_ID_RAT_VOL_TYPE  !(ID, VOL)
      PROCEDURE, PASS(TYP):: CALC_RAT => CALC_RAT_ID_RAT_VOL_TYPE  !(DELT)
      PROCEDURE, PASS(TYP):: CALC_VOL => CALC_VOL_ID_RAT_VOL_TYPE  !(DELT)
      PROCEDURE, PASS(TYP):: GET_RAT  =>  GET_RAT_ID_RAT_VOL_TYPE  !(ID, [EVAL])
      PROCEDURE, PASS(TYP):: GET_VOL  =>  GET_VOL_ID_RAT_VOL_TYPE  !(ID, [EVAL])
      PROCEDURE, PASS(TYP), PRIVATE:: ALLOC_ID_RAT_VOL_TYPE
      PROCEDURE, PASS(TYP), PRIVATE:: ALLOC_ID_RAT_VOL_TYPE_INIT_SCA
      PROCEDURE, PASS(TYP), PRIVATE:: ALLOC_ID_RAT_VOL_TYPE_INIT_VEC
  END TYPE
  !
  TYPE ID_VAL_TYPE
      LOGICAL:: INUSE = FALSE
      INTEGER:: N = Z
      TYPE(ID_VAL_BASE), DIMENSION(:), ALLOCATABLE:: PT
      !
      CONTAINS
      !
      GENERIC             :: ALLOC   =>   ALLOC_ID_VAL_TYPE,          & !(DIM,[INIT])
                                          ALLOC_ID_VAL_TYPE_INIT_SCA, & 
                                          ALLOC_ID_VAL_TYPE_INIT_VEC  
      PROCEDURE, PASS(TYP):: ADD     =>  EXTEND_ID_VAL_TYPE  !(ID, VAL)
      PROCEDURE, PASS(TYP):: SET_VAL => SET_VAL_ID_VAL_TYPE  !(ID, VAL)
      PROCEDURE, PASS(TYP):: GET_VAL => GET_VAL_ID_VAL_TYPE  !(ID, [EVAL])
      GENERIC             :: SET     => SET_ID_VAL_TYPE_ALL, SET_ID_VAL_TYPE_POS  !(ID, VAL) or (POS, ID, VAL)
      PROCEDURE, PASS(TYP), PRIVATE:: SET_ID_VAL_TYPE_ALL
      PROCEDURE, PASS(TYP), PRIVATE:: SET_ID_VAL_TYPE_POS
      PROCEDURE, PASS(TYP), PRIVATE:: ALLOC_ID_VAL_TYPE      
      PROCEDURE, PASS(TYP), PRIVATE:: ALLOC_ID_VAL_TYPE_INIT_SCA
      PROCEDURE, PASS(TYP), PRIVATE:: ALLOC_ID_VAL_TYPE_INIT_VEC
  END TYPE
  !
  CONTAINS
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  !
  ! Utility Subroutines -- They help with compiler bugs with gfortran
  !
  PURE SUBROUTINE MOVE_ALLOC_CHARACTER_ARRAY(FROM, TOO)
     CHARACTER(:),DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: FROM
     CHARACTER(:),DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: TOO
     CALL MOVE_ALLOC(FROM, TOO)
  END SUBROUTINE
  !
  ELEMENTAL PURE FUNCTION COMPARE_CHARACTER_TYPE_STR(CH, STR) RESULT(CMP)
     CLASS(CHARACTER_TYPE),INTENT(IN):: CH
     CHARACTER(*),         INTENT(IN):: STR
     LOGICAL:: CMP
     !
     CMP = CH%STR == STR
     !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION COMPARE_CHARACTER_TYPE(CH, CH_CMP) RESULT(CMP)
     CLASS(CHARACTER_TYPE),INTENT(IN):: CH
     CLASS(CHARACTER_TYPE),INTENT(IN):: CH_CMP
     LOGICAL:: CMP
     !
     CMP = CH%STR == CH_CMP%STR
     !
  END FUNCTION
  !
  PURE ELEMENTAL SUBROUTINE ALLOCATE_CHARACTER_TYPE(CH,LINE)
     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
     CHARACTER(*),         INTENT(IN   ):: LINE
     !
     IF(ALLOCATED(CH%STR)) DEALLOCATE(CH%STR)
     ALLOCATE(CH%STR, SOURCE=LINE)
     CH%N = LEN(CH%STR)
     !
  END SUBROUTINE
  !
  PURE FUNCTION GET_CHARACTER_TYPE(CH) RESULT(LINE)
     CLASS(CHARACTER_TYPE), INTENT(IN):: CH
     CHARACTER(:),ALLOCATABLE:: LINE
     !
     IF(ALLOCATED(CH%STR)) THEN
         ALLOCATE(LINE, SOURCE=CH%STR)
     ELSE
         ALLOCATE(LINE, SOURCE=BLNK)
     END IF
     !
  END FUNCTION
  !
  PURE ELEMENTAL SUBROUTINE ADD_TO_ENDING_CHARACTER_TYPE(CH,LINE)
     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
     CHARACTER(*),          INTENT(IN   ):: LINE
     !
     IF(ALLOCATED(CH%STR)) THEN
                                CH%STR = CH%STR//LINE
     ELSE
                       ALLOCATE(CH%STR, SOURCE=LINE)
     END IF
     CH%N = LEN(CH%STR)
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ADD_TO_BEGIN_CHARACTER_TYPE(CH,LINE)
     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
     CHARACTER(*),          INTENT(IN   ):: LINE
     !
     IF(ALLOCATED(CH%STR)) THEN
                                CH%STR = LINE//CH%STR
     ELSE
                       ALLOCATE(CH%STR, SOURCE=LINE)
     END IF
     CH%N = LEN(CH%STR)
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE TRIM_ADD_TO_ENDING_CHARACTER_TYPE(CH,LINE)
     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
     CHARACTER(*),          INTENT(IN   ):: LINE
     !
     IF(ALLOCATED(CH%STR)) THEN
                                CH%STR = CH%STR//TRIM(LINE)
     ELSE
                       ALLOCATE(CH%STR, SOURCE=TRIM(LINE))
     END IF
     CH%N = LEN(CH%STR)
     !
  END SUBROUTINE
  !
!  PURE ELEMENTAL SUBROUTINE ADD_TO_ENDING_CHARACTER_TYPE(CH,LINE,TRIM_LINE)
!     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
!     CHARACTER(*),          INTENT(IN   ):: LINE
!     LOGICAL,     OPTIONAL, INTENT(IN   ):: TRIM_LINE
!     LOGICAL:: TL
!     !
!     TL = FALSE
!     IF(PRESENT(TRIM_LINE)) TL = TRIM_LINE
!     IF(ALLOCATED(CH%STR)) THEN
!         IF(TL) THEN
!                    CH%STR = CH%STR//TRIM(LINE)
!         ELSE
!                    CH%STR = CH%STR//LINE
!         END IF
!     ELSE
!         IF(TL) THEN
!                    ALLOCATE(CH%STR, SOURCE=TRIM(LINE))
!         ELSE
!                    ALLOCATE(CH%STR, SOURCE=LINE)
!         END IF
!     END IF
!     CH%N = LEN(CH%STR)
!     !
!  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE REMOVE_SPECIFIED_CHARACTER(CH,POS) 
     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
     INTEGER,               INTENT(IN   ):: POS
     CHARACTER(:), ALLOCATABLE:: LINE
     INTEGER:: Pp1,Pm1,Nm1,P
     !
     IF(ALLOCATED(CH%STR)) THEN
         IF    (POS >= 0) THEN
                 P = POS
         ELSEIF(POS < 0) THEN
                 P = CH%N + POS + ONE  !-1 IS THE END OF THE LIST
         END IF
         !
         IF    (P == ONE .AND. CH%N == ONE) THEN
                 CALL DEALLOCATE_CHARACTER_TYPE(CH)
         ELSEIF(Z < P .AND. P <= CH%N) THEN
             IF    (P == ONE) THEN
                                   ALLOCATE(LINE, SOURCE=CH%STR(TWO:))
                                   CALL MOVE_ALLOC(LINE, CH%STR)
             ELSEIF(P==CH%N) THEN
                                   ALLOCATE(LINE, SOURCE=CH%STR(ONE:CH%N-ONE))
                                   CALL MOVE_ALLOC(LINE, CH%STR)
             ELSE
                                   Pp1 = P + ONE
                                   Pm1 = P - ONE
                                   Nm1 = CH%N- ONE
                                   ALLOCATE(CHARACTER(Nm1)::LINE)
                                   !
                                   LINE(ONE:Pm1) = CH%STR(ONE:Pm1)
                                   LINE(P:Nm1) = CH%STR(Pp1:CH%N)
                                   !
                                   CALL MOVE_ALLOC(LINE, CH%STR)
             END IF
             !
             CH%N = LEN(CH%STR)
         END IF
     END IF
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE REMOVE_SPECIFIED_RANGE_CHARACTER(CH,P1,P2)
     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
     INTEGER,               INTENT(IN   ):: P1,P2
     CHARACTER(:), ALLOCATABLE:: LINE
     INTEGER:: Pp1,Pm1
     !
     IF( P2 < P1 .OR. (P1 < TWO .AND. P2 >= CH%N) ) THEN
                 CALL DEALLOCATE_CHARACTER_TYPE(CH)
    ELSEIF(ALLOCATED(CH%STR)) THEN
         !
         ALLOCATE(LINE, SOURCE= CH%STR(ONE:P1-ONE)//CH%STR(P2+ONE:CH%N) )
         IF    (P1 == P2) THEN
                 CALL REMOVE_SPECIFIED_CHARACTER(CH,P1)
         ELSE
             Pp1 = P2 + ONE
             Pm1 = P1 - ONE
             !
             IF(Pp1 >= CH%N) THEN
                 ALLOCATE(LINE, SOURCE= CH%STR(ONE:Pm1) )
             ELSEIF(Pm1 < ONE) THEN
                 ALLOCATE(LINE, SOURCE= CH%STR(Pp1:CH%N) )
             ELSE
                 ALLOCATE(LINE, SOURCE= CH%STR(ONE:Pm1)//CH%STR(Pp1:CH%N) )
             END IF
             !
             CALL MOVE_ALLOC(LINE, CH%STR)
             !
             CH%N = LEN(CH%STR)
         END IF
     END IF
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE REMOVE_LAST_CHARACTER(CH) 
     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
     !
     CALL REMOVE_SPECIFIED_CHARACTER(CH,NEG) 
     !
  END SUBROUTINE
  !
  IMPURE ELEMENTAL SUBROUTINE WRITE_CHARACTER_TYPE(CH,IU,FMT)
     CLASS(CHARACTER_TYPE),  INTENT(INOUT):: CH
     INTEGER,                INTENT(IN   ):: IU
     CHARACTER(*), OPTIONAL, INTENT(IN   ):: FMT
     !
     IF(IU.NE.Z .AND. CH%N > Z) THEN
         IF(PRESENT(FMT)) THEN
             WRITE(IU,FMT) CH%STR
         ELSE
             WRITE(IU,'(A)') CH%STR
         END IF
     END IF
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MOVE_CHARACTER_TYPE(CH,CH_OUT)
     CLASS(CHARACTER_TYPE),INTENT(INOUT):: CH
     CLASS(CHARACTER_TYPE),INTENT(INOUT):: CH_OUT
     !
     IF (ALLOCATED(CH%STR)) THEN
         CALL MOVE_ALLOC(CH%STR,CH_OUT%STR)
         CH_OUT%N = CH%N
         CH%N = Z 
     ELSE
         IF(ALLOCATED(CH_OUT%STR)) DEALLOCATE(CH_OUT%STR)
         CH_OUT%N = Z
     END IF
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE COPY_CHARACTER_TYPE_OPERATOR(CH_OUT,CH_IN)
     CLASS(CHARACTER_TYPE),INTENT(IN   ):: CH_IN
     CLASS(CHARACTER_TYPE),INTENT(INOUT):: CH_OUT
     !
     IF (ALLOCATED(CH_IN%STR)) THEN
         IF(ALLOCATED(CH_OUT%STR)) DEALLOCATE(CH_OUT%STR)
         ALLOCATE(CH_OUT%STR, SOURCE=CH_IN%STR)
        CH_OUT%N = CH_IN%N
     ELSE
         IF(ALLOCATED(CH_OUT%STR)) DEALLOCATE(CH_OUT%STR)
         CH_OUT%N = Z
     END IF
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE SET_CHARACTER_TYPE_OPERATOR(CH,LINE)
     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
     CHARACTER(*),          INTENT(IN   ):: LINE
     !
     IF (.NOT. ALLOCATED(CH%STR)) THEN
         ALLOCATE(CH%STR, SOURCE=LINE)
    ELSEIF(CH%N < LEN_TRIM(LINE)) THEN
        DEALLOCATE(CH%STR)
        ALLOCATE(CH%STR, SOURCE=LINE)
    ELSE
        CH%STR=LINE
    END IF
    !
    CH%N = LEN(CH%STR)
    !
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_CHARACTER_TYPE(CH)
     CLASS(CHARACTER_TYPE),INTENT(INOUT):: CH
     IF(ALLOCATED(CH%STR)) DEALLOCATE(CH%STR)
     CH%N = Z 
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_CHARACTER_TYPE(CH)
     TYPE(CHARACTER_TYPE),INTENT(INOUT):: CH
     CALL DEALLOCATE_CHARACTER_TYPE(CH)
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE ELEMENTAL SUBROUTINE ALLOCATE_CHARACTER_ARRAY(CH,MAX_LEN,DIM)
     CLASS(CHARACTER_ARRAY),INTENT(INOUT):: CH
     INTEGER,               INTENT(IN   ):: MAX_LEN, DIM
     IF(ALLOCATED(CH%STR)) DEALLOCATE(CH%STR)
     ALLOCATE(CHARACTER(MAX_LEN)::CH%STR(DIM))
     CH%N=DIM
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ALLOCATE_CHARACTER_ARRAY_STR(CH,STR,MAX_LEN,DIM)
     CLASS(CHARACTER_ARRAY),INTENT(INOUT):: CH
     CHARACTER(*),          INTENT(IN   ):: STR
     INTEGER, OPTIONAL,     INTENT(IN   ):: MAX_LEN, DIM
     INTEGER:: LIN_LEN, NDIM
     !
     LIN_LEN = ONE
     NDIM    = ONE
     IF(PRESENT(MAX_LEN)) LIN_LEN = MAX_LEN
     IF(PRESENT(DIM))     NDIM    = DIM
     !
     IF(ALLOCATED(CH%STR)) DEALLOCATE(CH%STR)
     ALLOCATE(CHARACTER(LIN_LEN)::CH%STR(NDIM))
     CH%N=NDIM
     !
     CH%STR(ONE) = STR
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MOVE_CHARACTER_ARRAY(CH,CH_OUT)
     CLASS(CHARACTER_ARRAY),INTENT(INOUT):: CH
     CLASS(CHARACTER_ARRAY),INTENT(INOUT):: CH_OUT
     !
     IF (CH%N > 0) THEN
         CH_OUT%N = CH%N
         CH%N     = Z
         !CALL MOVE_ALLOC(CH%STR,CH_OUT%STR)
         CALL MOVE_ALLOC_CHARACTER_ARRAY(CH%STR,CH_OUT%STR)
     ELSE
         CH_OUT%N = Z
         IF(ALLOCATED(CH_OUT%STR)) DEALLOCATE(CH_OUT%STR)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_CHARACTER_ARRAY_OPERATOR(CH_OUT,CH_IN)
     CLASS(CHARACTER_ARRAY),INTENT(IN   ):: CH_IN
     CLASS(CHARACTER_ARRAY),INTENT(INOUT):: CH_OUT
     INTEGER:: I
      !
      IF (CH_IN%N > Z) THEN
          IF(CH_OUT%N .NE. CH_IN%N) THEN
                                    I  = LEN(CH_IN%STR)
                                    CH_OUT%N = CH_IN%N
                                    IF(ALLOCATED(CH_OUT%STR)) DEALLOCATE(CH_OUT%STR)
                                    ALLOCATE(CHARACTER(I):: CH_OUT%STR(CH_IN%N) )
          END IF
          !
          DO I=ONE, CH_IN%N
                           CH_OUT%STR(I)(:) = CH_IN%STR(I)
          END DO
      ELSE
          CH_OUT%N = Z
          IF(ALLOCATED(CH_OUT%STR)) DEALLOCATE(CH_OUT%STR)
      END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ADD_ROW_CHARACTER_ARRAY(CH,STR)
     CLASS(CHARACTER_ARRAY),INTENT(INOUT):: CH
     CHARACTER(*),          INTENT(IN   ):: STR
     INTEGER:: MAX_LEN, DIM
     CHARACTER(:),DIMENSION(:), ALLOCATABLE::TMP
     !
     IF (CH%N > 0) THEN
         DIM  = CH%N
         CH%N = CH%N + ONE
         MAX_LEN = LEN(CH%STR)
         IF(MAX_LEN < LEN(STR)) MAX_LEN = LEN(STR)
         !
         ALLOCATE(CHARACTER(MAX_LEN)::TMP(DIM+ONE))
         !
         TMP(:DIM) = CH%STR
         TMP(DIM+ONE) = STR
         !
         !CALL MOVE_ALLOC(TMP,CH%STR)
         CALL MOVE_ALLOC_CHARACTER_ARRAY(TMP,CH%STR)
     ELSE
         CALL ALLOCATE_CHARACTER_ARRAY_STR(CH,STR)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ADD_UNIQUE_ROW_CHARACTER_ARRAY(CH,STR,POS)
     CLASS(CHARACTER_ARRAY),INTENT(INOUT):: CH
     CHARACTER(*),          INTENT(IN   ):: STR
     INTEGER,     OPTIONAL, INTENT(OUT  ):: POS
     INTEGER:: I
     LOGICAL:: NOT_FOUND
     !
     IF (CH%N > 0) THEN
         !
         IF(PRESENT(POS)) POS = Z
         NOT_FOUND = TRUE
         !
         DO I = ONE, CH%N
             IF(STR == CH%STR(I)) THEN
                 IF(PRESENT(POS)) POS = I
                 NOT_FOUND = FALSE
                 EXIT
             END IF
         END DO
         !
         IF(NOT_FOUND) CALL ADD_ROW_CHARACTER_ARRAY(CH,STR)
     ELSE
         CALL ALLOCATE_CHARACTER_ARRAY_STR(CH,STR)
         IF(PRESENT(POS)) POS = ONE
     END IF
  END SUBROUTINE
  !
  PURE FUNCTION GET_CHARACTER_ROW(CH,POS) RESULT (STR)
     CLASS(CHARACTER_ARRAY),INTENT(IN):: CH
     INTEGER,               INTENT(IN):: POS
     CHARACTER(:), ALLOCATABLE::STR
     !
     IF(Z < POS .AND. POS <= CH%N) THEN
         ALLOCATE(STR, SOURCE=CH%STR(POS))
     ELSE
         ALLOCATE(STR, SOURCE='ERROR')
     END IF
  END FUNCTION
  !
  PURE FUNCTION GET_CHARACTER_POSITION(CH,STR) RESULT (POS)
     CLASS(CHARACTER_ARRAY),INTENT(IN):: CH
     CHARACTER(*),          INTENT(IN):: STR
     INTEGER:: POS
     INTEGER:: I
     !
     POS = Z
     DO I = ONE, CH%N
         IF(STR == CH%STR(I)) THEN
             POS = I
             EXIT
         END IF
     END DO
     !
  END FUNCTION
  !    
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_CHARACTER_ARRAY(CH)
     CLASS(CHARACTER_ARRAY),INTENT(INOUT):: CH
     IF(ALLOCATED(CH%STR)) DEALLOCATE(CH%STR)
     CH%N=Z
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_CHARACTER_ARRAY(CH)
     TYPE(CHARACTER_ARRAY),INTENT(INOUT):: CH
     IF(ALLOCATED(CH%STR)) DEALLOCATE(CH%STR)
     CH%N=Z
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE ELEMENTAL SUBROUTINE ALLOCATE_DOUBLE_VECTOR(DB,DIM,VAL)
     CLASS(DOUBLE_VECTOR),       INTENT(INOUT):: DB
     INTEGER,                    INTENT(IN   ):: DIM
     DOUBLE PRECISION, OPTIONAL, INTENT(IN   ):: VAL
     !
     IF(DIM < ONE) THEN
         IF(ALLOCATED(DB%VEC)) DEALLOCATE(DB%VEC)
         DB%N=Z
     ELSEIF(PRESENT(VAL)) THEN
        IF(DB%N .NE. DIM) THEN
            IF(ALLOCATED(DB%VEC)) DEALLOCATE(DB%VEC)
            ALLOCATE(DB%VEC(DIM), SOURCE=VAL)
            DB%N=DIM
        ELSE
            DB%VEC = VAL
        END IF
     ELSEIF(DB%N .NE. DIM) THEN
            IF(ALLOCATED(DB%VEC)) DEALLOCATE(DB%VEC)
            ALLOCATE(DB%VEC(DIM))
            DB%N=DIM
     END IF
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MOVE_DOUBLE_VECTOR(DB,DB_OUT)
     CLASS(DOUBLE_VECTOR),INTENT(INOUT):: DB
     CLASS(DOUBLE_VECTOR),INTENT(INOUT):: DB_OUT
     !
     IF (DB%N > 0) THEN
         DB_OUT%N = DB%N
         DB%N     = Z
         CALL MOVE_ALLOC(DB%VEC,DB_OUT%VEC)
     ELSE
         DB_OUT%N = Z
         IF(ALLOCATED(DB_OUT%VEC)) DEALLOCATE(DB_OUT%VEC)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_DOUBLE_VECTOR_OPERATOR(DB_OUT,DB_IN)
     CLASS(DOUBLE_VECTOR),INTENT(IN   ):: DB_IN
     CLASS(DOUBLE_VECTOR),INTENT(INOUT):: DB_OUT
      !
      IF (DB_IN%N > Z) THEN
          DB_OUT%N = DB_IN%N
          IF(ALLOCATED(DB_OUT%VEC)) DEALLOCATE(DB_OUT%VEC)
          ALLOCATE(DB_OUT%VEC, SOURCE=DB_IN%VEC)
      ELSE
          DB_OUT%N = Z
          IF(ALLOCATED(DB_OUT%VEC)) DEALLOCATE(DB_OUT%VEC)
      END IF
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_DOUBLE_VECTOR_OPERATOR(DB_OUT,VEC)
     DOUBLE PRECISION,DIMENSION(:), INTENT(IN   ):: VEC
     CLASS(DOUBLE_VECTOR),          INTENT(INOUT):: DB_OUT
     INTEGER:: N
     LOGICAL:: ALLOC
     N     = SIZE(VEC)
     ALLOC = ALLOCATED(DB_OUT%VEC)
     !
     IF (N > Z) THEN
         IF(DB_OUT%N == SIZE(VEC) .AND. ALLOC) THEN
                           DB_OUT%VEC = VEC
         ELSEIF(ALLOC) THEN
                DEALLOCATE(DB_OUT%VEC)
                  ALLOCATE(DB_OUT%VEC, SOURCE=VEC)
         ELSE
               ALLOCATE(DB_OUT%VEC, SOURCE=VEC)
         END IF
     ELSE
         DB_OUT%N = Z
         IF(ALLOC) DEALLOCATE(DB_OUT%VEC)
     END IF
  END SUBROUTINE
  !
  IMPURE ELEMENTAL FUNCTION GET_DOUBLE_VEC_BY_INDEX(DB,POS) RESULT (VAL)
     CLASS(DOUBLE_VECTOR),INTENT(IN):: DB
     INTEGER,             INTENT(IN):: POS
     DOUBLE PRECISION:: VAL
     !
     IF(Z < POS .AND. POS <= DB%N) THEN
         VAL=DB%VEC(POS)
     ELSE
         CALL SET_NAN(VAL)
     END IF
  END FUNCTION
  !    
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_DOUBLE_VECTOR(DB)
     CLASS(DOUBLE_VECTOR),INTENT(INOUT):: DB
     IF(ALLOCATED(DB%VEC)) DEALLOCATE(DB%VEC)
     DB%N=Z
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_DOUBLE_VECTOR(DB)
     TYPE(DOUBLE_VECTOR),INTENT(INOUT):: DB
     IF(ALLOCATED(DB%VEC)) DEALLOCATE(DB%VEC)
     DB%N=Z
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE SUBROUTINE INIT_DOUBLE_MATRIX_OPERATOR(DB,MAT)
     CLASS(DOUBLE_MATRIX),             INTENT(INOUT):: DB
     DOUBLE PRECISION, DIMENSION(:,:), INTENT(IN   ):: MAT
     INTEGER:: DIM1,DIM2
     !
     DIM1 = SIZE(MAT,1)
     DIM2 = SIZE(MAT,2)
     !
     CALL ALLOCATE_DOUBLE_MATRIX_SRC(DB,DIM1,DIM2,MAT)
  END SUBROUTINE
  ! 
  PURE ELEMENTAL SUBROUTINE ALLOCATE_DOUBLE_MATRIX(DB,DIM1,DIM2,SRC)
     CLASS(DOUBLE_MATRIX),         INTENT(INOUT):: DB
     INTEGER,                      INTENT(IN   ):: DIM1,DIM2
     DOUBLE PRECISION,    OPTIONAL,INTENT(IN   ):: SRC
     !
     IF(DIM1 < ONE .OR. DIM2 < ONE) THEN
         IF(ALLOCATED(DB%MAT)) DEALLOCATE(DB%MAT)
         DB%N=Z
         DB%M=Z
     ELSEIF(DB%N .NE. DIM1 .OR. DB%M .NE. DIM2) THEN
         IF(ALLOCATED(DB%MAT)) DEALLOCATE(DB%MAT)
         IF(PRESENT(SRC)) THEN
                             ALLOCATE(DB%MAT(DIM1,DIM2), SOURCE=SRC)
         ELSE
                             ALLOCATE(DB%MAT(DIM1,DIM2))
         END IF
         DB%N=DIM1
         DB%M=DIM2
    ELSEIF(PRESENT(SRC)) THEN
        DB%MAT = SRC
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOCATE_DOUBLE_MATRIX_SRC(DB,DIM1,DIM2,SRC)
     CLASS(DOUBLE_MATRIX),                  INTENT(INOUT):: DB
     INTEGER,                               INTENT(IN   ):: DIM1,DIM2
     DOUBLE PRECISION, DIMENSION(DIM1,DIM2),INTENT(IN   ):: SRC
     !
     IF(DIM1 < ONE .OR. DIM2 < ONE) THEN
         IF(ALLOCATED(DB%MAT)) DEALLOCATE(DB%MAT)
         DB%N=Z
         DB%M=Z
     ELSEIF(DB%N .NE. DIM1 .OR. DB%M .NE. DIM2) THEN
         IF(ALLOCATED(DB%MAT)) DEALLOCATE(DB%MAT)
         !
         ALLOCATE(DB%MAT(DIM1,DIM2), SOURCE=SRC)
         DB%N=DIM1
         DB%M=DIM2
    ELSE
        DB%MAT = SRC
    END IF
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MOVE_DOUBLE_MATRIX(DB,DB_OUT)
     CLASS(DOUBLE_MATRIX),INTENT(INOUT):: DB
     CLASS(DOUBLE_MATRIX),INTENT(INOUT):: DB_OUT
     !
     IF (DB%N > 0) THEN
         DB_OUT%N = DB%N
         DB_OUT%M = DB%M
         DB%N     = Z
         DB%M     = Z
         CALL MOVE_ALLOC(DB%MAT,DB_OUT%MAT)
     ELSE
         DB_OUT%N = Z
         DB_OUT%M = Z
         IF(ALLOCATED(DB_OUT%MAT)) DEALLOCATE(DB_OUT%MAT)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_DOUBLE_MATRIX_OPERATOR(DB_OUT,DB_IN)
     CLASS(DOUBLE_MATRIX),INTENT(IN   ):: DB_IN
     CLASS(DOUBLE_MATRIX),INTENT(INOUT):: DB_OUT
      !
      IF (DB_IN%N > Z) THEN
          DB_OUT%N = DB_IN%N
          DB_OUT%M = DB_IN%M
          IF(ALLOCATED(DB_OUT%MAT)) DEALLOCATE(DB_OUT%MAT)
          ALLOCATE(DB_OUT%MAT, SOURCE=DB_IN%MAT)
      ELSE
          DB_OUT%N = Z
          DB_OUT%M = Z
          IF(ALLOCATED(DB_OUT%MAT)) DEALLOCATE(DB_OUT%MAT)
      END IF
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_DOUBLE_MATRIX_OPERATOR(DB_OUT,MAT)
     CLASS(DOUBLE_MATRIX),             INTENT(INOUT):: DB_OUT
     DOUBLE PRECISION, DIMENSION(:,:), INTENT(IN   ):: MAT
     INTEGER:: DIM1,DIM2
     !
     DIM1 = SIZE(MAT,1)
     DIM2 = SIZE(MAT,2)
     !
     CALL ALLOCATE_DOUBLE_MATRIX_SRC(DB_OUT,DIM1,DIM2,MAT)
  END SUBROUTINE
  !
  IMPURE ELEMENTAL FUNCTION GET_DOUBLE_MAT_BY_INDEX(DB,POS1,POS2) RESULT (VAL)
     CLASS(DOUBLE_MATRIX),INTENT(IN):: DB
     INTEGER,             INTENT(IN):: POS1,POS2
     DOUBLE PRECISION:: VAL
     !
     IF(Z < POS1 .AND. POS1 <= DB%N .AND. Z < POS2 .AND. POS2 <= DB%M) THEN
         VAL=DB%MAT(POS1,POS2)
     ELSE
         CALL SET_NAN(VAL)
     END IF
  END FUNCTION
  !
  PURE ELEMENTAL SUBROUTINE SET_DOUBLE_MAT_BY_2_INDEX(DB,POS1,POS2,VAL)
     CLASS(DOUBLE_MATRIX), INTENT(INOUT):: DB
     INTEGER,              INTENT(IN   ):: POS1,POS2
     DOUBLE PRECISION,     INTENT(IN   ):: VAL
     !
     IF(Z < POS1 .AND. POS1 <= DB%N .AND. Z < POS2 .AND. POS2 <= DB%M)  DB%MAT(POS1,POS2) = VAL
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_DOUBLE_MAT_BY_1_INDEX(DB,POS,VEC,DIMSET)
     CLASS(DOUBLE_MATRIX),                     INTENT(INOUT):: DB
     INTEGER,                                  INTENT(IN   ):: POS
     DOUBLE PRECISION,DIMENSION(:),CONTIGUOUS, INTENT(IN   ):: VEC
     INTEGER,                      OPTIONAL,   INTENT(IN   ):: DIMSET
     INTEGER:: DIM
     !
     IF(PRESENT(DIMSET)) THEN
         IF    (DIMSET==1) THEN
                               DIM = NEG
         ELSEIF(DIMSET==2) THEN
                               DIM = NINER
         ELSE
                               DIM = SIZE(VEC)
         END IF
    ELSE
                               DIM = SIZE(VEC)
    END IF
    !
    IF    (DIM == DB%N .OR. DIM == NEG  ) THEN
                                              DB%MAT(:,POS) = VEC
    ELSEIF(DIM == DB%M .OR. DIM == NINER) THEN
                                              DB%MAT(POS,:) = VEC
    END IF
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_DOUBLE_MATRIX(DB)
     CLASS(DOUBLE_MATRIX),INTENT(INOUT):: DB
     IF(ALLOCATED(DB%MAT)) DEALLOCATE(DB%MAT)
     DB%N=Z
     DB%M=Z
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_DOUBLE_MATRIX(DB)
     TYPE(DOUBLE_MATRIX),INTENT(INOUT):: DB
     IF(ALLOCATED(DB%MAT)) DEALLOCATE(DB%MAT)
     DB%N=Z
     DB%M=Z
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE SUBROUTINE INIT_INTEGER_VECTOR(IT,VEC)
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT
     INTEGER, DIMENSION(:),INTENT(IN   ):: VEC
     !
     CALL ALLOCATE_INTEGER_VECTOR(IT,SIZE(VEC))
     IT%VEC = VEC
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ALLOCATE_INTEGER_VECTOR(IT,DIM,IVAL)
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT
     INTEGER,             INTENT(IN   ):: DIM
     INTEGER, OPTIONAL,   INTENT(IN   ):: IVAL
     !
     IF(DIM < ONE) THEN
         IF(ALLOCATED(IT%VEC)) DEALLOCATE(IT%VEC)
         IT%N=Z
     ELSEIF(IT%N .NE. DIM) THEN
         IF(ALLOCATED(IT%VEC)) DEALLOCATE(IT%VEC)
         ALLOCATE(IT%VEC(DIM))
         IT%N=DIM
    END IF
    !
    IF(PRESENT(IVAL) .AND. IT%N > Z) THEN
        IT%VEC = IVAL
    END IF
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_INTEGER_VECTOR_VALUE(IT,POS,VAL)
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT
     INTEGER,              INTENT(IN   ):: POS,VAL
     !
     IF(IT%N < ONE) CALL ALLOCATE_INTEGER_VECTOR(IT,POS)
     !
     IF(POS .LE. IT%N) THEN
          IT%VEC(POS) = VAL
     ELSEIF(POS > IT%N) THEN
        BLOCK 
            TYPE(INTEGER_VECTOR):: IT2
            CALL IT%MOVE(IT2)
            CALL ALLOCATE_INTEGER_VECTOR(IT,POS)
            CALL IT2%COPY(IT)
            IT%VEC(POS) = VAL
        END BLOCK
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ADD_VAL_INTEGER_VECTOR(IT,IVAL,POS)
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT
     INTEGER,              INTENT(IN   ):: IVAL
     INTEGER,    OPTIONAL, INTENT(IN   ):: POS
     INTEGER, DIMENSION(:), ALLOCATABLE:: TMP
     INTEGER:: P
     !
     IF(PRESENT(POS)) THEN
         IF    (POS >= 0) THEN
                 P = POS
         ELSEIF(POS < 0) THEN
                 P = IT%N + POS + ONE  !-1 IS THE END OF THE LIST
         END IF
     ELSE
                  P = IT%N + ONE
     END IF
     !
     IF (IT%N > 0) THEN
         !
         IT%N = IT%N + ONE
         !
         ALLOCATE(TMP(IT%N))
         !
         IF    ( P==IT%N ) THEN
                               TMP(  :IT%N-1) = IT%VEC
                               TMP(IT%N)      = IVAL
         ELSEIF( P==ONE ) THEN
                               TMP(ONE ) = IVAL
                               TMP(TWO:) = IT%VEC
         ELSE
                               TMP(:P-1) = IT%VEC(:P-1)
                               TMP(P)    = IVAL
                               TMP(P+1:) = IT%VEC(P:)
         END IF
         !
         CALL MOVE_ALLOC(TMP,IT%VEC)
     ELSE
         CALL ALLOCATE_INTEGER_VECTOR(IT, ONE, IVAL)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ADD_UNIQUE_VAL_INTEGER_VECTOR(IT,IVAL)
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT
     INTEGER,              INTENT(IN   ):: IVAL
     !
     IF (IT%N > 0) THEN
         !
         IF(ALL(IVAL.NE.IT%VEC)) CALL ADD_VAL_INTEGER_VECTOR(IT,IVAL)
     ELSE
         CALL ALLOCATE_INTEGER_VECTOR(IT, ONE, IVAL)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MOVE_INTEGER_VECTOR(IT,IT_OUT)
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT
     TYPE (INTEGER_VECTOR),INTENT(INOUT):: IT_OUT
     !
     IF (IT%N > 0) THEN
         IT_OUT%N = IT%N
         IT%N     = Z
         CALL MOVE_ALLOC(IT%VEC,IT_OUT%VEC)
     ELSE
         IT_OUT%N = Z
         IF(ALLOCATED(IT_OUT%VEC)) DEALLOCATE(IT_OUT%VEC)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_INTEGER_VECTOR_OPERATOR(IT_OUT,IT_IN)
     CLASS(INTEGER_VECTOR),INTENT(IN   ):: IT_IN
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT_OUT
      !
      IF (IT_IN%N > Z) THEN
          IF (IT_OUT%N == IT_IN%N) THEN
              IT_OUT%VEC= IT_IN%VEC
          ELSE
              IT_OUT%N = IT_IN%N
              IF(ALLOCATED(IT_OUT%VEC)) DEALLOCATE(IT_OUT%VEC)
              ALLOCATE(IT_OUT%VEC, SOURCE=IT_IN%VEC)
          END IF
      ELSE
          IT_OUT%N = Z
          IF(ALLOCATED(IT_OUT%VEC)) DEALLOCATE(IT_OUT%VEC)
      END IF
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_INTEGER_VECTOR_OPERATOR(IT_OUT,VEC)
     INTEGER, DIMENSION(:),INTENT(IN   ):: VEC
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT_OUT
     INTEGER:: N
     LOGICAL:: ALLOC
     !
     N     = SIZE(VEC)
     ALLOC = ALLOCATED(IT_OUT%VEC)
     !
     IF (N > Z) THEN
         IF(IT_OUT%N == SIZE(VEC) .AND. ALLOC) THEN
                           IT_OUT%VEC = VEC
         ELSEIF(ALLOC) THEN
                DEALLOCATE(IT_OUT%VEC)
                  ALLOCATE(IT_OUT%VEC, SOURCE=VEC)
         ELSE
               ALLOCATE(IT_OUT%VEC, SOURCE=VEC)
         END IF
     ELSE
         IT_OUT%N = Z
         IF(ALLOC) DEALLOCATE(IT_OUT%VEC)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE TRANSFER_INTEGER_VECTOR(IT,IT_OUT)
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT_OUT
     !
     IF (IT%N > 0) THEN
         IF(IT%N <= IT_OUT%N) THEN
             IT_OUT%VEC(:IT%N) = IT%VEC
         ELSE
             IT_OUT = IT
         END IF
     END IF
  END SUBROUTINE
  !
  IMPURE ELEMENTAL FUNCTION GET_INTEGER_BY_INDEX(IT,POS) RESULT (VAL)
     CLASS(INTEGER_VECTOR),INTENT(IN):: IT
     INTEGER,             INTENT(IN):: POS
     INTEGER :: VAL
     !
     IF(Z < POS .AND. POS <= IT%N) THEN
         VAL=IT%VEC(POS)
     ELSE
         VAL = inf_I
     END IF
  END FUNCTION
  !
  PURE ELEMENTAL FUNCTION FIND_INT_POS_INTEGER_VECTOR(IT, IVAL) RESULT(IDX)
    CLASS(INTEGER_VECTOR),INTENT(IN):: IT
    INTEGER,              INTENT(IN):: IVAL
    INTEGER:: IDX
    INTEGER:: I
    !
    IDX = Z
    DO I=ONE, IT%N
        IF(IVAL == IT%VEC(I)) THEN
            IDX = I
            EXIT
        END IF
    END DO
    !
  END FUNCTION
  !
  PURE FUNCTION IS_UNIQUE_INTEGER_VECTOR(IT,I) RESULT(ANS)
    CLASS(INTEGER_VECTOR),INTENT(IN):: IT
    INTEGER,                     INTENT(IN):: I
    LOGICAL:: ANS
    !
    IF(IT%N > Z) THEN
        ANS = ALL(I.NE.IT%VEC)
    ELSE
        ANS = TRUE
    END IF
    !
  END FUNCTION
  !
  PURE FUNCTION NOT_UNIQUE_INTEGER_VECTOR(IT,I) RESULT(ANS)
    CLASS(INTEGER_VECTOR),INTENT(IN):: IT
    INTEGER,              INTENT(IN):: I
    LOGICAL:: ANS
    !
    IF(IT%N > Z) THEN
        ANS = ANY(I == IT%VEC)
    ELSE
        ANS = FALSE
    END IF
    !
  END FUNCTION
  !
  PURE SUBROUTINE REMOVE_LOCATION_INTEGER_VECTOR(IT,POS)
    CLASS(INTEGER_VECTOR), INTENT(INOUT):: IT
    INTEGER, OPTIONAL,     INTENT(IN   ):: POS
    INTEGER, DIMENSION(:), ALLOCATABLE:: TMP
    INTEGER:: N
    !
    N = IT%N - ONE
    !
    IF(IT%N <= ONE) THEN
        !
        N = Z
        IF(ALLOCATED(IT%VEC)) DEALLOCATE(IT%VEC) 
        !
    ELSEIF(PRESENT(POS)) THEN
        IF(POS == ONE) THEN 
                                 ALLOCATE(TMP, SOURCE=IT%VEC(TWO:))
                                 CALL MOVE_ALLOC(TMP,IT%VEC)
        ELSEIF(POS == IT%N) THEN
                                 ALLOCATE(TMP, SOURCE=IT%VEC(:N))
                                 CALL MOVE_ALLOC(TMP,IT%VEC)
        ELSE
                                 ALLOCATE(TMP(N))
                                 TMP(:POS-ONE ) = IT%VEC(:POS-ONE )
                                 TMP( POS+ONE:) = IT%VEC( POS+ONE:)
                                 CALL MOVE_ALLOC(TMP,IT%VEC)
        END IF
    ELSE
        ALLOCATE(TMP, SOURCE=IT%VEC(:N))
        CALL MOVE_ALLOC(TMP,IT%VEC)
    END IF
    !
    IT%N = N
    !
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_INTEGER_VECTOR(IT)
     TYPE(INTEGER_VECTOR),INTENT(INOUT):: IT
     IF(ALLOCATED(IT%VEC)) DEALLOCATE(IT%VEC)
     IT%N=Z
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_INTEGER_VECTOR(IT)
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT
     IF(ALLOCATED(IT%VEC)) DEALLOCATE(IT%VEC)
     IT%N=Z
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE SUBROUTINE INIT_INTEGER_MATRIX_OPERATOR(IT,MAT)
     CLASS(INTEGER_MATRIX),   INTENT(INOUT):: IT
     INTEGER, DIMENSION(:,:), INTENT(IN   ):: MAT
     INTEGER:: DIM1,DIM2
     !
     DIM1 = SIZE(MAT,1)
     DIM2 = SIZE(MAT,2)
     !
     CALL ALLOCATE_INTEGER_MATRIX_SRC(IT,DIM1,DIM2,MAT)
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ALLOCATE_INTEGER_MATRIX(IT,DIM1,DIM2,SRC)
     CLASS(INTEGER_MATRIX),        INTENT(INOUT):: IT
     INTEGER,                      INTENT(IN   ):: DIM1,DIM2
     INTEGER,             OPTIONAL,INTENT(IN   ):: SRC
     !
     IF(DIM1 < ONE .OR. DIM2 < ONE) THEN
         IF(ALLOCATED(IT%MAT)) DEALLOCATE(IT%MAT)
         IT%N=Z
         IT%M=Z
     ELSEIF(IT%N .NE. DIM1 .OR. IT%M .NE. DIM2) THEN
         IF(ALLOCATED(IT%MAT)) DEALLOCATE(IT%MAT)
         IF(PRESENT(SRC)) THEN
                             ALLOCATE(IT%MAT(DIM1,DIM2), SOURCE=SRC)
         ELSE
                             ALLOCATE(IT%MAT(DIM1,DIM2))
         END IF
         IT%N=DIM1
         IT%M=DIM2
    ELSEIF(PRESENT(SRC)) THEN
        IT%MAT = SRC
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOCATE_INTEGER_MATRIX_SRC(IT,DIM1,DIM2,SRC)
     CLASS(INTEGER_MATRIX),                  INTENT(INOUT):: IT
     INTEGER,                               INTENT(IN   ):: DIM1,DIM2
     INTEGER, DIMENSION(DIM1,DIM2),INTENT(IN   ):: SRC
     !
     IF(DIM1 < ONE .OR. DIM2 < ONE) THEN
         IF(ALLOCATED(IT%MAT)) DEALLOCATE(IT%MAT)
         IT%N=Z
         IT%M=Z
     ELSEIF(IT%N .NE. DIM1 .OR. IT%M .NE. DIM2) THEN
         IF(ALLOCATED(IT%MAT)) DEALLOCATE(IT%MAT)
         !
         ALLOCATE(IT%MAT(DIM1,DIM2), SOURCE=SRC)
         IT%N=DIM1
         IT%M=DIM2
    ELSE
        IT%MAT = SRC
    END IF
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MOVE_INTEGER_MATRIX(IT,IT_OUT)
     CLASS(INTEGER_MATRIX),INTENT(INOUT):: IT
     CLASS(INTEGER_MATRIX),INTENT(INOUT):: IT_OUT
     !
     IF (IT%N > 0) THEN
         IT_OUT%N = IT%N
         IT_OUT%M = IT%M
         IT%N     = Z
         IT%M     = Z
         CALL MOVE_ALLOC(IT%MAT,IT_OUT%MAT)
     ELSE
         IT_OUT%N = Z
         IT_OUT%M = Z
         IF(ALLOCATED(IT_OUT%MAT)) DEALLOCATE(IT_OUT%MAT)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_INTEGER_MATRIX_OPERATOR(IT_OUT,IT_IN)
     CLASS(INTEGER_MATRIX),INTENT(IN   ):: IT_IN
     CLASS(INTEGER_MATRIX),INTENT(INOUT):: IT_OUT
      !
      IF (IT_IN%N > Z) THEN
          IT_OUT%N = IT_IN%N
          IT_OUT%M = IT_IN%M
          IF(ALLOCATED(IT_OUT%MAT)) DEALLOCATE(IT_OUT%MAT)
          ALLOCATE(IT_OUT%MAT, SOURCE=IT_IN%MAT)
      ELSE
          IT_OUT%N = Z
          IT_OUT%M = Z
          IF(ALLOCATED(IT_OUT%MAT)) DEALLOCATE(IT_OUT%MAT)
      END IF
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_INTEGER_MATRIX_OPERATOR(IT,MAT)
     CLASS(INTEGER_MATRIX),   INTENT(INOUT):: IT
     INTEGER, DIMENSION(:,:), INTENT(IN   ):: MAT
     INTEGER:: DIM1,DIM2
     !
     DIM1 = SIZE(MAT,1)
     DIM2 = SIZE(MAT,2)
     !
     CALL ALLOCATE_INTEGER_MATRIX_SRC(IT,DIM1,DIM2,MAT)
  END SUBROUTINE
  !
  IMPURE ELEMENTAL FUNCTION GET_INTEGER_MAT_BY_INDEX(IT,POS1,POS2) RESULT (VAL)
     CLASS(INTEGER_MATRIX),INTENT(IN):: IT
     INTEGER,             INTENT(IN):: POS1,POS2
     INTEGER:: VAL
     !
     IF(Z < POS1 .AND. POS1 <= IT%N .AND. Z < POS2 .AND. POS2 <= IT%M) THEN
         VAL=IT%MAT(POS1,POS2)
     ELSE
         VAL = inf_I
     END IF
  END FUNCTION
  !
  PURE ELEMENTAL SUBROUTINE SET_INTEGER_MAT_BY_2_INDEX(IT,POS1,POS2,IVAL)
     CLASS(INTEGER_MATRIX),INTENT(INOUT):: IT
     INTEGER,              INTENT(IN   ):: POS1,POS2,IVAL
     !
     IF(Z < POS1 .AND. POS1 <= IT%N .AND. Z < POS2 .AND. POS2 <= IT%M)  IT%MAT(POS1,POS2) = IVAL
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_INTEGER_MAT_BY_1_INDEX(IT,POS,VEC,DIMSET)
     CLASS(INTEGER_MATRIX),           INTENT(INOUT):: IT
     INTEGER,                         INTENT(IN   ):: POS
     INTEGER,DIMENSION(:),CONTIGUOUS, INTENT(IN   ):: VEC
     INTEGER,             OPTIONAL,   INTENT(IN   ):: DIMSET
     INTEGER:: DIM
     !
     IF(PRESENT(DIMSET)) THEN
         IF    (DIMSET==1) THEN
                               DIM = NEG
         ELSEIF(DIMSET==2) THEN
                               DIM = NINER
         ELSE
                               DIM = SIZE(VEC)
         END IF
    ELSE
                               DIM = SIZE(VEC)
    END IF
    !
    IF    (DIM == IT%N .OR. DIM == NEG  ) THEN
                                              IT%MAT(:,POS) = VEC
    ELSEIF(DIM == IT%M .OR. DIM == NINER) THEN
                                              IT%MAT(POS,:) = VEC
    END IF
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_INTEGER_MATRIX(IT)
     CLASS(INTEGER_MATRIX),INTENT(INOUT):: IT
     IF(ALLOCATED(IT%MAT)) DEALLOCATE(IT%MAT)
     IT%N=Z
     IT%M=Z
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_INTEGER_MATRIX(IT)
     TYPE(INTEGER_MATRIX),INTENT(INOUT):: IT
     IF(ALLOCATED(IT%MAT)) DEALLOCATE(IT%MAT)
     IT%N=Z
     IT%M=Z
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE ELEMENTAL SUBROUTINE ALLOCATE_LOGICAL_VECTOR(TF,DIM,LVAL)
     CLASS(LOGICAL_VECTOR),INTENT(INOUT):: TF
     INTEGER,              INTENT(IN   ):: DIM
     LOGICAL, OPTIONAL,    INTENT(IN   ):: LVAL
     !
     IF(DIM < ONE) THEN
         IF(ALLOCATED(TF%VEC)) DEALLOCATE(TF%VEC)
         TF%N=Z
     ELSEIF(TF%N .NE. DIM) THEN
         IF(ALLOCATED(TF%VEC)) DEALLOCATE(TF%VEC)
         ALLOCATE(TF%VEC(DIM))
         TF%N=DIM
     END IF
     !
     IF(PRESENT(LVAL) .AND. TF%N > Z) THEN
         TF%VEC = LVAL
     END IF
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ADD_VAL_LOGICAL_VECTOR(TF,LVAL,POS)
     CLASS(LOGICAL_VECTOR),INTENT(INOUT):: TF
     LOGICAL,              INTENT(IN   ):: LVAL
     INTEGER,    OPTIONAL, INTENT(IN   ):: POS
     LOGICAL,  DIMENSION(:), ALLOCATABLE:: TMP
     INTEGER:: P
     !
     IF(PRESENT(POS)) THEN
         IF    (POS >= 0) THEN
                 P = POS
         ELSEIF(POS < 0) THEN
                 P = TF%N + POS + ONE  !-1 IS THE END OF THE LIST
         END IF
     ELSE
                  P = TF%N + ONE
     END IF
     !
     IF (TF%N > 0) THEN
         !
         TF%N = TF%N + ONE
         !
         ALLOCATE(TMP(TF%N))
         !
         IF    ( P==TF%N ) THEN
                               TMP(  :TF%N-1) = TF%VEC
                               TMP(TF%N)      = LVAL
         ELSEIF( P==ONE ) THEN
                               TMP(ONE ) = LVAL
                               TMP(TWO:) = TF%VEC
         ELSE
                               TMP(:P-1) = TF%VEC(:P-1)
                               TMP(P)    = LVAL
                               TMP(P+1:) = TF%VEC(P:)
         END IF
         !
         CALL MOVE_ALLOC(TMP,TF%VEC)
     ELSE
         CALL ALLOCATE_LOGICAL_VECTOR(TF, ONE, LVAL)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MOVE_LOGICAL_VECTOR(TF,TF_OUT)
     CLASS(LOGICAL_VECTOR),INTENT(INOUT):: TF
     CLASS(LOGICAL_VECTOR),INTENT(INOUT):: TF_OUT
     !
     IF (TF%N > 0) THEN
         TF_OUT%N = TF%N
         TF%N     = Z
         CALL MOVE_ALLOC(TF%VEC,TF_OUT%VEC)
     ELSE
         TF_OUT%N = Z
         IF(ALLOCATED(TF_OUT%VEC)) DEALLOCATE(TF_OUT%VEC)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_LOGICAL_VECTOR_OPERATOR(TF_OUT,TF_IN)
     CLASS(LOGICAL_VECTOR),INTENT(IN   ):: TF_IN
     CLASS(LOGICAL_VECTOR),INTENT(INOUT):: TF_OUT
      !
      IF (TF_IN%N > Z) THEN
          TF_OUT%N = TF_IN%N
          IF(ALLOCATED(TF_OUT%VEC)) DEALLOCATE(TF_OUT%VEC)
          ALLOCATE(TF_OUT%VEC, SOURCE=TF_IN%VEC)
      ELSE
          TF_OUT%N = Z
          IF(ALLOCATED(TF_OUT%VEC)) DEALLOCATE(TF_OUT%VEC)
      END IF
  END SUBROUTINE
  !
  IMPURE ELEMENTAL FUNCTION GET_LOGICAL_BY_INDEX(TF,POS) RESULT (VAL)
     CLASS(LOGICAL_VECTOR),INTENT(IN):: TF
     INTEGER,             INTENT(IN):: POS
     LOGICAL:: VAL
     !
     IF(Z < POS .AND. POS <= TF%N) THEN
         VAL=TF%VEC(POS)
     ELSE
         VAL=FALSE
     END IF
  END FUNCTION
  !    
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_LOGICAL_VECTOR(TF)
     CLASS(LOGICAL_VECTOR),INTENT(INOUT):: TF
     IF(ALLOCATED(TF%VEC)) DEALLOCATE(TF%VEC)
     TF%N=Z
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_LOGICAL_VECTOR(TF)
     TYPE(LOGICAL_VECTOR),INTENT(INOUT):: TF
     IF(ALLOCATED(TF%VEC)) DEALLOCATE(TF%VEC)
     TF%N=Z
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  !
  PURE SUBROUTINE ALLOCATE_CVS(CVS, N, NDIM, NEW_ALLOC)
    !VEC IS VECTOR TO ALLOCATE
    !N IS THE DIMENSION TO ALLOCATE. IF <1 THEN SUBROUTINE DOES NOTHING
    !EXACT IF SET TO TRUE TO INDICATE ALLOCATION MUST MATCH N  (DEFAULT)
    !      IF SET TO FALSE THEN IF ALREADY ALLOCATED AND ALLOCATION IS GREATER THAN N, THEN NOTHING IS DONE
    CLASS (COMPRESSED_VALUE_STORAGE),   INTENT(INOUT):: CVS
    INTEGER,                            INTENT(IN   ):: N
    INTEGER,                  OPTIONAL, INTENT(IN   ):: NDIM  !Default to 2
    LOGICAL,                  OPTIONAL, INTENT(OUT  ):: NEW_ALLOC
    LOGICAL:: NEW_ALLOCATION
    INTEGER:: M
    !
    NEW_ALLOCATION  = FALSE
    CVS%IS_CONSTANT = FALSE
    !
    IF    (PRESENT(NDIM)) THEN; M = NDIM
    ELSEIF(CVS%M  > Z   ) THEN; M = CVS%M
    ELSE;                       M = TWO
    END IF
    !
    IF(N > Z) THEN
                  NEW_ALLOCATION = CVS%N.NE.N .OR. CVS%M.NE.M
                  !
                  IF(NEW_ALLOCATION) THEN
                      !
                      CALL DEALLCOATE_COMPRESSED_VALUE_STORAGE(CVS)
                      !
                      CVS%N = N
                      CVS%M = M
                      ALLOCATE(CVS%DIM(M,N))
                      ALLOCATE(CVS%VAL(N))
                  END IF
    ELSE
                  CALL DEALLCOATE_COMPRESSED_VALUE_STORAGE(CVS)
    END IF
    !
    IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=NEW_ALLOCATION
    !
  END SUBROUTINE
  !
  SUBROUTINE BUILD_NONZERO_CVS(CVS, ARR, TOLERANCE)
    CLASS (COMPRESSED_VALUE_STORAGE),            INTENT(INOUT):: CVS
    DOUBLE PRECISION, DIMENSION(:,:),CONTIGUOUS, INTENT(IN   ):: ARR
    DOUBLE PRECISION,                  OPTIONAL, INTENT(IN   ):: TOLERANCE
    INTEGER:: I,J,K,N,DIM1,DIM2
    DOUBLE PRECISION:: TOL
    !
    CVS%IS_CONSTANT = FALSE
    !
    DIM1 = SIZE(ARR, ONE)
    DIM2 = SIZE(ARR, TWO)
    !
    IF(PRESENT(TOLERANCE)) THEN
        TOL = TOLERANCE
    ELSE
        TOL = NEARZERO_30
    END IF
    !
    N = Z
    DO CONCURRENT (I=ONE:DIM1, J=ONE:DIM2, ABS(ARR(I,J)) > TOL .AND. ARR(I,J) == ARR(I,J));  N = N + ONE
    END  DO
    !
    IF(N == DIM1*DIM2 .AND. N > Z) THEN  !CHECK IF ALL THE SAME VALUES
                                   !
                                   N = Z
                                   DO CONCURRENT (I=ONE:DIM1, J=ONE:DIM2, ABS(ARR(ONE,ONE)-ARR(I,J)) < TOL);  N = N + ONE
                                   END  DO
                                   CVS%IS_CONSTANT = N == DIM1*DIM2
    END IF
    !
    IF(CVS%IS_CONSTANT) THEN
                                   CALL ALLOCATE_CVS(CVS, ONE, TWO)
                                   !
                                   N = INT(ARR(ONE,ONE))
                                   CVS%DIM = N
                                   CVS%VAL = ARR(ONE,ONE)
    ELSEIF (N > Z) THEN
                       IF( N .NE. CVS%N) THEN
                                             CALL DEALLCOATE_COMPRESSED_VALUE_STORAGE(CVS)
                                             CVS%N = N
                                             ALLOCATE(CVS%DIM(TWO,N))
                                             ALLOCATE(CVS%VAL(N))
                       END IF
                       !
                       K=Z
                       DO I=ONE, DIM1
                       DO J=ONE, DIM2
                             IF( ABS(ARR(I,J)) > TOL .AND. ARR(I,J) == ARR(I,J) ) THEN
                                   K = K + ONE
                                   CVS%DIM(ONE,K) = I
                                   CVS%DIM(TWO,K) = J
                                   CVS%VAL(K)     = ARR(I,J)
                             END IF
                       END DO
                       END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE DEALLCOATE_COMPRESSED_VALUE_STORAGE(CVS)
    CLASS (COMPRESSED_VALUE_STORAGE), INTENT(INOUT):: CVS
    !
    CVS%N = Z
    CVS%M = Z
    IF(ALLOCATED(CVS%DIM)) DEALLOCATE(CVS%DIM)
    IF(ALLOCATED(CVS%VAL)) DEALLOCATE(CVS%VAL)
    ! 
  END SUBROUTINE
  !
  PURE SUBROUTINE DEALLCOATE_COMPRESSED_VALUE_STORAGE_FINAL(CVS)
    TYPE (COMPRESSED_VALUE_STORAGE), INTENT(INOUT):: CVS
    !
    CALL DEALLCOATE_COMPRESSED_VALUE_STORAGE(CVS)
    ! 
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE SUBROUTINE ALLOCATE_LAC(LAC, N, NDIM, NEW_ALLOC)
    CLASS (COMPRESSED_LOCATION_STORAGE), INTENT(INOUT):: LAC
    INTEGER,                             INTENT(IN   ):: N
    INTEGER,                   OPTIONAL, INTENT(IN   ):: NDIM  !Default to 2
    LOGICAL,                   OPTIONAL, INTENT(OUT  ):: NEW_ALLOC
    LOGICAL:: NEW_ALLOCATION
    INTEGER:: M
    !
    NEW_ALLOCATION  = FALSE
    LAC%IS_CONSTANT = FALSE
    !
    IF    (PRESENT(NDIM)) THEN; M = NDIM
    ELSEIF(LAC%M  > Z   ) THEN; M = LAC%M
    ELSE;                       M = TWO
    END IF
    !
    IF(N > Z) THEN
                  NEW_ALLOCATION = LAC%SIZ < N .OR. LAC%M.NE.M
                  !
                  IF(NEW_ALLOCATION) THEN
                      !
                      CALL DEALLCOATE_COMPRESSED_LOCATION_STORAGE(LAC)
                      !
                      LAC%SIZ = N
                      LAC%N   = Z
                      LAC%M   = M
                      ALLOCATE(LAC%DIM(M,N))
                  END IF
    END IF
    !
    IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=NEW_ALLOCATION
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE BUILD_COMPRESSED_LOCATION_STORAGE_DIM2(LAC, ID, ARR)
    CLASS (COMPRESSED_LOCATION_STORAGE),         INTENT(INOUT):: LAC
    INTEGER,                                     INTENT(IN   ):: ID
    INTEGER, DIMENSION(:,:),         CONTIGUOUS, INTENT(IN   ):: ARR
    INTEGER:: I,J,K,N,DIM1,DIM2
    !
    DIM1 = SIZE(ARR, ONE)
    DIM2 = SIZE(ARR, TWO)
    !
    LAC%ID = ID
    LAC%IS_CONSTANT = FALSE
    !
    N = Z
    DO CONCURRENT (J=ONE:DIM2, I=ONE:DIM1, ARR(I,J) == ID);  N = N + ONE
    END  DO
    !
    LAC%N = N
    !
    IF(N == DIM1*DIM2 .AND. N > Z) THEN
                                   LAC%IS_CONSTANT = TRUE
                                   LAC%N = ONE
                                   N     = ONE
                                   IF( N > LAC%SIZ .OR. LAC%M.NE.TWO) THEN
                                                         CALL DEALLCOATE_COMPRESSED_LOCATION_STORAGE(LAC)
                                                         ALLOCATE(LAC%DIM(TWO,N))
                                                         LAC%SIZ = N
                                   END IF
    ELSEIF (N > Z) THEN
                       IF( N > LAC%SIZ .OR. LAC%M.NE.TWO) THEN
                                             CALL DEALLCOATE_COMPRESSED_LOCATION_STORAGE(LAC)
                                             ALLOCATE(LAC%DIM(TWO,N))
                                             LAC%SIZ = N
                       END IF
                       !
                       K=Z
                       DO J=ONE, DIM2
                       DO I=ONE, DIM1
                             IF( ARR(I,J) == ID ) THEN
                                   K = K + ONE
                                   LAC%DIM(ONE,K) = I
                                   LAC%DIM(TWO,K) = J
                             END IF
                       END DO
                       END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE BUILD_COMPRESSED_LOCATION_STORAGE_DIM3(LAC, ID, ARR)
    CLASS (COMPRESSED_LOCATION_STORAGE),         INTENT(INOUT):: LAC
    INTEGER,                                     INTENT(IN   ):: ID
    INTEGER, DIMENSION(:,:,:),       CONTIGUOUS, INTENT(IN   ):: ARR
    INTEGER:: I,J,K,N,DIM1,DIM2,DIM3
    !
    DIM1 = SIZE(ARR, ONE)
    DIM2 = SIZE(ARR, TWO)
    DIM3 = SIZE(ARR, THREE)
    !
    LAC%ID = ID
    LAC%IS_CONSTANT = FALSE
    !
    N = Z
    DO CONCURRENT (K=ONE:DIM3, J=ONE:DIM2, I=ONE:DIM1, ARR(I,J,K) == ID);  N = N + ONE
    END  DO
    !
    LAC%N = N
    IF(N == DIM1*DIM2*DIM3 .AND. N > Z) THEN
                                   LAC%IS_CONSTANT = TRUE
                                   LAC%N = ONE
                                   N     = ONE
                                   IF( N > LAC%SIZ .OR. LAC%M.NE.TWO) THEN
                                                         CALL DEALLCOATE_COMPRESSED_LOCATION_STORAGE(LAC)
                                                         ALLOCATE(LAC%DIM(THREE,N))
                                                         LAC%SIZ = N
                                   END IF
    ELSEIF (N > Z) THEN
                       IF( N > LAC%SIZ .OR. LAC%M.NE.THREE) THEN
                                             CALL DEALLCOATE_COMPRESSED_LOCATION_STORAGE(LAC)
                                             ALLOCATE(LAC%DIM(THREE,N))
                                             LAC%SIZ = N
                       END IF
                       !
                       N=Z
                       DO K=ONE, DIM3
                       DO J=ONE, DIM2
                       DO I=ONE, DIM1
                             IF( ARR(I,J,K) == ID ) THEN
                                   N = N + ONE
                                   LAC%DIM(  ONE,N) = I                   
                                   LAC%DIM(  TWO,N) = J                 
                                   LAC%DIM(THREE,N) = K
                             END IF
                       END DO
                       END DO
                       END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE BUILD_COMPRESSED_LOCATION_STORAGE_ALOC(LAC, ARR, HAS_ZERO, ID)
    CLASS (COMPRESSED_LOCATION_STORAGE),DIMENSION(:),ALLOCATABLE, INTENT(INOUT):: LAC
    INTEGER, DIMENSION(:,:),                          CONTIGUOUS, INTENT(IN   ):: ARR
    LOGICAL,                                            OPTIONAL, INTENT(IN   ):: HAS_ZERO
    INTEGER, DIMENSION(:),ALLOCATABLE,                  OPTIONAL, INTENT(INOUT):: ID
    INTEGER:: I,J,K,N,DIM1,DIM2,SIZ
    INTEGER, DIMENSION(:), ALLOCATABLE:: TMP1, TMP2
    LOGICAL:: DO_Z
    !
    DIM1 = SIZE(ARR, ONE)
    DIM2 = SIZE(ARR, TWO)
    !
    IF(PRESENT(HAS_ZERO)) THEN
        DO_Z = HAS_ZERO
    ELSE
        DO_Z = FALSE
    END IF
    !
    ALLOCATE(TMP1(64), SOURCE=Z)
    SIZ = 64
    N   = Z
    !
    IF(DO_Z) THEN
       DO J=ONE,DIM2
       DO I=ONE,DIM1
           IF( N==Z ) THEN
                                               N = N + ONE
                                               TMP1(ONE) = ARR(I,J)
           ELSEIF( ALL(ARR(I,J).NE.TMP1(:N)) ) THEN
               !
               N = N + ONE
               IF(N > SIZ) THEN
                   ALLOCATE(TMP2(N+63))
                   TMP2(:SIZ) = TMP1
                   CALL MOVE_ALLOC(TMP2, TMP1)
                   SIZ = N+FIFTY
               END IF
               !
               TMP1(N) = ARR(I,J)
           END IF
       END DO
       END DO
    ELSE
       DO J=ONE,DIM2
       DO I=ONE,DIM1
         IF(ARR(I,J).NE.Z) THEN
           IF( N==Z ) THEN
                                               N = N + ONE
                                               TMP1(ONE) = ARR(I,J)
           ELSEIF( ALL(ARR(I,J).NE.TMP1(:N)) ) THEN
               !
               N = N + ONE
               IF(N > SIZ) THEN
                   ALLOCATE(TMP2(N+63))
                   TMP2(:SIZ) = TMP1
                   CALL MOVE_ALLOC(TMP2, TMP1)
                   SIZ = N+FIFTY
               END IF
               !
               TMP1(N) = ARR(I,J)
           END IF
         END IF
       END DO
       END DO
    END IF
    !
    ! SORT VALUES
    !
    DO I=2, N
        K=TMP1(I)
        J=I
        DO WHILE ( J > ONE )
                           IF (TMP1(J-ONE) < K) EXIT
                           TMP1(J) = TMP1(J-ONE)
                           J=J-ONE
        END DO
        TMP1(J) = K
    END DO
    !
    IF(ALLOCATED(LAC)) THEN
        IF(SIZE(LAC).NE.N) THEN
            DEALLOCATE(LAC)
              ALLOCATE(LAC(N))
        END IF
    ELSE
        ALLOCATE(LAC(N))
    END IF
    !
    DO CONCURRENT(I=ONE:N)
        CALL BUILD_COMPRESSED_LOCATION_STORAGE_DIM2(LAC(I), TMP1(I), ARR)
    END DO
    !
    IF(PRESENT(ID)) THEN
        IF(ALLOCATED(ID)) THEN
          IF(SIZE(ID).NE.N) THEN
              DEALLOCATE(ID)
                ALLOCATE(ID(N))
          END IF
        ELSE
            ALLOCATE(ID(N))
        END IF
        !
        ID = TMP1(:N)
    END IF
    !
  END SUBROUTINE
  ! 
  PURE SUBROUTINE DEALLCOATE_COMPRESSED_LOCATION_STORAGE(LAC)
    CLASS (COMPRESSED_LOCATION_STORAGE), INTENT(INOUT):: LAC
    !
    LAC%ID  = Z
    LAC%N   = Z
    LAC%M   = Z
    LAC%SIZ = Z
    !
    LAC%IS_CONSTANT = FALSE
    !
    IF(ALLOCATED(LAC%DIM) ) DEALLOCATE(LAC%DIM)
    ! 
  END SUBROUTINE
  !
  PURE SUBROUTINE DEALLCOATE_COMPRESSED_LOCATION_STORAGE_FINAL(LAC)
    TYPE (COMPRESSED_LOCATION_STORAGE), INTENT(INOUT):: LAC
    !
    CALL DEALLCOATE_COMPRESSED_LOCATION_STORAGE(LAC)
    ! 
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE SUBROUTINE ALLOC_ID1_ID2_RAT_VOL_TYPE(TYP, DIM)
    CLASS(ID1_ID2_RAT_VOL_TYPE), INTENT(INOUT):: TYP
    INTEGER,            INTENT(IN   ):: DIM
    !
    IF(ALLOCATED(TYP%PT)) DEALLOCATE(TYP%PT)
    !
    IF(DIM > Z) THEN
                  ALLOCATE(TYP%PT(DIM))
                  TYP%N = DIM
                  TYP%INUSE = TRUE
    ELSE
                  TYP%N     = Z
                  TYP%INUSE = FALSE
    END IF
  END SUBROUTINE
  !
  !
  PURE SUBROUTINE EXTEND_ID1_ID2_RAT_VOL_TYPE(TYP, ID1, ID2, RAT, VOL)
    CLASS(ID1_ID2_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    INTEGER,                           INTENT(IN   ):: ID1, ID2
    DOUBLE PRECISION,                  INTENT(IN   ):: RAT, VOL
    TYPE (ID1_ID2_RAT_VOL_TYPE):: EXT
    !
    TYP%INUSE = TRUE
    !
    IF(TYP%N == Z) THEN
                  TYP%N = ONE
                  !
                  ALLOCATE( TYP%PT(TYP%N) )
                  TYP%PT(TYP%N)%ID1 = ID1;   TYP%PT(TYP%N)%ID2 = ID2
                  TYP%PT(TYP%N)%RAT  = RAT;    TYP%PT(TYP%N)%VOL  = VOL
    ELSE
                  EXT%N = TYP%N + ONE
                  !
                  ALLOCATE( EXT%PT (EXT%N) )
                  EXT%PT(:TYP%N)  = TYP%PT
                  !
                  EXT%PT(EXT%N)%ID1 = ID1;   EXT%PT(EXT%N)%ID2 = ID2
                  EXT%PT(EXT%N)%RAT  = RAT;    EXT%PT(EXT%N)%VOL  = VOL
                  !
                  CALL MOVE_ALLOC(EXT%PT,  TYP%PT)
                  TYP%N = EXT%N
    END IF
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_RAT_ID1_ID2_RAT_VOL_TYPE(TYP, ID1, ID2, RAT)
    CLASS(ID1_ID2_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    INTEGER,                       INTENT(IN   ):: ID1, ID2
    DOUBLE PRECISION,              INTENT(IN   ):: RAT
    INTEGER:: I
    !
    DO I=ONE, TYP%N
        IF(ID1 == TYP%PT(I)%ID1 .AND. ID2 == TYP%PT(I)%ID2) THEN
            TYP%PT(I)%RAT = RAT
            EXIT
        END IF
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_VOL_ID1_ID2_RAT_VOL_TYPE(TYP, ID1, ID2, VOL)
    CLASS(ID1_ID2_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    INTEGER,                       INTENT(IN   ):: ID1, ID2
    DOUBLE PRECISION,              INTENT(IN   ):: VOL
    INTEGER:: I
    !
    DO I=ONE, TYP%N
        IF(ID1 == TYP%PT(I)%ID1 .AND. ID2 == TYP%PT(I)%ID2) THEN
            TYP%PT(I)%VOL = VOL
            EXIT
        END IF
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_RAT_ID1_ID2_RAT_VOL_TYPE(TYP, DELT)
    CLASS(ID1_ID2_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    DOUBLE PRECISION,              INTENT(IN   ):: DELT
    INTEGER:: I
    !
    DO I=ONE, TYP%N
              TYP%PT(I)%RAT = TYP%PT(I)%VOL / DELT
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_VOL_ID1_ID2_RAT_VOL_TYPE(TYP, DELT)
    CLASS(ID1_ID2_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    DOUBLE PRECISION,              INTENT(IN   ):: DELT
    INTEGER:: I
    !
    DO I=ONE, TYP%N
              TYP%PT(I)%VOL = TYP%PT(I)%RAT * DELT
    END DO
    !
  END SUBROUTINE
  !
  PURE FUNCTION GET_RAT_ID1_ID2_RAT_VOL_TYPE(TYP, ID1, ID2, EVAL) RESULT(RAT)
    CLASS(ID1_ID2_RAT_VOL_TYPE), INTENT(IN):: TYP
    INTEGER,                     INTENT(IN):: ID1, ID2
    DOUBLE PRECISION, OPTIONAL,  INTENT(IN):: EVAL
    DOUBLE PRECISION:: RAT
    INTEGER:: I
    !
    IF(PRESENT(EVAL)) THEN
        RAT = EVAL
    ELSE
        RAT = IEEE_VALUE(RAT, IEEE_QUIET_NAN)
    END IF
    !
    DO I=ONE, TYP%N
        IF(ID1 == TYP%PT(I)%ID1 .AND. ID2 == TYP%PT(I)%ID2) THEN
            RAT = TYP%PT(I)%RAT
            EXIT
        END IF
    END DO
    !
  END FUNCTION
  !
  PURE FUNCTION GET_VOL_ID1_ID2_RAT_VOL_TYPE(TYP, ID1, ID2, EVAL) RESULT(VOL)
    CLASS(ID1_ID2_RAT_VOL_TYPE), INTENT(IN):: TYP
    INTEGER,                     INTENT(IN):: ID1, ID2
    DOUBLE PRECISION, OPTIONAL,  INTENT(IN):: EVAL
    DOUBLE PRECISION:: VOL
    INTEGER:: I
    !
    IF(PRESENT(EVAL)) THEN
        VOL = EVAL
    ELSE
        VOL = IEEE_VALUE(VOL, IEEE_QUIET_NAN)
    END IF
    !
    DO I=ONE, TYP%N
        IF(ID1 == TYP%PT(I)%ID1 .AND. ID2 == TYP%PT(I)%ID2) THEN
            VOL = TYP%PT(I)%VOL
            EXIT
        END IF
    END DO
    !
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE SUBROUTINE ALLOC_ID_RAT_VOL_TYPE(TYP, DIM)
    CLASS(ID_RAT_VOL_TYPE),     INTENT(INOUT):: TYP
    INTEGER,                    INTENT(IN   ):: DIM
    !
    IF(ALLOCATED(TYP%PT)) DEALLOCATE(TYP%PT)
    !
    IF(DIM > Z) THEN
                  ALLOCATE(TYP%PT(DIM))
                  TYP%N = DIM
                  TYP%INUSE = TRUE
    ELSE
                  TYP%N     = Z
                  TYP%INUSE = FALSE
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOC_ID_RAT_VOL_TYPE_INIT_SCA(TYP, DIM, INIT)
    CLASS(ID_RAT_VOL_TYPE),     INTENT(INOUT):: TYP
    INTEGER,                    INTENT(IN   ):: DIM
    DOUBLE PRECISION,           INTENT(IN   ):: INIT !If present then make ID sequential and set VAL to INIT
    INTEGER:: I
    !
    CALL ALLOC_ID_RAT_VOL_TYPE(TYP, DIM)
    !
    DO I=ONE, DIM
        TYP%PT(I)%ID  = I
        TYP%PT(I)%RAT = INIT
        TYP%PT(I)%VOL = INIT
    END DO
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOC_ID_RAT_VOL_TYPE_INIT_VEC(TYP, DIM, INIT)
    CLASS(ID_RAT_VOL_TYPE),          INTENT(INOUT):: TYP
    INTEGER,                         INTENT(IN   ):: DIM
    DOUBLE PRECISION,DIMENSION(DIM), INTENT(IN   ):: INIT !If present then make ID sequential and set VAL to INIT
    INTEGER:: I
    !
    CALL ALLOC_ID_RAT_VOL_TYPE(TYP, DIM)
    !
    DO I=ONE, DIM
        TYP%PT(I)%ID  = I
        TYP%PT(I)%RAT = INIT(I)
        TYP%PT(I)%VOL = INIT(I)
    END DO
  END SUBROUTINE
  !
  SUBROUTINE EXTEND_ID_RAT_VOL_TYPE(TYP, ID, RAT, VOL)
    CLASS(ID_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    INTEGER,                           INTENT(IN   ):: ID
    DOUBLE PRECISION,                  INTENT(IN   ):: RAT, VOL
    TYPE (ID_RAT_VOL_TYPE):: EXT
    !
    TYP%INUSE = TRUE
    !
    IF(TYP%N == Z) THEN
                  TYP%N = ONE
                  !
                  ALLOCATE( TYP%PT(TYP%N) )
                  TYP%PT(TYP%N)%ID = ID;   TYP%PT(TYP%N)%RAT = RAT;   TYP%PT(TYP%N)%VOL = VOL
    ELSE
                  EXT%N = TYP%N + ONE
                  !
                  ALLOCATE( EXT%PT (EXT%N) )
                  EXT%PT(:TYP%N)  = TYP%PT
                  !
                  EXT%PT(EXT%N)%ID = ID;   EXT%PT(EXT%N)%RAT = RAT;   EXT%PT(EXT%N)%VOL = VOL
                  !
                  CALL MOVE_ALLOC(EXT%PT,  TYP%PT)
                  TYP%N = EXT%N
    END IF
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_RAT_ID_RAT_VOL_TYPE(TYP, ID, RAT)
    CLASS(ID_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    INTEGER,                 INTENT(IN   ):: ID
    DOUBLE PRECISION,        INTENT(IN   ):: RAT
    INTEGER:: I
    !
    DO I=ONE, TYP%N
        IF(ID == TYP%PT(I)%ID) THEN
            TYP%PT(I)%RAT = RAT
            EXIT
        END IF
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_VOL_ID_RAT_VOL_TYPE(TYP, ID, VOL)
    CLASS(ID_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    INTEGER,                 INTENT(IN   ):: ID
    DOUBLE PRECISION,        INTENT(IN   ):: VOL
    INTEGER:: I
    !
    DO I=ONE, TYP%N
        IF(ID == TYP%PT(I)%ID) THEN
            TYP%PT(I)%VOL = VOL
            EXIT
        END IF
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_RAT_ID_RAT_VOL_TYPE(TYP, DELT)
    CLASS(ID_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    DOUBLE PRECISION,       INTENT(IN   ):: DELT
    INTEGER:: I
    !
    DO I=ONE, TYP%N
              TYP%PT(I)%RAT =  TYP%PT(I)%VOL / DELT
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_VOL_ID_RAT_VOL_TYPE(TYP, DELT)
    CLASS(ID_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    DOUBLE PRECISION,       INTENT(IN   ):: DELT
    INTEGER:: I
    !
    DO I=ONE, TYP%N
              TYP%PT(I)%VOL = TYP%PT(I)%RAT * DELT
    END DO
    !
  END SUBROUTINE
  !
  PURE FUNCTION GET_RAT_ID_RAT_VOL_TYPE(TYP, ID, EVAL) RESULT(RAT)
    CLASS(ID_RAT_VOL_TYPE),     INTENT(IN):: TYP
    INTEGER,                    INTENT(IN):: ID
    DOUBLE PRECISION, OPTIONAL, INTENT(IN):: EVAL
    DOUBLE PRECISION:: RAT
    INTEGER:: I
    !
    IF(PRESENT(EVAL)) THEN
        RAT = EVAL
    ELSE
        RAT = IEEE_VALUE(RAT, IEEE_QUIET_NAN)
    END IF
    !
    DO I=ONE, TYP%N
        IF(ID == TYP%PT(I)%ID) THEN
            RAT = TYP%PT(I)%RAT
            EXIT
        END IF
    END DO
    !
  END FUNCTION
  !
  PURE FUNCTION GET_VOL_ID_RAT_VOL_TYPE(TYP, ID, EVAL) RESULT(VOL)
    CLASS(ID_RAT_VOL_TYPE),     INTENT(IN):: TYP
    INTEGER,                    INTENT(IN):: ID
    DOUBLE PRECISION, OPTIONAL, INTENT(IN):: EVAL
    DOUBLE PRECISION:: VOL
    INTEGER:: I
    !
    IF(PRESENT(EVAL)) THEN
        VOL = EVAL
    ELSE
        VOL = IEEE_VALUE(VOL, IEEE_QUIET_NAN)
    END IF
    !
    DO I=ONE, TYP%N
        IF(ID == TYP%PT(I)%ID) THEN
            VOL = TYP%PT(I)%VOL
            EXIT
        END IF
    END DO
    !
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE SUBROUTINE ALLOC_ID_VAL_TYPE(TYP, DIM)
    CLASS(ID_VAL_TYPE),         INTENT(INOUT):: TYP
    INTEGER,                    INTENT(IN   ):: DIM
    !
    IF(ALLOCATED(TYP%PT)) DEALLOCATE(TYP%PT)
    !
    IF(DIM > Z) THEN
                  ALLOCATE(TYP%PT(DIM))
                  TYP%N = DIM
                  TYP%INUSE = TRUE
    ELSE
                  TYP%N     = Z
                  TYP%INUSE = FALSE
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOC_ID_VAL_TYPE_INIT_SCA(TYP, DIM, INIT)
    CLASS(ID_VAL_TYPE),         INTENT(INOUT):: TYP
    INTEGER,                    INTENT(IN   ):: DIM
    DOUBLE PRECISION,           INTENT(IN   ):: INIT !If present then make ID sequential and set VAL to INIT
    INTEGER:: I
    !
    CALL ALLOC_ID_VAL_TYPE(TYP, DIM)
    !
    DO I=ONE, DIM
        TYP%PT(I)%ID  = I
        TYP%PT(I)%VAL = INIT
    END DO
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOC_ID_VAL_TYPE_INIT_VEC(TYP, DIM, INIT)
    CLASS(ID_VAL_TYPE),               INTENT(INOUT):: TYP
    INTEGER,                          INTENT(IN   ):: DIM
    DOUBLE PRECISION, DIMENSION(DIM), INTENT(IN   ):: INIT
    INTEGER:: I
    !
    CALL ALLOC_ID_VAL_TYPE(TYP, DIM)
    !
    DO I=ONE, DIM
        TYP%PT(I)%ID  = I
        TYP%PT(I)%VAL = INIT(I)
    END DO
  END SUBROUTINE
  !
  PURE SUBROUTINE EXTEND_ID_VAL_TYPE(TYP, ID, VAL)
    CLASS(ID_VAL_TYPE), INTENT(INOUT)::TYP
    INTEGER,            INTENT(IN   ):: ID
    DOUBLE PRECISION,   INTENT(IN   ):: VAL
    TYPE (ID_VAL_TYPE):: EXT
    !
    TYP%INUSE = TRUE
    !
    IF(TYP%N == Z) THEN
                  TYP%N = ONE
                  !
                  ALLOCATE( TYP%PT(TYP%N) )
                  TYP%PT(TYP%N)%ID = ID;   TYP%PT(TYP%N)%VAL = VAL
    ELSE
                  EXT%N = TYP%N + ONE
                  !
                  ALLOCATE( EXT%PT (EXT%N) )
                  EXT%PT(:TYP%N)  = TYP%PT
                  !
                  EXT%PT(EXT%N)%ID = ID;   EXT%PT(EXT%N)%VAL = VAL
                  !
                  CALL MOVE_ALLOC(EXT%PT,  TYP%PT)
                  TYP%N = EXT%N
    END IF
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_VAL_ID_VAL_TYPE(TYP, ID, VAL)
    CLASS(ID_VAL_TYPE), INTENT(INOUT)::TYP
    INTEGER,            INTENT(IN   ):: ID
    DOUBLE PRECISION,   INTENT(IN   ):: VAL
    INTEGER:: I
    !
    DO I=ONE, TYP%N
        IF(ID == TYP%PT(I)%ID) THEN
            TYP%PT(I)%VAL = VAL
            EXIT
        END IF
    END DO
    !
  END SUBROUTINE
  !
  PURE FUNCTION GET_VAL_ID_VAL_TYPE(TYP, ID, EVAL) RESULT(VAL)
    CLASS(ID_VAL_TYPE),         INTENT(IN):: TYP
    INTEGER,                    INTENT(IN):: ID
    DOUBLE PRECISION, OPTIONAL, INTENT(IN):: EVAL
    DOUBLE PRECISION:: VAL
    INTEGER:: I
    !
    IF(PRESENT(EVAL)) THEN
        VAL = EVAL
    ELSE
        VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)
    END IF
    !
    DO I=ONE, TYP%N
        IF(ID == TYP%PT(I)%ID) THEN
            VAL = TYP%PT(I)%VAL
            EXIT
        END IF
    END DO
    !
  END FUNCTION
  !
  PURE SUBROUTINE SET_ID_VAL_TYPE_ALL(TYP, ID, VAL)
    CLASS(ID_VAL_TYPE),                 INTENT(INOUT)::TYP
    INTEGER,          DIMENSION(TYP%N), INTENT(IN   ):: ID
    DOUBLE PRECISION, DIMENSION(TYP%N), INTENT(IN   ):: VAL
    INTEGER:: I
    !
    DO I=ONE, TYP%N
            TYP%PT(I)%ID  = ID(I)
            TYP%PT(I)%VAL = VAL(I)
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_ID_VAL_TYPE_POS(TYP, POS, ID, VAL)
    CLASS(ID_VAL_TYPE), INTENT(INOUT)::TYP
    INTEGER,            INTENT(IN   ):: POS, ID
    DOUBLE PRECISION,   INTENT(IN   ):: VAL
    INTEGER:: I
    !
    IF( Z < POS .AND. POS <= TYP%N) THEN
        TYP%PT(POS)%ID  = ID
        TYP%PT(POS)%VAL = VAL
    ELSEIF(TYP%N < POS) THEN
        DO I= TYP%N+ONE, POS
                         CALL EXTEND_ID_VAL_TYPE(TYP, ID, VAL)
        END DO
    END IF
    !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE SUBROUTINE ALLOC_RAT_VOL_TYPE(TYP, DIM)
    CLASS(RAT_VOL_TYPE),     INTENT(INOUT):: TYP
    INTEGER,                 INTENT(IN   ):: DIM
    !
    IF(ALLOCATED(TYP%PT)) DEALLOCATE(TYP%PT)
    !
    IF(DIM > Z) THEN
                  ALLOCATE(TYP%PT(DIM))
                  TYP%N = DIM
                  TYP%INUSE = TRUE
    ELSE
                  TYP%N     = Z
                  TYP%INUSE = FALSE
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOC_RAT_VOL_TYPE_INIT_SCA(TYP, DIM, INIT)
    CLASS(RAT_VOL_TYPE),     INTENT(INOUT):: TYP
    INTEGER,                    INTENT(IN   ):: DIM
    DOUBLE PRECISION,           INTENT(IN   ):: INIT
    INTEGER:: I
    !
    CALL ALLOC_RAT_VOL_TYPE(TYP, DIM)
    !
    DO I=ONE, DIM
        TYP%PT(I)%RAT = INIT
        TYP%PT(I)%VOL = INIT
    END DO
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOC_RAT_VOL_TYPE_INIT_VEC(TYP, DIM, INIT)
    CLASS(RAT_VOL_TYPE),          INTENT(INOUT):: TYP
    INTEGER,                         INTENT(IN   ):: DIM
    DOUBLE PRECISION,DIMENSION(DIM), INTENT(IN   ):: INIT 
    INTEGER:: I
    !
    CALL ALLOC_RAT_VOL_TYPE(TYP, DIM)
    !
    DO I=ONE, DIM
        TYP%PT(I)%RAT = INIT(I)
        TYP%PT(I)%VOL = INIT(I)
    END DO
  END SUBROUTINE
  !
  SUBROUTINE EXTEND_RAT_VOL_TYPE(TYP, RAT, VOL)
    CLASS(RAT_VOL_TYPE), INTENT(INOUT)::TYP
    DOUBLE PRECISION,       INTENT(IN   ):: RAT, VOL
    TYPE (RAT_VOL_TYPE):: EXT
    !
    TYP%INUSE = TRUE
    !
    IF(TYP%N == Z) THEN
                  TYP%N = ONE
                  !
                  ALLOCATE( TYP%PT(TYP%N) )
                  TYP%PT(TYP%N)%RAT = RAT;   TYP%PT(TYP%N)%VOL = VOL
    ELSE
                  EXT%N = TYP%N + ONE
                  !
                  ALLOCATE( EXT%PT (EXT%N) )
                  EXT%PT(:TYP%N)  = TYP%PT
                  !
                  EXT%PT(EXT%N)%RAT = RAT;   EXT%PT(EXT%N)%VOL = VOL
                  !
                  CALL MOVE_ALLOC(EXT%PT,  TYP%PT)
                  TYP%N = EXT%N
    END IF
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_RAT_POS_RAT_VOL_TYPE(TYP, POS, RAT)
    CLASS(RAT_VOL_TYPE),     INTENT(INOUT):: TYP
    INTEGER,                 INTENT(IN   ):: POS
    DOUBLE PRECISION,        INTENT(IN   ):: RAT
    !
    IF(Z<POS .AND. POS <= TYP%N) TYP%PT(POS)%RAT = RAT
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_VOL_POS_RAT_VOL_TYPE(TYP, POS, VOL)
    CLASS(RAT_VOL_TYPE),     INTENT(INOUT):: TYP
    INTEGER,                 INTENT(IN   ):: POS
    DOUBLE PRECISION,        INTENT(IN   ):: VOL
    !
    IF(Z<POS .AND. POS <= TYP%N) TYP%PT(POS)%VOL = VOL
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_RAT_RAT_VOL_TYPE(TYP, DELT)
    CLASS(RAT_VOL_TYPE), INTENT(INOUT)::TYP
    DOUBLE PRECISION,       INTENT(IN   ):: DELT
    INTEGER:: I
    !
    DO I=ONE, TYP%N
              TYP%PT(I)%RAT =  TYP%PT(I)%VOL / DELT
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_VOL_RAT_VOL_TYPE(TYP, DELT)
    CLASS(RAT_VOL_TYPE), INTENT(INOUT)::TYP
    DOUBLE PRECISION,       INTENT(IN   ):: DELT
    INTEGER:: I
    !
    DO I=ONE, TYP%N
              TYP%PT(I)%VOL = TYP%PT(I)%RAT * DELT
    END DO
    !
  END SUBROUTINE
  !
  PURE FUNCTION GET_RAT_POS_RAT_VOL_TYPE(TYP, POS, EVAL) RESULT(RAT)
    CLASS(RAT_VOL_TYPE),        INTENT(IN):: TYP
    INTEGER,                    INTENT(IN):: POS
    DOUBLE PRECISION, OPTIONAL, INTENT(IN):: EVAL
    DOUBLE PRECISION:: RAT
    !
    IF(Z<POS .AND. POS <= TYP%N) THEN
                                      RAT = TYP%PT(POS)%RAT
    ELSEIF(PRESENT(EVAL)) THEN
                                      RAT = EVAL
    ELSE
                                      RAT = IEEE_VALUE(RAT, IEEE_QUIET_NAN)
    END IF
    !
  END FUNCTION
  !
  PURE FUNCTION GET_VOL_POS_RAT_VOL_TYPE(TYP, POS, EVAL) RESULT(VOL)
    CLASS(RAT_VOL_TYPE),     INTENT(IN):: TYP
    INTEGER,                    INTENT(IN):: POS
    DOUBLE PRECISION, OPTIONAL, INTENT(IN):: EVAL
    DOUBLE PRECISION:: VOL
    !
    IF(Z<POS .AND. POS <= TYP%N) THEN
                                      VOL = TYP%PT(POS)%VOL
    ELSEIF(PRESENT(EVAL)) THEN
                                      VOL = EVAL
    ELSE
                                      VOL = IEEE_VALUE(VOL, IEEE_QUIET_NAN)
    END IF
    !
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE ELEMENTAL SUBROUTINE COPY_RAT_VOL_BASE(OTYP, ITYP)
    CLASS(RAT_VOL_BASE), INTENT(IN   ):: ITYP
    CLASS(RAT_VOL_BASE), INTENT(INOUT):: OTYP
    !
    OTYP%RAT = ITYP%RAT
    OTYP%VOL = ITYP%VOL
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_RAT_RAT_VOL_BASE(TYP, RAT)
    CLASS(RAT_VOL_BASE),     INTENT(INOUT):: TYP
    DOUBLE PRECISION,        INTENT(IN   ):: RAT
    !
    TYP%RAT = RAT
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_VOL_RAT_VOL_BASE(TYP, VOL)
    CLASS(RAT_VOL_BASE),     INTENT(INOUT):: TYP
    DOUBLE PRECISION,        INTENT(IN   ):: VOL
    !
    TYP%VOL = VOL
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_RAT_RAT_VOL_BASE(TYP, DELT)
    CLASS(RAT_VOL_BASE), INTENT(INOUT)::TYP
    DOUBLE PRECISION,       INTENT(IN   ):: DELT
    !
    TYP%RAT =  TYP%VOL / DELT
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_VOL_RAT_VOL_BASE(TYP, DELT)
    CLASS(RAT_VOL_BASE), INTENT(INOUT)::TYP
    DOUBLE PRECISION,    INTENT(IN   ):: DELT
    !
    TYP%VOL = TYP%RAT * DELT
    !
  END SUBROUTINE
  !
  PURE FUNCTION GET_RAT_RAT_VOL_BASE(TYP) RESULT(RAT)
    CLASS(RAT_VOL_BASE), INTENT(IN):: TYP
    DOUBLE PRECISION:: RAT
    !
    RAT = TYP%RAT
    !
  END FUNCTION
  !
  PURE FUNCTION GET_VOL_RAT_VOL_BASE(TYP) RESULT(VOL)
    CLASS(RAT_VOL_BASE), INTENT(IN):: TYP
    DOUBLE PRECISION:: VOL
    !
    VOL = TYP%VOL
    !
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE ELEMENTAL SUBROUTINE COPY_ID1_ID2_RAT_VOL_BASE(OTYP, ITYP)
    CLASS(ID1_ID2_RAT_VOL_BASE), INTENT(IN   ):: ITYP
    CLASS(ID1_ID2_RAT_VOL_BASE), INTENT(INOUT):: OTYP
    !
    OTYP%ID1 = ITYP%ID1
    OTYP%ID2 = ITYP%ID2
    OTYP%RAT  = ITYP%RAT
    OTYP%VOL  = ITYP%VOL
    !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE ELEMENTAL SUBROUTINE COPY_ID_RAT_VOL_BASE(OTYP, ITYP)
    CLASS(ID_RAT_VOL_BASE), INTENT(IN   ):: ITYP
    CLASS(ID_RAT_VOL_BASE), INTENT(INOUT):: OTYP
    !
    OTYP%ID = ITYP%ID
    OTYP%RAT = ITYP%RAT
    OTYP%VOL = ITYP%VOL
    !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE ELEMENTAL SUBROUTINE COPY_ID_VAL_BASE(OTYP, ITYP)
    CLASS(ID_VAL_BASE), INTENT(IN   ):: ITYP
    CLASS(ID_VAL_BASE), INTENT(INOUT):: OTYP
    !
    OTYP%ID  = ITYP%ID
    OTYP%VAL = ITYP%VAL
    !
  END SUBROUTINE
  !
END MODULE
!
!##############################################################
!##############################################################
!##############################################################
    
!!!  !
!!!  IMPURE ELEMENTAL SUBROUTINE SET_REAL_NAN(NaN)
!!!     REAL, INTENT(OUT):: NaN
!!!     REAL,        SAVE:: NaN_REL=0.0
!!!     LOGICAL,     SAVE:: SET_REL=TRUE
!!!     CHARACTER(3):: CNAN
!!!     !
!!!     IF(SET_REL) THEN
!!!        SET_REL = FALSE
!!!        CNAN = 'NaN'
!!!        READ(CNAN,*) NaN_REL
!!!     END IF
!!!     !
!!!     NaN = NaN_REL
!!!     !
!!!  END SUBROUTINE  
!!!  !
!!!  IMPURE ELEMENTAL SUBROUTINE SET_DBLE_NAN(NaN)
!!!     DOUBLE PRECISION, INTENT(OUT):: NaN
!!!     DOUBLE PRECISION,        SAVE:: NaN_DBL = DZ
!!!     LOGICAL,                 SAVE:: SET_DBL  = TRUE
!!!     CHARACTER(3):: CNAN
!!!     !
!!!     IF(SET_DBL) THEN
!!!        SET_DBL = FALSE
!!!        CNAN = 'NaN'
!!!        READ(CNAN,*) NaN_DBL
!!!     END IF
!!!     !
!!!     NaN = NaN_DBL
!!!     !
!!!  END SUBROUTINE  
    
    

!!!!
!!!!##############################################################
!!!!##############################################################
!!!!##############################################################
!!!!
!!!MODULE MOVE_ALLOC_SUBS ! Utility Subroutines -- They help with compiler bugs with gfortran
!!!  !
!!!  IMPLICIT NONE
!!!  CONTAINS
!!!  !
!!!  PURE SUBROUTINE MOVE_ALLOC_CHARACTER_ARRAY(FROM, TOO)
!!!     CHARACTER(:),DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: FROM
!!!     CHARACTER(:),DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: TOO
!!!     CALL MOVE_ALLOC(FROM, TOO)
!!!  END SUBROUTINE
!!!  !
!!!END MODULE
!! 
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
!
MODULE SORT_INTERFACE ! SORT(DIM1,ARR) or SORT(DIM1,DIM2,ARR,COL)
  !
  USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: REAL32, REAL64, REAL128
  !
  USE CONSTANTS,   ONLY:BLNK,NL,TAB,COM,Z,ONE,TWO,TEN,DZ,UNO,DOS,DIEZ,TRUE,FALSE
  IMPLICIT NONE
  PRIVATE
  PUBLIC SORT, SORTED, REVERSE_ORDER  !SORT IS A SUBROUTINE AND SORTED RETURNS A SORTED VECTOR
  !
  ! SORTING IS FROM SMALLEST TO LARGEST VALUE
  !
  ! SORT OPTIONS
  ! GIVEN AN VECTOR X(DIM1) 
  ! SORT(DIM1, X)
  !
  ! GIVEN AN ARRAY Y(DIM1,DIM2)  THAT IS SORTED ON COLUMN "COL"
  ! SORT(DIM1, DIM2, Y, COL)
  ! or
  ! SORT(DIM1, DIM2, Y, [COL1,COL2,...COLN])  -- SORT BY SPECIFIED COLUMNS -- NOTE: SORT(DIM1, DIM2, Y, COL)  <==> SORT(DIM1, DIM2, Y, [COL1]) WHEN COL = COL1
  !
  ! MIXED SORTING
  ! GIVEN AN VECTOR X(DIM1), Z(DIM1) 
  ! SORT(DIM1, X, Z)                  --SORTS ON X AND INCLUDES SORTING OPERATIONS ON Z, NOTE SORT(DIM1, X, Z) <==> SORT(DIM1, DIM2, Y, COL=1) WHEN Y=[X; Z]
  !
  ! MIXED SORTING
  ! GIVEN AN INTEGER VECTOR A(DIM1) AND DOUBLE PERCISION ARRAYS B(DIM1) AND C(DIM1,DIM2)
  ! WILL SORT USING INTEGER VECTOR THE DOUBLE PRECISION PART
  ! SORT(DIM1,      A, B)
  ! SORT(DIM1,DIM2, A, C)
  !
  ! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  ! TO REVERSE RESULTING ORDER USE THE FOLLOWING SUBROUTINES ARE AVAIBLE:
  !    CALL REVERSE_ORDER(DIM1, VEC)
  !    CALL REVERSE_ORDER(DIM1, DIM2, ARR)
  ! <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  !
  ! FORMAL INTERFACES:
  !
  INTERFACE REVERSE_ORDER
    MODULE PROCEDURE REVERSE_ORDER_INT_VECTOR       !(DIM1,IVEC                )
    MODULE PROCEDURE REVERSE_ORDER_REAL_VECTOR      !(DIM1,RVEC                )
    MODULE PROCEDURE REVERSE_ORDER_DBLE_VECTOR      !(DIM1,DVEC                )
    MODULE PROCEDURE REVERSE_ORDER_INT_ARRAY_COL    !(DIM1,DIM2,IARR,[ByColumn])
    MODULE PROCEDURE REVERSE_ORDER_REAL_ARRAY_COL   !(DIM1,DIM2,RARR,[ByColumn])
    MODULE PROCEDURE REVERSE_ORDER_DBLE_ARRAY_COL   !(DIM1,DIM2,DARR,[ByColumn])
  END INTERFACE
  !
  ! MAGNITUDE is an optional LOGICAL that when present and true indicates sort is based on magnitude (ABS) of numbers
  !  
  INTERFACE SORT
    MODULE PROCEDURE SORT_INT_VECTOR       !(DIM1,IVEC,         [MAGNITUDE])
    MODULE PROCEDURE SORT_REAL_VECTOR      !(DIM1,RVEC,         [MAGNITUDE])
    MODULE PROCEDURE SORT_DBLE_VECTOR      !(DIM1,DVEC,         [MAGNITUDE])
    MODULE PROCEDURE SORT_INT_ARRAY_COL    !(DIM1,DIM2,IARR,COL,[MAGNITUDE])
    MODULE PROCEDURE SORT_REAL_ARRAY_COL   !(DIM1,DIM2,RARR,COL,[MAGNITUDE])
    MODULE PROCEDURE SORT_DBLE_ARRAY_COL   !(DIM1,DIM2,DARR,COL,[MAGNITUDE])
    MODULE PROCEDURE SORT_INT_ARRAY_COLDIM !(DIM1,DIM2,IARR,COLDIM)   -- COLDIM is vec of columns to sort by in order of preference
    MODULE PROCEDURE SORT_DBLE_ARRAY_COLDIM!(DIM1,DIM2,DARR,COLDIM)   -- COLDIM is vec of columns to sort by in order of preference
    MODULE PROCEDURE SORT_DBLE_2VECTOR     !(DIM1,DVEC,DVEC2)          -- SORT ON DVEC COLUMN AS IF MERGED ARRAY WITH ARRAY = [DVEC; DVEC2]
    MODULE PROCEDURE SORT_INT_2VECTOR      !(DIM1,IVEC,IVEC2)
    MODULE PROCEDURE SORT_INT_VECTOR_DBLE_VECTOR!(DIM1,IVEC,DVEC     ,[MAGNITUDE])
    MODULE PROCEDURE SORT_INT_VECTOR_DBLE_ARRAY !(DIM1,DIM2,IVEC,DARR,[MAGNITUDE])
    MODULE PROCEDURE SORT_DBLE_VECTOR_INT_VECTOR!(DIM1,DVEC,IVEC     ,[MAGNITUDE])
    MODULE PROCEDURE SORT_DBLE_VECTOR_INT_ARRAY !(DIM1,DIM2,DVEC,IARR,[MAGNITUDE])
    !
    MODULE PROCEDURE SORT_DBLE_VECTOR_INT_ARRAY_SORT_DIM         !(DIM1,DIM2,ARR,ARR2,SORT_DIM,[MAGNITUDE]) -- SORT_DIM IS THE MATCHING DIM FROM ARR TO ARR2 -- SORT_DIM = 1  CALLS SORT_DBLE_VECTOR_INT_ARRAY
    MODULE PROCEDURE SORT_DBLE_VECTOR_INT_ARRAY_SORT_MATCHING_DIM!(ARR,ARR2,MAGNITUDE) !GUESS SORT_DIM, IF DIM1==DIM2 THEN TREAT AS SORT_DIM = 1
    
  END INTERFACE
  !
  INTERFACE SORTED
    MODULE PROCEDURE SORTED_INT_VECTOR       !(DIM1,IVEC,         [MAGNITUDE])
    MODULE PROCEDURE SORTED_REAL_VECTOR      !(DIM1,RVEC,         [MAGNITUDE])
    MODULE PROCEDURE SORTED_DBLE_VECTOR      !(DIM1,DVEC,         [MAGNITUDE])
    MODULE PROCEDURE SORTED_INT_ARRAY_COL    !(DIM1,DIM2,IARR,COL,[MAGNITUDE])
    MODULE PROCEDURE SORTED_REAL_ARRAY_COL   !(DIM1,DIM2,RARR,COL,[MAGNITUDE])
    MODULE PROCEDURE SORTED_DBLE_ARRAY_COL   !(DIM1,DIM2,DARR,COL,[MAGNITUDE])
    MODULE PROCEDURE SORTED_INT_ARRAY_COLDIM !(DIM1,DIM2,IARR,COLDIM)   -- COLDIM is vec of columns to sort by in order of preference
    MODULE PROCEDURE SORTED_DBLE_ARRAY_COLDIM!(DIM1,DIM2,DARR,COLDIM)   -- COLDIM is vec of columns to sort by in order of preference
  END INTERFACE
  !
  CONTAINS
  !
  !######################################################################    
  !
  PURE SUBROUTINE SORT_INT_VECTOR(DIM1,ARR,MAGNITUDE)
    INTEGER,                 INTENT(IN   ):: DIM1
    INTEGER, DIMENSION(DIM1),INTENT(INOUT):: ARR
    LOGICAL, OPTIONAL,       INTENT(IN   ):: MAGNITUDE
    INTEGER:: I, J, VAL, AVAL
    LOGICAL:: NO_ABS
    !
    NO_ABS = TRUE
    IF(PRESENT(MAGNITUDE)) NO_ABS = .NOT. MAGNITUDE
    !
    IF(NO_ABS) THEN
        DO I=2, DIM1
            VAL=ARR(I)
            J=I
            DO WHILE ( J > ONE )
                               IF (ARR(J-ONE) < VAL) EXIT
                               ARR(J) = ARR(J-ONE)
                               J=J-ONE
            END DO
            ARR(J) = VAL
        END DO
    ELSE
        DO I=2, DIM1
            VAL =ARR(I)
            AVAL=ABS(VAL)
            J=I
            DO WHILE ( J > ONE )
                               IF (ABS(ARR(J-ONE)) < AVAL) EXIT
                               ARR(J) = ARR(J-ONE)
                               J=J-ONE
            END DO
            ARR(J) = VAL
        END DO
    END IF
    !
  END SUBROUTINE 
  !
  !######################################################################    
  !
  PURE SUBROUTINE SORT_REAL_VECTOR(DIM1,ARR,MAGNITUDE)
    INTEGER,              INTENT(IN   ):: DIM1
    REAL(REAL32), DIMENSION(DIM1),INTENT(INOUT):: ARR
    LOGICAL, OPTIONAL,    INTENT(IN   ):: MAGNITUDE
    INTEGER:: I, J
    REAL(REAL32):: VAL, AVAL
    LOGICAL:: NO_ABS
    !
    NO_ABS = TRUE
    IF(PRESENT(MAGNITUDE)) NO_ABS = .NOT. MAGNITUDE
    !
    IF(NO_ABS) THEN
        DO I=2, DIM1
            VAL=ARR(I)
            J=I
            DO WHILE ( J > ONE )
                               IF (ARR(J-ONE) < VAL) EXIT
                               ARR(J) = ARR(J-ONE)
                               J=J-ONE
            END DO
            ARR(J) = VAL
        END DO
    ELSE
        DO I=2, DIM1
            VAL=ARR(I)
            AVAL = ABS(VAL)
            J=I
            DO WHILE ( J > ONE )
                               IF (ABS(ARR(J-ONE)) < AVAL) EXIT
                               ARR(J) = ARR(J-ONE)
                               J=J-ONE
            END DO
            ARR(J) = VAL
        END DO
    END IF
  END SUBROUTINE 
  !
  !######################################################################    
  !
  PURE SUBROUTINE SORT_DBLE_VECTOR(DIM1,ARR,MAGNITUDE)
    INTEGER,                          INTENT(IN   ):: DIM1
    REAL(REAL64), DIMENSION(DIM1),INTENT(INOUT):: ARR
    LOGICAL, OPTIONAL,       INTENT(IN   ):: MAGNITUDE
    INTEGER:: I, J
    REAL(REAL64):: VAL, AVAL
    LOGICAL:: NO_ABS
    !
    NO_ABS = TRUE
    IF(PRESENT(MAGNITUDE)) NO_ABS = .NOT. MAGNITUDE
    !
    IF(NO_ABS) THEN
        DO I=2, DIM1
            VAL=ARR(I)
            J=I
            DO WHILE ( J > ONE )
                               IF (ARR(J-ONE) < VAL) EXIT
                               ARR(J) = ARR(J-ONE)
                               J=J-ONE
            END DO
            ARR(J) = VAL
        END DO
    ELSE
        DO I=2, DIM1
            VAL  = ARR(I)
            AVAL = ABS(VAL)
            J=I
            DO WHILE ( J > ONE )
                               IF (ABS(ARR(J-ONE)) < AVAL) EXIT
                               ARR(J) = ARR(J-ONE)
                               J=J-ONE
            END DO
            ARR(J) = VAL
        END DO
    END IF
  END SUBROUTINE 
  !
  !######################################################################    
  !
  PURE SUBROUTINE SORT_INT_ARRAY_COL(DIM1,DIM2,ARR,COL,MAGNITUDE)
    INTEGER,                      INTENT(IN   ):: DIM1, DIM2, COL
    INTEGER, DIMENSION(DIM1,DIM2),INTENT(INOUT):: ARR
    LOGICAL, OPTIONAL,            INTENT(IN   ):: MAGNITUDE
    INTEGER:: I, J, K
    INTEGER, DIMENSION(DIM2):: VAL
    INTEGER:: AVAL
    LOGICAL:: NO_ABS
    !
    NO_ABS = TRUE
    IF(PRESENT(MAGNITUDE)) NO_ABS = .NOT. MAGNITUDE
    !
    IF(NO_ABS) THEN
        DO I=2, DIM1
            DO CONCURRENT(K=1:DIM2); VAL(K)=ARR(I,K)
            END DO
            !
            J=I
            DO WHILE ( J > ONE )
                               IF (ARR(J-1,COL) < VAL(COL)) EXIT
                               DO CONCURRENT(K=1:DIM2); ARR(J,K) = ARR(J-1,K)
                               END DO
                               J=J-ONE
            END DO
            DO CONCURRENT(K=1:DIM2); ARR(J,K) = VAL(K)
            END DO
        END DO
    ELSE
        DO I=2, DIM1
            DO CONCURRENT(K=1:DIM2); VAL(K)=ARR(I,K)
            END DO
            AVAL = ABS(VAL(COL))
            J=I
            DO WHILE ( J > ONE )
                               IF (ABS(ARR(J-1,COL)) < AVAL) EXIT
                               DO CONCURRENT(K=1:DIM2); ARR(J,K) = ARR(J-1,K)
                               END DO
                               J=J-ONE
            END DO
            DO CONCURRENT(K=1:DIM2); ARR(J,K) = VAL(K)
            END DO
        END DO
    END IF
  END SUBROUTINE 
  !
  !######################################################################    
  !
  PURE SUBROUTINE SORT_INT_ARRAY_COLDIM(DIM1,DIM2,ARR,COLDIM)
    INTEGER,                      INTENT(IN   ):: DIM1, DIM2
    INTEGER, DIMENSION(DIM1,DIM2),INTENT(INOUT):: ARR
    INTEGER, DIMENSION(:),        INTENT(IN   ):: COLDIM
    INTEGER:: I, J, K, M, N, P, COL
    INTEGER, DIMENSION(DIM2):: VAL
    !
    COL = COLDIM(1)
    DO I=2, DIM1
        DO CONCURRENT(K=1:DIM2); VAL(K)=ARR(I,K)
        END DO
        !
        J=I
        DO WHILE ( J > ONE )
                           IF (ARR(J-1,COL) < VAL(COL)) EXIT
                           DO CONCURRENT(K=1:DIM2); ARR(J,K) = ARR(J-1,K)
                           END DO
                           J=J-ONE
        END DO
        !
        DO CONCURRENT(K=1:DIM2); ARR(J,K) = VAL(K)
        END DO
    END DO
    !
    CDIM: DO P=2, SIZE(COLDIM) 
        COL = COLDIM(P)
        I=1
        J=2
        DIM_SEARCH: DO WHILE (I <= DIM1)
           JSEARCH: DO WHILE (J <= DIM1)
               DO K=1, P-1
                   IF (ARR(I,COLDIM(K)) .NE. ARR(J,COLDIM(K))) EXIT JSEARCH
               END DO
               J = J + 1
           END DO JSEARCH
           !
           J = J - 1
           !
           IF(J - I == 1) THEN
                              IF (ARR(I,COL) > ARR(J,COL)) THEN
                                  DO CONCURRENT(K=1:DIM2) 
                                                   VAL(1)   = ARR(I,K)   !JUST USE VAL(1) AS TEMP VARIABLE
                                                   ARR(I,K) = ARR(J,K)
                                                   ARR(J,K) = VAL(1)
                                  END DO
                              END IF
           ELSEIF(I.NE.J) THEN
                              DO M=I+1, J
                                  DO CONCURRENT(K=1:DIM2); VAL(K)=ARR(M,K)
                                  END DO
                                  N = M
                                  DO WHILE ( N > I ) !I IS THE LOWER LIMIT OF SEARCH
                                                     IF (ARR(N-1,COL) < VAL(COL)) EXIT
                                                     DO CONCURRENT(K=1:DIM2); ARR(N,K) = ARR(N-1,K)
                                                     END DO
                                                     N=N-ONE
                                  END DO
                                  DO CONCURRENT(K=1:DIM2); ARR(N,K) = VAL(K)
                                  END DO
                              END DO
           END IF
           I = J + 1
           J = I + 1
        END DO DIM_SEARCH
    END DO CDIM
    !
  END SUBROUTINE 
  !
  !######################################################################    
  !
  PURE SUBROUTINE SORT_REAL_ARRAY_COL(DIM1,DIM2,ARR,COL,MAGNITUDE)
    INTEGER,                       INTENT(IN   ):: DIM1, DIM2, COL
    REAL(REAL32),    DIMENSION(DIM1,DIM2), INTENT(INOUT):: ARR
    LOGICAL, OPTIONAL,             INTENT(IN   ):: MAGNITUDE
    INTEGER:: I, J, K
    REAL(REAL32), DIMENSION(DIM2):: VAL
    REAL(REAL32):: AVAL
    LOGICAL:: NO_ABS
    !
    NO_ABS = TRUE
    IF(PRESENT(MAGNITUDE)) NO_ABS = .NOT. MAGNITUDE
    !
    IF(NO_ABS) THEN
        DO I=2, DIM1
            DO CONCURRENT(K=1:DIM2); VAL(K)=ARR(I,K)
            END DO
            J=I
            DO WHILE ( J > ONE )
                               IF (ARR(J-1,COL) < VAL(COL)) EXIT
                               DO CONCURRENT(K=1:DIM2); ARR(J,K) = ARR(J-1,K)
                               END DO
                               J=J-1
            END DO
            DO CONCURRENT(K=1:DIM2); ARR(J,K) = VAL(K)
            END DO
        END DO
    ELSE
        DO I=2, DIM1
            DO CONCURRENT(K=1:DIM2); VAL(K)=ARR(I,K)
            END DO
            AVAL = ABS(VAL(COL))
            J=I
            DO WHILE ( J > ONE )
                               IF (ABS(ARR(J-1,COL)) < AVAL) EXIT
                               DO CONCURRENT(K=1:DIM2); ARR(J,K) = ARR(J-1,K)
                               END DO
                               J=J-1
            END DO
            DO CONCURRENT(K=1:DIM2); ARR(J,K) = VAL(K)
            END DO
        END DO
    END IF
  END SUBROUTINE 
  !
  !######################################################################    
  !
  PURE SUBROUTINE SORT_DBLE_ARRAY_COL(DIM1,DIM2,ARR,COL,MAGNITUDE)
    INTEGER,                               INTENT(IN   ):: DIM1, DIM2, COL
    REAL(REAL64), DIMENSION(DIM1,DIM2),INTENT(INOUT):: ARR
    LOGICAL,          OPTIONAL,            INTENT(IN   ):: MAGNITUDE
    INTEGER:: I, J, K
    REAL(REAL64), DIMENSION(DIM2):: VAL
    REAL(REAL64):: AVAL
    LOGICAL:: NO_ABS
    !
    NO_ABS = TRUE
    IF(PRESENT(MAGNITUDE)) NO_ABS = .NOT. MAGNITUDE
    !
    IF(NO_ABS) THEN
        DO I=2, DIM1
            DO CONCURRENT(K=1:DIM2); VAL(K)=ARR(I,K)
            END DO
            J=I
            DO WHILE ( J > ONE )
                               IF (ARR(J-1,COL) < VAL(COL)) EXIT
                               DO CONCURRENT(K=1:DIM2); ARR(J,K) = ARR(J-1,K)
                               END DO
                               J=J-1
            END DO
            DO CONCURRENT(K=1:DIM2); ARR(J,K) = VAL(K)
            END DO
        END DO
    ELSE
        DO I=2, DIM1
            DO CONCURRENT(K=1:DIM2); VAL(K)=ARR(I,K)
            END DO
            AVAL = ABS(VAL(COL))
            J=I
            DO WHILE ( J > ONE )
                               IF (ABS(ARR(J-1,COL)) < AVAL) EXIT
                               DO CONCURRENT(K=1:DIM2); ARR(J,K) = ARR(J-1,K)
                               END DO
                               J=J-1
            END DO
            DO CONCURRENT(K=1:DIM2); ARR(J,K) = VAL(K)
            END DO
        END DO
    END IF
  END SUBROUTINE   
  !
  !######################################################################    
  !
  PURE SUBROUTINE SORT_DBLE_ARRAY_COLDIM(DIM1,DIM2,ARR,COLDIM)
    INTEGER,                               INTENT(IN   ):: DIM1, DIM2
    REAL(REAL64), DIMENSION(DIM1,DIM2),INTENT(INOUT):: ARR
    INTEGER, DIMENSION(:),                 INTENT(IN   ):: COLDIM
    INTEGER:: I, J, K, M, N, P, COL
    REAL(REAL64), DIMENSION(DIM2):: VAL
    !
    COL = COLDIM(1)
    DO I=2, DIM1
        DO CONCURRENT(K=1:DIM2); VAL(K)=ARR(I,K)
        END DO
        J=I
        DO WHILE ( J > ONE )
                           IF (ARR(J-1,COL) < VAL(COL)) EXIT
                           DO CONCURRENT(K=1:DIM2); ARR(J,K) = ARR(J-1,K)
                           END DO
                           J=J-ONE
        END DO
        DO CONCURRENT(K=1:DIM2); ARR(J,K) = VAL(K)
        END DO
    END DO
    !
    CDIM: DO P=2, SIZE(COLDIM) 
        COL = COLDIM(P)
        I=1
        J=2
        DIM_SEARCH: DO WHILE (I <= DIM1)
           JSEARCH: DO WHILE (J <= DIM1)
               DO K=1, P-1
                   IF (ARR(I,COLDIM(K)) .NE. ARR(J,COLDIM(K))) EXIT JSEARCH
               END DO
               J = J + 1
           END DO JSEARCH
           !
           J = J - 1
           !
           IF(J - I == 1) THEN
                              IF (ARR(I,COL) > ARR(J,COL)) THEN
                                  DO CONCURRENT(K=1:DIM2) 
                                                   VAL(1)   = ARR(I,K)   !JUST USE VAL(1) AS TEMP VARIABLE
                                                   ARR(I,K) = ARR(J,K)
                                                   ARR(J,K) = VAL(1)
                                  END DO
                              END IF
           ELSEIF(I.NE.J) THEN
                              DO M=I+1, J
                                  DO CONCURRENT(K=1:DIM2); VAL(K)=ARR(M,K)
                                  END DO
                                  N = M
                                  DO WHILE ( N > I ) !I IS THE LOWER LIMIT OF SEARCH
                                                     IF (ARR(N-1,COL) < VAL(COL)) EXIT
                                                     DO CONCURRENT(K=1:DIM2); ARR(N,K) = ARR(N-1,K)
                                                     END DO
                                                     N=N-ONE
                                  END DO
                                  DO CONCURRENT(K=1:DIM2); ARR(N,K) = VAL(K)
                                  END DO
                              END DO
           END IF
           I = J + 1
           J = I + 1
        END DO DIM_SEARCH
    END DO CDIM
    !
  END SUBROUTINE 
  !
  !######################################################################    
  !
  PURE SUBROUTINE SORT_DBLE_2VECTOR(DIM1,ARR,ARR2)
    INTEGER,              INTENT(IN):: DIM1
    REAL(REAL64), DIMENSION(DIM1),INTENT(INOUT):: ARR,ARR2
    INTEGER:: I, J
    REAL(REAL64):: VAL, VAL2
    !
    DO I=2, DIM1
        VAL =ARR(I)
        VAL2=ARR2(I)
        J=I
        DO WHILE ( J > ONE )
                           IF (ARR(J-ONE) < VAL) EXIT
                           ARR(J)  = ARR(J-ONE)
                           ARR2(J) = ARR2(J-ONE)
                           J=J-ONE
        END DO
        ARR(J) = VAL
        ARR2(J) = VAL2
    END DO
  END SUBROUTINE 
  !
  !######################################################################    
  !
  PURE SUBROUTINE SORT_INT_2VECTOR(DIM1,ARR,ARR2)
    INTEGER,              INTENT(IN):: DIM1
    INTEGER, DIMENSION(DIM1),INTENT(INOUT):: ARR,ARR2
    INTEGER:: I, J
    INTEGER:: VAL, VAL2
    !
    DO I=2, DIM1
        VAL =ARR(I)
        VAL2=ARR2(I)
        J=I
        DO WHILE ( J > ONE )
                           IF (ARR(J-ONE) < VAL) EXIT
                           ARR(J)  = ARR(J-ONE)
                           ARR2(J) = ARR2(J-ONE)
                           J=J-ONE
        END DO
        ARR(J) = VAL
        ARR2(J) = VAL2
    END DO
  END SUBROUTINE 
  !
  !######################################################################    
  !
  PURE SUBROUTINE SORT_INT_VECTOR_DBLE_VECTOR(DIM1,ARR,ARR2,MAGNITUDE)
    INTEGER,                      INTENT(IN   ):: DIM1
    INTEGER,      DIMENSION(DIM1),INTENT(INOUT):: ARR
    REAL(REAL64), DIMENSION(DIM1),INTENT(INOUT):: ARR2
    LOGICAL,      OPTIONAL,       INTENT(IN   ):: MAGNITUDE
    INTEGER:: I, J
    INTEGER:: VAL
    REAL(REAL64):: VAL2
    INTEGER:: AVAL
    LOGICAL:: NO_ABS
    !
    NO_ABS = TRUE
    IF(PRESENT(MAGNITUDE)) NO_ABS = .NOT. MAGNITUDE
    !
    IF(NO_ABS) THEN
        DO I=2, DIM1
            VAL =ARR(I)
            VAL2=ARR2(I)
            J=I
            DO WHILE ( J > ONE )
                               IF (ARR(J-ONE) < VAL) EXIT
                               ARR(J)  = ARR(J-ONE)
                               ARR2(J) = ARR2(J-ONE)
                               J=J-ONE
            END DO
            ARR(J) = VAL
            ARR2(J) = VAL2
        END DO
    ELSE
        DO I=2, DIM1
            VAL =ARR(I)
            VAL2=ARR2(I)
            !
            AVAL = ABS(VAL)
            J=I
            DO WHILE ( J > ONE )
                               IF (ABS(ARR(J-ONE)) < AVAL) EXIT
                               ARR(J)  = ARR(J-ONE)
                               ARR2(J) = ARR2(J-ONE)
                               J=J-ONE
            END DO
            ARR(J) = VAL
            ARR2(J) = VAL2
        END DO
    END IF
  END SUBROUTINE 
  !
  !######################################################################    
  !
  PURE SUBROUTINE SORT_INT_VECTOR_DBLE_ARRAY(DIM1,DIM2,ARR,ARR2,MAGNITUDE)
    INTEGER,                           INTENT(IN   ):: DIM1,DIM2
    INTEGER,      DIMENSION(DIM1),     INTENT(INOUT):: ARR
    REAL(REAL64), DIMENSION(DIM1,DIM2),INTENT(INOUT):: ARR2
    LOGICAL,      OPTIONAL,            INTENT(IN   ):: MAGNITUDE
    INTEGER:: I, J, K
    INTEGER:: VAL
    REAL(REAL64), DIMENSION(DIM2):: VAL2
    INTEGER:: AVAL
    LOGICAL:: NO_ABS
    !
    NO_ABS = TRUE
    IF(PRESENT(MAGNITUDE)) NO_ABS = .NOT. MAGNITUDE
    !
    IF(NO_ABS) THEN
        DO I=2, DIM1
            VAL = ARR(I)
            DO CONCURRENT(K=1:DIM2); VAL2(K)=ARR2(I,K)
            END DO
            J=I
            DO WHILE ( J > ONE )
                               IF (ARR(J-ONE) < VAL) EXIT
                               ARR(J)  = ARR(J-ONE)
                               DO CONCURRENT(K=1:DIM2); ARR2(J,K) = ARR2(J-ONE,K)
                               END DO
                               J=J-ONE
            END DO
            ARR(J) = VAL
            DO CONCURRENT(K=1:DIM2); ARR2(J,K) = VAL2(K)
            END DO
        END DO
    ELSE
        DO I=2, DIM1
            VAL  = ARR(I)
            AVAL = ABS(VAL)
            DO CONCURRENT(K=1:DIM2); VAL2(K)=ARR2(I,K)
            END DO
            J=I
            DO WHILE ( J > ONE )
                               IF (ABS(ARR(J-ONE)) < AVAL) EXIT
                               ARR(J)  = ARR(J-ONE)
                               DO CONCURRENT(K=1:DIM2); ARR2(J,K) = ARR2(J-ONE,K)
                               END DO
                               J=J-ONE
            END DO
            ARR(J) = VAL
            DO CONCURRENT(K=1:DIM2); ARR2(J,K) = VAL2(K)
            END DO
        END DO
    END IF
  END SUBROUTINE 
  !
  !######################################################################    
  !
  PURE SUBROUTINE SORT_DBLE_VECTOR_INT_VECTOR(DIM1,ARR,ARR2,MAGNITUDE)
    INTEGER,                      INTENT(IN   ):: DIM1
    REAL(REAL64), DIMENSION(DIM1),INTENT(INOUT):: ARR
    INTEGER,      DIMENSION(DIM1),INTENT(INOUT):: ARR2
    LOGICAL,      OPTIONAL,       INTENT(IN   ):: MAGNITUDE
    INTEGER:: I, J
    REAL(REAL64):: VAL
    INTEGER:: VAL2
    REAL(REAL64):: AVAL
    LOGICAL:: NO_ABS
    !
    NO_ABS = TRUE
    IF(PRESENT(MAGNITUDE)) NO_ABS = .NOT. MAGNITUDE
    !
    IF(NO_ABS) THEN
        DO I=2, DIM1
            VAL =ARR(I)
            VAL2=ARR2(I)
            J=I
            DO WHILE ( J > ONE )
                               IF (ARR(J-ONE) < VAL) EXIT
                               ARR(J)  = ARR(J-ONE)
                               ARR2(J) = ARR2(J-ONE)
                               J=J-ONE
            END DO
            ARR(J) = VAL
            ARR2(J) = VAL2
        END DO
    ELSE
        DO I=2, DIM1
            VAL =ARR(I)
            VAL2=ARR2(I)
            !
            AVAL = ABS(VAL)
            J=I
            DO WHILE ( J > ONE )
                               IF (ABS(ARR(J-ONE)) < AVAL) EXIT
                               ARR(J)  = ARR(J-ONE)
                               ARR2(J) = ARR2(J-ONE)
                               J=J-ONE
            END DO
            ARR(J) = VAL
            ARR2(J) = VAL2
        END DO
    END IF
  END SUBROUTINE 
  !
  !######################################################################    
  !
  PURE SUBROUTINE SORT_DBLE_VECTOR_INT_ARRAY(DIM1,DIM2,ARR,ARR2,MAGNITUDE)
    INTEGER,                           INTENT(IN   ):: DIM1,DIM2
    REAL(REAL64), DIMENSION(DIM1),     INTENT(INOUT):: ARR
    INTEGER,      DIMENSION(DIM1,DIM2),INTENT(INOUT):: ARR2
    LOGICAL,      OPTIONAL,            INTENT(IN   ):: MAGNITUDE
    INTEGER:: I, J, K
    REAL(REAL64):: VAL
    INTEGER, DIMENSION(DIM2):: VAL2
    REAL(REAL64):: AVAL
    LOGICAL:: NO_ABS
    !
    NO_ABS = TRUE
    IF(PRESENT(MAGNITUDE)) NO_ABS = .NOT. MAGNITUDE
    !
    IF(NO_ABS) THEN
        DO I=2, DIM1
            VAL = ARR(I)
            DO CONCURRENT(K=1:DIM2); VAL2(K)=ARR2(I,K)
            END DO
            J=I
            DO WHILE ( J > ONE )
                               IF (ARR(J-ONE) < VAL) EXIT
                               ARR(J)  = ARR(J-ONE)
                               DO CONCURRENT(K=1:DIM2); ARR2(J,K) = ARR2(J-ONE,K)
                               END DO
                               J=J-ONE
            END DO
            ARR(J) = VAL
            DO CONCURRENT(K=1:DIM2); ARR2(J,K) = VAL2(K)
            END DO
        END DO
    ELSE
        DO I=2, DIM1
            VAL  = ARR(I)
            AVAL = ABS(VAL)
            DO CONCURRENT(K=1:DIM2); VAL2(K)=ARR2(I,K)
            END DO
            J=I
            DO WHILE ( J > ONE )
                               IF (ABS(ARR(J-ONE)) < AVAL) EXIT
                               ARR(J)  = ARR(J-ONE)
                               DO CONCURRENT(K=1:DIM2); ARR2(J,K) = ARR2(J-ONE,K)
                               END DO
                               J=J-ONE
            END DO
            ARR(J) = VAL
            DO CONCURRENT(K=1:DIM2); ARR2(J,K) = VAL2(K)
            END DO
        END DO
    END IF
  END SUBROUTINE 
  !
  !######################################################################    
  !
  PURE SUBROUTINE SORT_DBLE_VECTOR_INT_ARRAY_SORT_DIM(DIM1,DIM2,ARR,ARR2,SORT_DIM, MAGNITUDE)
    ! SORT_DIM = 1 => ARR DIM IS SAME AS ARR2 FIRST DIM  --SHIFT FIRST DIM WITH ARR
    ! SORT_DIM = 2 => ARR DIM IS SAME AS ARR2 SECOND DIM --SHIFT   2nd DIM WITH ARR
    INTEGER,                           INTENT(IN   ):: DIM1,DIM2
    REAL(REAL64), DIMENSION(DIM1),     INTENT(INOUT):: ARR
    INTEGER,      DIMENSION(:,:),      INTENT(INOUT):: ARR2
    INTEGER,                           INTENT(IN   ):: SORT_DIM
    LOGICAL,      OPTIONAL,            INTENT(IN   ):: MAGNITUDE
    CONTIGUOUS:: ARR2
    !
    IF(SORT_DIM == ONE) THEN
        CALL SORT_DBLE_VECTOR_INT_ARRAY(DIM1,DIM2,ARR,ARR2,MAGNITUDE)
    ELSE
        CALL SORT_DBLE_VECTOR_INT_ARRAY_SORT_DIM2(DIM1,DIM2,ARR,ARR2,MAGNITUDE)
    END IF
  END SUBROUTINE 
  !
  PURE SUBROUTINE SORT_DBLE_VECTOR_INT_ARRAY_SORT_MATCHING_DIM(ARR,ARR2,MAGNITUDE)
    ! AUTO-DETERMINE MATCHING ARR WITH ARR2 DIM. IF TIME THEN USE SORT_DIM = 1
    REAL(REAL64), DIMENSION(:),  CONTIGUOUS, INTENT(INOUT):: ARR
    INTEGER,      DIMENSION(:,:),CONTIGUOUS, INTENT(INOUT):: ARR2
    LOGICAL,      OPTIONAL,                  INTENT(IN   ):: MAGNITUDE
    INTEGER:: DIM1,DIM2
    !
    DIM1 = SIZE(ARR, ONE)
    DIM2 = SIZE(ARR2,ONE)
    !
    IF(DIM1 == DIM2) THEN
        DIM2 = SIZE(ARR2,TWO)
        CALL SORT_DBLE_VECTOR_INT_ARRAY(DIM1,DIM2,ARR,ARR2,MAGNITUDE)
    ELSE
        CALL SORT_DBLE_VECTOR_INT_ARRAY_SORT_DIM2(DIM1,DIM2,ARR,ARR2,MAGNITUDE)
    END IF
  END SUBROUTINE
  !
  PURE SUBROUTINE SORT_DBLE_VECTOR_INT_ARRAY_SORT_DIM2(DIM1,DIM2,ARR,ARR2,MAGNITUDE)
    INTEGER,                           INTENT(IN   ):: DIM1,DIM2
    REAL(REAL64), DIMENSION(DIM1),     INTENT(INOUT):: ARR
    INTEGER,      DIMENSION(DIM2, DIM1),INTENT(INOUT):: ARR2
    LOGICAL,      OPTIONAL,            INTENT(IN   ):: MAGNITUDE
    !
    INTEGER:: I, J, K
    REAL(REAL64):: VAL
    INTEGER, DIMENSION(DIM2):: VAL2
    REAL(REAL64):: AVAL
    LOGICAL:: NO_ABS
    !
    NO_ABS = TRUE
    IF(PRESENT(MAGNITUDE)) NO_ABS = .NOT. MAGNITUDE
    !
    IF(NO_ABS) THEN
        DO I=2, DIM1
            VAL = ARR(I)
            DO CONCURRENT(K=1:DIM2); VAL2(K)=ARR2(K,I)
            END DO
            J=I
            DO WHILE ( J > ONE )
                               IF (ARR(J-ONE) < VAL) EXIT
                               ARR(J)  = ARR(J-ONE)
                               DO CONCURRENT(K=1:DIM2); ARR2(K,J) = ARR2(K,J-ONE)
                               END DO
                               J=J-ONE
            END DO
            ARR(J) = VAL
            DO CONCURRENT(K=1:DIM2); ARR2(K,J) = VAL2(K)
            END DO
        END DO
    ELSE
        DO I=2, DIM1
            VAL  = ARR(I)
            AVAL = ABS(VAL)
            DO CONCURRENT(K=1:DIM2); VAL2(K)=ARR2(K,I)
            END DO
            J=I
            DO WHILE ( J > ONE )
                               IF (ABS(ARR(J-ONE)) < AVAL) EXIT
                               ARR(J)  = ARR(J-ONE)
                               DO CONCURRENT(K=1:DIM2); ARR2(K,J) = ARR2(K,J-ONE)
                               END DO
                               J=J-ONE
            END DO
            ARR(J) = VAL
            DO CONCURRENT(K=1:DIM2); ARR2(K,J) = VAL2(K)
            END DO
        END DO
    END IF
  END SUBROUTINE 
  !
  !######################################################################   
  !## SORT FUNCTIONS ==> SORTED 
  !######################################################################  
  !
  PURE FUNCTION SORTED_INT_VECTOR(DIM1,IVEC,MAGNITUDE) RESULT(SRT)
    INTEGER,                 INTENT(IN):: DIM1
    INTEGER, DIMENSION(DIM1),INTENT(IN):: IVEC
    LOGICAL, OPTIONAL,       INTENT(IN):: MAGNITUDE
    INTEGER, DIMENSION(DIM1):: SRT
    !
    SRT = IVEC
    CALL SORT_INT_VECTOR(DIM1, SRT, MAGNITUDE)
    !
  END FUNCTION
  !
  PURE FUNCTION SORTED_REAL_VECTOR(DIM1,RVEC,MAGNITUDE) RESULT(SRT) 
    INTEGER,                  INTENT(IN):: DIM1
    REAL(REAL32),    DIMENSION(DIM1), INTENT(IN):: RVEC
    LOGICAL, OPTIONAL,        INTENT(IN):: MAGNITUDE
    REAL(REAL32), DIMENSION(DIM1):: SRT
    !
    SRT = RVEC
    CALL SORT_REAL_VECTOR(DIM1, SRT, MAGNITUDE)
    !
  END FUNCTION
  !
  PURE FUNCTION SORTED_DBLE_VECTOR(DIM1,DVEC,MAGNITUDE) RESULT(SRT) 
    INTEGER,                      INTENT(IN):: DIM1
    REAL(REAL64), DIMENSION(DIM1),INTENT(IN):: DVEC
    LOGICAL,      OPTIONAL,       INTENT(IN):: MAGNITUDE
    REAL(REAL64), DIMENSION(DIM1):: SRT
    !
    SRT = DVEC
    CALL SORT_DBLE_VECTOR(DIM1, SRT, MAGNITUDE)
    !
  END FUNCTION
  !
  PURE FUNCTION SORTED_INT_ARRAY_COL(DIM1,DIM2,IARR,COL,MAGNITUDE) RESULT(SRT) 
    INTEGER,                      INTENT(IN):: DIM1, DIM2, COL
    INTEGER, DIMENSION(DIM1,DIM2),INTENT(IN):: IARR
    LOGICAL, OPTIONAL,            INTENT(IN):: MAGNITUDE
    INTEGER, DIMENSION(DIM1,DIM2):: SRT
    !
    SRT = IARR
    CALL SORT_INT_ARRAY_COL(DIM1,DIM2,SRT,COL,MAGNITUDE)
  END FUNCTION
  !
  PURE FUNCTION SORTED_REAL_ARRAY_COL(DIM1,DIM2,RARR,COL,MAGNITUDE) RESULT(SRT) 
    INTEGER,                      INTENT(IN):: DIM1, DIM2, COL
    REAL(REAL32),    DIMENSION(DIM1,DIM2),INTENT(IN):: RARR
    LOGICAL, OPTIONAL,            INTENT(IN):: MAGNITUDE
    REAL(REAL32), DIMENSION(DIM1,DIM2):: SRT
    !
    SRT = RARR
    CALL SORT_REAL_ARRAY_COL(DIM1,DIM2,SRT,COL,MAGNITUDE)
    !
  END FUNCTION
  !
  PURE FUNCTION SORTED_DBLE_ARRAY_COL(DIM1,DIM2,DARR,COL,MAGNITUDE) RESULT(SRT) 
    INTEGER,                           INTENT(IN):: DIM1, DIM2, COL
    REAL(REAL64), DIMENSION(DIM1,DIM2),INTENT(IN):: DARR
    LOGICAL,      OPTIONAL,            INTENT(IN):: MAGNITUDE
    REAL(REAL64), DIMENSION(DIM1,DIM2):: SRT
    !
    SRT = DARR
    CALL SORT_DBLE_ARRAY_COL(DIM1,DIM2,SRT,COL,MAGNITUDE)
    !
  END FUNCTION
  !
  PURE FUNCTION SORTED_INT_ARRAY_COLDIM(DIM1,DIM2,IARR,COLDIM) RESULT(SRT) !-- COLDIM is vec of columns to sort by in order of preference
    INTEGER,                      INTENT(IN):: DIM1, DIM2
    INTEGER, DIMENSION(DIM1,DIM2),INTENT(IN):: IARR
    INTEGER, DIMENSION(:),        INTENT(IN):: COLDIM
    INTEGER, DIMENSION(DIM1,DIM2):: SRT
    !
    SRT = IARR
    CALL SORT_INT_ARRAY_COLDIM(DIM1,DIM2,SRT,COLDIM)
    !
  END FUNCTION
  !
  PURE FUNCTION SORTED_DBLE_ARRAY_COLDIM(DIM1,DIM2,DARR,COLDIM) RESULT(SRT) !-- COLDIM is vec of columns to sort by in order of preference
    INTEGER,                           INTENT(IN):: DIM1, DIM2
    REAL(REAL64), DIMENSION(DIM1,DIM2),INTENT(IN):: DARR
    INTEGER, DIMENSION(:),             INTENT(IN):: COLDIM
    REAL(REAL64), DIMENSION(DIM1,DIM2):: SRT
    !
    SRT = DARR
    CALL SORT_DBLE_ARRAY_COLDIM(DIM1,DIM2,SRT,COLDIM)
    !
  END FUNCTION
  !
  !######################################################################   
  !## REVERSE ORDER SUBROUTINES
  !######################################################################  
  !
  PURE SUBROUTINE REVERSE_ORDER_INT_VECTOR(DIM1,ARR)
    INTEGER,                 INTENT(IN   ):: DIM1
    INTEGER, DIMENSION(DIM1),INTENT(INOUT):: ARR
    INTEGER:: I, J, HALF_DIM
    INTEGER:: VAL
    !
    J = DIM1
    HALF_DIM = DIM1/TWO
    !
    DO I=ONE, HALF_DIM
        VAL    = ARR(I)
        ARR(I) = ARR(J)
        ARR(J) = VAL
        J = J - ONE
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE REVERSE_ORDER_REAL_VECTOR(DIM1,ARR)
    INTEGER,                INTENT(IN   ):: DIM1
    REAL(REAL32),   DIMENSION(DIM1),INTENT(INOUT):: ARR
    INTEGER:: I, J, HALF_DIM
    REAL(REAL32):: VAL
    !
    J = DIM1
    HALF_DIM = DIM1/TWO
    !
    DO I=ONE, HALF_DIM
        VAL    = ARR(I)
        ARR(I) = ARR(J)
        ARR(J) = VAL
        J = J - ONE
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE REVERSE_ORDER_DBLE_VECTOR(DIM1,ARR)
    INTEGER,                          INTENT(IN   ):: DIM1
    REAL(REAL64), DIMENSION(DIM1),INTENT(INOUT):: ARR
    INTEGER:: I, J, HALF_DIM
    REAL(REAL64):: VAL
    !
    J = DIM1
    HALF_DIM = DIM1/TWO
    !
    DO I=ONE, HALF_DIM
        VAL    = ARR(I)
        ARR(I) = ARR(J)
        ARR(J) = VAL
        J = J - ONE
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE REVERSE_ORDER_INT_ARRAY_COL (DIM1,DIM2,ARR,BYCOLUMN)
    INTEGER,                      INTENT(IN   ):: DIM1, DIM2
    INTEGER, DIMENSION(DIM1,DIM2),INTENT(INOUT):: ARR
    LOGICAL, OPTIONAL,            INTENT(IN   ):: BYCOLUMN
    INTEGER:: I, J, K, HALF_DIM
    INTEGER:: VAL
    LOGICAL:: ByROW
    !
    ByROW = TRUE
    IF(PRESENT(BYCOLUMN)) ByROW = .NOT. BYCOLUMN
    !
    IF(BYROW) THEN
        J = DIM1
        HALF_DIM = DIM1/TWO
        !
        DO K=ONE, DIM2
            DO I=ONE, HALF_DIM
                VAL      = ARR(I,K)
                ARR(I,K) = ARR(J,K)
                ARR(J,K) = VAL
                J = J - ONE
            END DO
        END DO
    ELSE
        BLOCK
            INTEGER,DIMENSION(DIM1):: TMP
            J = DIM2
            HALF_DIM = DIM2/TWO
            !
            DO I=ONE, HALF_DIM
                TMP = ARR(:,I)
                ARR(:,I) = ARR(:,J)
                ARR(:,J) = TMP
                J = J - ONE
            END DO
        END BLOCK
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE REVERSE_ORDER_REAL_ARRAY_COL(DIM1,DIM2,ARR,BYCOLUMN)
    INTEGER,                      INTENT(IN   ):: DIM1, DIM2
    REAL(REAL32),    DIMENSION(DIM1,DIM2),INTENT(INOUT):: ARR
    LOGICAL, OPTIONAL,            INTENT(IN   ):: BYCOLUMN
    INTEGER:: I, J, K, HALF_DIM
    REAL(REAL32):: VAL
    LOGICAL:: ByROW
    !
    ByROW = TRUE
    IF(PRESENT(BYCOLUMN)) ByROW = .NOT. BYCOLUMN
    !
    IF(BYROW) THEN
        J = DIM1
        HALF_DIM = DIM1/TWO
        !
        DO K=ONE, DIM2
            DO I=ONE, HALF_DIM
                VAL      = ARR(I,K)
                ARR(I,K) = ARR(J,K)
                ARR(J,K) = VAL
                J = J - ONE
            END DO
        END DO
    ELSE
        BLOCK
            REAL(REAL32),DIMENSION(DIM1):: TMP
            J = DIM2
            HALF_DIM = DIM2/TWO
            !
            DO I=ONE, HALF_DIM
                TMP = ARR(:,I)
                ARR(:,I) = ARR(:,J)
                ARR(:,J) = TMP
                J = J - ONE
            END DO
        END BLOCK
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE REVERSE_ORDER_DBLE_ARRAY_COL(DIM1,DIM2,ARR,BYCOLUMN)
    INTEGER,                               INTENT(IN   ):: DIM1, DIM2
    REAL(REAL64), DIMENSION(DIM1,DIM2),INTENT(INOUT):: ARR
    LOGICAL, OPTIONAL,                     INTENT(IN   ):: BYCOLUMN
    INTEGER:: I, J, K, HALF_DIM
    REAL(REAL64):: VAL
    LOGICAL:: ByROW
    !
    ByROW = TRUE
    IF(PRESENT(BYCOLUMN)) ByROW = .NOT. BYCOLUMN
    !
    IF(BYROW) THEN
        J = DIM1
        HALF_DIM = DIM1/TWO
        !
        DO K=ONE, DIM2
            DO I=ONE, HALF_DIM
                VAL      = ARR(I,K)
                ARR(I,K) = ARR(J,K)
                ARR(J,K) = VAL
                J = J - ONE
            END DO
        END DO
    ELSE
        BLOCK
            REAL(REAL64),DIMENSION(DIM1):: TMP
            J = DIM2
            HALF_DIM = DIM2/TWO
            !
            DO I=ONE, HALF_DIM
                TMP = ARR(:,I)
                ARR(:,I) = ARR(:,J)
                ARR(:,J) = TMP
                J = J - ONE
            END DO
        END BLOCK
    END IF
    !
  END SUBROUTINE
  !
END MODULE
!
!!
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
! Generic Allocation Routine that can allocate 
!  the base Fortran data types (REAL, INTEGER, LOGICAL, CHARACTER)
!
    
MODULE ALLOC_INTERFACE!, ONLY: ALLOC
  !
  USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: REAL32, REAL64, REAL128
  !
  USE CONSTANTS, ONLY: Z, ONE, TWO, TRUE, FALSE
  !
  IMPLICIT NONE
  !
  PRIVATE
  !
  PUBLIC::  ALLOC
  !
  INTERFACE ALLOC
    ! GENERIC ALLOCATION ROUTINES
    !N is DIM1 size
    !M is DIM2 size
    !DIMCHK IS THE DIMENSION TO CHECK FOR A MATCH, 0 IS EXACT MATCH ALL DIM, 1 MUST MATCH DIM 1, etc.
    !EXACT = False will not reallocate if N and M are smaller than current dimensions. Defualt is TRUE
    !SRC is what the array is set to
    MODULE PROCEDURE ALLOCATE_INT_VECTOR      !(VEC, N,              [EXACT], [SRC], [NEW_ALLOC])   -- SRC is a scalar
    MODULE PROCEDURE ALLOCATE_INT_VECTOR_SRC  !(VEC, N,              [EXACT],  SRC , [NEW_ALLOC])   -- SRC is dim N
    MODULE PROCEDURE ALLOCATE_INT_ARRAY       !(ARR, N, M, [DIMCHK], [EXACT], [SRC])                -- SRC is a scalar
    MODULE PROCEDURE ALLOCATE_INT_ARRAY_SRC   !(ARR, N, M, [DIMCHK], [EXACT],  SRC )                -- SRC is dim NxM
    MODULE PROCEDURE ALLOCATE_DBLE_VECTOR     !(VEC, N,              [EXACT], [SRC], [NEW_ALLOC])
    MODULE PROCEDURE ALLOCATE_DBLE_ARRAY      !(ARR, N, M, [DIMCHK], [EXACT], [SRC])
    MODULE PROCEDURE ALLOCATE_TF_VECTOR       !(VEC, N,              [EXACT], [SRC], [NEW_ALLOC])   -- SRC is a scalar
    MODULE PROCEDURE ALLOCATE_TF_VECTOR_SRC   !(VEC, N,              [EXACT], [SRC], [NEW_ALLOC])   -- SRC is dim N
    MODULE PROCEDURE ALLOCATE_TF_ARRAY        !(ARR, N, M)
    MODULE PROCEDURE ALLOCATE_CHAR_VECTOR     !(VEC, N, EXACT, SRC, NEW_ALLOC)
    MODULE PROCEDURE ALLOCATE_CHAR_VECTOR_SRC !(VEC, N, EXACT, SRC, NEW_ALLOC)
    MODULE PROCEDURE ALLOCATE_DIM_CHAR_VECTOR !(VEC, N, DIM, EXACT, SRC, NEW_ALLOC)
    MODULE PROCEDURE ALLOCATE_DIM_CHAR_VECTOR_SRC !(VEC, N, DIM, EXACT, SRC, NEW_ALLOC)
  END INTERFACE
  !
  CONTAINS
  !
  PURE SUBROUTINE ALLOCATE_INT_VECTOR(VEC, N, EXACT, SRC, NEW_ALLOC)
    !VEC IS VECTOR TO ALLOCATE
    !N IS THE DIMENSION TO ALLOCATE. IF <1 THEN SUBROUTINE DOES NOTHING
    !EXACT IF SET TO TRUE TO INDICATE ALLOCATION MUST MATCH N  (DEFAULT)
    !      IF SET TO FALSE THEN IF ALREADY ALLOCATED AND ALLOCATION IS GREATER THAN N, THEN NOTHING IS DONE
    INTEGER, DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: VEC
    INTEGER,                            INTENT(IN   ):: N
    LOGICAL,                  OPTIONAL, INTENT(IN   ):: EXACT
    INTEGER,                  OPTIONAL, INTENT(IN   ):: SRC
    LOGICAL,                  OPTIONAL, INTENT(OUT  ):: NEW_ALLOC
    LOGICAL:: EXACT_DIM, NEW_ALLOCATION
    !
    NEW_ALLOCATION = FALSE
    !
    IF(N > Z) THEN
                  EXACT_DIM = TRUE
                  IF(PRESENT(EXACT)) EXACT_DIM = EXACT
                  !
                  IF( ALLOCATED(VEC) ) THEN
                                       IF(EXACT_DIM .AND. SIZE(VEC).NE.N) THEN
                                                                               NEW_ALLOCATION = TRUE
                                                                               DEALLOCATE(VEC)
                                                                               IF(PRESENT(SRC)) THEN
                                                                                                    ALLOCATE(VEC(N), SOURCE=SRC)
                                                                               ELSE
                                                                                                    ALLOCATE(VEC(N))
                                                                               END IF
                                       ELSEIF(            SIZE(VEC).LT.N) THEN
                                                                               NEW_ALLOCATION = TRUE
                                                                               DEALLOCATE(VEC   )
                                                                               IF(PRESENT(SRC)) THEN
                                                                                                    ALLOCATE(VEC(N), SOURCE=SRC)
                                                                               ELSE
                                                                                                    ALLOCATE(VEC(N))
                                                                               END IF
                                       ELSEIF(PRESENT(SRC)) THEN
                                                                               VEC=SRC
                                       END IF
                  ELSE
                                                                               IF(PRESENT(SRC)) THEN
                                                                                                    ALLOCATE(VEC(N), SOURCE=SRC)
                                                                               ELSE
                                                                                                    ALLOCATE(VEC(N))
                                                                               END IF
                                                                               NEW_ALLOCATION = TRUE
                  END IF
    ELSEIF(ALLOCATED(VEC)) THEN
                  EXACT_DIM = TRUE
                  IF(PRESENT(EXACT)) EXACT_DIM = EXACT
                  IF(EXACT_DIM) DEALLOCATE(VEC)
    END IF
    !
    IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=NEW_ALLOCATION
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE SUBROUTINE ALLOCATE_INT_VECTOR_SRC(VEC, N, EXACT, SRC, NEW_ALLOC)
    !VEC IS VECTOR TO ALLOCATE
    !N IS THE DIMENSION TO ALLOCATE. IF <1 THEN SUBROUTINE DOES NOTHING
    !EXACT IF SET TO TRUE TO INDICATE ALLOCATION MUST MATCH N  (DEFAULT)
    !      IF SET TO FALSE THEN IF ALREADY ALLOCATED AND ALLOCATION IS GREATER THAN N, THEN NOTHING IS DONE
    INTEGER, DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: VEC
    INTEGER,                            INTENT(IN   ):: N
    LOGICAL,                  OPTIONAL, INTENT(IN   ):: EXACT
    INTEGER, DIMENSION(:),  CONTIGUOUS, INTENT(IN   ):: SRC
    LOGICAL,                  OPTIONAL, INTENT(OUT  ):: NEW_ALLOC
    LOGICAL:: EXACT_DIM, NEW_ALLOCATION
    !
    NEW_ALLOCATION = FALSE
    !
    IF(N > Z) THEN
                  EXACT_DIM = TRUE
                  IF(PRESENT(EXACT)) EXACT_DIM = EXACT
                  !
                  IF( ALLOCATED(VEC) ) THEN
                                       IF(EXACT_DIM .AND. SIZE(VEC).NE.N) THEN
                                                                               NEW_ALLOCATION = TRUE
                                                                               DEALLOCATE(VEC)
                                                                               ALLOCATE(VEC(N), SOURCE=SRC)
                                       ELSEIF(            SIZE(VEC).LT.N) THEN
                                                                               NEW_ALLOCATION = TRUE
                                                                               DEALLOCATE(VEC   )
                                                                               ALLOCATE(VEC(N), SOURCE=SRC)
                                       ELSE
                                                                               VEC=SRC
                                       END IF
                  ELSE
                                                                               ALLOCATE(VEC(N), SOURCE=SRC)
                                                                               NEW_ALLOCATION = TRUE
                  END IF
    ELSEIF(ALLOCATED(VEC)) THEN
                  EXACT_DIM = TRUE
                  IF(PRESENT(EXACT)) EXACT_DIM = EXACT
                  IF(EXACT_DIM) DEALLOCATE(VEC)
    END IF
    !
    IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=NEW_ALLOCATION
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE SUBROUTINE ALLOCATE_INT_ARRAY(ARR, N, M, DIMCHK, EXACT, SRC)
    !ARR IS ARRAY TO ALLOCATE
    !N,M ARE THE DIMENSION TO ALLOCATE => ARR(N,M)
    !DIMCHK IS THE DIMENSION TO CHECK FOR A MATCH, 0 IS EXACT MATCH ALL DIM, 1 MUST MATCH DIM 1, etc.
    INTEGER, DIMENSION(:,:), ALLOCATABLE, INTENT(INOUT):: ARR
    INTEGER,                              INTENT(IN   ):: N, M
    INTEGER,                    OPTIONAL, INTENT(IN   ):: DIMCHK
    LOGICAL,                    OPTIONAL, INTENT(IN   ):: EXACT
    INTEGER,                    OPTIONAL, INTENT(IN   ):: SRC
    !
    IF(PRESENT(DIMCHK) .AND. ALLOCATED(ARR)) THEN
        CALL ALLOCATE_INT_ARRAY_DIMCHK(ARR, N, M, DIMCHK, EXACT, SRC)
    ELSE
        IF( ALLOCATED(ARR) ) DEALLOCATE(ARR)
        !
        IF(N>Z .AND. M>Z) THEN
            IF( PRESENT(SRC) ) THEN
                ALLOCATE(ARR(N,M), SOURCE=SRC)
            ELSE
                ALLOCATE(ARR(N,M))
            END IF
        END IF
    END IF
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE SUBROUTINE ALLOCATE_INT_ARRAY_SRC(ARR, N, M, DIMCHK, EXACT, SRC)
    !ARR IS ARRAY TO ALLOCATE
    !N,M ARE THE DIMENSION TO ALLOCATE => ARR(N,M)
    !DIMCHK IS THE DIMENSION TO CHECK FOR A MATCH, 0 IS EXACT MATCH ALL DIM, 1 MUST MATCH DIM 1, etc.
    INTEGER, DIMENSION(:,:), ALLOCATABLE, INTENT(INOUT):: ARR
    INTEGER,                              INTENT(IN   ):: N, M
    INTEGER,                    OPTIONAL, INTENT(IN   ):: DIMCHK
    LOGICAL,                    OPTIONAL, INTENT(IN   ):: EXACT
    INTEGER, DIMENSION(:,:),  CONTIGUOUS, INTENT(IN   ):: SRC
    !
    IF(PRESENT(DIMCHK) .AND. ALLOCATED(ARR) .AND. N > Z .AND. M > Z) THEN
        !
        CALL ALLOCATE_INT_ARRAY_DIMCHK_SRC(ARR, N, M, DIMCHK, EXACT, SRC)
    ELSE
        IF( ALLOCATED(ARR) ) DEALLOCATE(ARR)
        !
        IF(N>Z .AND. M>Z) ALLOCATE(ARR(N,M), SOURCE=SRC)
    END IF
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE SUBROUTINE ALLOCATE_INT_ARRAY_DIMCHK_SRC(ARR, N, M, DIMCHK, EXACT, SRC)
    !ARR IS ARRAY TO ALLOCATE
    !N,M ARE THE DIMENSION TO ALLOCATE => ARR(N,M)
    !DIMCHK IS THE DIMENSION TO CHECK FOR A MATCH, 0 IS EXACT MATCH ALL DIM, 1 MUST MATCH DIM 1, etc.
    INTEGER, DIMENSION(:,:), ALLOCATABLE, INTENT(INOUT):: ARR
    INTEGER,                              INTENT(IN   ):: N, M, DIMCHK
    LOGICAL,                    OPTIONAL, INTENT(IN   ):: EXACT
    INTEGER, DIMENSION(N,M),              INTENT(IN   ):: SRC
    LOGICAL:: EXACT_DIM, ALOC
    !
    IF(N>Z .AND. M>Z) THEN
       EXACT_DIM = TRUE
       IF(PRESENT(EXACT)) EXACT_DIM = EXACT
       !
       ALOC = TRUE
       !
       IF( ALLOCATED(ARR) ) THEN
           ALOC = FALSE
           IF(DIMCHK == ONE) THEN
               IF(EXACT_DIM .AND. SIZE(ARR,ONE).NE.N) THEN
                                                          ALOC = TRUE
                                                          DEALLOCATE(ARR)
               ELSEIF(            SIZE(ARR,ONE).LT.N) THEN
                                                          ALOC = TRUE
                                                          DEALLOCATE(ARR)
               END IF
           ELSEIF(DIMCHK == TWO) THEN
               IF(EXACT_DIM .AND. SIZE(ARR,TWO).NE.M) THEN
                                                          ALOC = TRUE
                                                          DEALLOCATE(ARR)
               ELSEIF(            SIZE(ARR,TWO).LT.M) THEN
                                                          ALOC = TRUE
                                                          DEALLOCATE(ARR)
               END IF
           ELSEIF(SIZE(ARR,TWO).NE.N .OR. SIZE(ARR,TWO).NE.M) THEN
                                                          ALOC = TRUE
                                                          DEALLOCATE(ARR)
           
           END IF
       END IF
       !
       IF(ALOC) THEN
           ALLOCATE(ARR(N,M), SOURCE=SRC)
       ELSE
                                ARR  = SRC
       END IF
       !
    ELSEIF(ALLOCATED(ARR)) THEN
                                DEALLOCATE(ARR)
    END IF
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE SUBROUTINE ALLOCATE_INT_ARRAY_DIMCHK(ARR, N, M, DIMCHK, EXACT, SRC)
    !ARR IS ARRAY TO ALLOCATE
    !N,M ARE THE DIMENSION TO ALLOCATE => ARR(N,M)
    !DIMCHK IS THE DIMENSION TO CHECK FOR A MATCH, 0 IS EXACT MATCH ALL DIM, 1 MUST MATCH DIM 1, etc.
    INTEGER, DIMENSION(:,:), ALLOCATABLE, INTENT(INOUT):: ARR
    INTEGER,                              INTENT(IN   ):: N, M, DIMCHK
    LOGICAL,                    OPTIONAL, INTENT(IN   ):: EXACT
    INTEGER,                    OPTIONAL, INTENT(IN   ):: SRC
    LOGICAL:: EXACT_DIM, ALOC
    !
    IF(N>Z .AND. M>Z) THEN
       EXACT_DIM = TRUE
       IF(PRESENT(EXACT)) EXACT_DIM = EXACT
       !
       ALOC = TRUE
       !
       IF( ALLOCATED(ARR) ) THEN
           ALOC = FALSE
           IF(DIMCHK == ONE) THEN
               IF(EXACT_DIM .AND. SIZE(ARR,ONE).NE.N) THEN
                                                          ALOC = TRUE
                                                          DEALLOCATE(ARR)
               ELSEIF(            SIZE(ARR,ONE).LT.N) THEN
                                                          ALOC = TRUE
                                                          DEALLOCATE(ARR)
               END IF
           ELSEIF(DIMCHK == TWO) THEN
               IF(EXACT_DIM .AND. SIZE(ARR,TWO).NE.M) THEN
                                                          ALOC = TRUE
                                                          DEALLOCATE(ARR)
               ELSEIF(            SIZE(ARR,TWO).LT.M) THEN
                                                          ALOC = TRUE
                                                          DEALLOCATE(ARR)
               END IF
           ELSEIF(SIZE(ARR,TWO).NE.N .OR. SIZE(ARR,TWO).NE.M) THEN
                                                          ALOC = TRUE
                                                          DEALLOCATE(ARR)
           
           END IF
       END IF
       !
       IF(ALOC) THEN
           IF( PRESENT(SRC) ) THEN
               ALLOCATE(ARR(N,M), SOURCE=SRC)
           ELSE
               ALLOCATE(ARR(N,M))
           END IF
       ELSEIF(PRESENT(SRC)) THEN
                                ARR  = SRC
       END IF
       !
    ELSEIF(ALLOCATED(ARR)) THEN
                                DEALLOCATE(ARR)
    END IF
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE SUBROUTINE ALLOCATE_DBLE_VECTOR(VEC, N, EXACT, SRC, NEW_ALLOC)
    !VEC IS VECTOR TO ALLOCATE
    !N IS THE DIMENSION TO ALLOCATE
    !EXACT IF SET TO TRUE TO INDICATE ALLOCATION MUST MATCH N  (DEFAULT)
    !      IF SET TO FALSE THEN IF ALREADY ALLOCATED AND ALLOCATION IS GREATER THAN N, THEN NOTHING IS DONE
    REAL(REAL64), DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: VEC
    INTEGER,                                 INTENT(IN   ):: N
    LOGICAL,                       OPTIONAL, INTENT(IN   ):: EXACT
    REAL(REAL64),                  OPTIONAL, INTENT(IN   ):: SRC
    LOGICAL,                       OPTIONAL, INTENT(OUT  ):: NEW_ALLOC
    LOGICAL:: EXACT_DIM, NEW_ALLOCATION
    !
    NEW_ALLOCATION = FALSE
    !
    IF(N > Z) THEN
                  EXACT_DIM = TRUE
                  IF(PRESENT(EXACT)) EXACT_DIM = EXACT
                  !
                  IF( ALLOCATED(VEC) ) THEN
                                       IF(EXACT_DIM .AND. SIZE(VEC).NE.N) THEN
                                                                               NEW_ALLOCATION = TRUE
                                                                               DEALLOCATE(VEC   )
                                                                               IF(PRESENT(SRC)) THEN
                                                                                                    ALLOCATE(VEC(N), SOURCE=SRC)
                                                                               ELSE
                                                                                                    ALLOCATE(VEC(N))
                                                                               END IF
                                       ELSEIF(            SIZE(VEC).LT.N) THEN
                                                                               NEW_ALLOCATION = TRUE
                                                                               DEALLOCATE(VEC   )
                                                                               IF(PRESENT(SRC)) THEN
                                                                                                    ALLOCATE(VEC(N), SOURCE=SRC)
                                                                               ELSE
                                                                                                    ALLOCATE(VEC(N))
                                                                               END IF
                                       ELSEIF(PRESENT(SRC)) THEN
                                                                               VEC=SRC
                                       END IF
                  ELSE
                                                                               IF(PRESENT(SRC)) THEN
                                                                                                    ALLOCATE(VEC(N), SOURCE=SRC)
                                                                               ELSE
                                                                                                    ALLOCATE(VEC(N))
                                                                               END IF
                                                                               NEW_ALLOCATION = TRUE
                  END IF
    ELSEIF(ALLOCATED(VEC)) THEN
                  EXACT_DIM = TRUE
                  IF(PRESENT(EXACT)) EXACT_DIM = EXACT
                  IF(EXACT_DIM) DEALLOCATE(VEC)
    END IF
    !
    IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=NEW_ALLOCATION
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE SUBROUTINE ALLOCATE_DBLE_ARRAY(ARR, N, M, DIMCHK, EXACT, SRC)
    !ARR IS ARRAY TO ALLOCATE
    !N,M ARE THE DIMENSION TO ALLOCATE => ARR(N,M)
    !DIMCHK IS THE DIMENSION TO CHECK FOR A MATCH, 0 IS EXACT MATCH ALL DIM, 1 MUST MATCH DIM 1, etc.
    REAL(REAL64), DIMENSION(:,:), ALLOCATABLE, INTENT(INOUT):: ARR
    INTEGER,                                   INTENT(IN   ):: N, M
    INTEGER,                         OPTIONAL, INTENT(IN   ):: DIMCHK
    LOGICAL,                         OPTIONAL, INTENT(IN   ):: EXACT
    REAL(REAL64),                    OPTIONAL, INTENT(IN   ):: SRC
    !
    IF(PRESENT(DIMCHK) .AND. ALLOCATED(ARR)) THEN
        CALL ALLOCATE_DBLE_ARRAY_DIMCHK(ARR, N, M, DIMCHK, EXACT, SRC)
    ELSE
        IF( ALLOCATED(ARR) ) DEALLOCATE(ARR)
        !
        IF(N>Z .AND. M>Z) THEN
            IF( PRESENT(SRC) ) THEN
                ALLOCATE(ARR(N,M), SOURCE=SRC)
            ELSE
                ALLOCATE(ARR(N,M))
            END IF
        END IF
    END IF
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE SUBROUTINE ALLOCATE_DBLE_ARRAY_DIMCHK(ARR, N, M, DIMCHK, EXACT, SRC)
    !ARR IS ARRAY TO ALLOCATE
    !N,M ARE THE DIMENSION TO ALLOCATE => ARR(N,M)
    !DIMCHK IS THE DIMENSION TO CHECK FOR A MATCH, 0 IS EXACT MATCH ALL DIM, 1 MUST MATCH DIM 1, etc.
    REAL(REAL64), DIMENSION(:,:), ALLOCATABLE, INTENT(INOUT):: ARR
    INTEGER,                                   INTENT(IN   ):: N, M, DIMCHK
    LOGICAL,                         OPTIONAL, INTENT(IN   ):: EXACT
    REAL(REAL64),                    OPTIONAL, INTENT(IN   ):: SRC
    LOGICAL:: EXACT_DIM, ALOC
    !
    IF(N>Z .AND. M>Z) THEN
       EXACT_DIM = TRUE
       IF(PRESENT(EXACT)) EXACT_DIM = EXACT
       !
       ALOC = TRUE
       !
       IF( ALLOCATED(ARR) ) THEN
           ALOC = FALSE
           IF(DIMCHK == ONE) THEN
               IF(EXACT_DIM .AND. SIZE(ARR,ONE).NE.N) THEN
                                                          ALOC = TRUE
                                                          DEALLOCATE(ARR)
               ELSEIF(            SIZE(ARR,ONE).LT.N) THEN
                                                          ALOC = TRUE
                                                          DEALLOCATE(ARR)
               END IF
           ELSEIF(DIMCHK == TWO) THEN
               IF(EXACT_DIM .AND. SIZE(ARR,TWO).NE.M) THEN
                                                          ALOC = TRUE
                                                          DEALLOCATE(ARR)
               ELSEIF(            SIZE(ARR,TWO).LT.M) THEN
                                                          ALOC = TRUE
                                                          DEALLOCATE(ARR)
               END IF
           ELSEIF(SIZE(ARR,TWO).NE.N .OR. SIZE(ARR,TWO).NE.M) THEN
                                                          ALOC = TRUE
                                                          DEALLOCATE(ARR)
           
           END IF
       END IF
       !
       IF(ALOC) THEN
           IF( PRESENT(SRC) ) THEN
               ALLOCATE(ARR(N,M), SOURCE=SRC)
           ELSE
               ALLOCATE(ARR(N,M))
           END IF
       ELSEIF(PRESENT(SRC)) THEN
                                ARR  = SRC
       END IF
       !
    ELSEIF(ALLOCATED(ARR)) THEN
                                DEALLOCATE(ARR)
    END IF
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  !!!PURE SUBROUTINE ALLOCATE_TF_VECTOR(VEC, N, EXACT, NEW_ALLOC)
  !!!  !VEC IS VECTOR TO ALLOCATE
  !!!  !N IS THE DIMENSION TO ALLOCATE. IF <1 THEN SUBROUTINE DOES NOTHING
  !!!  !EXACT IF SET TO TRUE TO INDICATE ALLOCATION MUST MATCH N  (DEFAULT)
  !!!  !      IF SET TO FALSE THEN IF ALREADY ALLOCATED AND ALLOCATION IS GREATER THAN N, THEN NOTHING IS DONE
  !!!  LOGICAL, DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: VEC
  !!!  INTEGER,                            INTENT(IN   ):: N
  !!!  LOGICAL,                  OPTIONAL, INTENT(IN   ):: EXACT
  !!!  LOGICAL,                  OPTIONAL, INTENT(OUT  ):: NEW_ALLOC
  !!!  LOGICAL:: EXACT_DIM, NEW_ALLOCATION
  !!!  !
  !!!  NEW_ALLOCATION = FALSE
  !!!  !
  !!!  IF(N > Z) THEN
  !!!                EXACT_DIM = TRUE
  !!!                IF(PRESENT(EXACT)) EXACT_DIM = EXACT
  !!!                !
  !!!                IF( ALLOCATED(VEC) ) THEN
  !!!                                     IF(EXACT_DIM .AND. SIZE(VEC).NE.N) THEN
  !!!                                                                             NEW_ALLOCATION = TRUE
  !!!                                                                             DEALLOCATE(VEC   )
  !!!                                                                             ALLOCATE(  VEC(N))
  !!!                                     ELSEIF(            SIZE(VEC).LT.N) THEN
  !!!                                                                             NEW_ALLOCATION = TRUE
  !!!                                                                             DEALLOCATE(VEC   )
  !!!                                                                             ALLOCATE(  VEC(N))
  !!!                                     END IF
  !!!                ELSE
  !!!                                                                             ALLOCATE(  VEC(N))
  !!!                                                                             NEW_ALLOCATION = TRUE
  !!!                END IF
  !!!  ELSEIF(ALLOCATED(VEC)) THEN
  !!!                EXACT_DIM = TRUE
  !!!                IF(PRESENT(EXACT)) EXACT_DIM = EXACT
  !!!                IF(EXACT_DIM) DEALLOCATE(VEC)
  !!!  END IF
  !!!  !
  !!!  IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=NEW_ALLOCATION
  !!!  !
  !!!END SUBROUTINE
  PURE SUBROUTINE ALLOCATE_TF_VECTOR(VEC, N, EXACT, SRC, NEW_ALLOC)
    !VEC IS VECTOR TO ALLOCATE
    !N IS THE DIMENSION TO ALLOCATE. IF <1 THEN SUBROUTINE DOES NOTHING
    !EXACT IF SET TO TRUE TO INDICATE ALLOCATION MUST MATCH N  (DEFAULT)
    !      IF SET TO FALSE THEN IF ALREADY ALLOCATED AND ALLOCATION IS GREATER THAN N, THEN NOTHING IS DONE
    LOGICAL, DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: VEC
    INTEGER,                            INTENT(IN   ):: N
    LOGICAL,                  OPTIONAL, INTENT(IN   ):: EXACT
    LOGICAL,                  OPTIONAL, INTENT(IN   ):: SRC
    LOGICAL,                  OPTIONAL, INTENT(OUT  ):: NEW_ALLOC
    LOGICAL:: EXACT_DIM, NEW_ALLOCATION
    !
    NEW_ALLOCATION = FALSE
    !
    IF(N > Z) THEN
                  EXACT_DIM = TRUE
                  IF(PRESENT(EXACT)) EXACT_DIM = EXACT
                  !
                  IF( ALLOCATED(VEC) ) THEN
                                       IF(EXACT_DIM .AND. SIZE(VEC).NE.N) THEN
                                                                               NEW_ALLOCATION = TRUE
                                                                               DEALLOCATE(VEC)
                                                                               IF(PRESENT(SRC)) THEN
                                                                                                    ALLOCATE(VEC(N), SOURCE=SRC)
                                                                               ELSE
                                                                                                    ALLOCATE(VEC(N))
                                                                               END IF
                                       ELSEIF(            SIZE(VEC).LT.N) THEN
                                                                               NEW_ALLOCATION = TRUE
                                                                               DEALLOCATE(VEC   )
                                                                               IF(PRESENT(SRC)) THEN
                                                                                                    ALLOCATE(VEC(N), SOURCE=SRC)
                                                                               ELSE
                                                                                                    ALLOCATE(VEC(N))
                                                                               END IF
                                       ELSEIF(PRESENT(SRC)) THEN
                                                                               VEC=SRC
                                       END IF
                  ELSE
                                                                               IF(PRESENT(SRC)) THEN
                                                                                                    ALLOCATE(VEC(N), SOURCE=SRC)
                                                                               ELSE
                                                                                                    ALLOCATE(VEC(N))
                                                                               END IF
                                                                               NEW_ALLOCATION = TRUE
                  END IF
    ELSEIF(ALLOCATED(VEC)) THEN
                  EXACT_DIM = TRUE
                  IF(PRESENT(EXACT)) EXACT_DIM = EXACT
                  IF(EXACT_DIM) DEALLOCATE(VEC)
    END IF
    !
    IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=NEW_ALLOCATION
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE SUBROUTINE ALLOCATE_TF_VECTOR_SRC(VEC, N, EXACT, SRC, NEW_ALLOC)
    !VEC IS VECTOR TO ALLOCATE
    !N IS THE DIMENSION TO ALLOCATE. IF <1 THEN SUBROUTINE DOES NOTHING
    !EXACT IF SET TO TRUE TO INDICATE ALLOCATION MUST MATCH N  (DEFAULT)
    !      IF SET TO FALSE THEN IF ALREADY ALLOCATED AND ALLOCATION IS GREATER THAN N, THEN NOTHING IS DONE
    LOGICAL, DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: VEC
    INTEGER,                            INTENT(IN   ):: N
    LOGICAL,                  OPTIONAL, INTENT(IN   ):: EXACT
    LOGICAL, DIMENSION(:),  CONTIGUOUS, INTENT(IN   ):: SRC
    LOGICAL,                  OPTIONAL, INTENT(OUT  ):: NEW_ALLOC
    LOGICAL:: EXACT_DIM, NEW_ALLOCATION
    !
    NEW_ALLOCATION = FALSE
    !
    IF(N > Z) THEN
                  EXACT_DIM = TRUE
                  IF(PRESENT(EXACT)) EXACT_DIM = EXACT
                  !
                  IF( ALLOCATED(VEC) ) THEN
                                       IF(EXACT_DIM .AND. SIZE(VEC).NE.N) THEN
                                                                               NEW_ALLOCATION = TRUE
                                                                               DEALLOCATE(VEC)
                                                                               ALLOCATE(VEC(N), SOURCE=SRC)
                                       ELSEIF(            SIZE(VEC).LT.N) THEN
                                                                               NEW_ALLOCATION = TRUE
                                                                               DEALLOCATE(VEC   )
                                                                               ALLOCATE(VEC(N), SOURCE=SRC)
                                       ELSE
                                                                               VEC=SRC
                                       END IF
                  ELSE
                                                                               ALLOCATE(VEC(N), SOURCE=SRC)
                                                                               NEW_ALLOCATION = TRUE
                  END IF
    ELSEIF(ALLOCATED(VEC)) THEN
                  EXACT_DIM = TRUE
                  IF(PRESENT(EXACT)) EXACT_DIM = EXACT
                  IF(EXACT_DIM) DEALLOCATE(VEC)
    END IF
    !
    IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=NEW_ALLOCATION
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE SUBROUTINE ALLOCATE_TF_ARRAY(ARR, N, M)
    !ARR IS ARRAY TO ALLOCATE
    !N,M ARE THE DIMENSION TO ALLOCATE => ARR(N,M)
    LOGICAL, DIMENSION(:,:), ALLOCATABLE, INTENT(INOUT):: ARR
    INTEGER,                              INTENT(IN   ):: N, M
    !
    IF( ALLOCATED(ARR) ) DEALLOCATE(ARR)
    !
    IF(N>Z .AND. M>Z) ALLOCATE(ARR(N,M))
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE SUBROUTINE ALLOCATE_CHAR_VECTOR(VEC, N, EXACT, SRC, NEW_ALLOC) 
    !VEC IS VECTOR TO ALLOCATE
    !N IS THE DIMENSION TO ALLOCATE. IF <1 THEN SUBROUTINE DOES NOTHING
    !EXACT IF SET TO TRUE TO INDICATE ALLOCATION MUST MATCH N  (DEFAULT)
    !      IF SET TO FALSE THEN IF ALREADY ALLOCATED AND ALLOCATION IS GREATER THAN N, THEN NOTHING IS DONE
    CHARACTER(*), DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: VEC
    INTEGER,                                 INTENT(IN   ):: N
    LOGICAL,                       OPTIONAL, INTENT(IN   ):: EXACT
    CHARACTER(*),                  OPTIONAL, INTENT(IN   ):: SRC
    LOGICAL,                       OPTIONAL, INTENT(OUT  ):: NEW_ALLOC
    LOGICAL:: EXACT_DIM, NEW_ALLOCATION
    !
    NEW_ALLOCATION = FALSE
    !
    IF(N > Z) THEN
                  EXACT_DIM = TRUE
                  IF(PRESENT(EXACT)) EXACT_DIM = EXACT
                  !
                  IF( ALLOCATED(VEC) ) THEN
                                       IF((EXACT_DIM .AND. SIZE(VEC).NE.N) .OR. SIZE(VEC) < N ) THEN
                                                                               NEW_ALLOCATION = TRUE
                                                                               DEALLOCATE(VEC)
                                                                               ALLOCATE(VEC(N))
                                       END IF
                  ELSE
                                                                               ALLOCATE(VEC(N))
                                                                               NEW_ALLOCATION = TRUE
                  END IF
                  IF(PRESENT(SRC)) VEC = SRC
    ELSEIF(ALLOCATED(VEC)) THEN
                  EXACT_DIM = TRUE
                  IF(PRESENT(EXACT)) EXACT_DIM = EXACT
                  IF(EXACT_DIM) DEALLOCATE(VEC)
    END IF
    !
    IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=NEW_ALLOCATION
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE SUBROUTINE ALLOCATE_CHAR_VECTOR_SRC(VEC, N, EXACT, SRC, NEW_ALLOC) 
    !VEC IS VECTOR TO ALLOCATE
    !N IS THE DIMENSION TO ALLOCATE. IF <1 THEN SUBROUTINE DOES NOTHING
    !EXACT IF SET TO TRUE TO INDICATE ALLOCATION MUST MATCH N  (DEFAULT)
    !      IF SET TO FALSE THEN IF ALREADY ALLOCATED AND ALLOCATION IS GREATER THAN N, THEN NOTHING IS DONE
    CHARACTER(*), DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: VEC
    INTEGER,                                 INTENT(IN   ):: N
    LOGICAL,                       OPTIONAL, INTENT(IN   ):: EXACT
    CHARACTER(*), DIMENSION(:),  CONTIGUOUS, INTENT(IN   ):: SRC
    LOGICAL,                       OPTIONAL, INTENT(OUT  ):: NEW_ALLOC
    LOGICAL:: EXACT_DIM, NEW_ALLOCATION
    !
    NEW_ALLOCATION = FALSE
    !
    IF(N > Z) THEN
                  EXACT_DIM = TRUE
                  IF(PRESENT(EXACT)) EXACT_DIM = EXACT
                  !
                  IF( ALLOCATED(VEC) ) THEN
                                       IF((EXACT_DIM .AND. SIZE(VEC).NE.N) .OR. SIZE(VEC) < N ) THEN
                                                                               NEW_ALLOCATION = TRUE
                                                                               DEALLOCATE(VEC)
                                                                               ALLOCATE(VEC(N))
                                       END IF
                  ELSE
                                                                               ALLOCATE(VEC(N))
                                                                               NEW_ALLOCATION = TRUE
                  END IF
                  VEC = SRC
    ELSEIF(ALLOCATED(VEC)) THEN
                  EXACT_DIM = TRUE
                  IF(PRESENT(EXACT)) EXACT_DIM = EXACT
                  IF(EXACT_DIM) DEALLOCATE(VEC)
    END IF
    !
    IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=NEW_ALLOCATION
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE SUBROUTINE ALLOCATE_DIM_CHAR_VECTOR(VEC, N, DIM, EXACT, SRC, NEW_ALLOC)
    !VEC IS VECTOR TO ALLOCATE
    !N IS THE DIMENSION TO ALLOCATE. IF <1 THEN SUBROUTINE DOES NOTHING
    !EXACT IF SET TO TRUE TO INDICATE ALLOCATION MUST MATCH N  (DEFAULT)
    !      IF SET TO FALSE THEN IF ALREADY ALLOCATED AND ALLOCATION IS GREATER THAN N, THEN NOTHING IS DONE
    CHARACTER(:), DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: VEC
    INTEGER,                                 INTENT(IN   ):: N, DIM
    LOGICAL,                       OPTIONAL, INTENT(IN   ):: EXACT
    CHARACTER(*),                  OPTIONAL, INTENT(IN   ):: SRC
    LOGICAL,                       OPTIONAL, INTENT(OUT  ):: NEW_ALLOC
    LOGICAL:: EXACT_DIM, NEW_ALLOCATION
    !
    NEW_ALLOCATION = FALSE
    !
    IF(N > Z .AND. DIM > Z) THEN
                  EXACT_DIM = TRUE
                  IF(PRESENT(EXACT)) EXACT_DIM = EXACT
                  !
                  IF( ALLOCATED(VEC) ) THEN
                                       IF((EXACT_DIM .AND. (SIZE(VEC).NE.N .OR. LEN(VEC).NE.DIM)) .OR. SIZE(VEC) < N  .OR. LEN(VEC) < DIM) THEN
                                                                               NEW_ALLOCATION = TRUE
                                                                               DEALLOCATE(VEC)
                                                                               ALLOCATE(CHARACTER(DIM):: VEC(N))
                                       END IF
                  ELSE
                                                                               ALLOCATE(CHARACTER(DIM):: VEC(N))
                                                                               NEW_ALLOCATION = TRUE
                  END IF
                  IF(PRESENT(SRC)) VEC = SRC
    ELSEIF(ALLOCATED(VEC)) THEN
                  EXACT_DIM = TRUE
                  IF(PRESENT(EXACT)) EXACT_DIM = EXACT
                  IF(EXACT_DIM) DEALLOCATE(VEC)
    END IF
    !
    IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=NEW_ALLOCATION
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE SUBROUTINE ALLOCATE_DIM_CHAR_VECTOR_SRC(VEC, N, DIM, EXACT, SRC, NEW_ALLOC)
    !VEC IS VECTOR TO ALLOCATE
    !N IS THE DIMENSION TO ALLOCATE. IF <1 THEN SUBROUTINE DOES NOTHING
    !EXACT IF SET TO TRUE TO INDICATE ALLOCATION MUST MATCH N  (DEFAULT)
    !      IF SET TO FALSE THEN IF ALREADY ALLOCATED AND ALLOCATION IS GREATER THAN N, THEN NOTHING IS DONE
    CHARACTER(:), DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: VEC
    INTEGER,                                 INTENT(IN   ):: N, DIM
    LOGICAL,                       OPTIONAL, INTENT(IN   ):: EXACT
    CHARACTER(*), DIMENSION(:),  CONTIGUOUS, INTENT(IN   ):: SRC
    LOGICAL,                       OPTIONAL, INTENT(OUT  ):: NEW_ALLOC
    LOGICAL:: EXACT_DIM, NEW_ALLOCATION
    !
    NEW_ALLOCATION = FALSE
    !
    IF(N > Z .AND. DIM > Z) THEN
                  EXACT_DIM = TRUE
                  IF(PRESENT(EXACT)) EXACT_DIM = EXACT
                  !
                  IF( ALLOCATED(VEC) ) THEN
                                       IF((EXACT_DIM .AND. (SIZE(VEC).NE.N .OR. LEN(VEC).NE.DIM)) .OR. SIZE(VEC) < N  .OR. LEN(VEC) < DIM) THEN
                                                                               NEW_ALLOCATION = TRUE
                                                                               DEALLOCATE(VEC)
                                                                               ALLOCATE(CHARACTER(DIM):: VEC(N))
                                       END IF
                  ELSE
                                                                               ALLOCATE(CHARACTER(DIM):: VEC(N))
                                                                               NEW_ALLOCATION = TRUE
                  END IF
                  VEC = SRC
    ELSEIF(ALLOCATED(VEC)) THEN
                  EXACT_DIM = TRUE
                  IF(PRESENT(EXACT)) EXACT_DIM = EXACT
                  IF(EXACT_DIM) DEALLOCATE(VEC)
    END IF
    !
    IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=NEW_ALLOCATION
    !
  END SUBROUTINE
  !
END MODULE
!
!! 
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
MODULE NUM2STR_INTERFACE!, ONLY: NUM2STR, NUM2STR7, INTFMT, NUMFMT
!  NUM2STR(VAL,[GENERAL]) =>
!                            INT2STR(VAL, [PAD])              PAD > 0 is right justified, PAD < 0 is left justified
!                            REAL2STR(VAL,[GENERAL])
!                            DBLE2STR(VAL,[GENERAL])
  USE CONSTANTS,                    ONLY: BLNK, Z, ONE, TWO, DNEG, DZ, UNO, DIEZ, HECTO, KILO, inf_R, inf, TRUE, FALSE
  USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: SNG => REAL32, DBL => REAL64
  !
  IMPLICIT NONE
  !
  PRIVATE
  !
  PUBLIC:: NUM2STR, NUM2STR7, INTFMT, NUMFMT, SEQ2STR
  !
  !---------------------------------------------------------------------------------------------------------------------
  !
  INTERFACE NUM2STR
    MODULE PROCEDURE INTVEC2STR   !(IVAL,[PAD],  [SEP],[ZPAD])  --ZPAD is logical to indicate padding with 000
    MODULE PROCEDURE INT2STR      !(IVAL,[PAD],  [ZPAD])
    MODULE PROCEDURE REAL2STR     !(RVAL,        [GENERAL])
    MODULE PROCEDURE DBLVEC2STR   !(DVAL,[SEP], [PAD], [GENERAL])
    MODULE PROCEDURE DBLE2STR     !(DVAL,[PAD],  [GENERAL])
    MODULE PROCEDURE DBLE2STRDIG  !(DVAL, DIGIT, [PAD])
    MODULE PROCEDURE DBLEPAD2STR  !(DVAL, PAD, IPREC)          --High Precision Printout -- set PAD=0 to autosize, IPREC > 0 for high precision
    MODULE PROCEDURE TF2STR       !(LVAL,[PAD],  [OPT]) --NO OPT or OPT = 0 returns number, OPT = 1 returns T/F OPT = 2 returns TRUE/FALSE
  END INTERFACE
  !
  INTERFACE NUM2STR7
    MODULE PROCEDURE DBLE2STR7
    MODULE PROCEDURE SNGL2STR7
    !
    MODULE PROCEDURE INTVEC2STR   !(IVAL,[PAD],  [SEP],[ZPAD])  --ZPAD is logical to indicate padding with 000
    MODULE PROCEDURE INT2STR      !(IVAL,[PAD],  [ZPAD])
    MODULE PROCEDURE TF2STR       !(LVAL,[PAD],  [OPT]) --NO OPT or OPT = 0 returns number, OPT = 1 returns T/F OPT = 2 returns TRUE/FALSE
  END INTERFACE
  !
  INTERFACE SEQ2STR
    MODULE PROCEDURE SEQ2STR_INT  !(PRE, SEQ_END, [WIDTH], [SEP], [START], [PAD])
    MODULE PROCEDURE SEQ2STR_VEC  !(PRE, SEQ,     [WIDTH], [SEP],          [PAD])
  END INTERFACE
  !
  CONTAINS
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  FUNCTION INTFMT(LINE)
    CHARACTER(*):: LINE
    CHARACTER(8):: INTFMT
    INTEGER:: W
    !  '(I10000)'
    W = LEN_TRIM(ADJUSTL(LINE))
    INTFMT = '(I' // TRIM(INT2STR(W)) // ')'
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  FUNCTION NUMFMT(LINE)
    CHARACTER(*):: LINE
    CHARACTER(10):: NUMFMT
    INTEGER:: W
    !  '(F10000.0)'
    W = LEN_TRIM(ADJUSTL(LINE))
    NUMFMT = '(F' // TRIM(INT2STR(W)) // '.0)'
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE FUNCTION TF2STR(LVAL,PAD,OPT) !NO OPT or OPT = 0 returns number, OPT = 1 returns T/F OPT = 2 returns TRUE/FALSE
    LOGICAL,           INTENT(IN):: LVAL
    INTEGER, OPTIONAL, INTENT(IN):: PAD
    INTEGER, OPTIONAL, INTENT(IN):: OPT
    CHARACTER(:), ALLOCATABLE:: TF2STR
    CHARACTER(5)::TF
    !
    IF(.NOT. PRESENT(OPT)) THEN
                           IF(LVAL) THEN
                               TF = '1'
                           ELSE
                               TF = '0'
                           END IF
    ELSEIF(OPT == ONE) THEN
                           IF(LVAL) THEN
                               TF = 'T'
                           ELSE
                               TF = 'F'
                           END IF
    ELSEIF(OPT == TWO) THEN
                           IF(LVAL) THEN
                               TF = 'True'
                           ELSE
                               TF = 'False'
                           END IF
    ELSEIF(OPT == 3) THEN
                           IF(LVAL) THEN
                               TF = 'TRUE'
                           ELSE
                               TF = 'FALSE'
                           END IF
    ELSEIF(OPT > 3) THEN
                           IF(LVAL) THEN
                               TF = 'true'
                           ELSE
                               TF = 'false'
                           END IF
    ELSE
                           IF(LVAL) THEN
                               TF = '1'
                           ELSE
                               TF = '0'
                           END IF
    END IF
    !   
    IF(PRESENT(PAD)) THEN
        !
        TF = ADJUSTL(TF)
        !
        IF( LEN_TRIM(TF) < ABS(PAD)) THEN
                IF (PAD>Z) THEN
                           TF2STR = TRIM( REPEAT(' ',PAD-LEN_TRIM(TF))//TF )
                ELSE
                           TF2STR = TRIM(TF)//REPEAT(' ',ABS(PAD)-LEN_TRIM(TF))
                END IF
        ELSE
                           TF2STR = TRIM(TF)
        END IF
    ELSE
        TF2STR = TRIM(ADJUSTL(TF))
    END IF
       
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  !PURE FUNCTION TF2STR(LVAL) !,RIGHT
  !  LOGICAL,INTENT(IN):: LVAL
  !  CHARACTER:: TF2STR
  !  !
  !  IF(LVAL) THEN
  !      TF2STR = 'T'
  !  ELSE
  !      TF2STR = 'F'
  !  END IF
  !  !
  !END FUNCTION
  !
  !PURE FUNCTION COND2STR(LVAL,PAD) !,RIGHT
  !  LOGICAL,         INTENT(IN):: LVAL
  !  INTEGER,         INTENT(IN):: PAD
  !  CHARACTER(:),   ALLOCATABLE:: COND2STR
  !  INTEGER:: I
  !  !
  !  I = ABS(PAD)
  !  !
  !  IF (LVAL) THEN
  !      IF(I == 0) I = 5
  !      IF(I <= 4) I = 4 
  !      COND2STR = REPEAT(' ',I-4)//'True'
  !  ELSE
  !      IF(I <= 5) I = 5 
  !      COND2STR = REPEAT(' ',I-5)//'False'
  !  END IF
  !  IF(PAD<Z) COND2STR(:) = ADJUSTL(COND2STR)
  !  !
  !END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE FUNCTION INTVEC2STR(IVAL,PAD,SEP,ZPAD) RESULT(STR)
    INTEGER,DIMENSION(:),CONTIGUOUS,INTENT(IN):: IVAL
    INTEGER,     OPTIONAL,          INTENT(IN):: PAD
    CHARACTER(*),OPTIONAL,          INTENT(IN):: SEP
    LOGICAL,     OPTIONAL,          INTENT(IN):: ZPAD
    !LOGICAL,OPTIONAL,INTENT(IN):: RIGHT
    CHARACTER(:),   ALLOCATABLE:: STR
    CHARACTER(:),   ALLOCATABLE:: SEPOR
    INTEGER:: I, N
    !
    IF(PRESENT(SEP)) THEN
        ALLOCATE(SEPOR, SOURCE=SEP)
    ELSE
        ALLOCATE(SEPOR, SOURCE=BLNK)
    END IF
    !
    N = SIZE(IVAL)
    !
    IF(N < ONE) THEN
        STR = BLNK
    ELSE
        STR = INT2STR(IVAL(ONE),PAD,ZPAD)
    END IF
    !
    IF(N>ONE) THEN
          DO I=TWO, N
              STR=STR//SEPOR//INT2STR(IVAL(I),PAD,ZPAD)
          END DO
    END IF
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE FUNCTION INT2STR(IVAL,PAD,ZPAD) !,RIGHT
    INTEGER,         INTENT(IN):: IVAL
    INTEGER,OPTIONAL,INTENT(IN):: PAD
    LOGICAL,OPTIONAL,INTENT(IN):: ZPAD
    CHARACTER(:),   ALLOCATABLE:: INT2STR
    CHARACTER(30)::NUM
    !
    WRITE(NUM,'(I30)') IVAL
    !
    NUM=ADJUSTL(NUM)
    IF(PRESENT(PAD)) THEN
          !
          IF(LEN_TRIM(NUM) < ABS(PAD)) THEN
                IF (PAD>Z) THEN
                           IF(PRESENT(ZPAD)) THEN 
                               IF(ZPAD) THEN
                                   INT2STR = TRIM( REPEAT('0',PAD-LEN_TRIM(NUM))//NUM )
                               ELSE
                                   INT2STR = TRIM( REPEAT(' ',PAD-LEN_TRIM(NUM))//NUM )
                               END IF
                           ELSE
                                   INT2STR = TRIM( REPEAT(' ',PAD-LEN_TRIM(NUM))//NUM )
                           END IF
                ELSE
                                   INT2STR = TRIM(NUM)//REPEAT(' ',ABS(PAD)-LEN_TRIM(NUM))
                END IF
          ELSE
                                   INT2STR = TRIM(NUM)
          END IF
    ELSE
                                   INT2STR = TRIM(NUM)
    END IF
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE FUNCTION REAL2STR(RVAL,GENERAL)
    REAL(SNG),       INTENT(IN):: RVAL
    LOGICAL,OPTIONAL,INTENT(IN):: GENERAL
    CHARACTER(:),  ALLOCATABLE :: REAL2STR
    CHARACTER(41)::NUM
    LOGICAL::GEN
    GEN=FALSE
    IF(PRESENT(GENERAL))GEN=GENERAL
    !
    NUM=BLNK
    IF(RVAL.NE.RVAL) THEN
        NUM='NaN'
    ELSEIF(RVAL.GE.inf_R) THEN
        NUM = 'inf'
    ELSEIF(RVAL.LE.-inf_R) THEN
        NUM = '-inf'
    ELSEIF(.NOT. GEN) THEN
     !
     IF(RVAL==0E0)                               THEN
        WRITE(NUM,'(F3.1)') RVAL
     ELSEIF(RVAL>=1E10 .OR. RVAL<=-1E10)         THEN
        WRITE(NUM,'(ES40.7E2)') RVAL
     ELSEIF(RVAL>=1D6 .OR. RVAL<=-1D6)           THEN
        WRITE(NUM,'(ES40.7E1)') RVAL
     ELSEIF(RVAL>=1E0 .OR. RVAL<=-1E0 )          THEN
        WRITE(NUM,'(F40.5)') RVAL
     ELSEIF(RVAL>=0.00099E0 .OR. RVAL<=-0.00099E0 )  THEN
        WRITE(NUM,'(F40.7)') RVAL
     ELSEIF(RVAL>1E-9 .OR. RVAL<-1E-9)           THEN
        WRITE(NUM,'(ES40.5E1)') RVAL
     ELSEIF(RVAL>0E0 .OR. RVAL<0E0)              THEN
        WRITE(NUM,'(ES40.5E2)') RVAL
     END IF
     !
    ELSE
        WRITE(NUM,'(ES40.6)') RVAL 
    END IF
    !
    REAL2STR=TRIM(ADJUSTL(NUM))
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE FUNCTION DBLVEC2STR(DVAL,SEP,PAD,GENERAL) RESULT(STR)
    REAL(DBL),DIMENSION(:),CONTIGUOUS,INTENT(IN):: DVAL
    CHARACTER(*),OPTIONAL,            INTENT(IN):: SEP
    INTEGER,     OPTIONAL,            INTENT(IN):: PAD
    LOGICAL,     OPTIONAL,            INTENT(IN):: GENERAL
    !LOGICAL,OPTIONAL,INTENT(IN):: RIGHT
    CHARACTER(:),   ALLOCATABLE:: STR
    CHARACTER(:),   ALLOCATABLE:: SEPOR
    INTEGER:: I, N
    !
    IF(PRESENT(SEP)) THEN
        ALLOCATE(SEPOR, SOURCE=SEP)
    ELSE
        ALLOCATE(SEPOR, SOURCE=BLNK)
    END IF
    !
    N = SIZE(DVAL)
    !
    IF(N < ONE) THEN
        STR = BLNK
    ELSE
        STR = DBLE2STR(DVAL(ONE),PAD,GENERAL)
    END IF
    !
    IF(N>ONE) THEN
          DO I=TWO, N
              STR=STR//SEPOR//DBLE2STR(DVAL(I),PAD,GENERAL)
          END DO
    END IF
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE FUNCTION DBLE2STR(DVAL,PAD,GENERAL)
    REAL(DBL),         INTENT(IN):: DVAL
    INTEGER, OPTIONAL, INTENT(IN):: PAD
    LOGICAL, OPTIONAL, INTENT(IN):: GENERAL
    CHARACTER(:),  ALLOCATABLE :: DBLE2STR
    REAL(DBL):: DVAL1C, DVAL10, DVAL1K
    CHARACTER(15)::NUM !LARGEST POSSIBLE NUMBER IS 14 CHARACTERS
    LOGICAL::GEN
    !
    GEN=FALSE; IF(PRESENT(GENERAL))GEN=GENERAL
    !
    NUM=BLNK
    DVAL10 = DIEZ*DVAL;   DVAL1C = HECTO*DVAL;   DVAL1K = KILO*DVAL
    !
    IF(DVAL.NE.DVAL) THEN
        NUM='NaN'
    ELSEIF(DVAL.GE.inf) THEN
        NUM = 'inf'
    ELSEIF(DVAL.LE.-inf) THEN
        NUM = '-inf'
    ELSEIF(.NOT. GEN) THEN
    !
    IF(DVAL==DZ)                 THEN
       WRITE(NUM,'(F3.1)') DVAL
    ELSEIF(DVAL>=1D100 .OR. DVAL<=-1D100)       THEN
       WRITE(NUM,'(ES15.7E3)') DVAL
    ELSEIF(DVAL>=1D10 .OR. DVAL<=-1D10)         THEN
       WRITE(NUM,'(ES15.7E2)') DVAL
    ELSEIF( DVAL10 == AINT(DVAL10) .AND. (DVAL10>=UNO.OR.DVAL10<=DNEG) ) THEN
       WRITE(NUM,'(F15.1)') DVAL
    ELSEIF( DVAL1C == AINT(DVAL1C) .AND. (DVAL1C>=UNO.OR.DVAL1C<=DNEG) ) THEN
       WRITE(NUM,'(F15.2)') DVAL
    ELSEIF( DVAL1K == AINT(DVAL1K) .AND. (DVAL1K>=UNO.OR.DVAL1K<=DNEG) ) THEN
       WRITE(NUM,'(F15.3)') DVAL
    ELSEIF(DVAL>=1D6 .OR. DVAL<=-1D6)           THEN
       WRITE(NUM,'(ES15.7E1)') DVAL
    ELSEIF(DVAL>=1D2 .OR. DVAL<=-1D2 )          THEN
       WRITE(NUM,'(F15.5)') DVAL
    ELSEIF(DVAL>=0.00099D0 .OR. DVAL<=-0.00099D0 )  THEN
       WRITE(NUM,'(F15.7)') DVAL
    ELSEIF(DVAL>=1D-9 .OR. DVAL<=-1D-9)         THEN
       WRITE(NUM,'(ES15.7E1)') DVAL
    ELSEIF(DVAL>=1D-99 .OR. DVAL<=-1D-99)       THEN
       WRITE(NUM,'(ES15.7E2)') DVAL
    ELSEIF(DVAL>0D0 .OR. DVAL<0D0)              THEN
       WRITE(NUM,'(ES15.7E3)') DVAL
    END IF
    !
    ELSE
        WRITE(NUM,'(ES15.6)') DVAL 
    END IF
    !    
    IF(PRESENT(PAD)) THEN
        !
        NUM = ADJUSTL(NUM)
        !
        IF( LEN_TRIM(NUM) < ABS(PAD)) THEN
                IF (PAD>Z) THEN
                           DBLE2STR = TRIM( REPEAT(' ',PAD-LEN_TRIM(NUM))//NUM )
                ELSE
                           DBLE2STR = TRIM(NUM)//REPEAT(' ',ABS(PAD)-LEN_TRIM(NUM))
                END IF
        ELSE
                           DBLE2STR = TRIM(NUM)
        END IF
    ELSE
        DBLE2STR = TRIM(ADJUSTL(NUM))
    END IF
    !
  END FUNCTION 
  !
  !#########################################################################################################################
  !
  PURE FUNCTION DBLE2STRDIG(DVAL,DIGIT,PAD)
    REAL(DBL),        INTENT(IN):: DVAL
    CHARACTER(*),     INTENT(IN):: DIGIT
    INTEGER,OPTIONAL, INTENT(IN):: PAD
    CHARACTER(:),  ALLOCATABLE :: DBLE2STRDIG
    CHARACTER(:),  ALLOCATABLE :: DIG
    REAL(DBL)::  DVAL100
    CHARACTER(41 )::NUM
    !
    NUM=BLNK
    ALLOCATE(DIG, SOURCE=TRIM(ADJUSTL(DIGIT)))
    !DVAL10 = DIEZ*DVAL !FOR CHECKING IF THE SAME TO THE NEARIEST 
    DVAL100= HECTO*DVAL
    !
    IF(DVAL.NE.DVAL) THEN
        NUM='NaN'
    ELSEIF(DVAL.GE.inf) THEN
        NUM = 'inf'
    ELSEIF(DVAL.LE.-inf) THEN
        NUM = '-inf'
    ELSEIF(DVAL==DZ .OR. DVAL==UNO)             THEN
       WRITE(NUM,'(F3.1)') DVAL
    ELSEIF(DVAL>=1D100 .OR. DVAL<=-1D100)       THEN
       WRITE(NUM,'(ES40.'//DIG//'E3)') DVAL
    ELSEIF(DVAL>=1D10 .OR. DVAL<=-1D10)         THEN
       WRITE(NUM,'(ES40.'//DIG//'E2)') DVAL
    !ELSEIF( DVAL10 == AINT(DVAL10) .AND. (DVAL10>=UNO .OR. DVAL10<=DNEG) ) THEN
    !   WRITE(NUM,'(F40.1)') DVAL
    ELSEIF( DVAL100 == AINT(DVAL100) .AND. (DVAL100>=UNO .OR. DVAL100<=DNEG) ) THEN
       WRITE(NUM,'(F40.2)') DVAL
    ELSEIF(DVAL>=1D6 .OR. DVAL<=-1D6)           THEN
       WRITE(NUM,'(ES40.'//DIG//'E1)') DVAL
    ELSEIF(DVAL>=1D2 .OR. DVAL<=-1D2 )          THEN
       WRITE(NUM,'(F40.5)') DVAL
    ELSEIF(DVAL>=0.00099D0 .OR. DVAL<=-0.00099D0 )  THEN
       WRITE(NUM,'(F40.'//DIG//')') DVAL
    ELSEIF(DVAL>=1D-9 .OR. DVAL<=-1D-9)         THEN
       WRITE(NUM,'(ES40.'//DIG//'E1)') DVAL
    ELSEIF(DVAL>=1D-99 .OR. DVAL<=-1D-99)       THEN
       WRITE(NUM,'(ES40.'//DIG//'E2)') DVAL
    ELSEIF(DVAL>0D0 .OR. DVAL<0D0)              THEN
       WRITE(NUM,'(ES40.'//DIG//'E3)') DVAL
    END IF
    !    
    IF(PRESENT(PAD)) THEN
        !
        NUM = ADJUSTL(NUM)
        !
        IF( LEN_TRIM(NUM) < ABS(PAD)) THEN
                IF (PAD>Z) THEN
                           DBLE2STRDIG = TRIM( REPEAT(' ',PAD-LEN_TRIM(NUM))//NUM )
                ELSE
                           DBLE2STRDIG = TRIM(NUM)//REPEAT(' ',ABS(PAD)-LEN_TRIM(NUM))
                END IF
        ELSE
                           DBLE2STRDIG = TRIM(NUM)
        END IF
    ELSE
        DBLE2STRDIG = TRIM(ADJUSTL(NUM))
    END IF
    !
  END FUNCTION 
  !
  !#########################################################################################################################
  !
  PURE FUNCTION DBLEPAD2STR(DVAL, PAD, IPREC)   !HIGH PRECISION PRINT OUT
    REAL(DBL), INTENT(IN):: DVAL
    INTEGER,   INTENT(IN):: PAD, IPREC
    CHARACTER(:),  ALLOCATABLE :: DBLEPAD2STR
    REAL(DBL):: DVAL100
    CHARACTER(18)::NUM
    !
    IF( IPREC < ONE) THEN
        DBLEPAD2STR = DBLE2STR(DVAL,PAD)
    ELSE
        NUM=BLNK
        !DVAL10 = DIEZ*DVAL !FOR CHECKING IF THE SAME TO THE NEARIEST 
        DVAL100= HECTO*DVAL
        !
        IF(DVAL.NE.DVAL) THEN
            NUM='NaN'
        ELSEIF(DVAL.GE.inf) THEN
            NUM = 'inf'
        ELSEIF(DVAL.LE.-inf) THEN
            NUM = '-inf'
        ELSEIF(DVAL==DZ .OR. DVAL==UNO)             THEN
           WRITE(NUM,'(F3.1)') DVAL
        ELSEIF(DVAL>=1D100 .OR. DVAL<=-1D100)       THEN
           WRITE(NUM,'(ES18.10E3)') DVAL
        ELSEIF(DVAL>=1D10 .OR. DVAL<=-1D10)         THEN
           WRITE(NUM,'(ES18.11E2)') DVAL
        !ELSEIF( DVAL10 == AINT(DVAL10) .AND. (DVAL10>=UNO .OR. DVAL10<=DNEG) ) THEN
        !   WRITE(NUM,'(F18.1)') DVAL
        ELSEIF( DVAL100 == AINT(DVAL100) .AND. (DVAL100>=UNO.OR.DVAL100<=DNEG) ) THEN
           WRITE(NUM,'(F18.2)') DVAL
        ELSEIF(DVAL>=1D6 .OR. DVAL<=-1D6)           THEN
           WRITE(NUM,'(ES18.12E1)') DVAL
        ELSEIF(DVAL>=1D2 .OR. DVAL<=-1D2 )          THEN
           WRITE(NUM,'(F18.8)') DVAL
        ELSEIF(DVAL>=0.00099D0 .OR. DVAL<=-0.00099D0 )  THEN
           WRITE(NUM,'(F18.8)') DVAL
        ELSEIF(DVAL>=1D-9 .OR. DVAL<=-1D-9)         THEN
           WRITE(NUM,'(ES18.12E1)') DVAL
        ELSEIF(DVAL>=1D-99 .OR. DVAL<=-1D-99)       THEN
           WRITE(NUM,'(ES18.11E2)') DVAL
        ELSEIF(DVAL>0D0 .OR. DVAL<0D0)              THEN
           WRITE(NUM,'(ES18.10E3)') DVAL
        END IF
        !    
        NUM = ADJUSTL(NUM)
        !
        IF( LEN_TRIM(NUM) < ABS(PAD)) THEN
                IF (PAD>Z) THEN
                           DBLEPAD2STR = TRIM( REPEAT(' ',PAD-LEN_TRIM(NUM))//NUM )
                ELSE
                           DBLEPAD2STR = TRIM(NUM)//REPEAT(' ',ABS(PAD)-LEN_TRIM(NUM))
                END IF
        ELSE
                           DBLEPAD2STR = TRIM(NUM)
        END IF
    END IF
    !
  END FUNCTION 
  !
  !#########################################################################################################################
  !
  PURE FUNCTION DBLE2STR7(DVAL,PAD)
    REAL(DBL),        INTENT(IN):: DVAL
    INTEGER,OPTIONAL, INTENT(IN):: PAD
    CHARACTER(:),  ALLOCATABLE :: DBLE2STR7
    CHARACTER(15)::NUM !LARGEST POSSIBLE NUMBER IS 14 CHARACTERS
    !
    NUM=BLNK
    !DVAL10 = DIEZ*DVAL !FOR CHECKING IF THE SAME TO THE NEARIEST 
    !
    IF(DVAL.NE.DVAL) THEN
        NUM='NaN'
    ELSEIF(DVAL.GE.inf) THEN
        NUM = 'inf'
    ELSEIF(DVAL.LE.-inf) THEN
        NUM = '-inf'
    ELSE
    !
    IF(DVAL==DZ .OR. DVAL==UNO)                 THEN
       WRITE(NUM,'(F15.7)') DVAL
    ELSEIF(DVAL>=1D100 .OR. DVAL<=-1D100)       THEN
       WRITE(NUM,'(ES15.7E3)') DVAL
    ELSEIF(DVAL>=1D10 .OR. DVAL<=-1D10)         THEN
       WRITE(NUM,'(ES15.7E2)') DVAL
    !ELSEIF( DVAL10 == AINT(DVAL10) .AND. (DVAL10>=UNO .OR. DVAL10<=DNEG) ) THEN
    !   WRITE(NUM,'(F15.1)') DVAL
    ELSEIF(DVAL>=1D5 .OR. DVAL<=-1D5)           THEN
       WRITE(NUM,'(ES15.7E1)') DVAL
    ELSEIF(DVAL>=1D2 .OR. DVAL<=-1D2 )          THEN
       WRITE(NUM,'(F15.7)') DVAL
    ELSEIF(DVAL>=0.00099D0 .OR. DVAL<=-0.00099D0 )  THEN
       WRITE(NUM,'(F15.7)') DVAL
    ELSEIF(DVAL>=1D-9 .OR. DVAL<=-1D-9)         THEN
       WRITE(NUM,'(ES15.7E1)') DVAL
    ELSEIF(DVAL>=1D-99 .OR. DVAL<=-1D-99)       THEN
       WRITE(NUM,'(ES15.7E2)') DVAL
    ELSE!IF(DVAL>0D0 .OR. DVAL<0D0)              THEN
       WRITE(NUM,'(ES15.7E3)') DVAL
    END IF
    END IF
    !    
    IF(PRESENT(PAD)) THEN
        !
        NUM = ADJUSTL(NUM)
        !
        IF( LEN_TRIM(NUM) < ABS(PAD)) THEN
                IF (PAD>Z) THEN
                           DBLE2STR7 = TRIM( REPEAT(' ',PAD-LEN_TRIM(NUM))//NUM )
                ELSE
                           DBLE2STR7 = TRIM(NUM)//REPEAT(' ',ABS(PAD)-LEN_TRIM(NUM))
                END IF
        ELSE
                           DBLE2STR7 = TRIM(NUM)
        END IF
    ELSE
        DBLE2STR7 = TRIM(ADJUSTL(NUM))
    END IF
    !
  END FUNCTION 
  !
  !#########################################################################################################################
  !
  PURE FUNCTION SNGL2STR7(RVAL,PAD)
    REAL(SNG),       INTENT(IN):: RVAL
    INTEGER,OPTIONAL,INTENT(IN):: PAD
    CHARACTER(:),  ALLOCATABLE :: SNGL2STR7
    !
    SNGL2STR7 = DBLE2STR7(REAL(RVAL,DBL),PAD)
    !
  END FUNCTION 
  !
  !#########################################################################################################################
  !
  PURE FUNCTION SEQ2STR_INT(PRE,SEQ_END,WIDTH,SEP,START,PAD) RESULT(STR)
    CHARACTER(*),          INTENT(IN):: PRE
    INTEGER,               INTENT(IN):: SEQ_END
    INTEGER,     OPTIONAL, INTENT(IN):: WIDTH
    CHARACTER(*),OPTIONAL, INTENT(IN):: SEP
    INTEGER,     OPTIONAL, INTENT(IN):: START, PAD
    !
    CHARACTER(:),   ALLOCATABLE:: STR
    CHARACTER(:),   ALLOCATABLE:: WORD
    INTEGER:: I, N, ISTR, W, NSEP
    LOGICAL:: HAS_SEP
    !
    HAS_SEP = PRESENT(SEP)
    !
    IF(PRESENT(START)) THEN
        ISTR = START
    ELSE
        ISTR = ONE
    END IF
    !
    IF(PRESENT(WIDTH)) THEN
           W = WIDTH
    ELSE
           W = Z
    END IF
    !
    IF(HAS_SEP) THEN
        NSEP = LEN(SEP)
    ELSE
        NSEP = Z
    END IF
    
    !
    N = SEQ_END - ISTR + ONE
    !
    IF(N < ONE) THEN
        STR = PRE
    ELSE
        WORD = PRE // INT2STR(ISTR,PAD,TRUE)
        !
        IF     (W>Z) THEN
                            WORD = TRIM( REPEAT(' ',W-LEN_TRIM(WORD)-NSEP)//WORD )
        ELSEIF (W<Z) THEN
                            WORD = TRIM(WORD)//REPEAT(' ',ABS(W)-LEN_TRIM(WORD)-NSEP)
        END IF
        !
        STR  = WORD
        ISTR = ISTR + ONE
    END IF
    !
    IF(N>ONE) THEN
          DO I=ISTR, SEQ_END
              !
              WORD = PRE // INT2STR(I,PAD,TRUE)
              !
              IF     (W>Z) THEN
                                  WORD = TRIM( REPEAT(' ',W-LEN_TRIM(WORD)-NSEP)//WORD )
              ELSEIF (W<Z) THEN
                                  WORD = TRIM(WORD)//REPEAT(' ',ABS(W)-LEN_TRIM(WORD)-NSEP)
              END IF
              !
              IF(HAS_SEP) WORD=SEP//WORD
              !
              STR = STR//WORD
              !
          END DO
    END IF
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE FUNCTION SEQ2STR_VEC(PRE, SEQ, WIDTH, SEP, PAD) RESULT(STR)
    CHARACTER(*),                      INTENT(IN):: PRE
    INTEGER, DIMENSION(:), CONTIGUOUS, INTENT(IN):: SEQ
    INTEGER,     OPTIONAL,             INTENT(IN):: WIDTH
    CHARACTER(*),OPTIONAL,             INTENT(IN):: SEP
    INTEGER,     OPTIONAL,             INTENT(IN):: PAD
    !
    CHARACTER(:),   ALLOCATABLE:: STR
    CHARACTER(:),   ALLOCATABLE:: WORD
    INTEGER:: I, N, W, NSEP
    LOGICAL:: HAS_SEP
    !
    HAS_SEP = PRESENT(SEP)
    !
    IF(PRESENT(WIDTH)) THEN
           W = WIDTH
    ELSE
           W = Z
    END IF
    !
    IF(HAS_SEP) THEN
        NSEP = LEN(SEP)
    ELSE
        NSEP = Z
    END IF
    !
    N = SIZE(SEQ)
    !
    IF(N < ONE) THEN
        STR = PRE
    ELSE
        WORD = PRE // INT2STR(SEQ(ONE),PAD,TRUE)
        !
        IF     (W>Z) THEN
                            WORD = TRIM( REPEAT(' ',W-LEN_TRIM(WORD)-NSEP)//WORD )
        ELSEIF (W<Z) THEN
                            WORD = TRIM(WORD)//REPEAT(' ',ABS(W)-LEN_TRIM(WORD)-NSEP)
        END IF
        !
        STR  = WORD
    END IF
    !
    IF(N>ONE) THEN
          DO I=TWO, N
              !
              WORD = PRE // INT2STR(SEQ(I),PAD,TRUE)
              !
              IF     (W>Z) THEN
                                  WORD = TRIM( REPEAT(' ',W-LEN_TRIM(WORD)-NSEP)//WORD )
              ELSEIF (W<Z) THEN
                                  WORD = TRIM(WORD)//REPEAT(' ',ABS(W)-LEN_TRIM(WORD)-NSEP)
              END IF
              !
              IF(HAS_SEP) WORD=SEP//WORD
              !
              STR = STR//WORD
              !
          END DO
    END IF
    !
  END FUNCTION
END MODULE
!
!! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
! MODULE EquationParser
!  DESIGNED TO TAKE IN A LIST OF VARIABLE VALUES AND EVALUTE --SIMILAR TO ExpressionParser, but handlese equations and conditionals such as x = x + 1 or COND = X > Y
!    --MAJOR LIMITATION:
!                        EQUATION PARSER CAN NOT HANDLE NEGATIVE NUMBER INPUTS eg: "A+B*(-3+C)"  A, B, C CAN CONTAIN NEGATIVE NUMBERS, BUT "-3" DOES NOT WORK
!                        USE NEG FUNCTION TO GET NEGATIVE NUMBERS IF NEEDED      eg: "A+B*(NEG(3)+C)"    => "NEG(3)" YIELDS "-3"
!
!  VERSION 3.0 [5/17/2017] NOW CALLED EQUATIONPARSER AND ONLY HANDLES SCALAR RETURN VARIABLES.
!                          ADDED NEW FUNCTIONS
!                              EVAL          (Ln,NML,NMV,CHKCASE,CHKKEY) RESULT(ANS)  -- SOLVES EQUATION AND RETURNS ANSWER (SAME AS OLD EXPERSION PARSER)
!                              EVAL_CONDITION(Ln,NML,NMV,CHKCASE,CHKKEY) RESULT(COND) -- SOLVES INEQUALITY IN Ln
!                              EVAL_EQUATION (Ln,NML,NMV,CHKCASE,CHKKEY,IDX)          -- SOLVES EQUATION OF THE FORM   "A = B + C". IT WILL SET VALUE IN VECTOR FOR A WITH SUM OF B AND C. IT MUST CONTAIN ONE VARIABLE TO LEFT OF = AND HAVE ONE =
!
!                              INEQUALITY HASS PRIORITY ON | THEN &.
!                                  YOU CANNOT HAVE () ACROSS | OR &
!                                                                    eg. (5<3 & 8>5) | 4==4
!
!  VERSION 2.0 [6/15/2015] RESTRUCTURED MAIN VARIABLE "EQN" TO BE DERIVED DATA TYPE
!                          ADDED ABILITY TO HAVE CONDITIONAL EQUATION OF THE FORMAT "IF[CONDITION, TRUE, FALSE]"
!                               WHERE "CONDITION" IS AN EQUATION WITH "<", ">", "<=", OR ">=", THERE ALSO CAN BE MULTIPLE CONDITIONS WITH & (AND) or | (OR) OPERATORS.
!                                                 --NOTE & IS HIGHER PRECEDANCE THAN | SO IT IS ALWAYS EVALUATED FIRST. PARENTHESIS ARE NOT ALLOWED TO SPAN ACROSS THE INEQUALITY!
!                                     "TRUE"  IS THE RESULT THAT IS RETURNED IF "CONDITION" IS TRUE,  IT CAN BE AN EQUATION AS WELL
!                                     "FALSE" IS THE RESULT THAT IS RETURNED IF "CONDITION" IS FALSE, IT CAN BE AN EQUATION AS WELL  --THIS IS OPTIONAL
!                                             WHEN "FALSE" IS NOT PRESENT AND THE CONDITIONAL IS FALSE THEN THE RESULT IS SET TO NaN
!                                             THIS ALLOWS FOR OUTSIDE PROGRAMS TO CASECASE CONDITIONAL EXPRESSIONS BY CHECKING FOR NaN
!                               
!                               EXAMPLE:  IF[A<B, NEG(1), EXP(C*D)]
!                               EXAMPLE:  IF[(A+B*C)<B & A<C | B>C, NEG(1), EXP(C*D)]  
!                               CONDITIONAL EQUATION CAN BE APART OF ANY EQUATION OR WITHIN ANOTHER CONDITINAL EQUATION, eg: A + IF[A<B, IF[B<C,1,0], IF[A<C,1,0]]
!                          ADDED ABILITY TO SOLVE FOR MIN OR MAX OF A SEQUENCE OF EXPRESSIONS OF THE FORMAT "MAX[SEQ1, SEQ2, SEQ3, ...]"
!                               WHERE "SEQ" CAN BE ANY VALID EQUATION (NOTE THE LENGTH CAN BE AS MANY TERMS AS NEEDED)
!                               EXAMPLE:  MAX[1,2,3,4] or MIN[A, B, EXP(C*D), ABS(E-F^2)]
!
!  VERSION 1.1 [3/30/2014] ADDED THE ABILITY TO HAVE KEYWORD FUNCTIONS 
!                          SUCH AS "EXP", NUMERICAL INPUT (eg 5*8+A), AND NEW ELEMENTAL SUBROUTINE UPPER
!
!  VERSION 1.0 [5/01/2013] ORIGINAL VERSION THAT SUPPORTS 5 OPERATION, +-*/^, PARSING WITH ( )
!
!
! MODULE IS DESIGNED TO TAKE IN A LIST OF VARIABLE VALUES AND EVALUTE
! AN EQUATION CONTAINING THE VARIABLES WITHIN A STRING
! THE EQUATION FOLLOWS ORDER PRECIDENCE (ORDER OF OPERATIONS)
!
MODULE EquationParser!, ONLY: EVAL, EVAL_EQUATION, EVAL_CONDITION, NAME_LOOKUP    
  USE, INTRINSIC:: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN                                         !MODULE THAT TAKES IN A STRING EQUATION, REMOVES BLANKS, SOLVES FOR VARIABLE DEFINITIONS.
  USE CONSTANTS
  USE DATE_OPERATOR_INSTRUCTION
  IMPLICIT NONE
  PRIVATE                                                           !MAKES ALL VARIABLES AND FUNCTIONS PRIVATE
  !INTEGER,PARAMETER:: VARLEN=25                                     !LENTH OF VARIABLE NAMES
  !CHARACTER(VARLEN),   ALLOCATABLE,DIMENSION(:)::VAR                !NAME OF VARIABLES USED MAX LEN OF 25
  !DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:,:)::VAL                !STORED VALUES OF VARIABLES, 3rd DIM IS 1to1 WITH VAR NAMES
  CHARACTER(4), PARAMETER:: WARN='WARN'
  !CHARACTER(10),PARAMETER:: NUMBERS='0123456789'
  !CHARACTER(11),PARAMETER:: NUMPNT='0123456789.'
  CHARACTER(9), PARAMETER:: NEGCHK='([{,+-*/^'
  CHARACTER(4), PARAMETER:: ED = 'EeDd'
  CHARACTER(2), PARAMETER:: PM = '+-'
  CHARACTER(5), PARAMETER::OP='+-*/^'
  CHARACTER(1), PARAMETER::LP='('
  CHARACTER(1), PARAMETER::RP=')'
  CHARACTER(1), PARAMETER::LB='['
  CHARACTER(1), PARAMETER::RB=']'
  CHARACTER(1), PARAMETER::LC='{'
  CHARACTER(1), PARAMETER::RC='}'
  !CHARACTER(1), PARAMETER::CM=','
  INTEGER,           SAVE::IOUT=Z
  !
  TYPE EQN_TERMS
    CHARACTER(:),ALLOCATABLE::T
  END TYPE
  !
  PUBLIC::  EVAL, EVAL_EQUATION, EVAL_CONDITION, NAME_LOOKUP, KEYWORDCHECK  !THIS IS THE DRIVER INTERFACE OF THE MODULE AND DIRECTS THE INPUTS TO THE APPORPIATE SUBROUTINES. EqnEval DEFERS TO 3 DIFFERENT FUNCTIONS DEPENDING ON INPUT
  !
  ! THESE SHOULD ONLY BE CALLED ONCE AND ALLOW FOR INDIRECT LINKAGE TO UTIL MODULE ERROR REPORTING.
  PUBLIC:: EQUATION_SETUP_ERROR_ROUTINES, REMOVE_EQUATION_ERROR_ROUTINES
  !
  INTEGER, PARAMETER:: KEYLEN = 12
  CHARACTER(KEYLEN),PARAMETER, DIMENSION(12)::  KEYWORDLIST = ['ABS         ','EXP         ','LOG         ', &
                                                               'LOG10       ','NEG         ','SQRT        ', &
                                                               'ROUND       ','TRUNCATE    ',                &
                                                               'CEILING     ','FLOOR       ',                &
                                                               'NEG_TO_ZERO ','POS_TO_ZERO ']   !CHECK SEARCH LOOPS AT "DO WHILE (I <= LINELEN-4)"
  !
  CHARACTER(KEYLEN),PARAMETER, DIMENSION(15)::  MAGICLIST = [  'DATE_DIFF   ', 'ADD_YEAR    ', 'ADD_MONTH   ', &
                                                                'ADD_DAY     ', 'ADD_HOUR    ', 'ADD_MIN     ', &
                                                                'ADD_SEC     ', 'MAKE_DATE   ', 'JULIAN_DAY  ', &
                                                                'GET_DAY     ', 'GET_MONTH   ', 'GEY_YEAR    ', &
                                                                'MONTHDAYS   ', 'HAS_MONTHDAY', 'MODULO      ' ]
  !CHARACTER(4),PARAMETER,DIMENSION(6)::  KEYWORDLIST = ['ABS ','EXP ','LOG ','L10 ','NEG ','SQRT','      ']   !CHECK SEARCH LOOPS AT "DO WHILE (I <= LINELEN-4)"
  !
  !CHARACTER(3),PARAMETER, DIMENSION(3):: SPECIALWORDLIST = ['IF ', 'MIN', 'MAX']
  !
  PROCEDURE(STOP_ERROR_ROUTINE), POINTER :: STOP_ERROR => NULL()
  PROCEDURE(WARNING_MESSAGE),  POINTER :: WARNING    => NULL()
  !
  ABSTRACT INTERFACE 
     SUBROUTINE STOP_ERROR_ROUTINE(LINE, INFILE, OUTPUT, MSG, MSG2, STAT, GUESS)
       CHARACTER(*), INTENT(IN), OPTIONAL:: LINE       ! Line that error occured on
       INTEGER,      INTENT(IN), OPTIONAL:: INFILE     ! File Unit that error originated from
       INTEGER,      INTENT(IN), OPTIONAL:: OUTPUT     ! File unit to write error too
       CHARACTER(*), INTENT(IN), OPTIONAL:: MSG, MSG2  ! Supplemental messages to write in error
       INTEGER,      INTENT(IN), OPTIONAL:: STAT       ! IOSTAT or STAT number associated with error (STAT=0 disables ERROR STOP)
       LOGICAL,      INTENT(IN), OPTIONAL:: GUESS      ! If set to TRUE, then the line is guessed as being the previous line in INFILE
     END SUBROUTINE
     !
     SUBROUTINE WARNING_MESSAGE(LINE,INFILE,OUTPUT,MSG, INLINE, CMD_PRINT, SET_UNIT, KPER)
        INTEGER,      INTENT(IN), OPTIONAL:: INFILE
        CHARACTER(*), INTENT(IN), OPTIONAL:: LINE
        CHARACTER(*), INTENT(IN), OPTIONAL:: MSG
        INTEGER,      INTENT(IN), OPTIONAL:: OUTPUT 
        LOGICAL,      INTENT(IN), OPTIONAL:: INLINE 
        LOGICAL,      INTENT(IN), OPTIONAL:: CMD_PRINT
        LOGICAL,      INTENT(IN), OPTIONAL:: SET_UNIT 
        INTEGER,      INTENT(IN), OPTIONAL:: KPER   
     END SUBROUTINE
  END INTERFACE
  !
CONTAINS
!
!######################################################################      
!
! OPTIONAL SET UP ROUTINE TO ALLOW INDIRECT LINK TO UNIT_MODULE FOR BETTER ERROR REPORTING
! ONLY CALL THIS ROUTINE ONCE AT THE START OF THE SIMULATION TO INITIALIZE SUBROUTINES
SUBROUTINE EQUATION_SETUP_ERROR_ROUTINES(OUTPUT,STOP_ERROR_SUB, WARNING_SUB)
  INTEGER, INTENT(IN):: OUTPUT
  PROCEDURE(STOP_ERROR_ROUTINE):: STOP_ERROR_SUB
  PROCEDURE(WARNING_MESSAGE ):: WARNING_SUB
  !
  IOUT = OUTPUT
  STOP_ERROR => STOP_ERROR_SUB
  WARNING    => WARNING_SUB
  !
END SUBROUTINE
SUBROUTINE REMOVE_EQUATION_ERROR_ROUTINES()
  !
  IOUT = Z
  STOP_ERROR => NULL()
  WARNING    => NULL()
  !
END SUBROUTINE
!
!######################################################################      
!
!!!SUBROUTINE CHECK_FOR_ERROR(ERRMSG,LN)
!!!  CHARACTER(:),ALLOCATABLE, INTENT(IN):: ERRMSG            !IS ALLOCATED WHEN THERE IS AN ERROR RAISED
!!!  CHARACTER(*),OPTIONAL,    INTENT(IN):: LN
!!!  !
!!!  IF(ERRMSG.NE.WARN) THEN
!!!      IF(ASSOCIATED(STOP_ERROR)) THEN
!!!          CALL STOP_ERROR(LINE=LN,OUTPUT=IOUT,MSG=ERRMSG)
!!!      ELSEIF(PRESENT(LN)) THEN
!!!         WRITE(*,'(A)') ERRMSG//BLN//'THIS ERROR OCCURED WHILE PROCESSING THE FOLLOWING LINE:'//BLN//TRIM(LN)
!!!      ELSE
!!!         WRITE(*,'(A)') ERRMSG//BLN//'THIS ERROR OCCURED WHILE PROCESSING THE FOLLOWING LINE:'//BLN//TRIM(LN)
!!!      END IF
!!!      ERROR STOP
!!!  ELSEIF(LEN_TRIM(ERRMSG)>FOUR) THEN
!!!             IF(ASSOCIATED(WARNING)) THEN
!!!                 CALL WARNING(LINE=LN, OUTPUT=IOUT,MSG=ERRMSG)
!!!             ELSE    
!!!                 WRITE(*,'(A)') ERRMSG
!!!             END IF
!!!  END IF
!!!  !
!!!END SUBROUTINE
!!!!
!!!!######################################################################      
!!!!
!!!PURE FUNCTION RETURN_CHECK(ERRMSG)
!!!  CHARACTER(:),ALLOCATABLE, INTENT(IN):: ERRMSG            !IS ALLOCATED WHEN THERE IS AN ERROR RAISED
!!!  LOGICAL:: RETURN_CHECK
!!!  !
!!!  RETURN_CHECK = ERRMSG(ONE:FOUR).NE.WARN
!!!  !
!!!END FUNCTION
!
!######################################################################      
!
SUBROUTINE CHECK_FOR_ERROR(ERRMSG,LN)
  CHARACTER(:),ALLOCATABLE, INTENT(IN):: ERRMSG            !IS ALLOCATED WHEN THERE IS AN ERROR RAISED
  CHARACTER(*),OPTIONAL,    INTENT(IN):: LN
  !
  IF(RETURN_CHECK(ERRMSG)) THEN
     IF(LEN_TRIM(ERRMSG)>FOUR) THEN
        IF( ERRMSG(1:4).NE.WARN .AND. INDEX(ERRMSG,'ERROR') > Z ) THEN
            IF(ASSOCIATED(STOP_ERROR)) THEN
                CALL STOP_ERROR(LINE=LN,OUTPUT=IOUT,MSG=ERRMSG)
            ELSEIF(PRESENT(LN)) THEN
               WRITE(*,'(A)') ERRMSG//BLN//'THIS ERROR OCCURED WHILE PROCESSING THE FOLLOWING LINE:'//BLN//TRIM(LN)
            ELSE
               WRITE(*,'(A)') ERRMSG//BLN//'THIS ERROR OCCURED WHILE PROCESSING THE FOLLOWING LINE:'//BLN//TRIM(LN)
            END IF
            ERROR STOP
        ELSE
                   IF(ASSOCIATED(WARNING)) THEN
                       CALL WARNING(LINE=LN, OUTPUT=IOUT,MSG=ERRMSG)
                   ELSE    
                       WRITE(*,'(A)') ERRMSG
                   END IF
        END IF
     END IF
  END IF
  !
END SUBROUTINE
!
!######################################################################      
!
PURE FUNCTION RETURN_CHECK(ERRMSG)
  CHARACTER(:),ALLOCATABLE, INTENT(IN):: ERRMSG            !IS ALLOCATED WHEN THERE IS AN ERROR RAISED
  LOGICAL:: RETURN_CHECK
  !
  RETURN_CHECK = .FALSE.
  IF(ALLOCATED(ERRMSG)) THEN
                        IF(ERRMSG.NE.'') RETURN_CHECK = .TRUE.
  END IF
END FUNCTION
!
!######################################################################      
!
SUBROUTINE EVAL_EQUATION(Ln,NML,NMV,IDX,ERRMSG)             !Ln='Actual EQUATION',NML='Named Variable List',NMV='Named Variable Values',CHKCASE=OPTIONAL:CONVERT A COPY OF NML TO UPPER,CHKKEY=OPTIONAL:CHECK FOR KEYWORD IN NML,RES='EQUATION Result'
  CHARACTER(*),                           INTENT(IN   ):: Ln               !STRING THAT CONTAINS EQUATION
  CHARACTER(*),              DIMENSION(:),INTENT(IN   ):: NML              !ARRAY OF VARIABLE NAMES
  DOUBLE PRECISION,          DIMENSION(:),INTENT(INOUT):: NMV              !ARRAY OF VARIABLE VALUES WITH HIGHEST DIMENSION ONE TO ONE WITH VARIABLE NAME ARRAY (RIGHT MOST DIM) 
  INTEGER,         OPTIONAL,              INTENT(OUT  ):: IDX              !OPTIONAL INDEX OF WHAT VARIABLE WAS SET
  CHARACTER(:),    OPTIONAL, ALLOCATABLE, INTENT(INOUT):: ERRMSG           !OPTIONAL AND IS SET TO NON-BLANK IF ERR OCCURED
  DOUBLE PRECISION::ANS
  CONTIGUOUS:: NML, NMV
  !
  TYPE (EQN_TERMS),DIMENSION(:),ALLOCATABLE::Eqn
  CHARACTER(LEN_TRIM(LN))::LOCAL_LINE
  CHARACTER(LEN(NML)):: NAME
  CHARACTER(:),ALLOCATABLE:: MSG
  !
  INTEGER::I,NAME_IDX,R,MP, ILB, IRB
  !INTEGER::NVAR
  LOGICAL:: CHECK
  !
  IF(PRESENT(ERRMSG)) THEN; IF(ALLOCATED(ERRMSG)) DEALLOCATE(ERRMSG)
  END IF
  !
  ILB = Z
  IRB = Z
  MP = LEN(LN)
  DO I=1, MP
      IF    (LN(I:I) == '=') THEN
                                  R=I
                                  EXIT
      ELSEIF(LN(I:I) == LB) THEN
                                  ILB = I
      ELSEIF(LN(I:I) == RB) THEN
                                  IRB = I
      END IF
      IF(I==MP) THEN
          IF(PRESENT(ERRMSG)) THEN
              ERRMSG = 'EVAL_EQUATION ERROR: WHILE SOLVING AN EQUATION, FAILED TO LOCATE WITHIN CURRENT LINE AN "="'//NL//'IT MUST BE PRESENT TO IDENTIFY WHAT VARIABLE IS TO BE SET.'
              IF(PRESENT(IDX)) IDX = ONE
              RETURN
          ELSE
              MSG = 'EVAL_EQUATION ERROR: WHILE SOLVING AN EQUATION, FAILED TO LOCATE WITHIN CURRENT LINE AN "="'//NL//'IT MUST BE PRESENT TO IDENTIFY WHAT VARIABLE IS TO BE SET.'
              CALL CHECK_FOR_ERROR(MSG,LN)
          END IF
      END IF
  END DO
  !
  IF (ILB > Z) THEN !FOUND ARRAY INDEX FOR LHS
      !
      IF(IRB==Z)THEN
          IF(PRESENT(ERRMSG)) THEN
              ERRMSG = 'EVAL_EQUATION ERROR: THE VARIABLE TO THE LEFT OF THE EQUATION SIGN, "=",'//NL//'CONTAINED A LEFT BRACKETS, "[", BUT NOT A CORRESPONDING RIGHT BRACKET, "]".'
              RETURN
          ELSE
              MSG = 'EVAL_EQUATION ERROR: THE VARIABLE TO THE LEFT OF THE EQUATION SIGN, "=",'//NL//'CONTAINED A LEFT BRACKETS, "[", BUT NOT A CORRESPONDING RIGHT BRACKET, "]".'
              CALL CHECK_FOR_ERROR(MSG,LN)
          END IF
      END IF
      !
      LOCAL_LINE = LN(ILB+1:IRB-1)
      !
      !CALL UPPER(LOCAL_LINE)
      CALL REMOVEBLANK(LOCAL_LINE)
      CALL SplitFunc(LOCAL_LINE,Eqn,MSG)
      !
      IRB=1 ! ==> R 
      MP=1      
      CALL EqnParser(Eqn,IRB,ANS,MP,NML,NMV,MSG)
      !
      DEALLOCATE(Eqn)
      !
      IF(RETURN_CHECK(MSG)) THEN
                            IF(PRESENT(ERRMSG)) THEN
                                ERRMSG = MSG
                                IF(PRESENT(IDX)) IDX = ONE
                                RETURN
                            ELSE
                                CALL CHECK_FOR_ERROR(MSG,LN)
                            END IF
      ELSE
          IRB = NINT(ANS) - ONE
      END IF
      !
      NAME = ADJUSTL(LN(:ILB-1))
  ELSE
      NAME = ADJUSTL(LN(:R-1))
  ENDIF
  !
  !CALL UPPER(NAME)
  !
  NAME_IDX = Z
  DO I=1, SIZE(NML,1)
                     IF(NAME.EQ.NML(I))THEN
                                            NAME_IDX=I
                                            EXIT
                     END IF
  END DO
  !
  IF(NAME_IDX==Z) THEN
      IF(PRESENT(ERRMSG)) THEN
          ERRMSG = 'EquationParser ERROR: FAILED TO IDENTIFY/LOCATION VARIABLE NAME TO THE LEFTSIDE OF EQUATION.'//BLN//'THE NAME BEING SEARCH FOR WAS: "'//TRIM(NAME)//'"'//BLN//'THE FOLLOWING IS A LIST OF THE AVAILBLE VARIABLE NAMES AND THEIR VALUES:'//PRINT_VARIABLE_LIST(NML,NMV)
          IF(PRESENT(IDX)) IDX = ONE
          RETURN
      ELSE
          MSG = 'EquationParser ERROR: FAILED TO IDENTIFY/LOCATION VARIABLE NAME TO THE LEFTSIDE OF EQUATION.'//BLN//'THE NAME BEING SEARCH FOR WAS: "'//TRIM(NAME)//'"'//BLN//'THE FOLLOWING IS A LIST OF THE AVAILBLE VARIABLE NAMES AND THEIR VALUES:'//PRINT_VARIABLE_LIST(NML,NMV)
          CALL CHECK_FOR_ERROR(MSG,LN)
      END IF
  ELSEIF(ILB > Z) THEN !HAS AN ARRAY INDEX.
      !
      IF( NML(NAME_IDX) == NML(NAME_IDX+IRB) ) THEN !IS FALSE IF BAD INDEX
          !
          NAME_IDX = NAME_IDX + IRB
      ELSE
          BLOCK
              CHARACTER(16):: ITXT
              INTEGER:: IERR
              !
              IRB = IRB + ONE
              READ(ITXT,*,IOSTAT=IERR) IRB
              !
              IF(IERR.NE.Z) ITXT='???'
              !
              ITXT = ADJUSTL(ITXT)
              !
              IF(PRESENT(ERRMSG)) THEN
                  ERRMSG = ERRMSG//BLN//'EQUATION ERROR: LEFT OF THE EQUAL SIGN FOUND "'//TRIM(ADJUSTL(LN(:R-1)))//'", WHICH IS A VARIABLE NAME FOLLOWED BY []'//NL//'INDICATING IT IS AN ARRAY VARIABLE.'//NL//'THE ARRAY INDEX "'//TRIM(ADJUSTL(LN(ILB+1:IRB-1)))//'" RETURNED THE RESULT OF "'//TRIM(ITXT)//'" WHICH IS INVALID'//NL//'FOR EQUATION:'//NL//TRIM(ADJUSTL(LN))
                  IF(PRESENT(IDX)) IDX = ONE
                  RETURN
              ELSE
                  MSG = 'EQUATION ERROR: LEFT OF THE EQUAL SIGN FOUND "'//TRIM(ADJUSTL(LN(:R-1)))//'", WHICH IS A VARIABLE NAME FOLLOWED BY []'//NL//'INDICATING IT IS AN ARRAY VARIABLE.'//NL//'THE ARRAY INDEX "'//TRIM(ADJUSTL(LN(ILB+1:IRB-1)))//'" RETURNED THE RESULT OF "'//TRIM(ITXT)//'" WHICH IS INVALID'//NL//'FOR EQUATION:'//NL//TRIM(ADJUSTL(LN))
                  CALL CHECK_FOR_ERROR(MSG,LN)
              END IF
          END BLOCK
      END IF
  END IF
  !
  LOCAL_LINE = ADJUSTL(LN(R+1:))
  !
  !MAKE LINE ALL UPPER CASE FOR COMPARISONS
  !CALL UPPER(LOCAL_LINE)
  !
  ! SEARCH FOR VARIABLE NAME -- Speed up for case of one variable setting another ==> X = Y
  MP = Z
  DO I=1, SIZE(NML)
    IF(LOCAL_LINE == NML(I))THEN
      MP=I
      EXIT
    END IF
  END DO
  !
  IF(MP > Z) THEN
      ANS = NMV(MP)
  ELSE
     CALL QUICK_NUM_CHECK(LOCAL_LINE, ANS, CHECK)
     !
     IF(CHECK) THEN
         !
         !REMOVE ALL INTERNAL BLANK SPACES
         CALL REMOVEBLANK(LOCAL_LINE)
         !
         CALL SplitFunc(LOCAL_LINE,Eqn,MSG)  !SPLIT STRING INTO AN ARRAY OF STRINGS FOR EACH VARIABLE, OPERATOR, AND PAREN
         !
         R=1
         MP=1      
         CALL EqnParser(Eqn,R,ANS,MP,NML,NMV,MSG)
         !
         IF(ALLOCATED(Eqn)) DEALLOCATE(Eqn)
         !
     END IF
  END IF
  !
  !
  IF(RETURN_CHECK(MSG)) THEN
                        IF(PRESENT(ERRMSG)) THEN
                            ERRMSG = MSG
                            IF(PRESENT(IDX)) IDX = ONE
                        ELSE
                            CALL CHECK_FOR_ERROR(MSG,LN)
                        END IF
  ELSE
      NMV(NAME_IDX) = ANS
      !
      MP = SIZE(NML,1)                      !CHECK IF SETTING ENTIRE ARRAY TO VALUE
      IF(ILB == Z .AND. NAME_IDX < MP) THEN
          !
          IF(NML(NAME_IDX) == NML(NAME_IDX+1)) THEN
              !
              DO R = NAME_IDX, MP-1
                  IF(NML(R) == NML(R+1)) THEN
                                             NMV(R+1) = NMV(R)
                  ELSE
                      EXIT
                  ENDIF
              END DO
          END IF
      END IF
      !
      IF(PRESENT(IDX)) IDX = NAME_IDX
  END IF
END SUBROUTINE
!
!######################################################################      
!
FUNCTION EVAL_CONDITION(Ln,NML,NMV,ERRMSG) RESULT(COND)       !Ln='Actual EQUATION',NML='Named Variable List',NMV='Named Variable Values',CHKCASE=OPTIONAL:CONVERT A COPY OF NML TO UPPER,CHKKEY=OPTIONAL:CHECK FOR KEYWORD IN NML,RES='EQUATION Result'
  CHARACTER(*),                           INTENT(IN   ):: Ln                 !STRING THAT CONTAINS EQUATION
  CHARACTER(*),             DIMENSION(:), INTENT(IN   ):: NML                !ARRAY OF VARIABLE NAMES
  DOUBLE PRECISION,         DIMENSION(:), INTENT(IN   ):: NMV                !ARRAY OF VARIABLE VALUES WITH HIGHEST DIMENSION ONE TO ONE WITH VARIABLE NAME ARRAY (RIGHT MOST DIM) 
  CHARACTER(:),    OPTIONAL, ALLOCATABLE, INTENT(INOUT):: ERRMSG             !OPTIONAL AND IS SET TO NON-BLANK IF ERR OCCURED
  LOGICAL                                              :: COND
  CONTIGUOUS:: NML, NMV
  !
  INTEGER,         DIMENSION(:),ALLOCATABLE:: IDX                      !POINTER ARRAY THAT IS ONLY USED TO POINT TO THE & AND | IN CONDITIONAL PART OF IF
  CHARACTER(LEN_TRIM(LN))::LOCAL_LINE
  CHARACTER(:),ALLOCATABLE:: MSG
  INTEGER::I,J,N
  !INTEGER::NVAR
  !LOGICAL::CHKC,CHKK
  LOGICAL:: COND2
  !
  IF(PRESENT(ERRMSG)) THEN; IF(ALLOCATED(ERRMSG)) DEALLOCATE(ERRMSG)
  END IF
  !
  LOCAL_LINE = TRIM(LN)
  !
  N = LEN(LOCAL_LINE)
  !
  DO J=1, N
      IF ( LB ==  LOCAL_LINE(J:J) ) THEN  !LOOK FOR STARTING [
          !
          LOCAL_LINE(J:J) = BLNK
          !
          DO I=N, J, -1
                 IF ( RB ==  LOCAL_LINE(I:I) )  THEN ! LOOK FOR ENDING ]
                       LOCAL_LINE(I:I) = BLNK
                       EXIT
                 END IF
          END DO
      END IF
      !
      IF ( BLNK.NE. LOCAL_LINE(J:J) ) EXIT
  END DO
  !
  !CALL UPPER(      LOCAL_LINE)
  CALL REMOVEBLANK(LOCAL_LINE)
  !
  ! PROCESS CONDITIONAL
  IF ( INDEX(LOCAL_LINE,'|') > Z ) THEN  !SEARCH IF THERE IS AN "OR" OPERATOR 
     !
     I=Z                                     !COUND THE NUMBER OF |'s
     DO J=1, LEN(LOCAL_LINE)
         IF ( '|' == LOCAL_LINE(J:J) ) I=I+1
     END DO
     !
     ALLOCATE(IDX(I+2))          !POINTER ARRAY OF THE LOCATION OF ALL |'s
     IDX(1)=Z                    !START OF LOCATION 
     IDX(I+2)=LEN(LOCAL_LINE)+1    !END OF LOCATION
     !
     I=2
     DO J=1, LEN(LOCAL_LINE)
        IF ( '|' == LOCAL_LINE(J:J) ) THEN
            IDX(I)=J                       !Store the locations from 2 to the last |
            I=I+1
        END IF
     END DO
     !
     DO I=1, SIZE(IDX,1)-1
        IF (I==1) THEN
           CALL PROCESS_CONDITION(LOCAL_LINE( IDX(I)+1:IDX(I+1)-1 ), COND, NML,NMV,MSG)    !PASS ONLY PORTION BETWEEN MULTIPLE |'s
        ELSE
           CALL PROCESS_CONDITION(LOCAL_LINE( IDX(I)+1:IDX(I+1)-1 ), COND2,NML,NMV,MSG)   !PASS ONLY PORTION BETWEEN MULTIPLE |'s
           COND = COND .OR. COND2
           IF(COND) EXIT  !OR HAS ONE TRUE, SO NO NEED TO CHECK THE REST
        END IF
     END DO
     !
     DEALLOCATE(IDX)
  ELSE
     CALL PROCESS_CONDITION(LOCAL_LINE, COND,NML,NMV,MSG)  !NO | SO EVALUATE CONDITIONAL (THERE STILL CAN BE &'s)
  END IF
  !
  IF(RETURN_CHECK(MSG)) THEN
    IF(PRESENT(ERRMSG)) THEN
        ERRMSG = MSG
        COND   = .TRUE.
    ELSE
        CALL CHECK_FOR_ERROR(MSG,LN)
    END IF
  END IF
  !
END FUNCTION
!
!######################################################################      
!
FUNCTION EVAL(Ln,NML,NMV,ERRMSG) RESULT(ANS)              !Ln='Actual EQUATION',NML='Named Variable List',NMV='Named Variable Values',CHKCASE=OPTIONAL:CONVERT A COPY OF NML TO UPPER,CHKKEY=OPTIONAL:CHECK FOR KEYWORD IN NML,RES='EQUATION Result'
  CHARACTER(*),                           INTENT(IN   ):: Ln             !STRING THAT CONTAINS EQUATION
  CHARACTER(*),             DIMENSION(:), INTENT(IN   ):: NML            !ARRAY OF VARIABLE NAMES
  DOUBLE PRECISION,         DIMENSION(:), INTENT(IN   ):: NMV            !ARRAY OF VARIABLE VALUES WITH HIGHEST DIMENSION ONE TO ONE WITH VARIABLE NAME ARRAY (RIGHT MOST DIM) 
  CHARACTER(:),    OPTIONAL, ALLOCATABLE, INTENT(INOUT):: ERRMSG         !OPTIONAL AND IS SET TO NON-BLANK IF ERR OCCURED
  DOUBLE PRECISION                                     :: ANS
  CONTIGUOUS:: NML, NMV
  !
  TYPE (EQN_TERMS),DIMENSION(:),ALLOCATABLE::Eqn
  CHARACTER(LEN_TRIM(LN))::LOCAL_LINE
  CHARACTER(:),ALLOCATABLE:: MSG            !IS ALLOCATED WHEN THERE IS AN ERROR RAISED
  INTEGER::R,MP
  !INTEGER::NVAR
  !
  IF(PRESENT(ERRMSG)) THEN; IF(ALLOCATED(ERRMSG)) DEALLOCATE(ERRMSG)
  END IF
  !
  IF(Ln==BLNK)  THEN
     IF(PRESENT(ERRMSG)) THEN
         ERRMSG = 'EquationParser EVAL ERROR: THE LINE PASSED TO "EVAL" ROUTINE TO BE SOLVED WAS EMPTY/BLANK. CAN NOT PROCESS AN EXPRESSION FROM AN EMPTY LINE. UNFORTUNETLY CANNOT SPECIFY WHERE THIS ERROR OCCURED DUE TO THE LINE BEING EMPTY.'
     ELSE
         MSG = 'EquationParser EVAL ERROR: THE LINE PASSED TO "EVAL" ROUTINE TO BE SOLVED WAS EMPTY/BLANK. CAN NOT PROCESS AN EXPRESSION FROM AN EMPTY LINE. UNFORTUNETLY CANNOT SPECIFY WHERE THIS ERROR OCCURED DUE TO THE LINE BEING EMPTY.'
     END IF
     ANS = DZ
     RETURN
  END IF
  !
  LOCAL_LINE = TRIM(LN)
  CALL SplitFunc_PREPARE_LINE(LOCAL_LINE)
  !
  CALL SplitFunc(LOCAL_LINE,Eqn,MSG)                                           !SPLIT STRING INTO AN ARRAY OF STRINGS FOR EACH VARIABLE, OPERATOR, AND PAREN
  !
  IF(.NOT. RETURN_CHECK(MSG)) THEN
      !
      R=1
      MP=1      
      CALL EqnParser(Eqn,R,ANS,MP,NML,NMV,MSG)
  END IF
  !
  IF(RETURN_CHECK(MSG)) THEN
    IF(PRESENT(ERRMSG)) THEN
        ERRMSG = MSG
        ANS   = DZ
    ELSE
        CALL CHECK_FOR_ERROR(MSG,LN)
    END IF
  END IF
  !
  DEALLOCATE(Eqn)
END FUNCTION
!
!######################################################################            
!
RECURSIVE PURE SUBROUTINE EqnParser(Eqn,R,ANS,MP,NML,NMV,ERRMSG)         !EVALUATE PARTS OF AN EQUATION
  !CHARACTER(VARLEN),DIMENSION(:), INTENT(IN   )::Eqn               !ARRAY CONTAINING ALL PARTS OF EQUATION
  TYPE (EQN_TERMS), DIMENSION(:), INTENT(IN   )::Eqn
  INTEGER,                        INTENT(INOUT)::R                  !CURRENT INDEX OF ARRAY TO OPERATE ON 
  INTEGER,                        INTENT(IN   )::MP                 !MINIMUM PRECDIENCE OF CURRENT EQUATION
  CHARACTER(*),    DIMENSION(:),  INTENT(IN   )::NML                !ARRAY OF VARIABLE NAMES
  DOUBLE PRECISION,DIMENSION(:),  INTENT(IN   )::NMV                !ARRAY OF VARIABLE VALUES WITH HIGHEST DIMENSION ONE TO ONE WITH VARIABLE NAME ARRAY (RIGHT MOST DIM) 
  DOUBLE PRECISION,               INTENT(INOUT)::ANS                !CAN THINK OF THIS AS THE LEFT HAND SIDE OF THE OPERATION (LHS op RIGHT)
  CHARACTER(:),ALLOCATABLE,       INTENT(INOUT):: ERRMSG            !IS ALLOCATED WHEN THERE IS AN ERROR RAISED
  CONTIGUOUS:: Eqn,NML,NMV
  !
  DOUBLE PRECISION:: RHS
  INTEGER::PREC
  !
  !CHARACTER(5), PARAMETER:: OP='+-*/^'
  !
  CHARACTER(1)::DIRECTION,COP  !DIRECTION OF OPERATOR, CURRENT OPERATOR
  !
  ! operator
  ! precedence   operators       associativity
  ! 3            ^               right to left
  ! 2            * /             left to right
  ! 1            + -             left to right
  ! StartOver    (      
  ! StartOver    KEYWORD    
  !
  RHS=DZ
  !
  CALL NextAtom(Eqn,R,ANS,NML,NMV,ERRMSG)                           !NEXT ATOM MOVES TO NEXT PART OF EQUATION
  !
  DO
    IF ( R>SIZE(Eqn)                      ) EXIT                    !REACHED END OF FUNCTION
    IF ( INDEX(OP,Eqn(R)%T) < 1           ) EXIT                    !ENSURE THAT IT IS AN OPERATOR 
    !                                                                
    CALL PRECEDENCE(Eqn(R)%T, DIRECTION, PREC, ERRMSG)              !RERETRIVE PRECEDENCE LEVEL AND GET THE DIRECTION OF THE OPERATOR
    !
    IF ( PREC < MP ) EXIT                                           !PRECEDENCE LEVEL HAS BEEN REDUCED SO EXIT TO BACK CALCULATE
    !
    COP=Eqn(R)%T                                                    !CURRENT OPERATION
    !
    IF (DIRECTION=='L')THEN                                         !DIRECTION IS TO THE LEFT
      PREC=PREC+1
    !ELSE DIRECTION=='R'                                            !DIRECTION IS TO THE RIGHT NO NEED FOR UPDATE
    ! PREC = PREC  
    END IF
    R=R+1
    CALL EqnParser(Eqn,R,RHS,PREC,NML,NMV,ERRMSG)
    !
    IF(COP=='/')THEN
      IF(NEGNEARZERO_30 < RHS .AND. RHS < NEARZERO_30 .AND. .NOT.(NEGNEARZERO_30 < ANS .AND. ANS < NEARZERO_30)) THEN  !DIV/0 ERROR, BUT 0/0 ALLOWED
         IF(R==ONE) R=TWO
         IF(RETURN_CHECK(ERRMSG) ) THEN
             ERRMSG = ERRMSG//BLN//'SOLVING MATH OPERATION "/" RESULTED IN A FATAL ERROR.'//BLN//'THE LEFT HAND SIDE OF DIVISION, /, IS NON-ZERO, BUT THE RIGHT HAND SIDE IS ZERO.'//NL//'THIS RESULTS IN A DIVISION BY ZERO ERROR (1/0).'//BLN//'THIS OCCURS DURING AN OPERATION SOMEWHERE BEFORE A "/" AROUND THE FOLLOWING TERM "'//Eqn(R-1)%T//'"'//BLN//'FOR EQUATION:'//NL//REMAKE_FUNCTION(Eqn)
         ELSE
             ERRMSG = 'SOLVING MATH OPERATION "/" RESULTED IN A FATAL ERROR.'//BLN//'THE LEFT HAND SIDE OF DIVISION, /, IS NON-ZERO, BUT THE RIGHT HAND SIDE IS ZERO.'//NL//'THIS RESULTS IN A DIVISION BY ZERO ERROR (1/0).'//BLN//'THIS OCCURS DURING AN OPERATION SOMEWHERE BEFORE A "/" AROUND THE FOLLOWING TERM "'//Eqn(R-1)%T//'"'//BLN//'FOR EQUATION:'//NL//REMAKE_FUNCTION(Eqn)
         END IF
         !
         ANS = DZ
         !IF(ASSOCIATED(STOP_ERROR)) THEN
         !    CALL STOP_ERROR(OUTPUT=IOUT,MSG='EQUATION ERROR: DIVIDE BY 0 DURING AN OPERATION SOMEWHERE AFTER A "/" AND BEFORE "'//Eqn(R-1)%T//'"'//NL//'FOR EQUATION:'//NL//REMAKE_FUNCTION(Eqn)//NL//'THE FOLLOWING IS A LIST OF THE AVAILBLE VARIABLE NAMES AND THEIR VALUES:'//PRINT_VARIABLE_LIST(NML,NMV) )
         !ELSE
         !    WRITE(*,'(4A /, 9x,A)')'EQUATION ERROR: DIVIDE BY 0 DURING AN OPERATION SOMEWHERE ', &
         !               'AFTER A "/" AND BEFORE "',Eqn(R-1)%T,'" FOR EQUATION:', REMAKE_FUNCTION(Eqn)
         !    ERROR STOP
         !END IF
      END IF
    END IF
    !
    IF ( RETURN_CHECK(ERRMSG) ) THEN
        R = SIZE(Eqn) + ONE
        EXIT
    ELSE
        !
        ANS=MathOP(COP,ANS,RHS)
        !
        IF(ANS.NE.ANS) THEN
            IF(R==ONE) R=TWO
            IF    (COP == '/') THEN
                 !
                 IF(RETURN_CHECK(ERRMSG) ) THEN
                     ERRMSG = ERRMSG//BLN//'SOLVING MATH OPERATION "/" RESULTED IN A FATAL ERROR.'//BLN//'THE LEFT HAND SIDE OF DIVISION, /, IS NON-ZERO, BUT THE RIGHT HAND SIDE IS ZERO.'//NL//'THIS RESULTS IN A DIVISION BY ZERO ERROR (1/0).'//BLN//'THIS OCCURS DURING AN OPERATION SOMEWHERE AFTER A "/" AROUND THE FOLLOWING TERM "'//Eqn(R-1)%T//'"'//BLN//'FOR EQUATION:'//NL//REMAKE_FUNCTION(Eqn)
                 ELSE
                     ERRMSG = 'SOLVING MATH OPERATION "/" RESULTED IN A FATAL ERROR.'//BLN//'THE LEFT HAND SIDE OF DIVISION, /, IS NON-ZERO, BUT THE RIGHT HAND SIDE IS ZERO.'//NL//'THIS RESULTS IN A DIVISION BY ZERO ERROR (1/0).'//BLN//'THIS OCCURS DURING AN OPERATION SOMEWHERE AFTER A "/" AROUND THE FOLLOWING TERM "'//Eqn(R-1)%T//'"'//BLN//'FOR EQUATION:'//NL//REMAKE_FUNCTION(Eqn)
                 END IF
            ELSEIF(COP == '^') THEN
                 !
                 IF(RETURN_CHECK(ERRMSG) ) THEN
                     ERRMSG = ERRMSG//BLN//'SOLVING MATH OPERATION "^" RESULTED IN A FATAL ERROR.'//BLN//'THE LEFT HAND SIDE OF POWER, ^, IS NEGATIVE AND THE RIGHT HAND SIDE IS NOT AN INTEGER.'//NL//'THIS RESULTED IN A FLAOTING POINT ERROR BECAUSE IMAGINARY NUMBERS ARE NOT SUPPORTED.'//BLN//'FOR EXAMPLE: -2^0.5 <==> SQRT(-2)'//BLN//'THIS OCCURS DURING AN OPERATION SOMEWHERE BEFORE A "^" AROUND THE FOLLOWING TERM "'//Eqn(R-1)%T//'"'//BLN//'FOR EQUATION:'//NL//REMAKE_FUNCTION(Eqn)
                 ELSE
                     ERRMSG = 'SOLVING MATH OPERATION "^" RESULTED IN A FATAL ERROR.'//BLN//'THE LEFT HAND SIDE OF POWER, ^, IS NEGATIVE AND THE RIGHT HAND SIDE IS NOT AN INTEGER.'//NL//'THIS RESULTED IN A FLAOTING POINT ERROR BECAUSE IMAGINARY NUMBERS ARE NOT SUPPORTED.'//BLN//'FOR EXAMPLE: -2^0.5 <==> SQRT(-2)'//BLN//'THIS OCCURS DURING AN OPERATION SOMEWHERE BEFORE A "^" AROUND THE FOLLOWING TERM "'//Eqn(R-1)%T//'"'//BLN//'FOR EQUATION:'//NL//REMAKE_FUNCTION(Eqn)
                 END IF
            ELSE
                 IF(RETURN_CHECK(ERRMSG) ) THEN
                     ERRMSG = ERRMSG//BLN//'SOLVING MATH OPERATION "'//COP//'" RESULTED IN A FATAL ERROR (EITHER DIVIDE BY ZERO OR NEGATIVE NUMBER RAISED TO A NON-INTEGER POWER). THIS OCCURED AROUND THE FOLLOWING TERM "'//Eqn(R-1)%T//'"'
                 ELSE
                     ERRMSG = 'SOLVING MATH OPERATION "'//COP//'" RESULTED IN A FATAL ERROR (EITHER DIVIDE BY ZERO OR NEGATIVE NUMBER RAISED TO A NON-INTEGER POWER). THIS OCCURED AROUND THE FOLLOWING TERM "'//Eqn(R-1)%T//'"'
                 END IF
            END IF
            ANS = DZ
            R = SIZE(Eqn) + ONE
            EXIT    
        END IF
    END IF
    !
  END DO
  !
END SUBROUTINE
!
!######################################################################    
!
RECURSIVE PURE SUBROUTINE NextAtom(Eqn,R,ANS,NML,NMV,ERRMSG) !PULLS NEXT VARIABLE IN EQUATION
  !CHARACTER(*),DIMENSION(:),      INTENT(IN   )::Eqn               !ARRAY CONTAINING ALL PARTS OF EQUATION
  TYPE (EQN_TERMS), DIMENSION(:), INTENT(IN   )::Eqn                !!ARRAY CONTAINING ALL PARTS OF EQUATION
  INTEGER,                        INTENT(INOUT)::R                  !CURRENT INDEX OF ARRAY TO OPERATE ON 
  DOUBLE PRECISION,               INTENT(INOUT)::ANS                !THE ATOM THAT IS RETURNED
  CHARACTER(*),    DIMENSION(:),  INTENT(IN   )::NML                !ARRAY OF VARIABLE NAMES
  DOUBLE PRECISION,DIMENSION(:),  INTENT(IN   )::NMV                !ARRAY OF VARIABLE VALUES WITH HIGHEST DIMENSION ONE TO ONE WITH VARIABLE NAME ARRAY (RIGHT MOST DIM) 
  CHARACTER(:),ALLOCATABLE,       INTENT(INOUT):: ERRMSG            !IS ALLOCATED WHEN THERE IS AN ERROR RAISED
  CONTIGUOUS:: Eqn,NML,NMV
  !
  !CHARACTER(5), PARAMETER::OP='+-*/^'
  !CHARACTER(1), PARAMETER::LP='('
  !CHARACTER(1), PARAMETER::RP=')'
  CHARACTER(LEN(NML))::WORD
  INTEGER:: I,MP
  LOGICAL:: VALID
  !
  IF(RETURN_CHECK(ERRMSG)) THEN
    ANS=DZ
    R = SIZE(Eqn) + ONE
  ELSEIF (R>SIZE(Eqn)) THEN
    ANS=DZ
  ELSE IF(LP==Eqn(R)%T)THEN          !FOUND "(" START PRECDIENCE OVER TO EVALUATE TO ")"
    MP=1
    R=R+1
    CALL EqnParser(Eqn,R,ANS,MP,NML,NMV,ERRMSG)
    IF( R > SIZE(Eqn,1) ) THEN
        IF(.NOT. RETURN_CHECK(ERRMSG)) THEN
            ERRMSG = 'EQUATION ERROR:  UNMATCHED PARENTHESIS SOMEWHERE AFTER A "(" AND BEFORE "'//Eqn(R-1)%T//'"'//NL//'FOR EQUATION:'//NL//REMAKE_FUNCTION(Eqn)//BLN//  &
                         'THIS ERROR COULD ALSO OCCUR IF YOU HAVE AN IF[] BLOCK THAT CONTAINS A SET OF PARENTHESIS AROUND AN INEQUALITY.'//NL// &
                         'FOR EXAMPLE:'//BLN//'IF[ (A<B), 1, 0] OR'//NL//'IF[ (C>A & A<B) | B>C, 1, 0]'//BLN//'HOWEVER THIS IS ALLOWED:'//BLN//'IF[ (B+C)>A & A<B | (A+B)*C > D, 1, 0]'//BLN!//'THE FOLLOWING IS A LIST OF THE AVAILBLE VARIABLE NAMES AND THEIR VALUES:'//PRINT_VARIABLE_LIST(NML,NMV)
        END IF
        !
    ELSEIF(RP/=Eqn(R)%T) THEN
        ERRMSG = 'EQUATION ERROR:  UNMATCHED PARENTHESIS SOMEWHERE AFTER A "(" AND BEFORE "'//Eqn(R)%T//'"'//NL//'FOR EQUATION:'//NL//REMAKE_FUNCTION(Eqn)//NL//'THE FOLLOWING IS A LIST OF THE AVAILBLE VARIABLE NAMES AND THEIR VALUES:'//PRINT_VARIABLE_LIST(NML,NMV)
        R = SIZE(Eqn)
        !
    END IF
    R=R+1
  ELSE IF( INDEX(OP,Eqn(R)%T)>Z ) THEN
       IF(R==ONE) THEN
           ERRMSG = 'EQUATION ERROR: EXPECTED VARIABLE, BUT FOUND AN OPERATOR: +, -, *, /, AT "'//Eqn(R)%T//'" WHICH IS LOCATED AT THE START OF THE EQUATION.'//NL//'PLEASE NOTE THAT A NEGATIVE VARIABLE "-Y + X" IS NOT ALLOWED.'//NL//'NEGATIVE VARIABLES CAN ONLY BE DEFINED WITH THE NEG FUNCTION SUCH AS "NEG(Y) + X" OR CHANGING THE MATH TO BE "X - Y"'//NL//'THIS OCCURED WITHIN THE FOLLOWING EQUATION:'//NL//REMAKE_FUNCTION(Eqn)//NL//'THE FOLLOWING IS A LIST OF THE AVAILBLE VARIABLE NAMES AND THEIR VALUES:'//PRINT_VARIABLE_LIST(NML,NMV)
       ELSE
           ERRMSG = 'EQUATION ERROR: EXPECTED VARIABLE, BUT FOUND AN OPERATOR: +, -, *, /, AT "'//Eqn(R-ONE)%T//'"'//NL//'THIS MOST LIKELY OCCURED CAUSE YOU HAD TWO OPERATORS IN A ROW SUCH AS ++ or -+ OR A NEGATIVE VARIABLE "X + (-Y)".'//NL//'NEGATIVE VARIABLES CAN ONLY BE DEFINED WITH THE NEG FUNCTION SUCH AS "X + NEG(Y)" OR CHANGING THE MATH TO BE "X - Y"'//NL//'THIS OCCURED WITHIN THE FOLLOWING EQUATION:'//NL//REMAKE_FUNCTION(Eqn)//NL//'THE FOLLOWING IS A LIST OF THE AVAILBLE VARIABLE NAMES AND THEIR VALUES:'//PRINT_VARIABLE_LIST(NML,NMV)
       END IF
       R = SIZE(Eqn) + 1
       !
  ELSE IF(KEYWORD(Eqn(R)%T)) THEN      !KEYWORD AND PARETHESIS FOUND SO RESTART EQUATION SEARCH
    WORD=Eqn(R)%T
    R=R+1
    !
    IF(LP/=Eqn(R)%T) THEN
         ERRMSG = 'EQUATION ERROR: KEYWORD MUST BE FOLLOWED BY "("'//NL//'THE KEYWORD FOUND IS "'//Eqn(R-1)%T//'" AND WAS FOLLOWED BY "'//Eqn(R)%T//'"'//NL//'FOR EQUATION:'//NL//REMAKE_FUNCTION(Eqn)//NL//'THE FOLLOWING IS A LIST OF THE AVAILBLE VARIABLE NAMES AND THEIR VALUES:'//PRINT_VARIABLE_LIST(NML,NMV)
         R = SIZE(Eqn) + 1
    ELSE
         MP=1   
         R=R+1
         CALL EqnParser(Eqn,R,ANS,MP,NML,NMV,ERRMSG)    !FOUND KEYWORD and "(" START PRECDIENCE OVER TO EVALUATE TO ")"
         !
         IF( R <= SIZE(Eqn,1) ) THEN
            IF( RP/=Eqn(R)%T  ) THEN
                 ERRMSG = 'EQUATION ERROR:  UNMATCHED PARENTHESIS FOR KEYWORD "'//TRIM(WORD)//'"'//NL//'THAT OCCURS BEFORE "'//Eqn(R)%T//'"'//NL//'FOR EQUATION:'//REMAKE_FUNCTION(Eqn)//NL//'THE FOLLOWING IS A LIST OF THE AVAILBLE VARIABLE NAMES AND THEIR VALUES:'//PRINT_VARIABLE_LIST(NML,NMV)
                 R = SIZE(Eqn)
            ELSE 
                 CALL KEYWORDEVAL(WORD,ANS,VALID)                                !UPDATE ANS BY SOLVING IT WITH THE FUNCTION WORD                        
                 !
                 IF( .NOT.VALID ) THEN
                      ERRMSG = 'EQUATION ERROR: BAD VALUE ( e.g. LOG(0) ) PASSED TO THE FOLLOWING KEYWORD, "'//TRIM(WORD)//'"'//NL//'FOR EQUATION:'//NL//REMAKE_FUNCTION(Eqn)//NL//'THE FOLLOWING IS A LIST OF THE AVAILBLE VARIABLE NAMES AND THEIR VALUES:'//PRINT_VARIABLE_LIST(NML,NMV)
                      R = SIZE(Eqn)
                 END IF
            END IF
            !
            R=R+1
         END IF 
    END IF       
  ELSEIF ('IF' == Eqn(R)%T) THEN
      CALL PROCESS_INLINE_CONDITIONAL(Eqn,R,ANS,NML,NMV,ERRMSG)
  ELSEIF ('MIN'==Eqn(R)%T .OR. 'MAX'==Eqn(R)%T) THEN
      CALL PROCESS_MINMAX(Eqn,R,ANS,NML,NMV,ERRMSG)
  ELSEIF (ANY(Eqn(R)%T==MAGICLIST)) THEN
      CALL PROCESS_MAGIC (Eqn,R,ANS,NML,NMV,ERRMSG)
  ELSE IF(BLNK==Eqn(R)%T)THEN
    IF(R==1)R=2  
    ERRMSG = 'EQUATION ERROR:  UNEXPECTED ENDING OF EQUATION AFTER "'//Eqn(R-1)%T//'"'//NL//'FOR EQUATION:'//NL//REMAKE_FUNCTION(Eqn)
    R = SIZE(Eqn) + 1
    !
  ELSE
    !
    ! SEARCH FOR VARIABLE NAME
    MP = Z
    DO I=1, SIZE(NML)
      IF(Eqn(R)%T == NML(I))THEN
        MP=I
        EXIT
      END IF
    END DO
    !
    IF(MP > Z) THEN
                   IF( R<SIZE(Eqn) ) THEN
                     !
                     IF ( Eqn(R+ONE)%T == LB ) THEN
                         !
                         CALL GET_ARRAY_INDEX(Eqn,R,I,NML,NMV,ERRMSG)
                         !
                         I = I - ONE
                         IF( NML(MP) == NML(MP+I) ) THEN !IS FALSE IF BAD INDEX
                             !
                             MP = MP + I
                         ELSE
                             BLOCK
                                 CHARACTER(16):: IDX
                                 INTEGER:: IERR
                                 !
                                 I = I + ONE
                                 READ(IDX,*,IOSTAT=IERR) I
                                 !
                                 IF(IERR.NE.Z) IDX='???'
                                 !
                                 IDX= ADJUSTL(IDX)
                                 !
                                 IF(RETURN_CHECK(ERRMSG) ) THEN
                                     ERRMSG = ERRMSG//BLN//'EQUATION ERROR: FOUND "'//Eqn(R-3)%T//Eqn(R-2)%T//Eqn(R-1)%T//Eqn(R)%T//'", WHICH IS A VARIABLE NAME FOLLOWED BY [] INDICATING IT IS AN ARRAY VARIABLE.'//NL//'THE ARRAY INDEX "'//Eqn(R-1)%T//'" RETURNED THE RESULT OF "'//TRIM(IDX)//'" WHICH IS INVALID'//NL//'FOR EQUATION:'//NL//REMAKE_FUNCTION(Eqn)
                                 ELSE
                                     ERRMSG =              'EQUATION ERROR: FOUND "'//Eqn(R-3)%T//Eqn(R-2)%T//Eqn(R-1)%T//Eqn(R)%T//'", WHICH IS A VARIABLE NAME FOLLOWED BY [] INDICATING IT IS AN ARRAY VARIABLE.'//NL//'THE ARRAY INDEX "'//Eqn(R-1)%T//'" RETURNED THE RESULT OF "'//TRIM(IDX)//'" WHICH IS INVALID'//NL//'FOR EQUATION:'//NL//REMAKE_FUNCTION(Eqn)
                                 END IF
                             END BLOCK
                             R = SIZE(Eqn)
                         END IF
                         !
                     END IF
                   END IF
                                  ANS = NMV( MP )
    ELSE
        CALL QUICK_NUM_CHECK(Eqn(R)%T, ANS, VALID) !VALID IS TRUE IF NOT FOUND NUMBER
        !
        IF(VALID) THEN
                    READ(Eqn(R)%T,*,IOSTAT=MP) ANS
                    !
                    IF(MP .NE. Z) THEN
                        ERRMSG = 'ERROR EVALUATING EQUATION - FALURE TO IDENTIFY VARIABLE NAME AMONG LIST OF PREVIOUSLY DEFINED NAMES'//NL//'OR CONVERT PART OF THE EQUATION TO A NUMBER.'//NL//                                                                                                                                         &
                                 'THE VARIABLE NAME BEING SEARCHED FOR/CONVERTED TO A NUMBER IS:'//BLN//'     "'//Eqn(R)%T//'"'//BLN//'THE VARIABLE NAME MAY NOT BE DEFINED OR CONTAINS A SPELLING ERROR.'//BLN//                                                                                                  &
                                 'IF THERE IS AN OPERATOR, + - / * IN THE NAME, THEN THE PARSER HAD AN ISSUE WITH THE EQUATION STRUCTURE'//NL//'MAYBE YOU HAVE TWO OPERATORS IN A ROW, LIKE "X+-Y"'//NL//'OR YOU HAVE A NEGATIVE SYMBOL WHEN YOU SHOULD USE THE NEG FUNCTION "-Y+X" INSTEAD OF "NEG(Y)+X"'//BLN//   &
                                 'FOR YOUR REFERENCE THE FOLLOWING IS A LIST OF THE VARIABLE NAMES'//NL//'THAT ARE CURRENTLY DEFINED AND WERE WHAT WAS SEARCHED THROUGH:'//PRINT_VARIABLE_NAMES(NML)
                        ANS = DZ
                        R = SIZE(Eqn)
                    END IF
        END IF
    END IF
    !
    R=R+1  !MOVE TO NEXT TERM
    !
  END IF
END SUBROUTINE
!
!######################################################################      
!
RECURSIVE PURE SUBROUTINE PROCESS_INLINE_CONDITIONAL(Eqn,R,COND_ANS,NML,NMV,ERRMSG)
  TYPE (EQN_TERMS), DIMENSION(:), INTENT(IN   )::Eqn                !!ARRAY CONTAINING ALL PARTS OF EQUATION
  INTEGER,                        INTENT(INOUT)::R                  !CURRENT INDEX OF ARRAY TO OPERATE ON 
  DOUBLE PRECISION,               INTENT(INOUT)::COND_ANS           !HOLDS EITHER THE TRUE OR FALSE PORTION OF THE IF STATEMENT
  CHARACTER(*),    DIMENSION(:),  INTENT(IN   )::NML                !ARRAY OF VARIABLE NAMES
  DOUBLE PRECISION,DIMENSION(:),  INTENT(IN   )::NMV                !ARRAY OF VARIABLE VALUES WITH HIGHEST DIMENSION ONE TO ONE WITH VARIABLE NAME ARRAY (RIGHT MOST DIM) 
  CHARACTER(:),ALLOCATABLE,       INTENT(INOUT):: ERRMSG            !IS ALLOCATED WHEN THERE IS AN ERROR RAISED
  CONTIGUOUS:: Eqn,NML,NMV
  !
  TYPE (EQN_TERMS),DIMENSION(:),ALLOCATABLE:: SubEqn
  !
  INTEGER,DIMENSION(:),ALLOCATABLE:: IDX                             !POINTER ARRAY THAT IS ONLY USED TO POINT TO THE & AND | IN CONDITIONAL PART OF IF
  INTEGER:: I, J, Rsub, MP, NR
  !
  LOGICAL:: COND
  LOGICAL:: COND2   !TEMPORARY ARRAY THAT IS ONLY USED IF THERE IS AN "OR" OPERATOR, ie "|"
  !
  NR = SIZE(Eqn)
  !
  !CHARACTER(:), ALLOCATABLE:: TRUE_LN, FALSE_LN
  !
  ! 'IF[...'
  !
  R = R + TWO   !SKIP THE 'IF' AND THE LEFT BRACKET '['
  !
  ! PROCESS CONDITIONAL
  IF ( INDEX(Eqn(R)%T,'|') > Z ) THEN  !SEARCH IF THERE IS AN "OR" OPERATOR 
     !
     I=Z                                     !COUND THE NUMBER OF |'s
     DO J=1, LEN(Eqn(R)%T)
         IF ( '|' == Eqn(R)%T(J:J) ) I=I+1
     END DO
     !
     ALLOCATE(IDX(I+2))          !POINTER ARRAY OF THE LOCATION OF ALL |'s
     IDX(1)=Z                    !START OF LOCATION 
     IDX(I+2)=LEN(Eqn(R)%T)+1    !END OF LOCATION
     !
     I=2
     DO J=1, LEN(Eqn(R)%T)
        IF ( '|' == Eqn(R)%T(J:J) ) THEN
            IDX(I)=J                       !Store the locations from 2 to the last |
            I=I+1
        END IF
     END DO
     !
     DO I=1, SIZE(IDX,1)-1
        IF (I==1) THEN
           CALL PROCESS_CONDITION(Eqn(R)%T( IDX(I)+1:IDX(I+1)-1 ), COND, NML,NMV,ERRMSG)    !PASS ONLY PORTION BETWEEN MULTIPLE |'s
        ELSE
           CALL PROCESS_CONDITION(Eqn(R)%T( IDX(I)+1:IDX(I+1)-1 ), COND2,NML,NMV,ERRMSG)   !PASS ONLY PORTION BETWEEN MULTIPLE |'s
           COND = COND .OR. COND2
           IF(COND) EXIT  !OR HAS ONE TRUE, SO NO NEED TO CHECK THE REST
        END IF
     END DO
     DEALLOCATE(IDX)
     !
  ELSE
     CALL PROCESS_CONDITION(Eqn(R)%T, COND,NML,NMV,ERRMSG)  !NO | SO EVALUATE CONDITIONAL (THERE STILL CAN BE &'s)
  END IF
  !  
  !R=R+1  !SKIP TO TRUE LOCATION
  !TRUE_LN=Eqn(R)%T
  !!  
  !R=R+1  !SKIP TO FALSE LOCATION
  !FALSE_LN=Eqn(R)%T
  !!
  !DO WHILE (']' .NE. Eqn(R)%T)  !MOVE TO WHERE CLOSING BRACKET IS LOCATED
  !  R=R+1
  !END DO
  !R=R+1  !MOVE PAST CLOSING BRACKET SO NEXTATOM EITHER TERMINATES OR PROCESSES THE NEXT OPERATOR
  !
  R=R+1  !SKIP TO TRUE LOCATION
  !
  IF(RETURN_CHECK(ERRMSG)) THEN
      COND_ANS = DZ
      R = NR
  ELSEIF (COND) THEN  !TRUE CONDITION
     CALL SplitFunc(Eqn(R)%T, SubEqn, ERRMSG)  !AT TRUE LOCATION EVALUATE WHAT IS THERE
     Rsub=1
     MP=1      
     CALL EqnParser(SubEqn,Rsub,COND_ANS,MP,NML,NMV,ERRMSG)    !SOLVE FOR THE RIGHT SIDE OF THE CONDITINAL
     DEALLOCATE(SubEqn)
  ELSE
     R=R+1  !SKIP TO FALSE LOCATION
     IF(RB .NE. Eqn(R)%T) THEN                   !CHECK FALSE LOCATION RB = ']'
        CALL SplitFunc(Eqn(R)%T, SubEqn,ERRMSG)
        Rsub=1
        MP=1      
        CALL EqnParser(SubEqn,Rsub,COND_ANS,MP,NML,NMV,ERRMSG)  !SOLVE FOR THE RIGHT SIDE OF THE CONDITINAL
        DEALLOCATE(SubEqn)
     ELSE
         COND_ANS = IEEE_VALUE(COND_ANS, IEEE_QUIET_NAN)
     END IF
  END IF
  !
  DO WHILE (RB .NE. Eqn(R)%T .AND. R < NR)  !MOVE TO WHERE CLOSING BRACKET IS LOCATED  RB = ']'
    R=R+1
  END DO
  R=R+1  !MOVE PAST CLOSING BRACKET SO NEXTATOM EITHER TERMINATES OR PROCESSES THE NEXT OPERATOR
  !
  !DEALLOCATE(LN)
  !DEALLOCATE(TRUE_LN, FALSE_LN)
END SUBROUTINE
!
!######################################################################      
!
!!!!!!!!!!!!!!!!!!!!PURE SUBROUTINE SplitCond(LN,CND,ERRMSG)  !SPLITS LINE BY VARIABLES,OPERATIONS, PARENTHESES, ALLOCATES SPACE REQUIRED FOR EQUATION STORAGE, LN_SETUP=.TRUE. => MAKE LN UPPER CASE AND REMOVE BLANK SPACES
!!!!!!!!!!!!!!!!!!!!  CHARACTER(*),                             INTENT(IN   ):: LN
!!!!!!!!!!!!!!!!!!!!  TYPE (EQN_TERMS),DIMENSION(:),ALLOCATABLE,INTENT(INOUT):: CND
!!!!!!!!!!!!!!!!!!!!  CHARACTER(:),ALLOCATABLE,                 INTENT(INOUT):: ERRMSG
!!!!!!!!!!!!!!!!!!!!  
!!!!!!!!!!!!!!!!!!!!  
!!!!!!!!!!!!!!!!!!!!  
!!!!!!!!!!!!!!!!!!!!END SUBROUTINE
!!!!!!!!!!!!!!!!!!!!RECURSIVE PURE SUBROUTINE EVAL_CONDITIONAL(Ln,NML,NMV,COND,ERRMSG)        !Ln='Actual EQUATION',NML='Named Variable List',NMV='Named Variable Values',CHKCASE=OPTIONAL:CONVERT A COPY OF NML TO UPPER,CHKKEY=OPTIONAL:CHECK FOR KEYWORD IN NML,RES='EQUATION Result'
!!!!!!!!!!!!!!!!!!!!  CHARACTER(*),                 INTENT(IN   ):: Ln      !STRING THAT CONTAINS EQUATION
!!!!!!!!!!!!!!!!!!!!  CHARACTER(*),    DIMENSION(:),INTENT(INOUT):: NML     !ARRAY OF VARIABLE NAMES
!!!!!!!!!!!!!!!!!!!!  DOUBLE PRECISION,DIMENSION(:),INTENT(IN   ):: NMV     !ARRAY OF VARIABLE VALUES WITH HIGHEST DIMENSION ONE TO ONE WITH VARIABLE NAME ARRAY (RIGHT MOST DIM) 
!!!!!!!!!!!!!!!!!!!!  CHARACTER(:),ALLOCATABLE,     INTENT(INOUT):: ERRMSG  !IS ALLOCATED WHEN THERE IS AN ERROR RAISED
!!!!!!!!!!!!!!!!!!!!  LOGICAL,                      INTENT(  OUT):: COND    !TRUE/FALSE RESULT
!!!!!!!!!!!!!!!!!!!!  CONTIGUOUS:: NML, NMV
!!!!!!!!!!!!!!!!!!!!  !
!!!!!!!!!!!!!!!!!!!!  INTEGER, DIMENSION(:),ALLOCATABLE:: IDX                      !POINTER ARRAY THAT IS ONLY USED TO POINT TO THE & AND | IN CONDITIONAL PART OF IF
!!!!!!!!!!!!!!!!!!!!  INTEGER::I,J,N B,P
!!!!!!!!!!!!!!!!!!!!  !INTEGER::NVAR
!!!!!!!!!!!!!!!!!!!!  LOGICAL::COND2
!!!!!!!!!!!!!!!!!!!!  !
!!!!!!!!!!!!!!!!!!!!  COND2=FALSE
!!!!!!!!!!!!!!!!!!!!  !
!!!!!!!!!!!!!!!!!!!!  N = LEN_TRIM(LN)
!!!!!!!!!!!!!!!!!!!!  !
!!!!!!!!!!!!!!!!!!!!  P = Z
!!!!!!!!!!!!!!!!!!!!  B = Z
!!!!!!!!!!!!!!!!!!!!  I = Z                        !COUND THE NUMBER OF |'s
!!!!!!!!!!!!!!!!!!!!  DO J=ONE, LEN(Ln)
!!!!!!!!!!!!!!!!!!!!      IF    ( LB  == Ln(J:J) ) THEN
!!!!!!!!!!!!!!!!!!!!                                    B = B + ONE
!!!!!!!!!!!!!!!!!!!!      ELSEIF( LP  == Ln(J:J) ) THEN    
!!!!!!!!!!!!!!!!!!!!                                    P = P + ONE
!!!!!!!!!!!!!!!!!!!!      ELSEIF( RP  == Ln(J:J) ) THEN    
!!!!!!!!!!!!!!!!!!!!                                    P = P - ONE
!!!!!!!!!!!!!!!!!!!!      ELSEIF( RB  == Ln(J:J) ) THEN
!!!!!!!!!!!!!!!!!!!!                                    B = B - ONE
!!!!!!!!!!!!!!!!!!!!      ELSEIF(B == Z .AND. P == Z) THEN
!!!!!!!!!!!!!!!!!!!!          IF( '|' == Ln(J:J) ) I=I+1
!!!!!!!!!!!!!!!!!!!!      END IF
!!!!!!!!!!!!!!!!!!!!  END DO
!!!!!!!!!!!!!!!!!!!!  !
!!!!!!!!!!!!!!!!!!!!  IF(I > Z) THEN
!!!!!!!!!!!!!!!!!!!!       ALLOCATE(IDX(I+2))          !POINTER ARRAY OF THE LOCATION OF ALL |'s
!!!!!!!!!!!!!!!!!!!!       IDX(1)=Z                    !START OF LOCATION 
!!!!!!!!!!!!!!!!!!!!       IDX(I+2)=LEN(Ln)+1    !END OF LOCATION
!!!!!!!!!!!!!!!!!!!!       DO J=ONE, LEN(Ln)
!!!!!!!!!!!!!!!!!!!!           IF    ( LB  == Ln(J:J) ) THEN
!!!!!!!!!!!!!!!!!!!!                                         B = B + ONE
!!!!!!!!!!!!!!!!!!!!           ELSEIF( LP  == Ln(J:J) ) THEN    
!!!!!!!!!!!!!!!!!!!!                                         P = P + ONE
!!!!!!!!!!!!!!!!!!!!           ELSEIF( RP  == Ln(J:J) ) THEN    
!!!!!!!!!!!!!!!!!!!!                                         P = P - ONE
!!!!!!!!!!!!!!!!!!!!           ELSEIF( RB  == Ln(J:J) ) THEN
!!!!!!!!!!!!!!!!!!!!                                         B = B - ONE
!!!!!!!!!!!!!!!!!!!!           ELSEIF(B == Z .AND. P == Z) THEN
!!!!!!!!!!!!!!!!!!!!               IF( '|' == Ln(J:J) ) I=I+1
!!!!!!!!!!!!!!!!!!!!           END IF
!!!!!!!!!!!!!!!!!!!!       END DO
!!!!!!!!!!!!!!!!!!!!  END IF
!!!!!!!!!!!!!!!!!!!!  
!!!!!!!!!!!!!!!!!!!!  !
!!!!!!!!!!!!!!!!!!!!  N = INDEX(Ln,'|')
!!!!!!!!!!!!!!!!!!!!  ! PROCESS CONDITIONAL
!!!!!!!!!!!!!!!!!!!!  IF ( N > ONE ) THEN  !SEARCH IF THERE IS AN "OR" OPERATOR 
!!!!!!!!!!!!!!!!!!!!     !
!!!!!!!!!!!!!!!!!!!!     N = N + ONE
!!!!!!!!!!!!!!!!!!!!     I = ONE                        !COUND THE NUMBER OF |'s
!!!!!!!!!!!!!!!!!!!!     DO J=N, LEN(Ln)
!!!!!!!!!!!!!!!!!!!!         IF ( '|' == Ln(J:J) ) I=I+1
!!!!!!!!!!!!!!!!!!!!     END DO
!!!!!!!!!!!!!!!!!!!!     !
!!!!!!!!!!!!!!!!!!!!     ALLOCATE(IDX(I+2))          !POINTER ARRAY OF THE LOCATION OF ALL |'s
!!!!!!!!!!!!!!!!!!!!     IDX(1)=Z                    !START OF LOCATION 
!!!!!!!!!!!!!!!!!!!!     IDX(I+2)=LEN(Ln)+1    !END OF LOCATION
!!!!!!!!!!!!!!!!!!!!     !
!!!!!!!!!!!!!!!!!!!!     I=2
!!!!!!!!!!!!!!!!!!!!     DO J=1, LEN(Ln)
!!!!!!!!!!!!!!!!!!!!        IF ( '|' == Ln(J:J) ) THEN
!!!!!!!!!!!!!!!!!!!!            IDX(I)=J                       !Store the locations from 2 to the last |
!!!!!!!!!!!!!!!!!!!!            I=I+1
!!!!!!!!!!!!!!!!!!!!        END IF
!!!!!!!!!!!!!!!!!!!!     END DO
!!!!!!!!!!!!!!!!!!!!     !
!!!!!!!!!!!!!!!!!!!!     DO I=1, SIZE(IDX,1)-1
!!!!!!!!!!!!!!!!!!!!        IF (I==1) THEN
!!!!!!!!!!!!!!!!!!!!           CALL PROCESS_CONDITION(Ln( IDX(I)+1:IDX(I+1)-1 ), COND, NML,NMV,ERRMSG)    !PASS ONLY PORTION BETWEEN MULTIPLE |'s
!!!!!!!!!!!!!!!!!!!!        ELSE
!!!!!!!!!!!!!!!!!!!!           CALL PROCESS_CONDITION(Ln( IDX(I)+1:IDX(I+1)-1 ), COND2,NML,NMV,ERRMSG)   !PASS ONLY PORTION BETWEEN MULTIPLE |'s
!!!!!!!!!!!!!!!!!!!!           COND = COND .OR. COND2
!!!!!!!!!!!!!!!!!!!!           IF(COND) EXIT  !OR HAS ONE TRUE, SO NO NEED TO CHECK THE REST
!!!!!!!!!!!!!!!!!!!!        END IF
!!!!!!!!!!!!!!!!!!!!     END DO
!!!!!!!!!!!!!!!!!!!!     !
!!!!!!!!!!!!!!!!!!!!     DEALLOCATE(IDX)
!!!!!!!!!!!!!!!!!!!!  ELSE
!!!!!!!!!!!!!!!!!!!!     CALL PROCESS_CONDITION(Ln, COND,NML,NMV,ERRMSG)  !NO | SO EVALUATE CONDITIONAL (THERE STILL CAN BE &'s)
!!!!!!!!!!!!!!!!!!!!  END IF
!!!!!!!!!!!!!!!!!!!!  !
!!!!!!!!!!!!!!!!!!!!  CALL CHECK_FOR_ERROR(ERRMSG,LN)
!!!!!!!!!!!!!!!!!!!!  !
!!!!!!!!!!!!!!!!!!!!END SUBROUTINE
!
!######################################################################      
!
RECURSIVE PURE SUBROUTINE PROCESS_CONDITION(COND_LN, COND,NML,NMV,ERRMSG)
  CHARACTER(*),                   INTENT(IN) :: COND_LN
  LOGICAL,                        INTENT(OUT):: COND
  CHARACTER(*),    DIMENSION(:),  INTENT(IN   )::NML                !ARRAY OF VARIABLE NAMES
  DOUBLE PRECISION,DIMENSION(:),  INTENT(IN   )::NMV                !ARRAY OF VARIABLE VALUES WITH HIGHEST DIMENSION ONE TO ONE WITH VARIABLE NAME ARRAY (RIGHT MOST DIM) 
  CHARACTER(:),ALLOCATABLE,       INTENT(INOUT):: ERRMSG            !IS ALLOCATED WHEN THERE IS AN ERROR RAISED
  CONTIGUOUS:: NML,NMV
  !
  TYPE (EQN_TERMS),DIMENSION(:),ALLOCATABLE:: SubEqn
  !
  DOUBLE PRECISION:: LCOND, RCOND
  INTEGER,DIMENSION(:),   ALLOCATABLE:: IDX
  INTEGER:: I, J, MP, Rsub!, LINELEN
  INTEGER:: OPLOC1, OPLOC2   !LOCATION JUST BEFORE AND JUST AFTER THE LOGICAL OPERATOR
  !CHARACTER(LEN(COND_LN)):: LCOND_LN, RCOND_LN
  CHARACTER(2):: REL_OP
  !
  !LINELEN=LEN(COND_LN)
  !ALLOCATE(CHARACTER(LINELEN)::LCOND_LN)
  !ALLOCATE(CHARACTER(LINELEN)::RCOND_LN)
  !
  ! COUNT THE NUMBER OF & AND FIND THEIR LOCATION
  IF ( INDEX(COND_LN,'&') > Z ) THEN
     !
     ! COUNT NUMBER OF &
     I=Z
     DO J=1, LEN(COND_LN)
         IF ( '&' == COND_LN(J:J) ) I=I+1
     END DO
     ALLOCATE(IDX(I+2))
     IDX(1)=Z                   !START OF LOCATION 
     IDX(I+2)=LEN(COND_LN)+1    !END OF LOCATION
     I=2
     DO J=1, LEN(COND_LN)
         IF ( '&' == COND_LN(J:J) ) THEN
             IDX(I)=J                    !Store the locations from 2 to the last &
             I=I+1
         END IF
     END DO
  ELSE
     ALLOCATE(IDX(2))
     IDX(1)=Z
     IDX(2)=LEN(COND_LN)+1
  END IF
  ! '5<3&6.1>5&ABC<=8'
  ! IDX=0,4,10,17
  DO I=1, SIZE(IDX,1)-1
     REL_OP=BLNK
     DO J=IDX(I)+1, IDX(I+1)-1          !SEARCH FOR LOGICAL OPERATOR
        IF     ( '==' == COND_LN(J:J+1) ) THEN
            REL_OP='EQ'
            OPLOC1=J-1
            OPLOC2=J+2
            EXIT
        ELSEIF ( '!=' == COND_LN(J:J+1) ) THEN
            REL_OP='NE'
            OPLOC1=J-1
            OPLOC2=J+2
            EXIT
        ELSEIF ( '>=' == COND_LN(J:J+1) .OR. '' == COND_LN(J:J) ) THEN
            REL_OP='GE'
            OPLOC1=J-1
            OPLOC2=J+2
            EXIT
        ELSEIF ( '<=' == COND_LN(J:J+1) .OR. '' == COND_LN(J:J) ) THEN
            REL_OP='LE'
            OPLOC1=J-1
            OPLOC2=J+2
            EXIT
        ELSEIF ( '>' == COND_LN(J:J) ) THEN
            REL_OP='GT'
            OPLOC1=J-1
            OPLOC2=J+1
            EXIT
        ELSEIF ( '<' == COND_LN(J:J) ) THEN
            REL_OP='LT'
            OPLOC1=J-1
            OPLOC2=J+1
            EXIT
        END IF
     END DO
     !
     IF(REL_OP==BLNK) THEN
          ERRMSG = 'PROCESS_CONDITION ERROR: WHILE PROCESSING A CONDITIONAL LINE,'//NL//'FAILED TO LOCATE ONE OF THE FOLLOWING RELATIONAL OPERATORS: <, <=, >, >=, ==, !='//NL//'WITHOUT THEM THERE IS NO WAY TO RETURN A TRUE OR FALSE EVALUATION.'
          COND = TRUE
          EXIT
          !IF(ASSOCIATED(STOP_ERROR)) THEN
          !    CALL STOP_ERROR(COND_LN,Z,IOUT,'PROCESS_CONDITION ERROR: WHILE PROCESSING A CONDITIONAL LINE,'//NL//'FAILED TO LOCATE ONE OF THE FOLLOWING RELATIONAL OPERATORS: <, <=, >, >=, =='//NL//'WITHOUT THEM THERE IS NO WAY TO RETURN A TRUE OR FALSE EVALUATION.')
          !ELSE
          !    WRITE(*,'(A)')'PROCESS_CONDITION ERROR: WHILE PROCESSING A CONDITIONAL LINE,'//NL//'FAILED TO LOCATE ONE OF THE FOLLOWING RELATIONAL OPERATORS: <, <=, >, >=, =='//NL//'WITHOUT THEM THERE IS NO WAY TO RETURN A TRUE OR FALSE EVALUATION.'//NL//'THE FOLLOWING IS THE LINE THAT WAS BEING PARSED: '//NL//'"'//TRIM(COND_LN)//'"'
          !    ERROR STOP
          !END IF
     END IF
     !
     !LCOND_LN=COND_LN(  IDX(I)+1:OPLOC1     )      !STORE THE TWO PARTS OF THE CONDITION  --THIS IS THE PART LEFT  OF THE INEQUALITY SYMBOL REL_OP
     !RCOND_LN=COND_LN(  OPLOC2  :IDX(I+1)-1 )      !STORE THE TWO PARTS OF THE CONDITION  --THIS IS THE PART RIGHT OF THE INEQUALITY SYMBOL REL_OP
     !  
     !FIGURE OUT WHAT IS ON THE LEFT  OF THE LOGICAL OPERATOR
     !
     CALL SplitFunc(COND_LN( IDX(I)+1:OPLOC1 ), SubEqn, ERRMSG)
     Rsub=1
     MP=1      
     CALL EqnParser(SubEqn,Rsub,LCOND,MP,NML,NMV,ERRMSG)  !SOLVE FOR THE LEFT SIDE OF THE CONDITINAL  
     !
     DEALLOCATE(SubEqn)
     !
     !FIGURE OUT WHAT IS ON THE RIGHT OF THE LOGICAL OPERATOR
     CALL SplitFunc(COND_LN( OPLOC2:IDX(I+1)-1 ), SubEqn, ERRMSG)
     Rsub=1
     MP=1      
     CALL EqnParser(SubEqn,Rsub,RCOND,MP,NML,NMV,ERRMSG)  !SOLVE FOR THE RIGHT SIDE OF THE CONDITINAL
     !
     DEALLOCATE(SubEqn)
     !
     IF (I==1) THEN   ! SET INITIAL CONDITIONAL       
        COND = INEQUALITY_EVAL(LCOND, RCOND, REL_OP)
     ELSE                                    !INTIAL CONDITIONAL WAS SET AND THERE WAS AN & DETECTED, SO COMPUTE COMBINED LOGICAL
        COND = COND .AND. INEQUALITY_EVAL(LCOND, RCOND, REL_OP) 
     END IF
  END DO
  !
  DEALLOCATE(IDX)
  !DEALLOCATE(LCOND_LN, RCOND_LN)
  !
END SUBROUTINE
!
!######################################################################      
!
PURE ELEMENTAL FUNCTION INEQUALITY_EVAL(LCOND, RCOND, REL_OP) RESULT(COND)
  DOUBLE PRECISION, INTENT(IN)::LCOND, RCOND
  CHARACTER(*),     INTENT(IN):: REL_OP
  !
  LOGICAL:: COND
  !
  SELECT CASE (REL_OP)
    CASE ('GE'); COND = LCOND >= RCOND
    CASE ('LE'); COND = LCOND <= RCOND
    CASE ('GT'); COND = LCOND >  RCOND
    CASE ('LT'); COND = LCOND <  RCOND
    CASE ('EQ'); COND = ABS(LCOND - RCOND) <= ABS(RCOND)*NEARZERO_10
    CASE ('NE'); COND = ABS(LCOND - RCOND)  > ABS(RCOND)*NEARZERO_10
  END SELECT
  !  
END FUNCTION
!
!######################################################################      
!
ELEMENTAL PURE FUNCTION IS_INEQUALITY(STR) 
  CHARACTER(*), INTENT(IN) :: STR
  LOGICAL:: IS_INEQUALITY
  !
  IS_INEQUALITY = '==' == STR(:TWO) .OR. &
                  '!=' == STR(:TWO) .OR. &
                  '>=' == STR(:TWO) .OR. &
                  '<=' == STR(:TWO) .OR. &
                  '>'  == STR(:ONE) .OR. &
                  '<'  == STR(:ONE)
  !
END FUNCTION
!
!######################################################################      
!
RECURSIVE PURE SUBROUTINE PROCESS_MINMAX(Eqn,R,MINMAX_ANS,NML,NMV, ERRMSG)
  TYPE (EQN_TERMS), DIMENSION(:), INTENT(IN   )::Eqn                !!ARRAY CONTAINING ALL PARTS OF EQUATION
  INTEGER,                        INTENT(INOUT)::R                  !CURRENT INDEX OF ARRAY TO OPERATE ON 
  DOUBLE PRECISION,               INTENT(INOUT)::MINMAX_ANS         !HOLDS MIN OR MAX OF ALL THE VALUES WITHIN THE BRACKETS
  CHARACTER(*),    DIMENSION(:),  INTENT(IN   )::NML                !ARRAY OF VARIABLE NAMES
  DOUBLE PRECISION,DIMENSION(:),  INTENT(IN   )::NMV                !ARRAY OF VARIABLE VALUES WITH HIGHEST DIMENSION ONE TO ONE WITH VARIABLE NAME ARRAY (RIGHT MOST DIM) 
  CHARACTER(:),ALLOCATABLE,       INTENT(INOUT):: ERRMSG            !IS ALLOCATED WHEN THERE IS AN ERROR RAISED
  CONTIGUOUS:: NML,NMV
  !
  TYPE (EQN_TERMS),DIMENSION(:),ALLOCATABLE:: SubEqn
  !
  INTEGER:: Rsub, MP
  !
  DOUBLE PRECISION:: NEXT_VAL
  LOGICAL:: COND
  !
  !CHARACTER(:), ALLOCATABLE:: VAL_LN
  CHARACTER(3):: OPT
  
  OPT=Eqn(R)%T
  
  ! 'MAX[...' or 'MIN[...'
  
  R = R + TWO   !SKIP THE 'MAX' OR 'MIN' AND THE LEFT BRACKET '['
  
  !LINELEN=ONE
  !DO I=R, SIZE(Eqn)
  !   IF(Eqn(I)%T==']') EXIT
  !   J=LEN(Eqn(I)%T)
  !   IF(LINELEN < J ) LINELEN = J
  !END DO
  !ALLOCATE(CHARACTER(LINELEN)::VAL_LN)
  
  !GET THE FIRST VALUE IN THE MINMAX SEQUENCE
  !
  !VAL_LN(:)=Eqn(R)%T
  CALL SplitFunc(Eqn(R)%T, SubEqn, ERRMSG)
  Rsub=1
  MP=1      
  CALL EqnParser(SubEqn,Rsub,MINMAX_ANS,MP,NML,NMV,ERRMSG)  !SOLVE FOR THE LEFT SIDE OF THE CONDITINAL  
  DEALLOCATE(SubEqn)
  R=R+1
  !
  DO WHILE ( RB .NE. Eqn(R)%T )  ! RB = ']'
      !VAL_LN(:)=Eqn(R)%T
      CALL SplitFunc(Eqn(R)%T, SubEqn, ERRMSG)
      Rsub=1
      MP=1      
      CALL EqnParser(SubEqn,Rsub,NEXT_VAL,MP,NML,NMV,ERRMSG)  !SOLVE FOR THE LEFT SIDE OF THE CONDITINAL  
      DEALLOCATE(SubEqn)
      !
      IF(RETURN_CHECK(ERRMSG)) THEN
          MINMAX_ANS = DZ
          R = SIZE(Eqn)
          EXIT
      END IF
      !
      SELECT CASE (OPT)
      CASE ('MAX'); COND = MINMAX_ANS < NEXT_VAL   !WHERE TRUE MEANS NEXT_VAL IS BIGGER  AND SHOULD REPLACE MINMAX_VAL
      CASE ('MIN'); COND = MINMAX_ANS > NEXT_VAL   !WHERE TRUE MEANS NEXT_VAL IS SMALLER AND SHOULD REPLACE MINMAX_VAL
      END SELECT
      !
      !DO CONCURRENT(I=1:ROW, J=1:COL, COND(I,J)); MINMAX_ANS(I,J) = NEXT_VAL(I,J)
      !END DO
      IF(COND) MINMAX_ANS = NEXT_VAL
      !    
      R=R+1
  END DO
  !
  ! MOVE PAST CLOSING BRACKET SO NEXT ATOM EITHER TERMINATES OR PROCESSES THE NEXT OPERATOR
  R=R+1
  !
  !DEALLOCATE(VAL_LN)
END SUBROUTINE    
!
RECURSIVE PURE SUBROUTINE PROCESS_MAGIC(Eqn,R,MAGIC_ANS,NML,NMV,ERRMSG)
  TYPE (EQN_TERMS), DIMENSION(:), INTENT(IN   ):: Eqn                !!ARRAY CONTAINING ALL PARTS OF EQUATION
  INTEGER,                        INTENT(INOUT):: R                  !CURRENT INDEX OF ARRAY TO OPERATE ON 
  DOUBLE PRECISION,               INTENT(INOUT):: MAGIC_ANS          !HOLDS MIN OR MAX OF ALL THE VALUES WITHIN THE BRACKETS
  CHARACTER(*),    DIMENSION(:),  INTENT(IN   ):: NML                !ARRAY OF VARIABLE NAMES
  DOUBLE PRECISION,DIMENSION(:),  INTENT(IN   ):: NMV                !ARRAY OF VARIABLE VALUES WITH HIGHEST DIMENSION ONE TO ONE WITH VARIABLE NAME ARRAY (RIGHT MOST DIM) 
  CHARACTER(:),ALLOCATABLE,       INTENT(INOUT):: ERRMSG             !IS ALLOCATED WHEN THERE IS AN ERROR RAISED
  CONTIGUOUS:: NML,NMV
  !
  TYPE (EQN_TERMS),DIMENSION(:),ALLOCATABLE:: SubEqn
  !
  INTEGER:: Rsub, MP, IVAL, I
  !
  TYPE(DATE_OPERATOR):: DATE
  !
  SELECT CASE(Eqn(R)%T)
  CASE('DATE_DIFF')
                   BLOCK
                       TYPE(DATE_OPERATOR):: DATE0
                       R = R + TWO
                       CALL MAKE_DATE_FROM_Eqn(Eqn(R)%T,DATE,SubEqn,Rsub,MP,NML,NMV,ERRMSG)
                       R = R + ONE
                       CALL MAKE_DATE_FROM_Eqn(Eqn(R)%T,DATE0,SubEqn,Rsub,MP,NML,NMV,ERRMSG)
                       R = R + ONE
                       !
                       MAGIC_ANS = DATE - DATE0
                   END BLOCK
  CASE('ADD_DAY')
                   R = R + TWO
                   CALL MAKE_DATE_FROM_Eqn(Eqn(R)%T,DATE,SubEqn,Rsub,MP,NML,NMV,ERRMSG)
                   R = R + ONE
                   CALL SplitFunc(Eqn(R)%T, SubEqn, ERRMSG)
                   R = R + ONE
                   Rsub=ONE
                   MP=ONE      
                   CALL EqnParser(SubEqn,Rsub,MAGIC_ANS,MP,NML,NMV,ERRMSG)  !SOLVE FOR THE LEFT SIDE OF THE CONDITINAL  
                   DEALLOCATE(SubEqn)
                   !
                   CALL DATE%ADD_DAY(MAGIC_ANS)
                   MAGIC_ANS = DATE%DYEAR
  CASE('ADD_YEAR')
                   R = R + TWO
                   CALL MAKE_DATE_FROM_Eqn(Eqn(R)%T,DATE,SubEqn,Rsub,MP,NML,NMV,ERRMSG)
                   R = R + ONE
                   CALL MAKE_INT_FROM_Eqn(Eqn(R)%T,IVAL,SubEqn,Rsub,MP,NML,NMV,ERRMSG,MP)  !SECOND MP IS JUST A PLACE HOLDER FOR INTERNAL ERROR CHECKING OF ROUTINE
                   R = R + ONE
                   !
                   CALL DATE%ADD_YEAR(IVAL)
                   MAGIC_ANS = DATE%DYEAR
  CASE('ADD_MONTH')
                   R = R + TWO
                   CALL MAKE_DATE_FROM_Eqn(Eqn(R)%T,DATE,SubEqn,Rsub,MP,NML,NMV,ERRMSG)
                   R = R + ONE
                   CALL MAKE_INT_FROM_Eqn(Eqn(R)%T,IVAL,SubEqn,Rsub,MP,NML,NMV,ERRMSG,MP)  !SECOND MP IS JUST A PLACE HOLDER FOR INTERNAL ERROR CHECKING OF ROUTINE
                   R = R + ONE
                   !
                   CALL DATE%ADD_MONTH(IVAL)
                   MAGIC_ANS = DATE%DYEAR
  CASE('MAKE_DATE')
                   BLOCK
                       INTEGER:: M, D, Y, HH, MM, SS
                       DOUBLE PRECISION:: FRAC
                       FRAC = DZ
                       R = R + TWO
                                  CALL MAKE_INT_FROM_Eqn(Eqn(R)%T,Y,SubEqn,Rsub,MP,NML,NMV,ERRMSG,I)
                                  R = R + ONE
                       IF(I == Z) CALL MAKE_INT_FROM_Eqn(Eqn(R)%T,M,SubEqn,Rsub,MP,NML,NMV,ERRMSG,I)
                                  R = R + ONE
                       IF(I == Z) CALL MAKE_INT_FROM_Eqn(Eqn(R)%T,D,SubEqn,Rsub,MP,NML,NMV,ERRMSG,I)
                                  R = R + ONE
                       IF(Eqn(R)%T .NE. RB) THEN
                          IF(I == Z) CALL MAKE_INT_FROM_Eqn(Eqn(R)%T,HH,SubEqn,Rsub,MP,NML,NMV,ERRMSG,I)
                                     R = R + ONE
                          IF(I == Z) CALL MAKE_INT_FROM_Eqn(Eqn(R)%T,MM,SubEqn,Rsub,MP,NML,NMV,ERRMSG,I)
                                     R = R + ONE
                          IF(I == Z) CALL MAKE_INT_FROM_Eqn(Eqn(R)%T,SS,SubEqn,Rsub,MP,NML,NMV,ERRMSG,I)
                                     R = R + ONE
                          IF(I == Z) FRAC = DBLE(HH)/24D0 + DBLE(MM)/1440D0 + DBLE(SS)/86400D0
                       END IF
                       !
                       IF(I == Z) THEN
                           CALL DATE%INIT_DMY(D,M,Y,FRAC)
                           MAGIC_ANS = DATE%DYEAR
                       ELSE
                           IF(RETURN_CHECK(ERRMSG)) THEN
                                                       ERRMSG = ERRMSG//BLN//'PROCESS_MAGIC FUNCTION ERROR: FOUND MAGIC FUNCTION "MAKE_DATE" BUT FAILED TO CONVERT ONE OF ITS INPUTS TO AN INTEGER'//NL//'e.g.'//NL//'MAKE_DATE[Year,Month,Day]  or'//NL//'MAKE_DATE[Year,Month,Day,Hour,Minute,Second],'//NL//'WHERE THE INPUTS ARE WITHIN THE BRACKETS []'
                           ELSE
                                                       ERRMSG = 'PROCESS_MAGIC FUNCTION ERROR: FOUND MAGIC FUNCTION "MAKE_DATE" BUT FAILED TO CONVERT ONE OF ITS INPUTS TO AN INTEGER'//NL//'e.g.'//NL//'MAKE_DATE[Year,Month,Day]  or'//NL//'MAKE_DATE[Year,Month,Day,Hour,Minute,Second],'//NL//'WHERE THE INPUTS ARE WITHIN THE BRACKETS []'
                           END IF
                           R = SIZE(Eqn)
                       END IF
                   END BLOCK
  CASE('JULIAN_DAY')
                   R = R + TWO
                   CALL MAKE_DATE_FROM_Eqn(Eqn(R)%T,DATE,SubEqn,Rsub,MP,NML,NMV,ERRMSG)
                   R = R + ONE
                   MAGIC_ANS = DBLE(DATE%JDN) + DATE%FRAC
  CASE('GET_DAY')
                   R = R + TWO
                   CALL MAKE_DATE_FROM_Eqn(Eqn(R)%T,DATE,SubEqn,Rsub,MP,NML,NMV,ERRMSG)
                   R = R + ONE
                   MAGIC_ANS = DBLE(DATE%DAY)
  CASE('GET_MONTH')
                   R = R + TWO
                   CALL MAKE_DATE_FROM_Eqn(Eqn(R)%T,DATE,SubEqn,Rsub,MP,NML,NMV,ERRMSG)
                   R = R + ONE
                   MAGIC_ANS = DBLE(DATE%MONTH)
  CASE('GEY_YEAR')
                   R = R + TWO
                   CALL MAKE_DATE_FROM_Eqn(Eqn(R)%T,DATE,SubEqn,Rsub,MP,NML,NMV,ERRMSG)
                   R = R + ONE
                   MAGIC_ANS = DBLE(DATE%YEAR)
  CASE('MONTHDAYS')
                   BLOCK
                       INTEGER:: MONTH, YEAR
                       !TYPE(DATE_OPERATOR):: DATE2
                       !
                       R = R + TWO
                       IVAL = Z
                       DO I = R, SIZE(Eqn)
                           IF (Eqn(I)%T == RB)  EXIT
                           IVAL = IVAL + ONE
                       END DO
                       !
                       IF    (IVAL == ONE) THEN
                                                CALL MAKE_DATE_FROM_Eqn(Eqn(R)%T,DATE,SubEqn,Rsub,MP,NML,NMV,ERRMSG)
                                                R = R + ONE
                                                MAGIC_ANS = DBLE(DATE%MONTHDAYS())
                       ELSEIF(IVAL == TWO) THEN
                                                 CALL MAKE_INT_FROM_Eqn(Eqn(R)%T,MONTH,SubEqn,Rsub,MP,NML,NMV,ERRMSG,I)
                                                 R = R + ONE
                                      IF(I == Z) CALL MAKE_INT_FROM_Eqn(Eqn(R)%T,YEAR,SubEqn,Rsub,MP,NML,NMV,ERRMSG,I)
                                                 R = R + ONE
                                      IF(I == Z) THEN
                                                 MAGIC_ANS = DBLE(DATE%MONTHDAYS(MONTH, YEAR))
                                      ELSE
                                                 MAGIC_ANS = UNO
                                      END IF
                       END IF
                   END BLOCK
  CASE('MODULO')   ! MODULO[A,P,INT]
                   R = R + TWO  !Move past bracket
                   ! 
                   IF    (Eqn(R+TWO)%T == RB) THEN
                                                       IVAL = ONE ! Make INT - Move One Space
                   ELSE
                       CALL MAKE_INT_FROM_Eqn(Eqn(R+TWO)%T,IVAL,SubEqn,Rsub,MP,NML,NMV,ERRMSG,I)
                       IF(I.NE.Z) THEN
                                                       IVAL     = NEG ! Error found
                                                       MAGIC_ANS= DZ
                                                       R        = SIZE(Eqn) + ONE
                       ELSEIF(IVAL > Z) THEN
                                                       IVAL = TWO ! Make INT - Move Two Space
                       ELSE
                                                       IVAL = Z   ! Keep as Float
                       END IF
                   ENDIF
                   !
                   IF    (IVAL == Z) THEN  !Solve with Float
                    BLOCK
                        DOUBLE PRECISION:: A, P
                        !
                                   CALL MAKE_DBLE_FROM_Eqn(Eqn(R)%T, A ,SubEqn,Rsub,MP,NML,NMV,ERRMSG,I)
                        R = R + ONE
                        IF(I == Z) CALL MAKE_DBLE_FROM_Eqn(Eqn(R)%T, P ,SubEqn,Rsub,MP,NML,NMV,ERRMSG,I)
                        !
                        IF(RETURN_CHECK(ERRMSG)) THEN
                            MAGIC_ANS=DZ
                            R = SIZE(Eqn) + ONE
                        ELSEIF(NEGNEARZERO_30 < P .AND. P < NEARZERO_30) THEN
                            MAGIC_ANS = DZ
                        ELSE
                            MAGIC_ANS = MODULO(A,P)
                        END IF
                        !
                        R = R + TWO  !Move to ] location
                    END BLOCK
                   ELSEIF(IVAL >  Z) THEN  !Solve with Int
                    BLOCK
                        INTEGER:: A, P
                        !
                                   CALL MAKE_INT_FROM_Eqn(Eqn(R)%T, A ,SubEqn,Rsub,MP,NML,NMV,ERRMSG,I)
                        R = R + ONE
                        IF(I == Z) CALL MAKE_INT_FROM_Eqn(Eqn(R)%T, P ,SubEqn,Rsub,MP,NML,NMV,ERRMSG,I)
                        !
                        IF(RETURN_CHECK(ERRMSG)) THEN
                            MAGIC_ANS=DZ
                            R = SIZE(Eqn) + ONE
                        ELSEIF(P == Z) THEN
                            MAGIC_ANS = DZ
                        ELSE
                            MAGIC_ANS = DBLE(MODULO(A,P))
                        END IF
                        !
                        R = R + IVAL  !Move to ] location -- IVAL set to correct number of spaces (1 or 2)
                    END BLOCK
                   END IF
  CASE('HAS_MONTHDAY')
                   BLOCK
                       INTEGER:: M, D
                       TYPE(DATE_OPERATOR):: DATE2
                       !
                       R = R + TWO
                       IVAL = Z
                       DO I = R, SIZE(Eqn)
                           IF (Eqn(I)%T == RB)  EXIT
                           IVAL = IVAL + ONE
                       END DO
                       !
                       IF    (IVAL == THREE) THEN
                                                  CALL MAKE_DATE_FROM_Eqn(Eqn(R)%T,DATE,SubEqn,Rsub,MP,NML,NMV,ERRMSG)
                                                  M = DATE%MONTH
                                                  D = DATE%DAY
                                                  R = R + ONE
                                                  I = Z
                       ELSEIF(IVAL == FOUR) THEN
                                                 CALL MAKE_INT_FROM_Eqn(Eqn(R)%T,M,SubEqn,Rsub,MP,NML,NMV,ERRMSG,I)
                                                 R = R + ONE
                                      IF(I == Z) CALL MAKE_INT_FROM_Eqn(Eqn(R)%T,D,SubEqn,Rsub,MP,NML,NMV,ERRMSG,I)
                                                 R = R + ONE
                           
                       ELSEIF(RETURN_CHECK(ERRMSG)) THEN
                                                       ERRMSG = ERRMSG//BLN//'PROCESS_MAGIC FUNCTION ERROR: FOUND MAGIC FUNCTION "HAS_MONTHDAY" BUT FAILED TO PARSE ITS ARGUMENTS. IT MUST ONLY INCLUDE THREE OR FOUR ARGUMENTS, WHICH ARE [DATE, DATE1, DATE2] OR [MONTH, DAY, DATE1, DATE2].'
                       ELSE
                                                       ERRMSG = 'PROCESS_MAGIC FUNCTION ERROR: FOUND MAGIC FUNCTION "HAS_MONTHDAY" BUT FAILED TO PARSE ITS ARGUMENTS. IT MUST ONLY INCLUDE THREE OR FOUR ARGUMENTS, WHICH ARE [DATE, DATE1, DATE2] OR [MONTH, DAY, DATE1, DATE2].'
                       END IF
                       !
                       CALL MAKE_DATE_FROM_Eqn(Eqn(R)%T,DATE,SubEqn,Rsub,MP,NML,NMV,ERRMSG)
                       R = R + ONE
                       CALL MAKE_DATE_FROM_Eqn(Eqn(R)%T,DATE2,SubEqn,Rsub,MP,NML,NMV,ERRMSG)
                       R = R + ONE
                       !
                       IF( DATE%CONTAIN_MD(M, D, DATE2, TRUE)) THEN
                           MAGIC_ANS = UNO
                       ELSE
                           MAGIC_ANS = DZ
                       END IF
                       !
                       IF(RETURN_CHECK(ERRMSG)) THEN
                           R = SIZE(Eqn)
                           MAGIC_ANS = DZ
                       END IF
                   END BLOCK
  CASE('ADD_HOUR','ADD_MIN','ADD_SEC')
                   IVAL = R  !BACK UP LOCATION FOR FINAL CHECK
                   R = R + TWO
                   CALL MAKE_DATE_FROM_Eqn(Eqn(R)%T,DATE,SubEqn,Rsub,MP,NML,NMV,ERRMSG)
                   R = R + ONE
                   CALL SplitFunc(Eqn(R)%T, SubEqn, ERRMSG)
                   R = R + ONE
                   Rsub=ONE
                   MP=ONE      
                   CALL EqnParser(SubEqn,Rsub,MAGIC_ANS,MP,NML,NMV,ERRMSG)  !SOLVE FOR THE LEFT SIDE OF THE CONDITINAL  
                   DEALLOCATE(SubEqn)
                   !
                   SELECT CASE(Eqn(IVAL)%T)
                   CASE('ADD_HOUR'); CALL DATE%ADD_HOUR(MAGIC_ANS)
                   CASE('ADD_MIN' ); CALL DATE%ADD_MIN (MAGIC_ANS)
                   CASE('ADD_SEC' ); CALL DATE%ADD_SEC (MAGIC_ANS)
                   END SELECT
                   !
                   MAGIC_ANS = DATE%DYEAR
  END SELECT
  !
  ! MOVE PAST CLOSING BRACKET SO NEXT ATOM EITHER TERMINATES OR PROCESSES THE NEXT OPERATOR
  R = R + ONE
  !
END SUBROUTINE
!
!######################################################################      
!
RECURSIVE PURE SUBROUTINE GET_ARRAY_INDEX(Eqn,R,INDEX,NML,NMV, ERRMSG)
  TYPE (EQN_TERMS), DIMENSION(:), INTENT(IN   ):: Eqn              !ARRAY CONTAINING ALL PARTS OF EQUATION
  INTEGER,                        INTENT(INOUT):: R                !CURRENT INDEX OF ARRAY TO OPERATE ON 
  INTEGER,                        INTENT(INOUT):: INDEX            !HOLDS THE SOLUTION FROM THE ARRAY LOOK UP
  CHARACTER(*),    DIMENSION(:),  INTENT(IN   ):: NML              !ARRAY OF VARIABLE NAMES
  DOUBLE PRECISION,DIMENSION(:),  INTENT(IN   ):: NMV              !ARRAY OF VARIABLE VALUES WITH HIGHEST DIMENSION ONE TO ONE WITH VARIABLE NAME ARRAY (RIGHT MOST DIM) 
  CHARACTER(:),ALLOCATABLE,       INTENT(INOUT):: ERRMSG           !IS ALLOCATED WHEN THERE IS AN ERROR RAISED
  CONTIGUOUS:: NML,NMV
  !
  TYPE (EQN_TERMS),DIMENSION(:),ALLOCATABLE:: SubEqn
  !
  INTEGER:: Rsub, MP
  !
  DOUBLE PRECISION:: IDX
  !
  !
  R = R + TWO   !SKIP THE 'VARNAM' AND THE LEFT BRACKET '['
  !
  !
  !Solve for index in VARNAM [ INDEX ]
  !
  CALL SplitFunc(Eqn(R)%T, SubEqn, ERRMSG)
  Rsub=1
  MP=1      
  CALL EqnParser(SubEqn,Rsub,IDX,MP,NML,NMV,ERRMSG)  !SOLVE FOR THE LEFT SIDE OF THE CONDITINAL  
  DEALLOCATE(SubEqn)
  !
  IF(RETURN_CHECK(ERRMSG)) THEN
                               INDEX = Z
  ELSE
                               INDEX = NINT(IDX)
  END IF
  !
  ! MOVE TO CLOSING BRACKET -- R is at ']' AT EXIT
  R=R+1
  !
END SUBROUTINE    
!
!######################################################################      
!
RECURSIVE PURE SUBROUTINE MAKE_DATE_FROM_Eqn(LN,DATE,SubEqn,Rsub,MP,NML,NMV,ERRMSG)
  CHARACTER(*),                              INTENT(IN   ):: LN
  TYPE(DATE_OPERATOR),                       INTENT(INOUT):: DATE
  TYPE (EQN_TERMS),DIMENSION(:),ALLOCATABLE, INTENT(INOUT):: SubEqn
  INTEGER,                                   INTENT(INOUT):: Rsub,MP
  CHARACTER(*),    DIMENSION(:),             INTENT(IN   ):: NML                !ARRAY OF VARIABLE NAMES
  DOUBLE PRECISION,DIMENSION(:),             INTENT(IN   ):: NMV                !ARRAY OF VARIABLE VALUES WITH HIGHEST DIMENSION ONE TO ONE WITH VARIABLE NAME ARRAY (RIGHT MOST DIM) 
  CHARACTER(:),ALLOCATABLE,                  INTENT(INOUT):: ERRMSG             !IS ALLOCATED WHEN THERE IS AN ERROR RAISED
  CONTIGUOUS:: NML,NMV
  !
  CALL DATE%INIT(LN)
  !
  IF(DATE%NOT_SET()) THEN
                         CALL SplitFunc(LN, SubEqn, ERRMSG)
                         Rsub = ONE
                         MP   = ONE
                         CALL EqnParser(SubEqn,Rsub,DATE%DYEAR,MP,NML,NMV,ERRMSG)
                         !
                         DATE%DAY = NEG  ! TELLS NEXT ROUTINE TO REMAKE DATE USING DYEAR
                         CALL DATE%DYEAR_MAKE_DATE()
  END IF
END SUBROUTINE
!
!######################################################################      
!
RECURSIVE PURE SUBROUTINE MAKE_INT_FROM_Eqn(LN,IVAR,SubEqn,Rsub,MP,NML,NMV,ERRMSG,IERR)
  CHARACTER(*),                              INTENT(IN   ):: LN
  INTEGER,                                   INTENT(INOUT):: IVAR
  TYPE (EQN_TERMS),DIMENSION(:),ALLOCATABLE, INTENT(INOUT):: SubEqn
  INTEGER,                                   INTENT(INOUT):: Rsub,MP
  CHARACTER(*),    DIMENSION(:),             INTENT(IN   ):: NML                !ARRAY OF VARIABLE NAMES
  DOUBLE PRECISION,DIMENSION(:),             INTENT(IN   ):: NMV                !ARRAY OF VARIABLE VALUES WITH HIGHEST DIMENSION ONE TO ONE WITH VARIABLE NAME ARRAY (RIGHT MOST DIM) 
  CHARACTER(:),ALLOCATABLE,                  INTENT(INOUT):: ERRMSG             !IS ALLOCATED WHEN THERE IS AN ERROR RAISED
  INTEGER,                                   INTENT(  OUT):: IERR
  CONTIGUOUS:: NML,NMV
  DOUBLE PRECISION:: VAL
  !
  READ(LN,*, IOSTAT = IERR) IVAR
  !
  IF(IERR.NE.Z) THEN
                         ! First check if just specified as single variable name
                         MP = Z
                         DO Rsub=ONE, SIZE(NML)
                           IF(LN == NML(Rsub))THEN
                                               MP=Rsub
                                               EXIT
                           END IF
                         END DO
                         !
                         IF(MP > Z) THEN   !Variable name found
                             VAL = NMV(MP)
                         ELSE
                             CALL SplitFunc(LN, SubEqn, ERRMSG)  !Solve sub-equation
                             Rsub = ONE
                             MP   = ONE
                             VAL  = DZ
                             CALL EqnParser(SubEqn,Rsub,VAL,MP,NML,NMV,ERRMSG)
                         END IF
                         !
                         IF(RETURN_CHECK(ERRMSG)) THEN
                             IERR = NEG
                             IVAR = ONE
                         ELSE
                             IERR = Z
                             IVAR = NINT(VAL)
                         END IF
  END IF
  !
  !IF(IERR.NE.Z) THEN
  !                       CALL SplitFunc(LN, SubEqn, ERRMSG)
  !                       Rsub = ONE
  !                       MP   = ONE
  !                       VAL  = DZ
  !                       CALL EqnParser(SubEqn,Rsub,VAL,MP,NML,NMV,ERRMSG)
  !                       !
  !                       IF(RETURN_CHECK(ERRMSG)) THEN
  !                           IERR = NEG
  !                           IVAR = ONE
  !                       ELSE
  !                           IERR = Z
  !                           IVAR = NINT(VAL)
  !                       END IF
  !END IF
END SUBROUTINE    
!
RECURSIVE PURE SUBROUTINE MAKE_DBLE_FROM_Eqn(LN,VAR,SubEqn,Rsub,MP,NML,NMV,ERRMSG,IERR)
  CHARACTER(*),                              INTENT(IN   ):: LN
  DOUBLE PRECISION,                          INTENT(INOUT):: VAR
  TYPE (EQN_TERMS),DIMENSION(:),ALLOCATABLE, INTENT(INOUT):: SubEqn
  INTEGER,                                   INTENT(INOUT):: Rsub,MP
  CHARACTER(*),    DIMENSION(:),             INTENT(IN   ):: NML                !ARRAY OF VARIABLE NAMES
  DOUBLE PRECISION,DIMENSION(:),             INTENT(IN   ):: NMV                !ARRAY OF VARIABLE VALUES WITH HIGHEST DIMENSION ONE TO ONE WITH VARIABLE NAME ARRAY (RIGHT MOST DIM) 
  CHARACTER(:),ALLOCATABLE,                  INTENT(INOUT):: ERRMSG             !IS ALLOCATED WHEN THERE IS AN ERROR RAISED
  INTEGER,                                   INTENT(  OUT):: IERR
  CONTIGUOUS:: NML,NMV
  !
  READ(LN,*, IOSTAT = IERR) VAR
  !
  IF(IERR.NE.Z) THEN
                         ! First check if just specified as single variable name
                         MP = Z
                         DO Rsub=ONE, SIZE(NML)
                           IF(LN == NML(Rsub))THEN
                                               MP=Rsub
                                               EXIT
                           END IF
                         END DO
                         !
                         IF(MP > Z) THEN   !Variable name found
                             VAR = NMV(MP)
                         ELSE
                             CALL SplitFunc(LN, SubEqn, ERRMSG)  !Solve sub-equation
                             Rsub = ONE
                             MP   = ONE
                             VAR  = DZ
                             CALL EqnParser(SubEqn,Rsub,VAR,MP,NML,NMV,ERRMSG)
                         END IF
                         !
                         IF(RETURN_CHECK(ERRMSG)) THEN
                             IERR = NEG
                         ELSE
                             IERR = Z
                         END IF
  END IF
  !
  !IF(IERR.NE.Z) THEN
  !                       CALL SplitFunc(LN, SubEqn, ERRMSG)
  !                       Rsub = ONE
  !                       MP   = ONE
  !                       VAL  = DZ
  !                       CALL EqnParser(SubEqn,Rsub,VAL,MP,NML,NMV,ERRMSG)
  !                       !
  !                       IF(RETURN_CHECK(ERRMSG)) THEN
  !                           IERR = NEG
  !                           VAR = ONE
  !                       ELSE
  !                           IERR = Z
  !                           VAR = NINT(VAL)
  !                       END IF
  !END IF
END SUBROUTINE
!
!######################################################################      
!
PURE SUBROUTINE REMOVEBLANK(LN)                                   !REMOVE INTERNAL BLANK SPACES IN A STRING
  CHARACTER(*),INTENT(INOUT)::LN
  !
  CHARACTER(LEN(LN))::T
  INTEGER::I, J
  !
  IF(LN(1:1)==BLNK) LN=ADJUSTL(LN)
  !
  T=BLNK
  J=1
  DO I=1, LEN_TRIM(LN)
     IF(LN(I:I).NE.BLNK .AND. LN(I:I).NE.TAB) THEN   !IF NOT BLANK AND NOT TAB THEN ADD CHARACTER
        T(J:J)=LN(I:I)  
        J=J+1
     END IF
  END DO
  !
  LN=T
  !
END SUBROUTINE
!
! OLD VERSION:
!   PURE SUBROUTINE REMOVEBLANK(LN)                                   !REMOVE INTERNAL BLANK SPACES IN A STRING
!     CHARACTER(*),INTENT(INOUT)::LN
!     !
!     CHARACTER(LEN(LN))::T
!     CHARACTER:: C
!     INTEGER::I
!     !
!     LN=ADJUSTL(LN)
!     !
!     T=' '
!     DO I=1,LEN(TRIM(LN))
!       C=LN(I:I)
!       IF(C.NE.' '.AND.C.NE.ACHAR(9)) T=TRIM(T)//C                     !IF NOT BLANK OR TAB ADD CHARACTER
!     END DO
!     !
!     LN=T
!     !
!   END SUBROUTINE
!
!######################################################################     
!
SUBROUTINE SplitFunc_PREPARE_LINE(LN)
  CHARACTER(*), INTENT(INOUT)::LN
  !
  !MAKE LINE ALL UPPER CASE FOR COMPARISONS
  !CALL UPPER(LN)
  !REMOVE ALL INTERNAL BLANK SPACES
  CALL REMOVEBLANK(LN)
  !
END SUBROUTINE
!
!######################################################################     
!
PURE SUBROUTINE SplitFunc(LN,Eqn,ERRMSG)  !SPLITS LINE BY VARIABLES,OPERATIONS, PARENTHESES, ALLOCATES SPACE REQUIRED FOR EQUATION STORAGE, LN_SETUP=.TRUE. => MAKE LN UPPER CASE AND REMOVE BLANK SPACES
  CHARACTER(*),                             INTENT(IN   ):: LN
  TYPE (EQN_TERMS),DIMENSION(:),ALLOCATABLE,INTENT(INOUT):: Eqn
  CHARACTER(:),ALLOCATABLE,                 INTENT(INOUT):: ERRMSG
  !
  !CHARACTER(5),PARAMETER::OP='+-*/^'
  
  !CHARACTER(1),PARAMETER::LP='('
  !CHARACTER(1),PARAMETER::RP=')'
  !CHARACTER(1),PARAMETER::LB='['
  !CHARACTER(1),PARAMETER::RB=']'
  !CHARACTER(1),PARAMETER::CM=','
  DOUBLE PRECISION:: TMP
  INTEGER::I,J,G,R,B,SymCnt,LINELEN,ISTART,II,JJ,KK
  LOGICAL:: CONT, IS_NUM
  TYPE(DATE_OPERATOR):: DATE
  !
  IF(RETURN_CHECK(ERRMSG)) THEN
      IF(ALLOCATED(Eqn)) DEALLOCATE(Eqn)
      ALLOCATE(Eqn(ONE))
      Eqn(ONE)%T = '0.'
      RETURN
  END IF
  !
  ISTART = 1
  IF(LN(1:1)=='-') ISTART = 2 
  !
  !COUNT NUMBER OF TOKENS WITH 
  !R:=PAREN AND KEYWORD COUNT
  !G:=BRACE GROUP COUNT
  !J:=OP COUNT
  !B:=BRACE COUNT --SHOULD BE ZERO
  !
  B=Z  ! BRACE COUNT --SHOULD BE ZERO
  G=Z  ! BRACE GROUP COUNT
  R=Z  ! PAREN AND KEYWORD COUNT
  J=Z  ! OP COUNT
  !
  LINELEN=LEN_TRIM(LN)
  !
  !!!DO I = ONE, LEN_TRIM(LN)  !CHECK FOR BAD ASCII CODES
  !!!    IF ( ICHAR( LN(I:I) ) > 126 ) THEN
  !!!        !
  !!!        ERRMSG = 'EQUATION ERROR: FOUND NON-ASCII CHARACTER IN EQUATION.'//BLN//'THE EQUATION PARSER ONLY ALLOWS FOR STANDARD ENGLISH ASCII CHARACTERS (ASCII CODES 1 TO 126)'//NL//'THE CHARACTER THAT IS A PROBLEM IS "'//LN(I:I)//'".'//BLN//'THIS CAN HAPPEN IF YOU COPY/PAST FROM AN ADVANCED EDITOR LIKE MS-WORD.'//NL//'AN EASY FIX IS TO REWRITE YOUR EQUATION IN AN ASCII/UNICODE BASIC TEXT EDITOR.'
  !!!        !
  !!!        RETURN
  !!!    END IF
  !!!END DO
  !
  II = ISTART                            !PREVIOUS TOKEN LOCATION
  JJ = Z                                 !Used to determine if MAGIC word is found
  CONT = FALSE
  DO I=ISTART,LINELEN                    !FIRST COUNT +,-,*,/,(,) and []
    !
    !!!IF( I < JJ ) THEN                    !BY PASS MAGIC WORD ARGUMNENTS
    !!!    CYCLE
    !!!ELSEIF( I == JJ) THEN
    !!!    JJ = Z
    !!!    II = I
    !!!END IF
    !!!!
    !!!IF(I - II > SIX ) THEN
    !!!    IF(MAGIC(LN(II:I)) THEN
    !!!         DO KK = I+TWO, LINELEN
    !!!             IF(RP==LN(I:I)) THEN
    !!!                 JJ = KK + ONE
    !!!                 EXIT
    !!!             END IF
    !!!         END DO
    !!!    END IF
    !!!END IF
    !
    IF(LB==LN(I:I)) THEN                 !FOUND '[' SKIP UNTIL ']' IS FOUND
      IF (B==Z) G=G+1                    !A [ INDICATES STORAGE OF A KEYWORD AND THE [. KEYWORD IS AUTOMATICALLY COUNTED BY
      B=B+1
    END IF
    IF(CM==LN(I:I) .AND. B==1) G=G+1     !FOUND ',' WITHIN [ and ]
    IF(RB==LN(I:I)) THEN                 !SEARCHING FOR CLOSING ']'
      B=B-1
      IF (B==Z) G=G+2
      II = I + ONE
    END IF
    IF (B > Z) CYCLE                      !WITHIN TWO BRACES [ ... X ... ]
    !
    IF(RC==LN(I:I)) THEN                 !FOUND '}' NO LONGER SKIPPING
      CONT = FALSE
      II = I + ONE
      CYCLE
    END IF
    IF(LC==LN(I:I)) THEN                 !FOUND '{' SKIP UNTIL '}' IS FOUND
      CONT = TRUE
      CYCLE
    END IF
    IF(CONT) CYCLE
    !
    IF(LP==LN(I:I) .OR. RP==LN(I:I)) THEN  !FOUND A ( OR )
        R=R+1
        II = I + ONE
    ELSEIF(INDEX(OP,LN(I:I))>Z)  THEN
        !
        IS_NUM = FALSE  !Check if it is a number with uni-operator such as -1.5 or (-6) or 1e+3 or 1D-4
        !
        ! First check if it is a negative uni-operator with a number, such as -1 or -3.5
        !
        IF( LN(I:I) == '-' .AND. I < LINELEN) THEN  !.AND. I > ONE <- Always true cause of ISTART check on first -
            !
            IS_NUM = INDEX(NEGCHK,LN(I-ONE:I-ONE))>Z .AND. INDEX(NUMPNT,LN(I+ONE:I+ONE))>Z
            !
        END IF
        !
        ! Check if Scientific Notation 1E-5 pr 1D+4
        !
        IF( (LN(I:I)=='+'  .OR.  LN(I:I) == '-') .AND.  &
             ISTART <= I-2 .AND. I < LINELEN     .AND.  .NOT. IS_NUM  ) THEN  !Need at least two spaces to the left and one space to the right
             !
             IS_NUM = INDEX(NUMPNT,LN(I-TWO:I-TWO))>Z .AND. INDEX(ED,LN(I-ONE:I-ONE))>Z .AND. INDEX(NUMBERS,LN(I+ONE:I+ONE))>Z  !eg 1.E-5 would pass on -
             !             
        END IF
        !
        IF( IS_NUM ) THEN  !If passed number test - try to do a read, as final check
              READ(LN(II:I+ONE),*, IOSTAT = KK) TMP
              !
              IS_NUM = KK == Z
        END IF
        !
        IF(.NOT. IS_NUM) THEN ! ITS AN OPERATOR
            J=J+1
            II = I + ONE
        END IF
        !IF( LN(I:I)=='+' .OR. LN(I:I) == '-' ) THEN
        !  !
        !  IS_NUM = FALSE
        !  IF(ISTART <= I-2 .AND. I+1 <= LINELEN) IS_NUM = INDEX(NUMPNT,LN(I-TWO:I-TWO))>Z .AND. INDEX(ED,LN(I-ONE:I-ONE))>Z .AND. INDEX(NUMBERS,LN(I+ONE:I+ONE))>Z
        !  !
        !  IF( IS_NUM ) THEN !MUST CHECK IF PRECEDED BY ED AND PROCEED BY A NUMBER
        !        READ(LN(II:I+ONE),*, IOSTAT = KK) TMP
        !        IF( KK .NE. Z) THEN
        !                           J=J+1  !NOT A VALID NUMBER SO TREAT AS OPERATOR
        !                           II = I + ONE
        !        END IF
        !  ELSE
        !      J=J+1
        !      II = I + ONE
        !  END IF
        !ELSE
        !    J=J+1
        !    II = I + ONE
        !END IF
    END IF
    !
  END DO
  !
  I=ISTART
  DO WHILE (I <= LINELEN-ONE)                !NEXT COUNT KEYWORDS  --NOTE A KEYWORD IS ALWAYS FOLLOWED BY A "("  eg ABS( or EXP( ALSO THE SMALLEST EQUATION WITH A KEYWORD IS LENGTH 6 SO IT SHOULD ALWAYS CHECK FOR IT
     !
     IF(LB==LN(I:I)) THEN                 !FOUND '[' SKIP UNTIL ']' IS FOUND
       I=I+1
       B=1
       DO WHILE (B > Z .AND. I <= LINELEN)  !NOTE THAT THIS WILL STOP ONE LESS THAN THE OUTER LOOP.
         IF(LB==LN(I:I)) B=B+1
         IF(RB==LN(I:I)) B=B-1
         I=I+1
       END DO
       IF(I >= LINELEN) EXIT
     END IF
     !
     IF(LP==LN(I:I)) THEN
         JJ = I - ONE
         !
         KK = I - KEYLEN
         IF(KK < ONE) KK = ONE
         !
         DO II = JJ-TWO, KK, NEG  ! ABS(  MOVE BACK TO THE "A" SPOT
             !
             IF( KEYWORD(LN(II:JJ)) ) THEN
                 R=R+1
                 EXIT
             END IF
         END DO
     END IF
     I=I+1
  END DO
  !DO WHILE (I <= LINELEN-4)                !NEXT COUNT KEYWORDS  --NOTE A KEYWORD IS ALWAYS FOLLOWED BY A "("  eg ABS( or EXP( ALSO THE SMALLEST EQUATION WITH A KEYWORD IS LENGTH 6 SO IT SHOULD ALWAYS CHECK FOR IT
  !   !
  !   IF(LB==LN(I:I)) THEN                 !FOUND '[' SKIP UNTIL ']' IS FOUND
  !     I=I+1
  !     B=1
  !     DO WHILE (B > Z .AND. I < LINELEN-4)  !NOTE THAT THIS WILL STOP ONE LESS THAN THE OUTER LOOP.
  !       IF(LB==LN(I:I)) B=B+1
  !       IF(RB==LN(I:I)) B=B-1
  !       I=I+1
  !     END DO
  !   END IF
  !   !
  !   IF     ( KEYWORD(LN(I:I+2))  .AND. LN(I+3:I+3)==LP ) THEN
  !      R=R+1
  !      I=I+3
  !   ELSEIF ( KEYWORD(LN(I:I+3))  .AND. LN(I+4:I+4)==LP ) THEN
  !      R=R+1
  !      I=I+4
  !   END IF
  !   I=I+1
  !END DO
  !
  SymCnt=2*J+1+R+G  !COUNT OF ALL TOKENS
  !IF(G>0) SymCnt=SymCnt-1
  !IF (J==0) SymCnt=SymCnt-1  !THERE ARE NO OPERATORS SO COUNT IS OFF BY 1
  !
  IF(ALLOCATED(Eqn)) DEALLOCATE(Eqn)
  ALLOCATE(Eqn(SymCnt))
  !
  R=1
  I=1
  J=ISTART  !J IS NOW THE POSITION. WORDS WILL BE FROM I:J-1
  DO WHILE (J.LE.LINELEN .AND. R.LE.SymCnt)
    !
    IF(LB==LN(J:J)) THEN                      ! FOUND A LEFT BRACKET, [, NOW BEGIN SEARCH FOR RIGHT BRACKET
      IF(I<J) THEN
        Eqn(R)%T=LN(I:J-1)
        R=R+1
      END IF  
      Eqn(R)%T=LN(J:J)
      R=R+1
      J=J+1
      I=J
      B=1
      DO WHILE (B > Z .AND. J.LE.LINELEN)      !BEGIN SEARCH FOR "]", B KEEPS COUNT OF HOW MANY LEFT BRACKETS ARE FOUND
         IF(CM==LN(J:J) .AND. B==1) THEN
            Eqn(R)%T=LN(I:J-1)
            R=R+1
            I=J+1
         END IF
         IF(LB==LN(J:J)) B=B+1
         IF(RB==LN(J:J)) B=B-1       
         J=J+1
      END DO
      J=J-1                 !DUE TO LOOP DESIGN J IS ONE PAST BRACKET
      !
      IF(R>SymCnt) THEN
                ERRMSG = 'EQUATION ERROR: FAILURE TO PARSE EQUATION LINE'//NL//'THIS MAY BE A RESULT IF THE LINE IS NOT LARGE ENOUGH TO HOLD THE ENTIRE EQUATION,'//NL//'THERE ARE UNMATCHED PARETHESIS (),'//NL//'UNMATCHED BRACKETS [],'//NL//'OR SOME OTHER UNKNOWN FAILURE OF THE EQUATION PARSER THAT I, OneWater, CAN NOT HELP YOU WITH.'
                !IF(ASSOCIATED(STOP_ERROR)) THEN
                !    CALL STOP_ERROR(LN,OUTPUT=IOUT,MSG='EQUATION ERROR: FAILURE TO PARSE EQUATION LINE'//NL//'THIS MAY BE A RESULT IF THE LINE IS NOT LARGE ENOUGH TO HOLD THE ENTIRE EQUATION,'//NL//'THERE ARE UNMATCHED PARETHESIS (),'//NL//'UNMATCHED BRACKETS [],'//NL//'OR SOME OTHER UNKNOWN FAILURE OF THE EQUATION PARSER THAT I, OneWater, CAN NOT HELP YOU WITH.')
                !ELSE
                !    WRITE(*,'(A)') 'EQUATION ERROR: FAILURE TO PARSE EQUATION LINE'//NL//'THIS MAY BE A RESULT IF THE LINE IS NOT LARGE ENOUGH TO HOLD THE ENTIRE EQUATION,'//NL//'THERE ARE UNMATCHED PARETHESIS (),'//NL//'UNMATCHED BRACKETS [],'//NL//'OR SOME OTHER UNKNOWN FAILURE OF THE EQUATION PARSER.'
                !    ERROR STOP 
                !END IF
      END IF
      !
      Eqn(R)%T=LN(I:J-1)
      R=R+1
      Eqn(R)%T=LN(J:J)
      R=R+1
      J=J+1
      I=J
      CYCLE
    END IF
    !
    IF(LC==LN(J:J)) THEN                 !FOUND '{' SKIP UNTIL '}' IS FOUND
          IF(I<J) THEN                   !STORE PREVIOUS ENTRY
            Eqn(R)%T=LN(I:J-1)
            R=R+1
          END IF  
          J=J+1
          I=J
          DO WHILE (RC.NE.LN(J:J) .AND. J < LINELEN)      !BEGIN SEARCH FOR "}", B KEEPS COUNT OF HOW MANY LEFT BRACKETS ARE FOUND
              J=J+1
          END DO
          !
          IF(RC.NE.LN(J:J)) THEN
                    ERRMSG = 'EQUATION ERROR: FAILURE TO PARSE EQUATION LINE'//NL//'THIS MAY BE A RESULT IF THE LINE IS NOT LARGE ENOUGH TO HOLD THE ENTIRE EQUATION,'//NL//'THERE ARE UNMATCHED BRACES {},'//NL//'OR SOME OTHER UNKNOWN FAILURE OF THE EQUATION PARSER THAT I, OneWater, CAN NOT HELP YOU WITH.'
                    !IF(ASSOCIATED(STOP_ERROR)) THEN
                    !    CALL STOP_ERROR(LN,OUTPUT=IOUT,MSG='EQUATION ERROR: FAILURE TO PARSE EQUATION LINE'//NL//'THIS MAY BE A RESULT IF THE LINE IS NOT LARGE ENOUGH TO HOLD THE ENTIRE EQUATION,'//NL//'THERE ARE UNMATCHED BRACES {},'//NL//'OR SOME OTHER UNKNOWN FAILURE OF THE EQUATION PARSER THAT I, OneWater, CAN NOT HELP YOU WITH.')
                    !ELSE
                    !    WRITE(*,'(A)') 'EQUATION ERROR: FAILURE TO PARSE EQUATION LINE'//NL//'THIS MAY BE A RESULT IF THE LINE IS NOT LARGE ENOUGH TO HOLD THE ENTIRE EQUATION,'//NL//'THERE ARE UNMATCHED BRACES {},'//NL//'OR SOME OTHER UNKNOWN FAILURE OF THE EQUATION PARSER THAT I, OneWater, CAN NOT HELP YOU WITH.'
                    !    ERROR STOP 
                    !END IF
          END IF
          !
          CALL DATE%INIT(LN(I:J-1))
          !
          IF(DATE%NOT_SET()) THEN
                    !
                    Eqn(R)%T = '{BAD_DATE}'
                    !
                    IF(RETURN_CHECK(ERRMSG)) THEN
                                                ERRMSG = ERRMSG//BLN//'EQUATION ERROR: FAILURE TO PARSE EQUATION LINE'//NL//'THIS MAY BE A RESULT OF A POORLY FORMATTED DATE CONTAINED WITHIN {}. THE ACCEPTED FORMS ARE:'//BLN//'   {yyyy-mm-dd}'//NL//'   {yyyy-mm-ddThh:mm:ss}'//NL//'   {mm/dd/yyyy}'//NL//'   {mm/dd/yyyyThh:mm:ss}'//NL//'   {yyyy-mmThh:mm:ss}'//NL//'   {mm/yyyy}'//NL//'   {mm/yyyyThh:mm:ss}'
                    ELSE
                                                ERRMSG = 'EQUATION ERROR: FAILURE TO PARSE EQUATION LINE'//NL//'THIS MAY BE A RESULT OF A POORLY FORMATTED DATE CONTAINED WITHIN {}. THE ACCEPTED FORMS ARE:'//BLN//'   {yyyy-mm-dd}'//NL//'   {yyyy-mm-ddThh:mm:ss}'//NL//'   {mm/dd/yyyy}'//NL//'   {mm/dd/yyyyThh:mm:ss}'//NL//'   {yyyy-mmThh:mm:ss}'//NL//'   {mm/yyyy}'//NL//'   {mm/yyyyThh:mm:ss}'
                    END IF
                    !ERRMSG = 'EQUATION ERROR: FAILURE TO PARSE EQUATION LINE'//NL//'THIS MAY BE A RESULT OF A POORLY FORMATTED DATE CONTAINED WITHIN {}. THE ACCEPTED FORMS ARE:'//NL//'{yyyy-mm-dd}'//NL//'{yyyy-mm-ddThh:mm:ss}'//NL//'{mm/dd/yyyy}'//NL//'{mm/dd/yyyyThh:mm:ss}'//NL//'{yyyy-mmThh:mm:ss}'//NL//'{mm/yyyy}'//NL//'{mm/yyyyThh:mm:ss}'
                    !IF(ASSOCIATED(STOP_ERROR)) THEN
                    !    CALL STOP_ERROR(LN,OUTPUT=IOUT,MSG='EQUATION ERROR: FAILURE TO PARSE EQUATION LINE'//NL//'THIS MAY BE A RESULT OF A POORLY FORMATTED DATE CONTAINED WITHIN {}. THE ACCEPTED FORMS ARE:'//NL//'{yyyy-mm-dd}'//NL//'{yyyy-mm-ddThh:mm:ss}'//NL//'{mm/dd/yyyy}'//NL//'{mm/dd/yyyyThh:mm:ss}'//NL//'{yyyy-mm}'//NL//'{yyyy-mmThh:mm:ss}'//NL//'{mm/yyyy}'//NL//'{mm/yyyyThh:mm:ss}')
                    !ELSE
                    !    WRITE(*,'(A)') 'EQUATION ERROR: FAILURE TO PARSE EQUATION LINE'//NL//'THIS MAY BE A RESULT OF A POORLY FORMATTED DATE CONTAINED WITHIN {}. THE ACCEPTED FORMS ARE:'//NL//'{yyyy-mm-dd}'//NL//'{yyyy-mm-ddThh:mm:ss}'//NL//'{mm/dd/yyyy}'//NL//'{mm/dd/yyyyThh:mm:ss}'//NL//'{yyyy-mm}'//NL//'{yyyy-mmThh:mm:ss}'//NL//'{mm/yyyy}'//NL//'{mm/yyyyThh:mm:ss}'
                    !    ERROR STOP 
                    !END IF
          ELSE
               ALLOCATE(CHARACTER(19)::Eqn(R)%T)
               WRITE(Eqn(R)%T,'(F17.12, A)') DATE%DYEAR, 'D0'
          END IF
          !
          !WRITE(Eqn(R)%T,'(F17.12)') DATE%DYEAR
          !Eqn(R)%T = TRIM(ADJUSTL(Eqn(R)%T))//'D0'
          R=R+1
          J=J+1
          I=J
          CYCLE
    END IF
    !
    IF(INDEX(OP,LN(J:J))>Z)THEN              ! FOUND AN OPERATOR SO STORE PRECEDING INFORMATION AND OPERATOR
        !
        IS_NUM = FALSE  !Check if it is a number with uni-operator such as -1.5 or (-6) or 1e+3 or 1D-4
        !
        ! First check if it is a negative uni-operator with a number, such as -1 or -3.5
        !
        ! Check if start of word and is negative and previous character is NEGCHK and next character is a NUMPNT
        !
        IF( LN(J:J) == '-' .AND. I==J .AND. J < LINELEN) THEN  !.AND. J > ONE <- Always true cause of ISTART check on first -
            !
            IS_NUM = INDEX(NEGCHK,LN(J-ONE:J-ONE))>Z .AND. INDEX(NUMPNT,LN(J+ONE:J+ONE))>Z
            !
        END IF
        !
        ! Check if Scientific Notation 1E-5 pr 1D+4
        !
        IF( (LN(J:J)=='+'  .OR.  LN(J:J) == '-') .AND.  .NOT. IS_NUM ) THEN
            !
            IF(I < J .AND. ISTART <= J-2 .AND. J < LINELEN ) THEN  !Need at least two spaces to the left and one space to the right
                 !
                 IS_NUM = INDEX(NUMPNT,LN(J-TWO:J-TWO))>Z .AND. INDEX(ED,LN(J-ONE:J-ONE))>Z .AND. INDEX(NUMBERS,LN(J+ONE:J+ONE))>Z  !eg 1.E-5 would pass on -
                 !             
            END IF
        END IF
        !
        IF( IS_NUM ) THEN   !Found starting negative, -.1 or -2.8, or found scientific notation, 1E-5 or 1D+8
                         ! Search for first non-number
                         !
                         J=J+2 !Move past the one number and check if next is still a number
                         DO WHILE (J .LE. LINELEN)
                             !
                             IF( INDEX(NUMPNT,LN(J:J))==Z ) EXIT
                             J=J+1
                             !
                         END DO
        ELSE                                     !Found Operator, so store previous word and operator, update pointers
                         IF(I<J) THEN
                                 Eqn(R)%T=LN(I:J-1)   !Store prevous word or number
                                 R=R+1
                         END IF
                         !
                         Eqn(R)%T=LN(J:J)
                         R=R+1
                         J=J+1
                         I=J
        ENDIF
        !
        CYCLE  ! Updated position or number/word stored, start loop again
        !
        !!!IF( I<J .AND. (LN(J:J)=='+' .OR. LN(J:J) == '-' ) ) THEN
        !!!      !
        !!!      IS_NUM = FALSE
        !!!      IF(ISTART <= J-2 .AND. J+1 <= LINELEN) IS_NUM = INDEX(NUMPNT,LN(J-TWO:J-TWO))>Z .AND. INDEX(ED,LN(J-ONE:J-ONE))>Z .AND. INDEX(NUMBERS,LN(J+ONE:J+ONE))>Z
        !!!      !
        !!!      IF( IS_NUM ) THEN !MUST CHECK IF PRECEDED BY ED AND PROCEED BY A NUMBER
        !!!           !
        !!!           K = ONE
        !!!           DO KK = TWO, THREE
        !!!              IF(J+KK <= LINELEN) THEN
        !!!                    !
        !!!                    IF( INDEX(NUMBERS,LN(J+KK:J+KK))==Z ) EXIT
        !!!                    !
        !!!                    K = KK
        !!!              ELSE 
        !!!                    EXIT
        !!!              END IF
        !!!           END DO
        !!!            !
        !!!            READ(LN(I:J+K),*, IOSTAT = KK) TMP
        !!!            IF( KK == Z) THEN
        !!!                   Eqn(R)%T=LN(I:J+K)
        !!!                   R=R+1
        !!!                   J=J+K+ONE
        !!!                   I=J
        !!!                   CYCLE
        !!!            END IF
        !!!      END IF
        !!!END IF
        !!!! 
        !!!IF(I<J) THEN
        !!!  Eqn(R)%T=LN(I:J-1)
        !!!  R=R+1
        !!!END IF  
        !!!Eqn(R)%T=LN(J:J)
        !!!R=R+1
        !!!J=J+1
        !!!I=J
        !!!CYCLE
    END IF
    !
    IF(LP==LN(J:J))THEN                     ! FOUND A LEFT PARENTHESIS STORE AND START LOOP OVER
      Eqn(R)%T=LN(J:J)
      R=R+1
      J=J+1
      I=J
      CYCLE
    END IF
    !
    IF(RP==LN(J:J))THEN                    ! FOUND A RIGHT PARENTHESIS STORE AND START LOOP OVER
      IF (I<J)THEN
        Eqn(R)%T=LN(I:J-1)
        R=R+1
      END IF  
      Eqn(R)%T=LN(J:J)
      R=R+1
      J=J+1
      I=J
      CYCLE
    END IF
    !
    !!!IF( KEYWORD(LN(I:J)) )THEN            ! FOUND KEYWORD, STORE AND START LOOP OVER
    !!!  Eqn(R)%T=LN(I:J)
    !!!  R=R+1
    !!!  J=J+1
    !!!  I=J
    !!!  CYCLE
    !!!END IF
    !
    IF(J < LINELEN    ) THEN
    IF(LP==LN(J+1:J+1)) THEN
        !
        IF( KEYWORD(LN(I:J)) )THEN            ! FOUND KEYWORD, STORE AND START LOOP OVER
          !
          Eqn(R)%T=LN(I:J) ! ADD Keyword
          R=R+1
          J=J+1
          I=J
          !
          Eqn(R)%T=LN(J:J)  !Add (
          R=R+1
          J=J+1
          I=J
          CYCLE
        END IF
    END IF
    END IF
    !
    J=J+1  !I a number of character, so move to next location and began check
    !
  END DO
  !
  IF (I<J)Eqn(R)%T=TRIM(LN(I:))
  !
END SUBROUTINE 
!
!!!SUBROUTINE SplitFunc(LN,Eqn,LN_SETUP)                           !SPLITS LINE BY VARIABLES,OPERATIONS, PARENTHESES, ALLOCATES SPACE REQUIRED FOR EQUATION STORAGE, LN_SETUP=.TRUE. => MAKE LN UPPER CASE AND REMOVE BLANK SPACES
!!!  CHARACTER(*),INTENT(INOUT)::LN
!!!  !CHARACTER(*),DIMENSION(:),ALLOCATABLE,INTENT(INOUT)::Eqn          !Eqn WILL BE ALLOCATED TO APPROPIATE SIZE CONTAINING SPECIFIED STRINGS FROM CALLING ROUTINE
!!!  TYPE (EQN_TERMS),DIMENSION(:),ALLOCATABLE,INTENT(INOUT)::Eqn
!!!  LOGICAL, INTENT(IN), OPTIONAL:: LN_SETUP
!!!  !
!!!  !CHARACTER(5),PARAMETER::OP='+-*/^'
!!!  
!!!  !CHARACTER(1),PARAMETER::LP='('
!!!  !CHARACTER(1),PARAMETER::RP=')'
!!!  !CHARACTER(1),PARAMETER::LB='['
!!!  !CHARACTER(1),PARAMETER::RB=']'
!!!  !CHARACTER(1),PARAMETER::CM=','
!!!  DOUBLE PRECISION:: TMP
!!!  INTEGER::I,J,K,G,R,B,SymCnt,LINELEN,ISTART,II,JJ,KK
!!!  LOGICAL:: LN_CHECK, CONT
!!!  TYPE(DATE_OPERATOR):: DATE
!!!  !
!!!  LN_CHECK=.TRUE.
!!!  IF(PRESENT(LN_SETUP)) LN_CHECK=LN_SETUP
!!!  !
!!!  IF (LN_CHECK) THEN
!!!     !MAKE LINE ALL UPPER CASE FOR COMPARISONS
!!!     CALL UPPER(LN)
!!!     !REMOVE ALL INTERNAL BLANK SPACES
!!!     CALL REMOVEBLANK(LN)
!!!  END IF
!!!  !
!!!  ISTART = 1
!!!  IF(LN(1:1)=='-') ISTART = 2 
!!!  !
!!!  !COUNT NUMBER OF TOKENS WITH 
!!!  !R:=PAREN AND KEYWORD COUNT
!!!  !G:=BRACE GROUP COUNT
!!!  !J:=OP COUNT
!!!  !B:=BRACE COUNT --SHOULD BE ZERO
!!!  !
!!!  B=Z
!!!  G=Z
!!!  R=Z
!!!  J=Z
!!!  LINELEN=LEN_TRIM(LN)
!!!  !
!!!  II = ISTART                            !PREVIOUS TOKEN LOCATION
!!!  JJ = Z                                 !Used to determine if MAGIC word is found
!!!  CONT = FALSE
!!!  DO I=ISTART,LINELEN                    !FIRST COUNT +,-,*,/,(,) and []
!!!    !
!!!    !!!IF( I < JJ ) THEN                    !BY PASS MAGIC WORD ARGUMNENTS
!!!    !!!    CYCLE
!!!    !!!ELSEIF( I == JJ) THEN
!!!    !!!    JJ = Z
!!!    !!!    II = I
!!!    !!!END IF
!!!    !!!!
!!!    !!!IF(I - II > SIX ) THEN
!!!    !!!    IF(MAGIC(LN(II:I)) THEN
!!!    !!!         DO KK = I+TWO, LINELEN
!!!    !!!             IF(RP==LN(I:I)) THEN
!!!    !!!                 JJ = KK + ONE
!!!    !!!                 EXIT
!!!    !!!             END IF
!!!    !!!         END DO
!!!    !!!    END IF
!!!    !!!END IF
!!!    !
!!!    IF(RC==LN(I:I)) THEN                 !FOUND '}' NO LONGER SKIPPING
!!!      CONT = FALSE
!!!      II = I + ONE
!!!      CYCLE
!!!    END IF
!!!    IF(LC==LN(I:I)) THEN                 !FOUND '{' SKIP UNTIL '}' IS FOUND
!!!      CONT = TRUE
!!!      CYCLE
!!!    END IF
!!!    IF(CONT) CYCLE
!!!    !
!!!    IF(LB==LN(I:I)) THEN                 !FOUND '[' SKIP UNTIL ']' IS FOUND
!!!      IF (B==Z) G=G+1                    !A [ INDICATES STORAGE OF A KEYWORD AND THE [. KEYWORD IS AUTOMATICALLY COUNTED BY
!!!      B=B+1
!!!    END IF
!!!    IF(CM==LN(I:I) .AND. B==1) G=G+1     !FOUND ',' WITHIN [ and ]
!!!    IF(RB==LN(I:I)) THEN                 !SEARCHING FOR CLOSING ']'
!!!      B=B-1
!!!      IF (B==Z) G=G+2
!!!      II = I + ONE
!!!    END IF
!!!    IF (B > Z) CYCLE                      !WITHIN TWO BRACES [ ... X ... ]
!!!    !
!!!    IF(LP==LN(I:I) .OR. RP==LN(I:I)) THEN  !FOUND A ( OR )
!!!        R=R+1
!!!        II = I + ONE
!!!    ELSEIF(INDEX(OP,LN(I:I))>Z)  THEN
!!!        IF( LN(I:I)=='+' .OR. LN(I:I) == '-' ) THEN
!!!          IF( INDEX(NUMPNT,LN(I-TWO:I-TWO))>Z .AND. INDEX(ED,LN(I-ONE:I-ONE))>Z .AND. INDEX(NUMBERS,LN(I+ONE:I+ONE))>Z ) THEN !MUST CHECK IF PRECEDED BY ED AND PROCEED BY A NUMBER
!!!                READ(LN(II:I+ONE),*, IOSTAT = KK) TMP
!!!                IF( KK .NE. Z) THEN
!!!                                   J=J+1  !NOT A VALID NUMBER SO TREAT AS OPERATOR
!!!                                   II = I + ONE
!!!                END IF
!!!          ELSE
!!!              J=J+1
!!!              II = I + ONE
!!!          END IF
!!!        ELSE
!!!            J=J+1
!!!            II = I + ONE
!!!        END IF
!!!    END IF
!!!    !
!!!  END DO
!!!  !
!!!  I=ISTART
!!!  DO WHILE (I <= LINELEN-ONE)                !NEXT COUNT KEYWORDS  --NOTE A KEYWORD IS ALWAYS FOLLOWED BY A "("  eg ABS( or EXP( ALSO THE SMALLEST EQUATION WITH A KEYWORD IS LENGTH 6 SO IT SHOULD ALWAYS CHECK FOR IT
!!!     !
!!!     IF(LB==LN(I:I)) THEN                 !FOUND '[' SKIP UNTIL ']' IS FOUND
!!!       I=I+1
!!!       B=1
!!!       DO WHILE (B > Z .AND. I <= LINELEN)  !NOTE THAT THIS WILL STOP ONE LESS THAN THE OUTER LOOP.
!!!         IF(LB==LN(I:I)) B=B+1
!!!         IF(RB==LN(I:I)) B=B-1
!!!         I=I+1
!!!       END DO
!!!       IF(I == LINELEN) EXIT
!!!     END IF
!!!     !
!!!     IF(LP==LN(I:I)) THEN
!!!         JJ = I - ONE
!!!         !
!!!         KK = I - KEYLEN
!!!         IF(KK < ONE) KK = ONE
!!!         !
!!!         DO II = JJ-TWO, KK, NEG  ! ABS(  MOVE BACK TO THE "A" SPOT
!!!             !
!!!             IF( KEYWORD(LN(II:JJ)) ) THEN
!!!                 R=R+1
!!!                 EXIT
!!!             END IF
!!!         END DO
!!!     END IF
!!!     I=I+1
!!!  END DO
!!!  !DO WHILE (I <= LINELEN-4)                !NEXT COUNT KEYWORDS  --NOTE A KEYWORD IS ALWAYS FOLLOWED BY A "("  eg ABS( or EXP( ALSO THE SMALLEST EQUATION WITH A KEYWORD IS LENGTH 6 SO IT SHOULD ALWAYS CHECK FOR IT
!!!  !   !
!!!  !   IF(LB==LN(I:I)) THEN                 !FOUND '[' SKIP UNTIL ']' IS FOUND
!!!  !     I=I+1
!!!  !     B=1
!!!  !     DO WHILE (B > Z .AND. I < LINELEN-4)  !NOTE THAT THIS WILL STOP ONE LESS THAN THE OUTER LOOP.
!!!  !       IF(LB==LN(I:I)) B=B+1
!!!  !       IF(RB==LN(I:I)) B=B-1
!!!  !       I=I+1
!!!  !     END DO
!!!  !   END IF
!!!  !   !
!!!  !   IF     ( KEYWORD(LN(I:I+2))  .AND. LN(I+3:I+3)==LP ) THEN
!!!  !      R=R+1
!!!  !      I=I+3
!!!  !   ELSEIF ( KEYWORD(LN(I:I+3))  .AND. LN(I+4:I+4)==LP ) THEN
!!!  !      R=R+1
!!!  !      I=I+4
!!!  !   END IF
!!!  !   I=I+1
!!!  !END DO
!!!  !
!!!  SymCnt=2*J+1+R+G  !COUNT OF ALL TOKENS
!!!  !IF(G>0) SymCnt=SymCnt-1
!!!  !IF (J==0) SymCnt=SymCnt-1  !THERE ARE NO OPERATORS SO COUNT IS OFF BY 1
!!!  !
!!!  IF(ALLOCATED(Eqn)) DEALLOCATE(Eqn)
!!!  ALLOCATE(Eqn(SymCnt))
!!!  !
!!!  R=1
!!!  I=1
!!!  J=ISTART  !J IS NOW THE POSITION. WORDS WILL BE FROM I:J-1
!!!  DO WHILE (J.LE.LINELEN .AND. R.LE.SymCnt)
!!!    !
!!!    IF(LB==LN(J:J)) THEN                      ! FOUND A LEFT BRACKET, [, NOW BEGIN SEARCH FOR RIGHT BRACKET
!!!      IF(I<J) THEN
!!!        Eqn(R)%T=LN(I:J-1)
!!!        R=R+1
!!!      END IF  
!!!      Eqn(R)%T=LN(J:J)
!!!      R=R+1
!!!      J=J+1
!!!      I=J
!!!      B=1
!!!      DO WHILE (B > Z .AND. J.LE.LINELEN)      !BEGIN SEARCH FOR "]", B KEEPS COUNT OF HOW MANY LEFT BRACKETS ARE FOUND
!!!         IF(CM==LN(J:J) .AND. B==1) THEN
!!!            Eqn(R)%T=LN(I:J-1)
!!!            R=R+1
!!!            I=J+1
!!!         END IF
!!!         IF(LB==LN(J:J)) B=B+1
!!!         IF(RB==LN(J:J)) B=B-1       
!!!         J=J+1
!!!      END DO
!!!      J=J-1                 !DUE TO LOOP DESIGN J IS ONE PAST BRACKET
!!!      !
!!!      IF(R>SymCnt) THEN
!!!                IF(ASSOCIATED(STOP_ERROR)) THEN
!!!                    CALL STOP_ERROR(LN,OUTPUT=IOUT,MSG='EQUATION ERROR: FAILURE TO PARSE EQUATION LINE'//NL//'THIS MAY BE A RESULT IF THE LINE IS NOT LARGE ENOUGH TO HOLD THE ENTIRE EQUATION,'//NL//'THERE ARE UNMATCHED PARETHESIS (),'//NL//'UNMATCHED BRACKETS [],'//NL//'OR SOME OTHER UNKNOWN FAILURE OF THE EQUATION PARSER THAT I, OneWater, CAN NOT HELP YOU WITH.')
!!!                ELSE
!!!                    WRITE(*,'(A)') 'EQUATION ERROR: FAILURE TO PARSE EQUATION LINE'//NL//'THIS MAY BE A RESULT IF THE LINE IS NOT LARGE ENOUGH TO HOLD THE ENTIRE EQUATION,'//NL//'THERE ARE UNMATCHED PARETHESIS (),'//NL//'UNMATCHED BRACKETS [],'//NL//'OR SOME OTHER UNKNOWN FAILURE OF THE EQUATION PARSER.'
!!!                    ERROR STOP 
!!!                END IF
!!!      END IF
!!!      !
!!!      Eqn(R)%T=LN(I:J-1)
!!!      R=R+1
!!!      Eqn(R)%T=LN(J:J)
!!!      R=R+1
!!!      J=J+1
!!!      I=J
!!!      CYCLE
!!!    END IF
!!!    !
!!!    IF(LC==LN(J:J)) THEN                 !FOUND '{' SKIP UNTIL '}' IS FOUND
!!!          IF(I<J) THEN                   !STORE PREVIOUS ENTRY
!!!            Eqn(R)%T=LN(I:J-1)
!!!            R=R+1
!!!          END IF  
!!!          J=J+1
!!!          I=J
!!!          DO WHILE (RC.NE.LN(J:J) .AND. J < LINELEN)      !BEGIN SEARCH FOR "]", B KEEPS COUNT OF HOW MANY LEFT BRACKETS ARE FOUND
!!!              J=J+1
!!!          END DO
!!!          !
!!!          IF(RC.NE.LN(J:J)) THEN
!!!                    IF(ASSOCIATED(STOP_ERROR)) THEN
!!!                        CALL STOP_ERROR(LN,OUTPUT=IOUT,MSG='EQUATION ERROR: FAILURE TO PARSE EQUATION LINE'//NL//'THIS MAY BE A RESULT IF THE LINE IS NOT LARGE ENOUGH TO HOLD THE ENTIRE EQUATION,'//NL//'THERE ARE UNMATCHED BRACES {},'//NL//'OR SOME OTHER UNKNOWN FAILURE OF THE EQUATION PARSER THAT I, OneWater, CAN NOT HELP YOU WITH.')
!!!                    ELSE
!!!                        WRITE(*,'(A)') 'EQUATION ERROR: FAILURE TO PARSE EQUATION LINE'//NL//'THIS MAY BE A RESULT IF THE LINE IS NOT LARGE ENOUGH TO HOLD THE ENTIRE EQUATION,'//NL//'THERE ARE UNMATCHED BRACES {},'//NL//'OR SOME OTHER UNKNOWN FAILURE OF THE EQUATION PARSER THAT I, OneWater, CAN NOT HELP YOU WITH.'
!!!                        ERROR STOP 
!!!                    END IF
!!!          END IF
!!!          !
!!!          CALL DATE%INIT(LN(I:J-1))
!!!          IF(DATE%NOT_SET()) THEN
!!!                    IF(ASSOCIATED(STOP_ERROR)) THEN
!!!                        CALL STOP_ERROR(LN,OUTPUT=IOUT,MSG='EQUATION ERROR: FAILURE TO PARSE EQUATION LINE'//NL//'THIS MAY BE A RESULT OF A POORLY FORMATTED DATE CONTAINED WITHIN {}. THE ACCEPTED FORMS ARE:'//NL//'{yyyy-mm-dd}'//NL//'{yyyy-mm-ddThh:mm:ss}'//NL//'{mm/dd/yyyy}'//NL//'{mm/dd/yyyyThh:mm:ss}'//NL//'{yyyy-mm}'//NL//'{yyyy-mmThh:mm:ss}'//NL//'{mm/yyyy}'//NL//'{mm/yyyyThh:mm:ss}')
!!!                    ELSE
!!!                        WRITE(*,'(A)') 'EQUATION ERROR: FAILURE TO PARSE EQUATION LINE'//NL//'THIS MAY BE A RESULT OF A POORLY FORMATTED DATE CONTAINED WITHIN {}. THE ACCEPTED FORMS ARE:'//NL//'{yyyy-mm-dd}'//NL//'{yyyy-mm-ddThh:mm:ss}'//NL//'{mm/dd/yyyy}'//NL//'{mm/dd/yyyyThh:mm:ss}'//NL//'{yyyy-mm}'//NL//'{yyyy-mmThh:mm:ss}'//NL//'{mm/yyyy}'//NL//'{mm/yyyyThh:mm:ss}'
!!!                        ERROR STOP 
!!!                    END IF
!!!          END IF
!!!          !
!!!          ALLOCATE(CHARACTER(19)::Eqn(R)%T)
!!!          WRITE(Eqn(R)%T,'(F17.12)') DATE%DYEAR
!!!          Eqn(R)%T = TRIM(ADJUSTL(Eqn(R)%T))//'D0'
!!!          R=R+1
!!!          J=J+1
!!!          I=J
!!!          CYCLE
!!!    END IF
!!!    !
!!!    IF(INDEX(OP,LN(J:J))>Z)THEN              ! FOUND AN OPERATOR SO STORE PRECEDING INFORMATION AND OPERATOR
!!!      IF( I<J .AND. (LN(J:J)=='+' .OR. LN(J:J) == '-' ) ) THEN
!!!            IF( INDEX(NUMPNT,LN(J-TWO:J-TWO))>Z .AND. INDEX(ED,LN(J-ONE:J-ONE))>Z .AND. INDEX(NUMBERS,LN(J+ONE:J+ONE))>Z ) THEN !MUST CHECK IF PRECEDED BY ED AND PROCEED BY A NUMBER
!!!                 !
!!!                 K = ONE
!!!                 DO KK = TWO, THREE
!!!                    IF(J+KK <= LINELEN) THEN
!!!                          !
!!!                          IF( INDEX(NUMBERS,LN(J+KK:J+KK))==Z ) EXIT
!!!                          !
!!!                          K = KK
!!!                    ELSE 
!!!                          EXIT
!!!                    END IF
!!!                 END DO
!!!                  !
!!!                  READ(LN(I:J+K),*, IOSTAT = KK) TMP
!!!                  IF( KK == Z) THEN
!!!                         Eqn(R)%T=LN(I:J+K)
!!!                         R=R+1
!!!                         J=J+K+ONE
!!!                         I=J
!!!                         CYCLE
!!!                  END IF
!!!            END IF
!!!      END IF
!!!      ! 
!!!      IF(I<J) THEN
!!!        Eqn(R)%T=LN(I:J-1)
!!!        R=R+1
!!!      END IF  
!!!      Eqn(R)%T=LN(J:J)
!!!      R=R+1
!!!      J=J+1
!!!      I=J
!!!      CYCLE
!!!    END IF
!!!    !
!!!    IF(LP==LN(J:J))THEN                     ! FOUND A LEFT PARENTHESIS STORE AND START LOOP OVER
!!!      Eqn(R)%T=LN(J:J)
!!!      R=R+1
!!!      J=J+1
!!!      I=J
!!!      CYCLE
!!!    END IF
!!!    !
!!!    IF(RP==LN(J:J))THEN                    ! FOUND A RIGHT PARENTHESIS STORE AND START LOOP OVER
!!!      IF (I<J)THEN
!!!        Eqn(R)%T=LN(I:J-1)
!!!        R=R+1
!!!      END IF  
!!!      Eqn(R)%T=LN(J:J)
!!!      R=R+1
!!!      J=J+1
!!!      I=J
!!!      CYCLE
!!!    END IF
!!!    !
!!!    IF( KEYWORD(LN(I:J)) )THEN            ! FOUND KEYWORD, STORE AND START LOOP OVER
!!!      Eqn(R)%T=LN(I:J)
!!!      R=R+1
!!!      J=J+1
!!!      I=J
!!!      CYCLE
!!!    END IF
!!!    !
!!!    !IF(' '==LN(J:J)) EXIT                !REACHED END OF EQUATION TERMINATE THE LOOP
!!!    !
!!!    J=J+1
!!!  END DO
!!!  !
!!!  IF (I<J)Eqn(R)%T=TRIM(LN(I:))
!!!  !
!!!END SUBROUTINE 
!
!######################################################################       
!
PURE SUBROUTINE PRECEDENCE(OPERATION,DIRECT,PREC,ERRMSG)                      !DETERMINES PRIORITY OF OPERATION ***CAN ADD ADDITION OPERATORS LIKE LOG/EXP
  CHARACTER(*),             INTENT(IN   ):: OPERATION                    !OPERATION
  CHARACTER(*),             INTENT(INOUT):: DIRECT                       !DIRECTION OF OPERATION
  INTEGER,                  INTENT(  OUT):: PREC                         !PRECIDENCE OF CURRENT OPERATOR
  CHARACTER(:),ALLOCATABLE, INTENT(INOUT):: ERRMSG
  !
  !
  SELECT CASE(OPERATION)
  CASE ('+', '-')
                PREC=ONE
                DIRECT='L'
  CASE ('*','/')
                PREC=TWO
                DIRECT='L'
  CASE ('^')
                PREC=THREE
                DIRECT='R'
  CASE DEFAULT 
                ERRMSG = 'EQUATION ERROR WITH FUNCTION OpInfo(OP): UNABLE TO UNDERSTAND OPERATOR "'//OPERATION//'"'//NL//'THE ONLY ACCEPTED OPERATORS ARE + - * / and ^'
                PREC  = Z
                DIRECT='L'
  END SELECT
END SUBROUTINE
!
!######################################################################       
!
!FUNCTION PRECEDENCE(OPERATION,ERRMSG,DIRECT)                             !DETERMINES PRIORITY OF OPERATION ***CAN ADD ADDITION OPERATORS LIKE LOG/EXP
!  INTEGER::PRECEDENCE
!  CHARACTER(*),             INTENT(IN   ):: OPERATION                    !OPERATION
!  CHARACTER(:),ALLOCATABLE, INTENT(INOUT):: ERRMSG
!  CHARACTER(*),OPTIONAL,    INTENT(INOUT):: DIRECT                       !DIRECTION OF OPERATION
!  !
!  !
!  SELECT CASE(OPERATION)
!  CASE ('+', '-')
!                PRECEDENCE=ONE
!                IF(PRESENT(DIRECT))DIRECT='L'
!  CASE ('*','/')
!                PRECEDENCE=TWO
!                IF(PRESENT(DIRECT))DIRECT='L'
!  CASE ('^')
!                PRECEDENCE=THREE
!                IF(PRESENT(DIRECT))DIRECT='R'
!  CASE DEFAULT 
!                ERRMSG = 'EQUATION ERROR WITH FUNCTION OpInfo(OP): UNABLE TO UNDERSTAND OPERATOR "'//OPERATION//'"'//NL//'THE ONLY ACCEPTED OPERATORS ARE + - * / and ^'
!                !IF(ASSOCIATED(STOP_ERROR)) THEN
!                !    CALL STOP_ERROR(OUTPUT=IOUT,MSG='EQUATION ERROR WITH FUNCTION OpInfo(OP): UNABLE TO UNDERSTAND OPERATOR "'//OPERATION//'"'//NL//'THE ONLY ACCEPTED OPERATORS ARE + - * / and ^')
!                !ELSE
!                !    WRITE(*,'(3A)') 'EQUATION ERROR WITH FUNCTION OpInfo(OP): UNABLE TO UNDERSTAND OPERATOR "',OPERATION,'"'//NL//'THE ONLY ACCEPTED OPERATORS ARE + - * / and ^'
!                !    ERROR STOP 
!                !END IF
!  END SELECT
!END FUNCTION
!
!######################################################################
!
PURE ELEMENTAL FUNCTION MathOP(OPERATION,L,R) RESULT(ANS)                     !APPLY THE CURRENT OPPORATOR TO THE TWO ADJACENT VARIABLES
  CHARACTER(*),    INTENT(IN)::OPERATION
  DOUBLE PRECISION,INTENT(IN)::L,R
  DOUBLE PRECISION           ::ANS
  !
  SELECT CASE(OPERATION)
              CASE ('+');  ANS =  L+R
              CASE ('-');  ANS =  L-R
              CASE ('*');  ANS =  L*R
              CASE ('/');  ANS =  ROBUST_DIV(L,R)
              CASE ('^');  ANS =  ROBUST_POW(L,R)
  END SELECT
  !
  !IF(NEGNEARZERO_30 < L .AND. L < NEARZERO_30) THEN
  !    ANS =  DZ
  !ELSEIF(NEGNEARZERO_30 < R .AND. R < NEARZERO_30) THEN
  !    ANS =  DZ
  !ELSE
  !    ANS =  L/R
  !END IF
  !
END FUNCTION
!
!######################################################################
!
PURE ELEMENTAL FUNCTION ROBUST_POW(L,R) RESULT(ANS) 
  DOUBLE PRECISION,INTENT(IN)::L,R
  DOUBLE PRECISION           ::ANS
  !
  IF(NEGNEARZERO_30 < L .AND. L < NEARZERO_30) THEN
      ANS =  DZ
  ELSEIF(NEGNEARZERO_7 < R .AND. R < NEARZERO_7) THEN
      ANS = UNO
  ELSEIF(0.999999D0 < R .AND. R < 1.000001D0) THEN
      ANS = L
  ELSEIF(L < DZ) THEN
          BLOCK
              INTEGER:: IR
              IR = NINT(R)
              IF    (ABS(R - DBLE(IR)) < NEARZERO_5) THEN
                  ANS = L**IR
              ELSE
                  ANS = IEEE_VALUE(ANS, IEEE_QUIET_NAN)
              END IF
          END BLOCK
  ELSE
      ANS =  L**R
  END IF
  !
END FUNCTION
!
!######################################################################
!
PURE ELEMENTAL FUNCTION ROBUST_DIV(L,R) RESULT(ANS) 
  DOUBLE PRECISION,INTENT(IN)::L,R
  DOUBLE PRECISION           ::ANS
  !
  IF(NEGNEARZERO_30 < L .AND. L < NEARZERO_30) THEN
      ANS =  DZ
  ELSEIF(NEGNEARZERO_30 < R .AND. R < NEGNEARZERO_30) THEN
      ANS = IEEE_VALUE(ANS, IEEE_QUIET_NAN)
  ELSE
      ANS =  L/R
  END IF
  !
END FUNCTION
!
!######################################################################       
! Never Actually Used - Kept just in case
!
!!!PURE SUBROUTINE GET_NAME_POS(POS, NAME, NML, ERRMSG)       !RETURNS LOCATION OF MULT ARRAY BASED ON NAME  **ASSUMES MLTNAM HAS BEEN INITIALIZED TO ' '
!!!  INTEGER,                                INTENT(  OUT):: POS
!!!  CHARACTER(*),                           INTENT(IN   ):: NAME
!!!  CHARACTER(*), DIMENSION(:), CONTIGUOUS, INTENT(IN   ):: NML                !ARRAY OF VARIABLE NAMES
!!!  CHARACTER(:),ALLOCATABLE,               INTENT(INOUT):: ERRMSG
!!!  !
!!!  INTEGER:: I,N
!!!  !
!!!  N=SIZE(NML)
!!!  !
!!!  POS=Z
!!!  DO I=1, N
!!!    IF(NAME.EQ.NML(I))THEN
!!!      POS=I
!!!      EXIT
!!!    END IF
!!!  END DO
!!!  !
!!!  IF (POS==Z) THEN
!!!      ERRMSG = 'ERROR EVALUATING EQUATION DUE TO FAILING TO LOCATE NAME OF VARIABLE IN EQUATION WTIHIN FUNCTION NAME_LOOKUP(NAME).'//NL//                                                                                                                                                    &
!!!                                        'THE VARIABLE NAME BEING SEARCHED FOR IS:'//BLN//'     "'//NAME//'"'//BLN//'IT MAY NOT BE DEFINED OR CONTAINS A SPELLING ERROR.'//BLN//                                                                                                                                                     &
!!!                                        'IF THERE IS AN OPERATOR, + - / * IN THE NAME, THEN THE PARSER HAD AN ISSUE WITH THE EQUATION STRUCTURE'//NL//'MAYBE YOU HAVE TWO OPERATORS IN A ROW, LIKE "X+-Y"'//NL//'OR YOU HAVE A NEGATIVE SYMBOL WHEN YOU SHOULD USE THE NEG FUNCTION "-Y+X" INSTEAD OF "NEG(Y)+X"'//BLN//   &
!!!                                        'FOR YOUR REFERENCE THE FOLLOWING IS A LIST OF THE VARIABLE NAMES THAT ARE CURRENTLY DEFINED AND WERE WHAT WAS SEARCHED THROUGH:'//PRINT_VARIABLE_NAMES(NML)
!!!    !IF(ASSOCIATED(STOP_ERROR)) THEN
!!!    !    CALL STOP_ERROR(OUTPUT=IOUT,MSG='ERROR EVALUATING EQUATION DUE TO FAILING TO LOCATE NAME OF VARIABLE IN EQUATION WTIHIN FUNCTION NAME_LOOKUP(NAME).'//NL//                                                                                                                                                    &
!!!    !                                    'THE VARIABLE NAME BEING SEARCHED FOR IS:'//BLN//'     "'//NAME//'"'//BLN//'IT MAY NOT BE DEFINED OR CONTAINS A SPELLING ERROR.'//BLN//                                                                                                                                                     &
!!!    !                                    'IF THERE IS AN OPERATOR, + - / * IN THE NAME, THEN THE PARSER HAD AN ISSUE WITH THE EQUATION STRUCTURE...MAYBE YOU HAVE TWO OPERATORS IN A ROW, LIKE "X+-Y"'//NL//'OR YOU HAVE A NEGATIVE SYMBOL WHEN YOU SHOULD USE THE NEG FUNCTION "-Y+X" INSTEAD OF "NEG(Y)+X"'//BLN//   &
!!!    !                                    'FOR YOUR REFERENCE THE FOLLOWING IS A LIST OF THE VARIABLE NAMES THAT ARE CURRENTLY DEFINED AND WERE WHAT WAS SEARCHED THROUGH:'//PRINT_VARIABLE_NAMES(NML))
!!!    !ELSE
!!!    !    WRITE(*,'(3A, *(/A))') 'ERROR EVALUATING EQUATION DUE TO FAILING TO LOCATE NAME OF VARIABLE IN EQUATION WTIHIN FUNCTION NAME_LOOKUP(NAME). THE VARIABLE NAME BEING SEARCHED FOR IS: "',NAME, &
!!!    !                    '". IT MAY NOT BE DEFINED OR CONTAINS A SPELLING ERROR',   &
!!!    !                'IF THERE IS AN OPERATOR, + - / * IN THE NAME, THEN THE PARSER HAD AN ISSUE WITH THE EXPRESSION STRUCTURE.','MAYBE YOU HAVE TWO OPERATORS IN A ROW, LIKE "X+-Y"','OR YOU HAVE A NEGATIVE SYMBOL WHEN YOU SHOULD USE THE NEG FUNCTION "-Y+X" INSTEAD OF "NEG(Y)+X"'
!!!    !    ERROR STOP 
!!!    !END IF
!!!  END IF
!!!  !
!!!END SUBROUTINE
!
!######################################################################       
!
FUNCTION NAME_LOOKUP(NAME,NML,ERRMSG)       !RETURNS LOCATION OF MULT ARRAY BASED ON NAME  **ASSUMES MLTNAM HAS BEEN INITIALIZED TO ' '
  INTEGER::NAME_LOOKUP
  CHARACTER(*):: NAME
  CHARACTER(*), DIMENSION(:), CONTIGUOUS::NML                !ARRAY OF VARIABLE NAMES
  CHARACTER(:),ALLOCATABLE, INTENT(INOUT):: ERRMSG
  !
  INTEGER:: I,N
  !
  N=SIZE(NML)
  !
  NAME_LOOKUP=NEG
  DO I=1, N
    IF(NAME.EQ.NML(I))THEN
      NAME_LOOKUP=I
      EXIT
    END IF
    IF (NAME_LOOKUP==NEG) THEN
        NAME_LOOKUP = ONE
        ERRMSG = 'ERROR EVALUATING EQUATION DUE TO FAILING TO LOCATE NAME OF VARIABLE IN EQUATION WTIHIN FUNCTION NAME_LOOKUP(NAME).'//NL//                                                                                                                                                    &
                                          'THE VARIABLE NAME BEING SEARCHED FOR IS:'//BLN//'     "'//NAME//'"'//BLN//'IT MAY NOT BE DEFINED OR CONTAINS A SPELLING ERROR.'//BLN//                                                                                                                                                     &
                                          'IF THERE IS AN OPERATOR, + - / * IN THE NAME, THEN THE PARSER HAD AN ISSUE WITH THE EQUATION STRUCTURE'//NL//'MAYBE YOU HAVE TWO OPERATORS IN A ROW, LIKE "X+-Y"'//NL//'OR YOU HAVE A NEGATIVE SYMBOL WHEN YOU SHOULD USE THE NEG FUNCTION "-Y+X" INSTEAD OF "NEG(Y)+X"'//BLN//   &
                                          'FOR YOUR REFERENCE THE FOLLOWING IS A LIST OF THE VARIABLE NAMES THAT ARE CURRENTLY DEFINED AND WERE WHAT WAS SEARCHED THROUGH:'//PRINT_VARIABLE_NAMES(NML)
      !IF(ASSOCIATED(STOP_ERROR)) THEN
      !    CALL STOP_ERROR(OUTPUT=IOUT,MSG='ERROR EVALUATING EQUATION DUE TO FAILING TO LOCATE NAME OF VARIABLE IN EQUATION WTIHIN FUNCTION NAME_LOOKUP(NAME).'//NL//                                                                                                                                                    &
      !                                    'THE VARIABLE NAME BEING SEARCHED FOR IS:'//BLN//'     "'//NAME//'"'//BLN//'IT MAY NOT BE DEFINED OR CONTAINS A SPELLING ERROR.'//BLN//                                                                                                                                                     &
      !                                    'IF THERE IS AN OPERATOR, + - / * IN THE NAME, THEN THE PARSER HAD AN ISSUE WITH THE EQUATION STRUCTURE...MAYBE YOU HAVE TWO OPERATORS IN A ROW, LIKE "X+-Y"'//NL//'OR YOU HAVE A NEGATIVE SYMBOL WHEN YOU SHOULD USE THE NEG FUNCTION "-Y+X" INSTEAD OF "NEG(Y)+X"'//BLN//   &
      !                                    'FOR YOUR REFERENCE THE FOLLOWING IS A LIST OF THE VARIABLE NAMES THAT ARE CURRENTLY DEFINED AND WERE WHAT WAS SEARCHED THROUGH:'//PRINT_VARIABLE_NAMES(NML))
      !ELSE
      !    WRITE(*,'(3A, *(/A))') 'ERROR EVALUATING EQUATION DUE TO FAILING TO LOCATE NAME OF VARIABLE IN EQUATION WTIHIN FUNCTION NAME_LOOKUP(NAME). THE VARIABLE NAME BEING SEARCHED FOR IS: "',NAME, &
      !                    '". IT MAY NOT BE DEFINED OR CONTAINS A SPELLING ERROR',   &
      !                'IF THERE IS AN OPERATOR, + - / * IN THE NAME, THEN THE PARSER HAD AN ISSUE WITH THE EXPRESSION STRUCTURE.','MAYBE YOU HAVE TWO OPERATORS IN A ROW, LIKE "X+-Y"','OR YOU HAVE A NEGATIVE SYMBOL WHEN YOU SHOULD USE THE NEG FUNCTION "-Y+X" INSTEAD OF "NEG(Y)+X"'
      !    ERROR STOP 
      !END IF
    END IF
  END DO
  !
END FUNCTION
!
!######################################################################    
!
PURE ELEMENTAL FUNCTION KEYWORD(WORD) RESULT(KEY)                      !LIST OF KEYWORDS
  CHARACTER(*),INTENT(IN)::WORD
  
  LOGICAL:: KEY
  !
  KEY=ANY(WORD==KEYWORDLIST)       !KEYWORDLIST IS A GLOBAL VARIABLE THAT CONTAINS ALL DEFINED KEY WORDS (eg LOG)
  !
END FUNCTION
!
!######################################################################    
!Never actually used - Kept just in case it might be
!
!!!PURE ELEMENTAL FUNCTION MAGIC(WORD) RESULT(KEY)                      !LIST OF KEYWORDS
!!!  CHARACTER(*),INTENT(IN)::WORD
!!!  
!!!  LOGICAL:: KEY
!!!  !
!!!  KEY=ANY(WORD==MAGICLIST)       !KEYWORDLIST IS A GLOBAL VARIABLE THAT CONTAINS ALL DEFINED KEY WORDS (eg LOG)
!!!  !
!!!END FUNCTION
!
!######################################################################    
!
PURE ELEMENTAL SUBROUTINE KEYWORDEVAL(WORD,ANS,VALID)
   CHARACTER(*),     INTENT(IN   )::WORD
   DOUBLE PRECISION, INTENT(INOUT)::ANS
   LOGICAL,          INTENT(OUT)::VALID
   !
   VALID=.TRUE.
   !
   SELECT CASE(WORD)
   CASE('ABS');  ANS=ABS(ANS)
   CASE('EXP');  ANS=EXP(ANS)
   CASE('LOG')
               IF(ANS<=DZ) THEN
                 VALID=.FALSE.
               ELSE
                 ANS=LOG(ANS)
               END IF
   CASE('LOG10')
               IF(ANS<=DZ) THEN
                 VALID=.FALSE.
               ELSE
                 ANS=LOG10(ANS)
               END IF
   CASE('NEG');  ANS=DNEG*ANS
   CASE('SQRT')
               IF(ANS<DZ) THEN
                 VALID=.FALSE.
               ELSE
                 ANS=SQRT(ANS)
               END IF
   CASE('NEG_TO_ZERO')
               IF(ANS<DZ) ANS = DZ
   CASE('POS_TO_ZERO')
               IF(ANS>DZ) ANS = DZ
   CASE('ROUND'   ); ANS = DNINT(ANS)
   CASE('CEILING' ); ANS = CEILING(ANS)
   CASE('FLOOR'   ); ANS = FLOOR(ANS)
   CASE('TRUNCATE'); ANS = DINT(ANS)
! CASE DEFAULT                                                     !FUNCTION CONVERTED TO PURE FOR SPEED, HOWEVER THIS NEGATES THE ABILITY OF I/O AND STOP
!   WRITE(*,'(3A)')'EQUATION: CODE ERROR - KEYWORD, ',TRIM(WORD), ', IS NOT SPECIFIED IN KEYWORDEVAL() FOR EVALUATION.'
!   STOP
  END SELECT
  !
END SUBROUTINE
!
!######################################################################    
!
SUBROUTINE KEYWORDCHECK(LIST)
  CHARACTER(*),DIMENSION(:), CONTIGUOUS::LIST
  INTEGER,DIMENSION(SIZE(LIST)):: FOUND
  INTEGER:: NLIST
  !
  INTEGER::I,J,N,NKEY
  !
  FOUND=Z
  N=LEN(LIST(1))
  NKEY=SIZE(KEYWORDLIST)
  NLIST=SIZE(LIST)
  !
  DO I=1, NLIST
     DO J=1, NKEY
        IF( INDEX( LIST(I),TRIM(KEYWORDLIST(J)) ) >Z ) THEN
           FOUND(I)=J
           EXIT
        END IF
     END DO
  END DO
  !
  IF(ANY( FOUND>Z )) THEN
      !ERRMSG = 'EQUATION ERROR: KEYWORD FOUND IN VARIABLE NAME LIST (NML)'//NL//'THE FOLLOWING ARE THE VARIABLES AND KEYWORDS THAT WERE FOUND: '//PRINT_KEYWORD_VARIABLE(LIST,FOUND)
      IF(ASSOCIATED(STOP_ERROR)) THEN
          CALL STOP_ERROR(OUTPUT=IOUT,MSG='EQUATION ERROR: KEYWORD FOUND IN VARIABLE NAME LIST (NML)'//NL//'THE FOLLOWING ARE THE VARIABLES AND KEYWORDS THAT WERE FOUND: '//PRINT_KEYWORD_VARIABLE(LIST,FOUND))
      ELSE
          WRITE(*,'(A,/A)') 'EQUATION ERROR: KEYWORD FOUND IN VARIABLE NAME LIST (NML) THE FOLLOWING ARE THE VARIABLES AND KEYWORDS THAT WERE FOUND:'
          DO I=1,NLIST
             IF(FOUND(I)>Z) WRITE(*,'(2(5x,A))') TRIM(LIST(I)), TRIM( KEYWORDLIST( FOUND(I) )  )
          END DO
              WRITE(*,'(/A)') '***THIS IS NOT ALLOWED; PROGRAM WILL NOW TERMINATE***'
              ERROR STOP
      END IF
  END IF
  !
END SUBROUTINE
!!######################################################################    
!
!!!PURE ELEMENTAL SUBROUTINE UPPER(LN)  !CLONE OF UTIL_INTERFACE SUBROUTINE OF SAME NAME  --ASSUME ALL IS CASE CORRECT
!!!    CHARACTER(*),INTENT(INOUT):: LN
!!!    INTEGER, PARAMETER:: IDIFF=ICHAR('a')-ICHAR('A')
!!!    INTEGER::I
!!!    !
!!!    DO CONCURRENT(I=1:LEN(LN), LN(I:I).GE.'a' .AND. LN(I:I).LE.'z');  LN(I:I)=CHAR(ICHAR(LN(I:I))-IDIFF)
!!!    END DO
!!!    !
!!!END SUBROUTINE
!
!######################################################################    
!
PURE FUNCTION REMAKE_FUNCTION(Eqn) RESULT(LN)
    TYPE (EQN_TERMS),DIMENSION(:), INTENT(IN)::Eqn
    CHARACTER(:),                  ALLOCATABLE:: LN
    INTEGER::R,N
    !
    N = SIZE(Eqn)
    IF(N>Z) THEN
          LN = Eqn(ONE)%T
        DO R=TWO, N
          LN = LN//BLNK//Eqn(R)%T
        END DO
    ELSE
          LN = 'NO EQUATION LOADED??? -- THIS SHOULD NOT HAPPEN!!!'
    END IF
    !
END FUNCTION
!
PURE FUNCTION PRINT_VARIABLE_LIST(NML,NMV) RESULT(LN)
    CHARACTER(*),    DIMENSION(:),INTENT(IN)::NML   !ARRAY OF VARIABLE NAMES
    DOUBLE PRECISION,DIMENSION(:),INTENT(IN)::NMV   !ARRAY OF VARIABLE VALUES WITH HIGHEST DIMENSION ONE TO ONE WITH VARIABLE NAME ARRAY (RIGHT MOST DIM) 
    CHARACTER(:),                 ALLOCATABLE:: LN
    CONTIGUOUS:: NML, NMV
    INTEGER:: I,N
    CHARACTER(:),ALLOCATABLE:: HED
    !
    ALLOCATE(CHARACTER(LEN(NML))::HED)
    HED(:) = 'VARNAM'
    LN = BLN//HED//'   VARVAL'
    DEALLOCATE(HED)
    !
    N = SIZE(NML)
    IF(N>Z) THEN
        DO I=ONE, N
          LN = LN//NL//NML(I)//' = '//DBLE2STR(NMV(I))
        END DO
        LN = LN//NL
    ELSE
          LN = BLN//'NO VARIABLES LOADED??? -- THIS SHOULD NOT HAPPEN!!!'//BLN
    END IF
    !
  END FUNCTION
  !
  PURE FUNCTION PRINT_VARIABLE_NAMES(NML) RESULT(LN)
    CHARACTER(*),    DIMENSION(:),INTENT(IN)::NML   !ARRAY OF VARIABLE NAMES
    CHARACTER(:),                 ALLOCATABLE:: LN
    CONTIGUOUS:: NML
    INTEGER:: I,N
    !
    LN = BLN//'VARNAM'
    N = SIZE(NML)
    IF(N>Z) THEN
        DO I=ONE, N
          LN = LN//NL//NML(I)
        END DO
        LN = LN//NL
    ELSE
          LN = BLN//'NO VARIABLES LOADED??? -- THIS SHOULD NOT HAPPEN!!!'//BLN
    END IF
    !
END FUNCTION
!
PURE FUNCTION PRINT_KEYWORD_VARIABLE(NML,FOUND) RESULT(LN)
    CHARACTER(*),    DIMENSION(:),INTENT(IN):: NML   !ARRAY OF VARIABLE NAMES
    INTEGER,         DIMENSION(:),INTENT(IN):: FOUND
    CHARACTER(:),                 ALLOCATABLE:: LN
    CONTIGUOUS:: NML, FOUND
    INTEGER:: I,N
    CHARACTER(:),ALLOCATABLE:: HED
    !
    ALLOCATE(CHARACTER(LEN(NML))::HED)
    HED(:) = 'VARNAM'
    LN = BLN//HED//'   KEYWORD'
    DEALLOCATE(HED)
    !
    N = SIZE(NML)
    IF(N>Z) THEN
        DO I=ONE, N
            IF(FOUND(I)>Z) LN = LN//NL//NML(I)//'   '//KEYWORDLIST( FOUND(I) )
        END DO
        LN = LN//NL
    ELSE
          LN = BLN//'NO VARIABLES LOADED??? -- THIS SHOULD NOT HAPPEN!!!'//BLN
    END IF
    !
END FUNCTION
!
PURE FUNCTION DBLE2STR(DVAL)
    DOUBLE PRECISION,INTENT(IN):: DVAL
    CHARACTER(:),  ALLOCATABLE :: DBLE2STR
    CHARACTER(50)::NUM
    !
    NUM=BLNK
    !
    IF(DVAL.NE.DVAL) THEN
        NUM='NaN'
    ELSEIF(DVAL.GE.D250) THEN
        NUM = 'inf'
    ELSEIF(DVAL.LE.negD250) THEN
        NUM = '-inf'
    ELSE
     !
     IF(DVAL==0D0)                               THEN
        WRITE(NUM,'(F3.1)') DVAL
     ELSEIF(DVAL>=1D100 .OR. DVAL<=-1D100)       THEN
        WRITE(NUM,'(ES40.7E3)') DVAL
     ELSEIF(DVAL>=1D10 .OR. DVAL<=-1D10)         THEN
        WRITE(NUM,'(ES40.7E2)') DVAL
     ELSEIF(DVAL>=1D6 .OR. DVAL<=-1D6)           THEN
        WRITE(NUM,'(ES40.7E1)') DVAL
     ELSEIF(DVAL>=1D2 .OR. DVAL<=-1D2 )          THEN
        WRITE(NUM,'(F40.5)') DVAL
     ELSEIF(DVAL>=0.00099D0 .OR. DVAL<=-0.00099D0 )  THEN
        WRITE(NUM,'(F40.7)') DVAL
     ELSEIF(DVAL>=1D-9 .OR. DVAL<=-1D-9)         THEN
        WRITE(NUM,'(ES40.7E1)') DVAL
     ELSEIF(DVAL>=1D-99 .OR. DVAL<=-1D-99)       THEN
        WRITE(NUM,'(ES40.7E2)') DVAL
     ELSEIF(DVAL>0D0 .OR. DVAL<0D0)              THEN
        WRITE(NUM,'(ES40.7E3)') DVAL
     END IF
    END IF
    !
    DBLE2STR=TRIM(ADJUSTL(NUM))
    !
    END FUNCTION 
    !
    PURE SUBROUTINE QUICK_NUM_CHECK(LINE, VAL, NOT_NUM)
    CHARACTER(*),     INTENT(IN   ):: LINE
    DOUBLE PRECISION, INTENT(INOUT):: VAL
    LOGICAL,          INTENT(INOUT):: NOT_NUM
    !
    NOT_NUM = FALSE
    !
    SELECT CASE(LINE)
      CASE('NAN');   VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)
      CASE('INF');   VAL = inf
      CASE('-INF');  VAL = ninf
      CASE('-5','-5.','-5.0');  VAL = -5D0
      CASE('-4','-4.','-4.0');  VAL = -4D0
      CASE('-3','-3.','-3.0');  VAL = -3D0
      CASE('-2','-2.','-2.0');  VAL = -2D0
      CASE('-1','-1.','-1.0');  VAL = DNEG
      CASE('0',  '0.', '0.0');  VAL = DZ
      CASE('0.001');            VAL = MILLI
      CASE('0.01');             VAL = CENTI
      CASE('0.1');              VAL = TENTH
      CASE('0.2','0.20');       VAL = FIFTH
      CASE('0.25');             VAL = FOURTH
      CASE('0.5','0.50');       VAL = HALF
      CASE('0.75');             VAL = DODRANT
      CASE('0.9','0.90');       VAL = 0.9D0
      CASE('0.95');             VAL = 0.95D0
      CASE('0.98');             VAL = 0.98D0
      CASE('0.99');             VAL = 0.99D0
      CASE('1',  '1.', '1.0');  VAL = UNO
      CASE('1.5','1.50');       VAL = 1.5D0
      CASE('2',  '2.', '2.0');  VAL = DOS
      CASE('3',  '3.', '3.0');  VAL = TRES
      CASE('4',  '4.', '4.0');  VAL = QUAD
      CASE('5',  '5.', '5.0');  VAL = CINCO
      CASE('6',  '6.', '6.0');  VAL = 6D0
      CASE('7',  '7.', '7.0');  VAL = 7D0
      CASE('8',  '8.', '8.0');  VAL = 8D0
      CASE('9',  '9.', '9.0');  VAL = 9D0
      CASE('10','10.','10.0');  VAL = DIEZ
      CASE('20','20.','20.0');  VAL = VIGINTI
      CASE('25','25.','25.0');  VAL = 25D0
      CASE('60','60.','60.0');  VAL = SEXAGEN
      CASE('100','100.','100.0');  VAL = HECTO
      CASE('1000','1000.','1000.0');  VAL = KILO
      CASE DEFAULT
                  NOT_NUM = TRUE
    END SELECT
    END SUBROUTINE
!
!
!######################################################################
!######################################################################    
!
END MODULE
!
!!
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
!
MODULE RANDOM_ROUTINES!, ONLY: RANDOM_GENERATOR, SHUFFLE, SET_FORTRAN_SEED, COIN_TOSS, BINARY_TOSS
  USE CONSTANTS
  USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: i8 => INT8,   i16 => INT16,  &
                                         i32 => INT32,  i64 => INT64,  &
                                         SNG => REAL32, DBL => REAL64, &
                                                        QAD => REAL128
  IMPLICIT NONE
  !
  PRIVATE
  !
  PUBLIC:: RANDOM_GENERATOR
  PUBLIC:: SET_FORTRAN_SEED!([SEED])
  PUBLIC:: SHUFFLE         !(VEC, [SEED])
  PUBLIC:: COIN_TOSS       !()
  PUBLIC:: BINARY_TOSS     !()
  !
  INTERFACE SHUFFLE
    MODULE PROCEDURE  INT_SHUFFLE  !(VEC,SEED)
    MODULE PROCEDURE DBLE_SHUFFLE  !(VEC,SEED)
    MODULE PROCEDURE REAL_SHUFFLE  !(VEC,SEED)
  END INTERFACE
  !  
  TYPE RANDOM_GENERATOR                      ! Uses a LINEAR_CONGRUENTIAL_GENERATOR to make random numbers
      !
      INTEGER(i64):: m    = 2147483647_i64   !Values from C18 standard  - Must be a power of 2 minus 1, eg 2^31-1
      INTEGER(i64):: a    = 1103515245_i64
      INTEGER(i64):: c    = 12345_i64
      INTEGER(i64):: seed = LONG_NEG         !Flag to indicate seed is not set
      !
      CONTAINS
      !
      PROCEDURE, PASS(LCG):: INIT       => INITIALIZE_LCG!([ID], [SEED])
      GENERIC             :: GEN        => GENERATE_RANDOM_INT_SUB_LCG, &  !GEN(RAND)
                                           GENERATE_RANDOM_DBL_SUB_LCG, &    
                                           GENERATE_RANDOM_SGL_SUB_LCG
      GENERIC             :: PURE_GEN   => GENERATE_RANDOM_INT_PURE_SUB_LCG,  &  !GEN(RAND)
                                           GENERATE_RANDOM_DBL_PURE_SUB_LCG,  &    
                                           GENERATE_RANDOM_SNG_PURE_SUB_LCG
      PROCEDURE, PASS(LCG):: GEN_INT    => GENERATE_RANDOM_INT_LCG             ! GEN_INT   ()
      PROCEDURE, PASS(LCG):: GEN_DOUBLE => GENERATE_RANDOM_DBL_LCG             ! GEN_DOUBLE() 
      PROCEDURE, PASS(LCG):: GEN_SINGLE => GENERATE_RANDOM_SNG_LCG             ! GEN_SINGLE() 
      PROCEDURE, PASS(LCG):: GEN_BINARY => GENERATE_RANDOM_BINARY_LCG          ! GEN_BINARY() 
      PROCEDURE, PASS(LCG):: FLIP_COIN  => GENERATE_RANDOM_COIN_LCG            ! FLIP_COIN () 
      PROCEDURE, PASS(LCG):: SET_PROP   => SET_SEED_LCG                        ! SET_PROP([ID], [SEED], [M], [A], [C])
      !
      GENERIC:: ASSIGNMENT(=)           => COPY_RANDOM_GENERATOR
      !
      PROCEDURE, PASS(LCG), PRIVATE:: GENERATE_RANDOM_INT_SUB_LCG
      PROCEDURE, PASS(LCG), PRIVATE:: GENERATE_RANDOM_DBL_SUB_LCG
      PROCEDURE, PASS(LCG), PRIVATE:: GENERATE_RANDOM_SGL_SUB_LCG
      PROCEDURE, PASS(LCG), PRIVATE:: GENERATE_RANDOM_INT_PURE_SUB_LCG
      PROCEDURE, PASS(LCG), PRIVATE:: GENERATE_RANDOM_DBL_PURE_SUB_LCG
      PROCEDURE, PASS(LCG), PRIVATE:: GENERATE_RANDOM_SNG_PURE_SUB_LCG 
      PROCEDURE,            PRIVATE:: COPY_RANDOM_GENERATOR
      !
      FINAL:: FINAL_DESTROY_LCG
      !
  END TYPE
  !
  TYPE(RANDOM_GENERATOR), ALLOCATABLE, SAVE:: LCG_COIN
  TYPE(RANDOM_GENERATOR), ALLOCATABLE, SAVE:: LCG_BINARY
  !
  INTRINSIC:: RANDOM_SEED, RANDOM_NUMBER, DATE_AND_TIME, INT, REAL
  !
  INTEGER(i64), PARAMETER:: Default_seed =   105155045_i64  !Random number I made up  -- Only used by PURE routines if the SEED is not yet initialized
  !	
  CONTAINS
  !	
  ! ------------------------------------------------------------------------------------------------------------------------------------------------------------
  !	
  SUBROUTINE SET_FORTRAN_SEED(SEED)
     INTEGER, OPTIONAL, INTENT(IN):: SEED
     !
     TYPE(RANDOM_GENERATOR):: LCG
     !
     INTEGER, DIMENSION(:),ALLOCATABLE:: S
     INTEGER:: I, DIM
     !
     CALL RANDOM_SEED (SIZE = DIM)
     ALLOCATE(S(DIM))
     !
     IF(PRESENT(SEED)) THEN
                       S(:) = SEED
     ELSE
                       S(1) = NEG
     END IF
     !
     IF(S(1) < ONE) THEN
         !
         DO I=ONE, DIM;  S(I) = LCG%GEN_INT()
         END DO
     END IF
     !
     CALL RANDOM_SEED (PUT = S)
     !
     DEALLOCATE(S)
     !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  SUBROUTINE INITIALIZE_LCG(LCG, ID, SEED)
    CLASS(RANDOM_GENERATOR), INTENT(INOUT):: LCG
    CLASS(*), OPTIONAL,      INTENT(IN   ):: ID    ! If returned then makes SEED unique to ID (Disables odd-even random shift)
    CLASS(*), OPTIONAL,      INTENT(IN   ):: SEED  ! If specified then defines the seed, if < 1 or not specified, then randomly generates SEED based in wall tine and PID. Set > 0 for repeatability, disables use of ID)
    !
    CALL DESTROY_LCG(LCG)
    !
    CALL SET_SEED_LCG(LCG, ID, SEED)
    !  
  END SUBROUTINE
  ! 
  PURE ELEMENTAL SUBROUTINE DESTROY_LCG(LCG)
    CLASS(RANDOM_GENERATOR), INTENT(INOUT):: LCG
    !
    LCG%m    = 2147483647_i64
    LCG%a    = 1103515245_i64
    LCG%c    =      12345_i64
    LCG%seed = LONG_NEG         !Flag to indicate seed is not set
    !  
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE COPY_RANDOM_GENERATOR(LCG_OUT,LCG_IN)
    CLASS(RANDOM_GENERATOR), INTENT(IN   ):: LCG_IN
    CLASS(RANDOM_GENERATOR), INTENT(INOUT):: LCG_OUT
    !
    LCG_OUT%m    = LCG_IN%m   
    LCG_OUT%a    = LCG_IN%a   
    LCG_OUT%c    = LCG_IN%c   
    LCG_OUT%seed = LCG_IN%seed
    !
  END SUBROUTINE
  !	
  ! ------------------------------------------------------------------------------------------------------------------------------------------------------------
  !	
  PURE SUBROUTINE GENERATE_RANDOM_INT_PURE_SUB_LCG(LCG, IRAND)
    CLASS(RANDOM_GENERATOR), INTENT(INOUT):: LCG
    INTEGER(i32),            INTENT(  OUT):: IRAND
    !
    IF(LCG%seed <= LONG_ONE) LCG%seed = Default_seed
    !
    ASSOCIATE(x => LCG%seed, m => LCG%m, a  => LCG%a, c => LCG%c)
        !
        !X1 = MODULO(X*a + c, m+LONG_ONE)
        X = IAND(X*a + c, m)             !Because M is a power of 2 minus 1, can use IAND in place of MOD()
        !
        IF(X < LONG_ZER) X = LONG_NEG*X
        !
        
        IF       (X > LONG_inf_I) THEN
        DO WHILE (X > LONG_inf_I)
                            X = IAND(X*a + c, m)
                            !
                            IF(X < LONG_ZER) X = LONG_NEG*X
        END DO
        END IF
        !
        IRAND = INT(X, i32)
        !                          seed    *     c     -   a
        IF(X <= LONG_ONE) X = Default_seed * 12345_i64 - 1103515245_i64 !Re-init random seed
        !
    END ASSOCIATE
    !  
  END SUBROUTINE
  !	
  ! ------------------------------------------------------------------------------------------------------------------------------------------------------------
  !	
  SUBROUTINE GENERATE_RANDOM_INT_SUB_LCG(LCG, IRAND)
    CLASS(RANDOM_GENERATOR), INTENT(INOUT):: LCG
    INTEGER(i32),            INTENT(  OUT):: IRAND
    !
    IF(LCG%seed <= LONG_ONE) CALL SET_SEED_LCG(LCG) 
    !
    CALL GENERATE_RANDOM_INT_PURE_SUB_LCG(LCG, IRAND)
    !  
  END SUBROUTINE
  !	
  FUNCTION GENERATE_RANDOM_INT_LCG(LCG)  RESULT(IRAND)
    CLASS(RANDOM_GENERATOR), INTENT(INOUT):: LCG
    INTEGER:: IRAND
    !
    IF(LCG%seed <= LONG_ONE) CALL SET_SEED_LCG(LCG) 
    !
    CALL GENERATE_RANDOM_INT_PURE_SUB_LCG(LCG, IRAND)
    !
  END FUNCTION
  !	
  ! ------------------------------------------------------------------------------------------------------------------------------------------------------------
  !	
  PURE SUBROUTINE GENERATE_RANDOM_DBL_PURE_SUB_LCG(LCG, RAND)
    CLASS(RANDOM_GENERATOR), INTENT(INOUT):: LCG
    REAL(DBL),               INTENT(  OUT):: RAND
    INTEGER(i32):: IRAND
    !
    CALL GENERATE_RANDOM_INT_PURE_SUB_LCG(LCG, IRAND)
    !
    RAND = REAL(IRAND, DBL) / REAL( LCG%m+LONG_ONE, DBL )
    !
    IF(RAND > UNO) RAND = UNO
    IF(RAND <  DZ) RAND = DZ
    !  
  END SUBROUTINE
  !
  ! ------------------------------------------------------------------------------------------------------------------------------------------------------------
  !	
  SUBROUTINE GENERATE_RANDOM_DBL_SUB_LCG(LCG, RAND)
    CLASS(RANDOM_GENERATOR), INTENT(INOUT):: LCG
    REAL(DBL),               INTENT(  OUT):: RAND
    INTEGER(i32):: IRAND
    !
    IF(LCG%seed <= LONG_ONE) CALL SET_SEED_LCG(LCG) 
    !
    CALL GENERATE_RANDOM_INT_PURE_SUB_LCG(LCG, IRAND)
    !
    RAND = REAL(IRAND, DBL) / REAL( LCG%m+LONG_ONE, DBL )
    !
    IF(RAND > UNO) RAND = UNO
    IF(RAND <  DZ) RAND = DZ
    !  
  END SUBROUTINE
  !	
  ! ------------------------------------------------------------------------------------------------------------------------------------------------------------
  !	
  FUNCTION GENERATE_RANDOM_DBL_LCG(LCG)  RESULT(RAND)
    CLASS(RANDOM_GENERATOR), INTENT(INOUT):: LCG
    REAL(DBL):: RAND
    !
    INTEGER(i32):: IRAND
    !
    IF(LCG%seed <= LONG_ONE) CALL SET_SEED_LCG(LCG) 
    !
    CALL GENERATE_RANDOM_INT_PURE_SUB_LCG(LCG, IRAND)
    !
    RAND = REAL(IRAND, DBL) / REAL( LCG%m+LONG_ONE, DBL )
    !
    IF(RAND > UNO) RAND = UNO
    IF(RAND <  DZ) RAND = DZ
    !
  END FUNCTION
  !	
  ! ------------------------------------------------------------------------------------------------------------------------------------------------------------
  !	
  PURE SUBROUTINE GENERATE_RANDOM_SNG_PURE_SUB_LCG(LCG, RAND)
    CLASS(RANDOM_GENERATOR), INTENT(INOUT):: LCG
    REAL(SNG),               INTENT(  OUT):: RAND
    REAL(DBL)     :: DRAND
    INTEGER(i32):: IRAND
    !
    CALL GENERATE_RANDOM_INT_PURE_SUB_LCG(LCG, IRAND)
    !
    DRAND = REAL(IRAND, DBL) / REAL( LCG%m+LONG_ONE, DBL )
    !
    IF(DRAND > UNO) DRAND = UNO
    IF(DRAND <  DZ) DRAND = DZ
    !
    RAND = REAL(DRAND, SNG)
    !  
  END SUBROUTINE
  !
  ! ------------------------------------------------------------------------------------------------------------------------------------------------------------
  !	
  SUBROUTINE GENERATE_RANDOM_SGL_SUB_LCG(LCG, RAND)
    CLASS(RANDOM_GENERATOR), INTENT(INOUT):: LCG
    REAL(SNG),               INTENT(  OUT):: RAND
    REAL(DBL)     :: DRAND
    INTEGER(i32):: IRAND
    !
    IF(LCG%seed <= LONG_ONE) CALL SET_SEED_LCG(LCG) 
    !
    CALL GENERATE_RANDOM_INT_PURE_SUB_LCG(LCG, IRAND)
    !
    DRAND = REAL(IRAND, DBL) / REAL( LCG%m+LONG_ONE, DBL )
    !
    IF(DRAND > UNO) DRAND = UNO
    IF(DRAND <  DZ) DRAND = DZ
    !
    RAND = REAL(DRAND, SNG)
    !  
  END SUBROUTINE
  !	
  ! ------------------------------------------------------------------------------------------------------------------------------------------------------------
  !	
  FUNCTION GENERATE_RANDOM_SNG_LCG(LCG)  RESULT(RAND)
    CLASS(RANDOM_GENERATOR), INTENT(INOUT):: LCG
    REAL(SNG):: RAND
    REAL(DBL)     :: DRAND
    INTEGER(i32):: IRAND
    !
    IF(LCG%seed <= LONG_ONE) CALL SET_SEED_LCG(LCG) 
    !
    CALL GENERATE_RANDOM_INT_PURE_SUB_LCG(LCG, IRAND)
    !
    DRAND = REAL(IRAND, SNG) / REAL( LCG%m+LONG_ONE, SNG )
    !
    IF(DRAND > UNO) DRAND = UNO
    IF(DRAND <  DZ) DRAND = DZ
    !
    RAND = REAL(DRAND, SNG)
    !
  END FUNCTION
  !	
  ! ------------------------------------------------------------------------------------------------------------------------------------------------------------
  !	
  FUNCTION GENERATE_RANDOM_COIN_LCG(LCG)  RESULT(COIN)
    CLASS(RANDOM_GENERATOR), INTENT(INOUT):: LCG
    LOGICAL:: COIN
    REAL(DBL)   :: DRAND
    INTEGER(i32):: IRAND
    !
    IF(LCG%seed <= LONG_ONE) CALL SET_SEED_LCG(LCG) 
    !
    CALL GENERATE_RANDOM_INT_PURE_SUB_LCG(LCG, IRAND)
    !
    DRAND = REAL(IRAND, SNG) / REAL( LCG%m+LONG_ONE, SNG )
    !
    IF(DRAND > UNO) DRAND = UNO
    IF(DRAND <  DZ) DRAND = DZ
    !
    COIN = DRAND <  HALF
    !
  END FUNCTION
  !	
  ! ------------------------------------------------------------------------------------------------------------------------------------------------------------
  !	
  FUNCTION GENERATE_RANDOM_BINARY_LCG(LCG)  RESULT(BIN)
    CLASS(RANDOM_GENERATOR), INTENT(INOUT):: LCG
    INTEGER:: BIN
    REAL(DBL)   :: DRAND
    INTEGER(i32):: IRAND
    !
    IF(LCG%seed <= LONG_ONE) CALL SET_SEED_LCG(LCG) 
    !
    CALL GENERATE_RANDOM_INT_PURE_SUB_LCG(LCG, IRAND)
    !
    DRAND = REAL(IRAND, SNG) / REAL( LCG%m+LONG_ONE, SNG )
    !
    IF(DRAND > UNO) DRAND = UNO
    IF(DRAND <  DZ) DRAND = DZ
    !
    IF( DRAND <  HALF ) THEN; BIN = ONE
    ELSE;                     BIN = Z
    END IF
    !
  END FUNCTION
  !
  ! ------------------------------------------------------------------------------------------------------------------------------------------------------------
  !	
  !!!PURE SUBROUTINE SHUFFLE_INT_LCG(LCG, DIM, VEC)  
  !!! !Modified SATTOLO Shuffle Method  
  !!!  CLASS(RANDOM_GENERATOR), INTENT(INOUT):: LCG
  !!!  INTEGER,                 INTENT(IN   ):: DIM
  !!!  INTEGER,DIMENSION(DIM), INTENT(INOUT):: VEC
  !!!  INTEGER:: I,J
  !!!  INTEGER:: TMP
  !!!  REAL(SNG):: RND 
  !!!  !double x = (int)( Math.random()*((max-min)+1) )+min;
  !!!  DO I=DIM, TWO, NEG
  !!!      !
  !!!      CALL GENERATE_RANDOM_INT_PURE_SUB_LCG(LCG, IRAND)
  !!!      !
  !!!      RND = RND * REAL(I-ONE, SNG) + 1_SNG
  !!!      !
  !!!      J = NINT(RND) 
  !!!      !
  !!!      TMP    = VEC(I)
  !!!      VEC(I) = VEC(J)
  !!!      VEC(J) = TMP
  !!!      !
  !!!  END DO
  !!!  !
  !!!END SUBROUTINE
  !
  ! ------------------------------------------------------------------------------------------------------------------------------------------------------------
  !	
  SUBROUTINE SET_SEED_LCG(LCG, ID, SEED, M, A, C)
    CLASS(RANDOM_GENERATOR), INTENT(INOUT):: LCG
    CLASS(*), OPTIONAL,      INTENT(IN   ):: ID    ! If returned then makes SEED unique to ID (Disables odd-even random shift)
    CLASS(*), OPTIONAL,      INTENT(IN   ):: SEED  ! If specified then defines the seed, if < 1 or not specified, then randomly generates SEED based in wall tine and PID. Set > 0 for repeatability, disables use of ID)
    CLASS(*), OPTIONAL,      INTENT(IN   ):: M     ! Set range of random numbers, must be a power of 2 minus one (default is 2^31 - 1)
    CLASS(*), OPTIONAL,      INTENT(IN   ):: A, C  ! Overrudes default va
    !
    INTEGER(i64):: YER, SEC, MS, CNT, PID
    !
    INTEGER, DIMENSION(EIGHT):: T
    INTEGER:: I, J
    !
    CHARACTER(EIGHT):: BYT
    CHARACTER(TWO  ):: TXT
    !
    IF(PRESENT(ID)) THEN
         SELECT TYPE(ID)
         TYPE IS (INTEGER(i32)); PID = INT(ID,i64)
         TYPE IS (INTEGER(i64)); PID = ID
         END SELECT
         !
         IF(PID < LONG_ONE) PID = LONG_ONE
    ELSE
            PID = LONG_ONE
    END IF
    !
    IF(PRESENT(M)) THEN
         SELECT TYPE(M)
         TYPE IS (INTEGER(i32)); LCG%M = INT(M,i64)
         TYPE IS (INTEGER(i64)); LCG%M = M
         END SELECT
         !
         !CNT = LOG2(LCG%M)
         !
         CNT = 1024_i64;   IF(LCG%M < CNT) LCG%M = CNT  !should be at least 2^10 = 1024
         !
         LCG%M = LCG%M + LONG_ONE
         !
         CNT   = LONG_NEG
         DO WHILE (LCG%M > 0)
                           CNT = CNT + LONG_ONE
                           LCG%M = SHIFTR( LCG%M, LONG_ONE )  !Drop out the right most bit
         ENDDO
         !
         LCG%M = LONG_TWO**CNT - LONG_ONE   !Ensure it is a power of 2
    END IF
    !
    IF(PRESENT(A)) THEN
         SELECT TYPE(A)
         TYPE IS (INTEGER(i32)); LCG%A = INT(A,i64)
         TYPE IS (INTEGER(i64)); LCG%A = A
         END SELECT
    END IF
    !
    IF(PRESENT(C)) THEN
         SELECT TYPE(C)
         TYPE IS (INTEGER(i32)); LCG%C = INT(C,i64)
         TYPE IS (INTEGER(i64)); LCG%C = C
         END SELECT
    END IF
    !
    LCG%seed = LONG_NEG
    !
    IF(PRESENT(SEED)) THEN
         SELECT TYPE(SEED)
         TYPE IS (INTEGER(i32)); LCG%seed = INT(SEED,i64)
         TYPE IS (INTEGER(i64)); LCG%seed = SEED
         END SELECT
    END IF
    !
    IF(LCG%seed <= LONG_ONE) THEN
        ASSOCIATE( X => LCG%seed )
           CALL DATE_AND_TIME(VALUES = T)  !GET CURRENT TIME VALUES
           !
           YER =       INT(T(1), i64)
           CNT =       INT(T(2), i64)*25920000_i64   !MON
           CNT = CNT + INT(T(3), i64)*8640000_i64    !DAY
           CNT = CNT + INT(T(5), i64)*3600000_i64    !HR 
           CNT = CNT + INT(T(6), i64)*60000_i64      !MIN
           SEC =       INT(T(7), i64)*1000_i64
           MS  =       INT(T(8), i64)
           !
           X = YER*SEC*PID + SEC*MS + MS + PID
           !
           IF( BTEST(T(8), Z) .AND. PID > LONG_ONE) THEN      !MS is odd
               BYT = TRANSFER(X, BYT)                         !Shift Bytes around for fun
               !
               TXT  = BYT(1:2)
               BYT(1:2) = BYT(6:7)
               BYT(6:7) = TXT
               !
               TXT  = BYT(5:6)
               BYT(5:6) = BYT(7:8)
               BYT(7:8) = TXT
               !
               DO J=TWO, EIGHT, TWO
                   I = J - ONE
                   !
                   TXT(1:1)  = BYT(J:J)
                   BYT(J:J) = BYT(I:I)
                   BYT(I:I) = TXT(1:1)
               END DO
               !
               X = TRANSFER(BYT, X)
           END IF
           !
           IF(X < LONG_ZER) X = LONG_NEG*X
           !
           IF(X < 10000_i64) X = X*10000_i64
           !
        END ASSOCIATE
    END IF
    !  
  END SUBROUTINE
  !
  ! ------------------------------------------------------------------------------------------------------------------------------------------------------------
  !
  PURE ELEMENTAL SUBROUTINE FINAL_DESTROY_LCG(LCG)
    TYPE(RANDOM_GENERATOR), INTENT(INOUT):: LCG
    !
    CALL DESTROY_LCG(LCG)
    ! 
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  FUNCTION COIN_TOSS(SEED)  RESULT(TIS_TRUE)
     !SEED<0 IS RANDOM SEED
     INTEGER,  OPTIONAL, INTENT(IN):: SEED
     LOGICAL:: TIS_TRUE
     !
     IF( .NOT. ALLOCATED(LCG_COIN) ) ALLOCATE( LCG_COIN )
     !
     IF(PRESENT(SEED)) CALL LCG_COIN%SET_PROP(SEED=SEED)
     !
     TIS_TRUE = LCG_COIN%GEN_DOUBLE() < HALF
     !
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  FUNCTION BINARY_TOSS(SEED)  RESULT(BINARY_RESULT)
     !SEED<0 IS RANDOM SEED
     INTEGER,  OPTIONAL, INTENT(IN):: SEED
     INTEGER:: BINARY_RESULT
     !
     IF( .NOT. ALLOCATED(LCG_BINARY) ) ALLOCATE( LCG_BINARY )
     !
     IF(PRESENT(SEED)) CALL LCG_BINARY%SET_PROP(SEED=SEED)
     !
     IF( LCG_BINARY%GEN_DOUBLE() < HALF ) THEN
                      BINARY_RESULT = ONE
     ELSE
                      BINARY_RESULT = Z
     END IF
     !
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  SUBROUTINE INT_SHUFFLE(VEC,SEED)  
     !Modified SATTOLO Shuffle Method  
     !SEED<0 IS RANDOM SEED
     INTEGER,DIMENSION(:),CONTIGUOUS,INTENT(INOUT):: VEC
     INTEGER,              OPTIONAL, INTENT(IN   ):: SEED
     INTEGER:: I,J,DIM
     INTEGER:: TMP
     REAL(SNG):: RND 
     !
     IF(PRESENT(SEED)) THEN; CALL SET_FORTRAN_SEED(SEED)
     END IF
     !
     DIM  = SIZE(VEC)
     !
     DO I=DIM, TWO, NEG
         !
         CALL RANDOM_NUMBER(RND)
         !
         RND = RND * REAL(I-ONE, SNG) + 1_SNG
         !
         J = NINT(RND) 
         !
         TMP    = VEC(I)
         VEC(I) = VEC(J)
         VEC(J) = TMP
         !
     END DO
     !
  END SUBROUTINE
  !
  ! ------------------------------------------------------------------------------------------------------------------------------------------------------------
  !	
  SUBROUTINE DBLE_SHUFFLE(VEC,SEED)  
     !Modified SATTOLO Shuffle Method  
     !SEED<0 IS RANDOM SEED
     REAL(DBL),DIMENSION(:),CONTIGUOUS,INTENT(INOUT):: VEC
     INTEGER,                   OPTIONAL, INTENT(IN   ):: SEED
     INTEGER:: I,J,DIM
     REAL(DBL):: TMP
     REAL(SNG):: RND 
     !
     IF(PRESENT(SEED)) THEN; CALL SET_FORTRAN_SEED(SEED)
     END IF
     !
     DIM  = SIZE(VEC)
     !
     DO I=DIM, TWO, NEG
         !
         CALL RANDOM_NUMBER(RND)
         !
         RND = RND * REAL(I-ONE, SNG) + 1_SNG
         !
         J = NINT(RND) 
         !
         TMP    = VEC(I)
         VEC(I) = VEC(J)
         VEC(J) = TMP
         !
     END DO
     !
  END SUBROUTINE
  !
  ! ------------------------------------------------------------------------------------------------------------------------------------------------------------
  !	
  SUBROUTINE REAL_SHUFFLE(VEC,SEED)  
     !Modified SATTOLO Shuffle Method  
     !SEED<0 IS RANDOM SEED
     REAL(SNG),DIMENSION(:),CONTIGUOUS,INTENT(INOUT):: VEC
     INTEGER,                   OPTIONAL, INTENT(IN   ):: SEED
     INTEGER:: I,J,DIM
     REAL(SNG):: TMP
     REAL(SNG):: RND 
     !
     IF(PRESENT(SEED)) THEN; CALL SET_FORTRAN_SEED(SEED)
     END IF
     !
     DIM  = SIZE(VEC)
     !
     DO I=DIM, TWO, NEG
         !
         CALL RANDOM_NUMBER(RND)
         !
         RND = RND * REAL(I-ONE, SNG) + 1_SNG
         !
         J = NINT(RND) 
         !
         TMP    = VEC(I)
         VEC(I) = VEC(J)
         VEC(J) = TMP
         !
     END DO
     !
  END SUBROUTINE
  !
END MODULE
!!
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
!
MODULE IS_PRESENT_INTERFACE
USE CONSTANTS, ONLY: TRUE, FALSE
IMPLICIT NONE
PUBLIC:: IS_PRESENT
PRIVATE
!
INTERFACE IS_PRESENT
  MODULE PROCEDURE:: IS_PRESENT_BOOL         !IS_PRESENT(LVAL)
  MODULE PROCEDURE:: IS_PRESENT_BOOL_WANT    !IS_PRESENT(LVAL, WANT)
  MODULE PROCEDURE:: IS_PRESENT_INT          !IS_PRESENT(IVAL, [ICMP])
END INTERFACE
!
CONTAINS
    !
    PURE FUNCTION IS_PRESENT_BOOL(LVAL) RESULT(ANS)
      LOGICAL, OPTIONAL, INTENT(IN):: LVAL
      LOGICAL:: ANS
      !
      IF (PRESENT(LVAL)) THEN
                         ANS = LVAL
      ELSE
                         ANS = FALSE
      END IF
      !
    END FUNCTION
    !
    PURE FUNCTION IS_PRESENT_BOOL_WANT(LVAL,WANT) RESULT(ANS)
      LOGICAL, OPTIONAL, INTENT(IN):: LVAL
      LOGICAL,           INTENT(IN):: WANT
      LOGICAL:: ANS
      !
      IF (PRESENT(LVAL)) THEN
                         ANS = LVAL == WANT
      ELSE
                         ANS = FALSE
      END IF
      !
    END FUNCTION
    !
    PURE FUNCTION IS_PRESENT_INT(IVAL, ICMP) RESULT(ANS)
      INTEGER, OPTIONAL, INTENT(IN):: IVAL, ICMP
      LOGICAL:: ANS
      !
      IF (PRESENT(IVAL)) THEN
                         IF (PRESENT(ICMP)) THEN
                                            ANS = IVAL == ICMP
                         ELSE
                                            ANS = TRUE
                         END IF
      ELSE
                         ANS = FALSE
      END IF
      !
    END FUNCTION
    !
END MODULE
!
!!
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
! MODULE LISTING:
!   UTIL_INTERFACE
!                           FUNCTIONS
!                                    RELAXER
!                                    TO_SNGL
!                                    STR_POS                      (STR, VEC)
!                                    INT_POS                      (IVAL,VEC)
!                                    SET_NAN
!                                    SET_ARRAY
!                                    IS_INTEGER
!                                    IS_NUMBER
!                                    IS_UNIQUE
!                                    IS_BLANK
!                                    IS_NAN_OR,  IS_NOT_NAN_OR    (VAR,[OP],[VAL])  
!                                    RELATIVE_CLOSE               (VAR1,VAR2,[RTOL])
!                                    IS_CLOSE                     (VAR1,VAR2,[RTOL],[ATOL])
!                                    ZERO_OR_GREATER, ZERO_OR_LESS
!                                    NEAR_ZERO, NOT_NEAR_ZERO, SET_NEAR_ZERO
!                                    JOIN_TXT
!                                    IS_IN_STR
!                                    COMMENT_INDEX 
!                                    MAX_LINE_LENGTH
!                                    DIM_OVERFLOW
!                                    DIM_MISMATCH
!                                    MAX_UNCOMMENTED_LINE_LEN
!                                    GO_UP
!                                    IS_ASCII                     (LN)
!                                    IS_ODD  or IS_EVEN           (NUM) - fast bitwise operation for odd/even check
!                           SUBROUTINES
!                                    READ_TO_DATA(LINE,INFILE,ERROR,OUTPUT,CNT,EOL,EOF,NOSHIFT,BACK_UP)
!                                    PARSE_WORD(LN,LOC,ISTART,ISTOP,COM_STOP,FIND_NEXT, OLD_LOC, EOL)
!                                    PARSE_WORD_UP(LN,LOC,ISTART,ISTOP,COM_STOP,FIND_NEXT, OLD_LOC, EOL) --MAKES WORD UPCASE
!                                    GET
!                                    GET_NUMBER
!                                    GET_INTEGER
!                                    GET_WORD
!                                    GET_DATE
!                                    GET_DOUBLE_DATE
!                                    GET_REAL_DATE
!                                    GET_FILE_NAME(IU,FNAME,[EXIST],[IOUT],[IN],[MSG],[HAS_ERROR]) 
!                                    FILENAME_TO_UNIT(FNAME,IU) 
!                                    FILENAME_TO_FULLNAME(FNAME,FULL,ISNEW) 
!                                    STOP_ERROR  (LINE,INFILE,OUTPUT,MSG)
!                                    FILE_IO_ERROR
!                                    WARNING_MESSAGE
!                                    MAKE_ZERO_IF_POS, MAKE_ZERO_IF_NEG
!                                    LRC_TO_CELLID(ID, LAY, ROW, COL, NLAY, NROW, NCOL)
!                                    CELLID_TO_LRC(ID, LAY, ROW, COL, NLAY, NROW, NCOL)
!                                    UPPER
!                                    VEC_ADJUST_MAXSUM
!                                    REDUCE_SUM_BY
!                                    ALLOC
!                                    COMMA_STRIP
!                                    TAB_STRIP
!                                    SPECIAL_BLANK_STRIP
!                                    NAME_LIST_DUBLICATE_CHECK
!                                    CHECK_FOR_POST_KEY 
!                                    ASCII_CHECK(LN, OUTPUT, [ERRMSG]) 
!
!    
!
!
MODULE UTIL_INTERFACE
! ROUTINES AVAILIBLE:
!
!  FILE_IO_ERROR(IOSTAT,UNIT,FNAME,LINE,INFILE,OUTPUT,MSG)
!  STOP_ERROR(LINE,INFILE,OUTPUT,MSG)
!  UPPER(LINE)
!  READ_TO_DATA(LINE,INFILE,ERROR,OUTPUT,CNT,EOL,EOF,NOSHIFT)
!
!  ZERO_OR_GREATER(VAL)   --RETURNS VAL IF > 0 OTHERWISE RETURNS 0
!  ZERO_OR_LESS(VAL)      --RETURNS VAL IF < 0 OTHERWISE RETURNS 0
!  NEAR_ZERO(VAL,[TOL])     -- RETURNS TRUE IF ABS(VAL)<1D-30 OR ABS(VAL)<TOL
!  NOT_NEAR_ZERO(VAL,[TOL]) -- RETURNS TRUE IF ABS(VAL)>1D-30 OR ABS(VAL)>TOL
!  COMMA_STRIP(LINE)
!  COMMENT_INDEX(LINE) RESULT(IDX)
!  MAX_LINE_LENGTH(UNIT)          or MAX_LINE_LENGTH(FILE)           --Function that returns the longest line in a file.
!  MAX_UNCOMMENTED_LINE_LEN(UNIT) or MAX_UNCOMMENTED_LINE_LEN(FILE)  --Function that returns the longest uncommented line in a file.
!  INTFMT(LINE)
!  NAME_LIST_DUBLICATE_CHECK(NAMES,OUTPUT)
!  CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,BUF,SPLIT)
!  
  USE CONSTANTS,                 ONLY: BLNK,NL,BLN,TAB,COM,Z,ONE,TWO,TEN,DZ,UNO,DOS,DNEG,DIEZ,TRUE,FALSE,ninf,inf,inf_I,inf_R,ninf_R,NEARZERO_29,NEARZERO_30,NEGNEARZERO_30,NEARZERO_5,HALF,TRES, QUIN, FOUR, SEV, EIGHT, HECTO, THOU, LF, CR, SNGL_inf, SNGL_ninf, SNGL_inf_R, SNGL_ninf_R, SNGL_inf_R, SNGL_ninf_R, SUB_ONE, NEAR_ONE, NEARZERO_6, NEARZERO_10, LOG_2, LOG_2_R
  USE DATE_OPERATOR_INSTRUCTION, ONLY: DATE_OPERATOR
  USE ARRAY_DATA_TYPES,          ONLY: CHARACTER_TYPE, INTEGER_VECTOR
  USE GENERIC_OPEN_INTERFACE,    ONLY: GENERIC_OPEN, FORCE_UNIT_CLOSE
  USE NUM2STR_INTERFACE,         ONLY: NUM2STR
  !
  USE, INTRINSIC:: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN, IEEE_IS_NAN
  USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: REAL32, REAL64, REAL128, INT8, INT16, INT32, INT64
  !
  IMPLICIT NONE
  !
  PRIVATE
  !
  PUBLIC:: STOP_ERROR, FILE_IO_ERROR, WARNING_MESSAGE, PAUSE, GAME_OVER, GET_WARN, CLOSE_WARNING_UNIT
  PUBLIC:: READ_TO_DATA, COMMENT_INDEX
  PUBLIC:: CHECK_FOR_POST_KEY
  PUBLIC:: GET, GET_WORD, GET_NUMBER, GET_INTEGER, GET_DATE, GET_DOUBLE_DATE, GET_FILE_NAME
  PUBLIC:: PARSE_WORD, PARSE_WORD_UP
  PUBLIC:: SET_ARRAY, SET_SEQUENCE, POSITION_SET_ARRAY
  PUBLIC:: FILENAME_TO_UNIT, FILENAME_TO_FULLNAME
  PUBLIC:: CELLID_TO_LRC, LRC_TO_CELLID
  PUBLIC:: RELAXER, RELAX_IT, DAMP_IT, TO_SNGL
  PUBLIC:: MAX_LINE_LENGTH, MAX_UNCOMMENTED_LINE_LEN, DIM_MISMATCH, DIM_OVERFLOW
  PUBLIC:: NAME_LIST_DUBLICATE_CHECK, STR_POS, INT_POS, IS_UNIQUE
  PUBLIC:: NEAR_ZERO, NOT_NEAR_ZERO, MAKE_ZERO_IF_POS, MAKE_ZERO_IF_NEG, ONLY_ZERO_TO_ONE_RANGE, SET_NEAR_ZERO
  PUBLIC:: ZERO_OR_GREATER, ZERO_OR_LESS
  PUBLIC:: RELATIVE_CLOSE, IS_CLOSE
  PUBLIC:: ASCII_CHECK, IS_ASCII
  PUBLIC:: IS_BLANK, IS_INTEGER, IS_NUMBER, IS_NAN_OR, IS_NOT_NAN_OR
  PUBLIC:: VEC_ADJUST_MAXSUM, REDUCE_SUM_BY
  PUBLIC:: SPECIAL_BLANK_STRIP, COMMA_STRIP, TAB_STRIP, IS_IN_STR, JOIN_TXT, UPPER, GO_UP
  PUBLIC:: LOG2
  !
  INTEGER, PRIVATE, SAVE:: WARN_IU = Z   !UNIT IS SET BY WARNING ROUTINE AND PROVIDES SEPARATE FILE FOR STOP, FILEIOU, AND WARN ROUTINES TO WRITE TOO
  !
  !---------------------------------------------------------------------------------------------------------------------
  !
  INTERFACE LOG2
    MODULE PROCEDURE LOG2_DBLE
    MODULE PROCEDURE LOG2_SNLG
    MODULE PROCEDURE LOG2_INT8
    MODULE PROCEDURE LOG2_INT16
    MODULE PROCEDURE LOG2_INT32
    MODULE PROCEDURE LOG2_INT64
  END INTERFACE
  !
  INTERFACE STR_POS
    MODULE PROCEDURE STR_POS_CHARACTER
    MODULE PROCEDURE STR_POS_CHARACTER_TYPE_CHAR
    MODULE PROCEDURE STR_POS_CHAR_CHARACTER_TYPE
    MODULE PROCEDURE STR_POS_CHARACTER_TYPE_CHARACTER_TYPE
  END INTERFACE
  !
  INTERFACE INT_POS
    MODULE PROCEDURE INT_POS_INTEGER
    MODULE PROCEDURE INT_POS_INTEGER_VECTOR
  END INTERFACE
  !
  INTERFACE IS_UNIQUE
    MODULE PROCEDURE STR_IS_UNIQUE      !(VAL, VEC, UPCASE)
    MODULE PROCEDURE STR_CASE_IS_UNIQUE !(VAL, VEC, [IQNORE])
    MODULE PROCEDURE INT_IS_UNIQUE      !(VAL, VEC)
    MODULE PROCEDURE REAL_IS_UNIQUE     !(VAL, VEC, [TOL])
    MODULE PROCEDURE DBLE_IS_UNIQUE     !(VAL, VEC, [TOL])
  END INTERFACE
  !
  INTERFACE GET_WORD
    MODULE PROCEDURE GET_WORD_ASSUM        !GET_WORD(WORD,LN,LOC,         [OLD_LOC],[COM_STOP],[NO_UPCASE])
    MODULE PROCEDURE GET_WORD_ALLOC        !GET_WORD(WORD,LN,LOC,IS_ALLOC,[OLD_LOC],[COM_STOP],[NO_UPCASE])
    MODULE PROCEDURE GET_WORD_ASSUM_ISTART !GET_WORD(LN,LOC,ISTART,ISTOP,WORD,         [OLD_LOC],[COM_STOP],[NO_UPCASE])
    MODULE PROCEDURE GET_WORD_ALLOC_ISTART !GET_WORD(LN,LOC,ISTART,ISTOP,WORD,IS_ALLOC,[OLD_LOC],[COM_STOP],[NO_UPCASE])
  END INTERFACE
  !
  INTERFACE GET_NUMBER
    MODULE PROCEDURE GET_DOUBLE_VEC        !GET_NUMBER(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,                [MSG],[ERROR_VAL],[HAS_ERROR], [IOSTAT])
    MODULE PROCEDURE GET_DOUBLE_VAL        !GET_NUMBER(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,[NO_PARSE_WORD],[MSG],[ERROR_VAL],[HAS_ERROR], [IOSTAT])
    MODULE PROCEDURE GET_REAL_VEC          !GET_NUMBER(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,[NO_PARSE_WORD],[MSG],[ERROR_VAL],[HAS_ERROR], [IOSTAT])
    MODULE PROCEDURE GET_REAL_VAL          !GET_NUMBER(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,[NO_PARSE_WORD],[MSG],[ERROR_VAL],[HAS_ERROR], [IOSTAT])
    MODULE PROCEDURE GET_QUAD_VEC          !GET_NUMBER(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,                [MSG],[ERROR_VAL],[HAS_ERROR], [IOSTAT])
    MODULE PROCEDURE GET_QUAD_VAL          !GET_NUMBER(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,[NO_PARSE_WORD],[MSG],[ERROR_VAL],[HAS_ERROR], [IOSTAT])
  END INTERFACE
  !
  !INTERFACE GET_DOUBLE
  !  MODULE PROCEDURE GET_DOUBLE_VEC        !(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,                [MSG],[ERROR_VAL],[HAS_ERROR])
  !  MODULE PROCEDURE GET_DOUBLE_VAL        !(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,[NO_PARSE_WORD],[MSG],[ERROR_VAL],[HAS_ERROR])
  !END INTERFACE
  !
  INTERFACE GET_INTEGER
    MODULE PROCEDURE GET_INTEGER_VEC       !GET_INTEGER(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,                [MSG],[ERROR_VAL],[HAS_ERROR])
    MODULE PROCEDURE GET_INTEGER_VAL       !GET_INTEGER(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,[NO_PARSE_WORD],[MSG],[ERROR_VAL],[HAS_ERROR])
  END INTERFACE
  !
  INTERFACE GET_DATE
    MODULE PROCEDURE GET_DATE_VAL          !(LN,LOC,ISTART,ISTOP,IOUT,IN,    DATE,[NO_PARSE_WORD],[MSG], [HAS_ERROR],[FOUND_DATE],[TIME_SPACE])
    MODULE PROCEDURE GET_DOUBLE_DATE       !(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,DATE,[NO_PARSE_WORD],[MSG], [HAS_ERROR],[FOUND_DATE],[TIME_SPACE])
    MODULE PROCEDURE GET_REAL_DATE         !(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,DATE,[NO_PARSE_WORD],[MSG], [HAS_ERROR],[FOUND_DATE],[TIME_SPACE])
  END INTERFACE
  !
  INTERFACE GET
    MODULE PROCEDURE PARSE_WORD            !(LN,LOC,ISTART,ISTOP,                 [COM_STOP], [FIND_NEXT], [OLD_LOC], [EOL])
    MODULE PROCEDURE GET_DATE_VAL          !(LN,LOC,ISTART,ISTOP,IOUT,IN,    DATE,[NO_PARSE_WORD],[MSG], [HAS_ERROR],[FOUND_DATE],[TIME_SPACE], [IOSTAT])
    MODULE PROCEDURE GET_DOUBLE_DATE       !(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,DATE,[NO_PARSE_WORD],[MSG], [HAS_ERROR],[FOUND_DATE],[TIME_SPACE], [IOSTAT])
    MODULE PROCEDURE GET_REAL_DATE         !(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,DATE,[NO_PARSE_WORD],[MSG], [HAS_ERROR],[FOUND_DATE],[TIME_SPACE], [IOSTAT])
    MODULE PROCEDURE GET_DOUBLE_VEC        !(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,                [MSG],[ERROR_VAL],[HAS_ERROR], [IOSTAT])
    MODULE PROCEDURE GET_DOUBLE_VAL        !(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,[NO_PARSE_WORD],[MSG],[ERROR_VAL],[HAS_ERROR], [IOSTAT])
    MODULE PROCEDURE GET_INTEGER_VEC       !(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,                [MSG],[ERROR_VAL],[HAS_ERROR], [IOSTAT])
    MODULE PROCEDURE GET_INTEGER_VAL       !(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,[NO_PARSE_WORD],[MSG],[ERROR_VAL],[HAS_ERROR], [IOSTAT])
    MODULE PROCEDURE GET_REAL_VEC          !(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,[NO_PARSE_WORD],[MSG],[ERROR_VAL],[HAS_ERROR], [IOSTAT])
    MODULE PROCEDURE GET_REAL_VAL          !(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,[NO_PARSE_WORD],[MSG],[ERROR_VAL],[HAS_ERROR], [IOSTAT])
    MODULE PROCEDURE GET_QUAD_VEC          !(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,                [MSG],[ERROR_VAL],[HAS_ERROR], [IOSTAT])
    MODULE PROCEDURE GET_QUAD_VAL          !(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,[NO_PARSE_WORD],[MSG],[ERROR_VAL],[HAS_ERROR], [IOSTAT])
    MODULE PROCEDURE GET_WORD_ASSUM_ISTART !(LN,LOC,ISTART,ISTOP,WORD,         [OLD_LOC],[COM_STOP],[NO_UPCASE])
    MODULE PROCEDURE GET_WORD_ALLOC_ISTART !(LN,LOC,ISTART,ISTOP,WORD,IS_ALLOC,[OLD_LOC],[COM_STOP],[NO_UPCASE])
    MODULE PROCEDURE GET_WORD_ASSUM        !(WORD,LN,LOC,         [OLD_LOC],[COM_STOP],[NO_UPCASE])
    MODULE PROCEDURE GET_WORD_ALLOC        !(WORD,LN,LOC,IS_ALLOC,[OLD_LOC],[COM_STOP],[NO_UPCASE])
    MODULE PROCEDURE GET_FILE_NAME         !(IU,FNAME,[EXIST],[IOUT],[IN],                   [MSG],[HAS_ERROR]) 
  END INTERFACE
  !
  INTERFACE MAX_LINE_LENGTH
    MODULE PROCEDURE MAX_LINE_LENGTH_FILE   !(FNAME, [INC]        ) RESULT(MXCOL)
    MODULE PROCEDURE MAX_LINE_LENGTH_UNIT   !(IU,    [INC], [LINE]) RESULT(MXCOL)
  END INTERFACE
  !
  !
  INTERFACE MAX_UNCOMMENTED_LINE_LEN
    MODULE PROCEDURE MAX_UNCOMMENTED_LINE_LEN_FILE   !(FNAME     ) RESULT(MXLEN)
    MODULE PROCEDURE MAX_UNCOMMENTED_LINE_LEN_UNIT   !(IU, [LINE]) RESULT(MXLEN)
  END INTERFACE
  !
  INTERFACE DIM_MISMATCH
    MODULE PROCEDURE DIM_MISMATCH_1D !(VEC,N)
    MODULE PROCEDURE DIM_MISMATCH_2D !(ARR,N,M)
  END INTERFACE
  !
  INTERFACE DIM_OVERFLOW
    MODULE PROCEDURE DIM_OVERFLOW_1D !(VEC,N)
    MODULE PROCEDURE DIM_OVERFLOW_2D !(ARR,N,M)
  END INTERFACE
  !
  INTERFACE SET_ARRAY
    MODULE PROCEDURE SET_ARRAY_3D3D_DBL !SET_ARRAY(DIM1, DIM2, DIM3, ARR1, ARR2)
    MODULE PROCEDURE SET_ARRAY_3D3D_INT !SET_ARRAY(DIM1, DIM2, DIM3, ARR1, ARR2)
    MODULE PROCEDURE SET_ARRAY_0D3D_DBL !SET_ARRAY(DIM1, DIM2, DIM3, VAL,  ARR2)
    MODULE PROCEDURE SET_ARRAY_0D3D_INT !SET_ARRAY(DIM1, DIM2, DIM3, VAL,  ARR2)
    MODULE PROCEDURE SET_ARRAY_2D2D_DBL !SET_ARRAY(DIM1, DIM2, ARR1, ARR2) 
    MODULE PROCEDURE SET_ARRAY_2D2D_INT !SET_ARRAY(DIM1, DIM2, ARR1, ARR2)
    MODULE PROCEDURE SET_ARRAY_0D2D_DBL !SET_ARRAY(DIM1, DIM2,  VAL, ARR2)
    MODULE PROCEDURE SET_ARRAY_0D2D_INT !SET_ARRAY(DIM1, DIM2,  VAL, ARR2)
    MODULE PROCEDURE SET_ARRAY_1D1D_DBL !SET_ARRAY(DIM1, ARR1, ARR2) 
    MODULE PROCEDURE SET_ARRAY_1D1D_INT !SET_ARRAY(DIM1, ARR1, ARR2) 
    MODULE PROCEDURE SET_ARRAY_0D1D_DBL !SET_ARRAY(DIM1,  VAL, ARR2)
    MODULE PROCEDURE SET_ARRAY_0D1D_INT !SET_ARRAY(DIM1,  VAL, ARR2)
    !
    MODULE PROCEDURE SET_ARRAY_SEQUENTIAL_1D_INT      !(DIM1, ARR2)
    MODULE PROCEDURE SET_ARRAY_SEQUENTIAL_1D_INT_START!(DIM1, ARR2, START)
    MODULE PROCEDURE SET_ARRAY_SEQUENTIAL_1D_INT_INC  !(DIM1, ARR2, START, INC)
  END INTERFACE
  !
  INTERFACE SET_SEQUENCE
    MODULE PROCEDURE SET_ARRAY_SEQUENTIAL_1D_INT      !(DIM1, ARR2)
    MODULE PROCEDURE SET_ARRAY_SEQUENTIAL_1D_INT_START!(DIM1, ARR2, START)
    MODULE PROCEDURE SET_ARRAY_SEQUENTIAL_1D_INT_INC  !(DIM1, ARR2, START, INC)
  END INTERFACE
  !
  INTERFACE POSITION_SET_ARRAY
    MODULE PROCEDURE POSITION_SET_ARRAY_2D_DBL!(DIM1, DIM2, SRCH, ARR1, SET, ARR2)
  END INTERFACE
  !
  INTERFACE RELAXER
    MODULE PROCEDURE RELAXER_DBLE!(NEW, OLD, RELAX) RESULT(REL)
    MODULE PROCEDURE RELAXER_SNGL!(NEW, OLD, RELAX) RESULT(REL)
  END INTERFACE
  !
  INTERFACE RELAX_IT
    MODULE PROCEDURE RELAX_IT_DBLE !(NEW, OLD, RELAX)        --NEW UPDATED WITH RELAXED VALUE
    MODULE PROCEDURE RELAX_IT_SNGL !(NEW, OLD, RELAX)
    MODULE PROCEDURE RELAX_IT2_DBLE!(NEW2, NEW, OLD, RELAX)  --NEW2 HOLDS RELAXED VALUE
    MODULE PROCEDURE RELAX_IT2_SNGL!(NEW2, NEW, OLD, RELAX)
  END INTERFACE
  !
  INTERFACE DAMP_IT
    MODULE PROCEDURE DAMP_IT_DBLE!(NEW, OLD, OLD2, DAMP, RELAX)
    MODULE PROCEDURE DAMP_IT_SNGL!(NEW, OLD, OLD2, DAMP, RELAX)
  END INTERFACE
  !
  INTERFACE TO_SNGL
    MODULE PROCEDURE SNGL_TO_SNGL!(X)
    MODULE PROCEDURE DBLE_TO_SNGL!(X)
    MODULE PROCEDURE QUAD_TO_SNGL!(X)
  END INTERFACE
  !
  INTERFACE  ASCII_CHECK
    MODULE PROCEDURE ASCII_CHECK_LOGICAL!(LN, IS_ASCII) 
    MODULE PROCEDURE ASCII_CHECK_STOP   !(LN, IOUT    ) 
    MODULE PROCEDURE ASCII_CHECK_CHAR   !(LN, NON_ASCII)
  END INTERFACE
  !
  CONTAINS
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  Error and Warning routines
  !
  SUBROUTINE WARNING_MESSAGE(LINE,INFILE,OUTPUT,MSG, INLINE, CMD_PRINT, SET_UNIT, KPER)
    INTEGER,      INTENT(IN), OPTIONAL:: INFILE
    CHARACTER(*), INTENT(IN), OPTIONAL:: LINE
    CHARACTER(*), INTENT(IN), OPTIONAL:: MSG
    INTEGER,      INTENT(IN), OPTIONAL:: OUTPUT       !UNIT TO WRITE WARNING TOO, MAY ALSO SET WARN_IU
    LOGICAL,      INTENT(IN), OPTIONAL:: INLINE       !IF TRUE, WARNING IS  WRITTEN TO ONE LINE
    LOGICAL,      INTENT(IN), OPTIONAL:: CMD_PRINT    !IF TRUE, WARNING IS  WRITTEN TO CMD PROMPT
    LOGICAL,      INTENT(IN), OPTIONAL:: SET_UNIT     !IF TRUE, THEN ONLY SETS OUTPUT TO WARN_IU AND RETURNS
    INTEGER,      INTENT(IN), OPTIONAL:: KPER         !RESETS WARNING HEADER TO NEW STRESS PERIOD, NEXT CALLED WARNING WILL WRITE HEADER
    !
    INTEGER, SAVE:: SP_NUM = Z
    LOGICAL, SAVE:: WRITE_HEADER = FALSE
    !
    CHARACTER(:),ALLOCATABLE :: WARN, FNAME
    INTEGER:: IOUT
    LOGICAL:: CMD_PRN, ONE_LINE, CHECK
    !
    IOUT = Z
    IF(PRESENT(OUTPUT)) IOUT = OUTPUT
    !
    IF(PRESENT(SET_UNIT)) THEN
          IF(SET_UNIT) THEN
                           WARN_IU = IOUT
                           IF(WARN_IU.NE.Z) WRITE(WARN_IU,'(A)') BLN//'                           ONE-WATER WARNING FILE'//BLN//'         THE FOLLOWING COMMENTS WERE PASSED TO THE WARNING ROUTINE'//BLN//REPEAT('#',80)//BLN
                           RETURN
          END IF
    END IF
    !
    IF(PRESENT(KPER)) THEN
         IF(WARN_IU.NE.Z .AND. WARN_IU.NE.IOUT) THEN
             SP_NUM = KPER
             WRITE_HEADER = TRUE
         END IF
         RETURN
    END IF
    !
    IF(WRITE_HEADER) THEN
       WRITE_HEADER = FALSE
       WRITE(WARN_IU,'(A)') BLN//REPEAT('>',104)//NL//REPEAT('<',104)//BLN//REPEAT(BLNK,33)//'WARNINGS FOR STRESS PERIOD '//NUM2STR(SP_NUM)//BLN//REPEAT('<',104)//NL//REPEAT('>',104)//BLN//BLN//REPEAT('#',104)//NL
    END IF
    !
    CMD_PRN = FALSE
    IF(PRESENT(CMD_PRINT)) CMD_PRN = CMD_PRINT
    !
    ONE_LINE = FALSE
    IF(PRESENT(INLINE)) ONE_LINE = INLINE
    !
    IF(ONE_LINE) THEN
        WARN=NL//'WARNING: '
        IF(PRESENT(MSG )) THEN; IF(MSG .NE.BLNK) WARN = WARN//TRIM(MSG)//BLNK
        END IF
        IF(PRESENT(LINE)) THEN; IF(LINE.NE.BLNK) WARN = WARN//'FROM PROCESSING LINE "'//TRIM(ADJUSTL(LINE))//'" '
        END IF
        IF(PRESENT(INFILE)) THEN
           IF(INFILE.NE.Z) THEN 
              CALL GET_FILE_NAME(INFILE,FNAME,HAS_ERROR=CHECK) 
              IF(.NOT. CHECK) WARN = WARN//'FROM FILE "'//TRIM(FNAME)//'" '
              DEALLOCATE(FNAME)
           END IF
        END IF
    ELSE
        WARN=BLN//'                           ONE-WATER WARNING'//BLN//'         THE FOLLOWING COMMENTS WERE PASSED TO THE WARNING ROUTINE'//NL
        !
        IF(PRESENT(INFILE)) THEN
           IF(INFILE.NE.Z) THEN
              CALL GET_FILE_NAME(INFILE,FNAME,HAS_ERROR=CHECK) 
              IF(.NOT. CHECK) WARN = WARN//NL//'THE WARNING IS BELIEVED TO HAVE ORIGINATED FROM THE FOLLOWING FILE:'//NL//'"'//TRIM(FNAME)//'"'//NL
              DEALLOCATE(FNAME)
           END IF
        END IF
        IF(PRESENT(LINE)) THEN; IF(LINE.NE.BLNK) WARN = WARN//NL//'THE GUESSED LINE THAT THE WARNING OCCURED ON IS:'//NL//'"'//TRIM(LINE)//'"'//NL
        END IF
        IF(PRESENT(MSG )) THEN; IF(MSG .NE.BLNK) WARN = WARN//NL//'THE DESRIPTION OF THE WARNING IS:'//BLN//TRIM(MSG)//NL
        END IF
        !
        WARN = BLN//REPEAT('#',104)//WARN//NL//REPEAT('#',104)//BLN
    END IF
    !
    IF(WARN_IU.NE.Z .AND. WARN_IU.NE.IOUT) THEN
        IF(ONE_LINE) THEN
            WRITE(WARN_IU,'(A///,A//)') WARN,REPEAT('#',104)
        ELSE
            WRITE(WARN_IU,'(A)') WARN(223:LEN(WARN)-1)
        END IF
    END IF
    !
    IF(IOUT.NE.Z) WRITE(IOUT,'(A/)') WARN
    IF(CMD_PRN  ) WRITE(*,   '(A/)') WARN
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  SUBROUTINE STOP_ERROR(LINE, INFILE, OUTPUT, MSG, MSG2, STAT, GUESS)
    CHARACTER(*), INTENT(IN), OPTIONAL:: LINE       ! Line that error occured on
    INTEGER,      INTENT(IN), OPTIONAL:: INFILE     ! File Unit that error originated from
    INTEGER,      INTENT(IN), OPTIONAL:: OUTPUT     ! File unit to write error too
    CHARACTER(*), INTENT(IN), OPTIONAL:: MSG, MSG2  ! Supplemental messages to write in error
    INTEGER,      INTENT(IN), OPTIONAL:: STAT       ! IOSTAT or STAT number associated with error (STAT=0 disables ERROR STOP)
    LOGICAL,      INTENT(IN), OPTIONAL:: GUESS      ! If set to TRUE, then the line is guessed as being the previous line in INFILE
    !
    CHARACTER(:), ALLOCATABLE:: FNAME
    CHARACTER(:), ALLOCATABLE:: ERR
    !
    LOGICAL:: HAS_LINE, HAS_INFILE, HAS_OUTPUT, GET_LINE, HAS_MSG, HAS_MSG2
    !
    INTEGER:: IOUT, IE
    !
    ! ----------------------------------------------------------------------------------------------------------------------------------------------
    !
    IF(PRESENT(STAT)) THEN; IF(STAT == Z) RETURN
    END IF
    !
    ! ----------------------------------------------------------------------------------------------------------------------------------------------
    !
    HAS_LINE = PRESENT(LINE)
    !
    IF(HAS_LINE) THEN; IF(LINE == BLNK) HAS_LINE = FALSE
    END IF
    !
    HAS_INFILE = PRESENT(INFILE)
    !
    IF(HAS_INFILE) THEN; IF(INFILE == Z) HAS_INFILE = FALSE
    END IF
    !
    HAS_OUTPUT = PRESENT(OUTPUT)
    !
    IF(HAS_OUTPUT) THEN; IF(OUTPUT == Z) HAS_OUTPUT = FALSE
    END IF
    !
    GET_LINE = FALSE
    IF( PRESENT(GUESS) )  GET_LINE = GUESS .AND. HAS_INFILE
    !
    HAS_MSG = FALSE
    IF( PRESENT(MSG) )  HAS_MSG = MSG .NE.BLNK
    !
    HAS_MSG2 = FALSE
    IF( PRESENT(MSG2) )  HAS_MSG2 = MSG2 .NE.BLNK
    !
    IF(HAS_INFILE .OR. GET_LINE) ALLOCATE(CHARACTER(700):: FNAME)
    !
    ! ----------------------------------------------------------------------------------------------------------------------------------------------
    !
    ERR=NL//NL//'                           ONE-WATER ERROR'//BLN//'         THE FOLLOWING COMMENTS WERE PASSED TO THE ERROR ROUTINE'//NL
    !
    IF(HAS_INFILE) THEN
        INQUIRE(INFILE,NAME=FNAME)
        ERR = ERR//NL//'THIS ERROR IS BELIEVED TO HAVE ORIGINATED FROM THE FOLLOWING FILE:'//NL//'"'//TRIM(FNAME)//'"'//NL
    END IF
    !
    IF(HAS_LINE) ERR = ERR//NL//'THE GUESSED LINE THAT THE ERROR OCCURED ON IS:'//BLN//'"'//TRIM(LINE)//'"'//NL
    !
    IF(GET_LINE) THEN
                 FNAME(:) = BLNK
                 BACKSPACE(INFILE, IOSTAT=IE)
                 IF(IE.NE.Z) READ(INFILE, "(A)", IOSTAT=IE) FNAME
                 !
                 IF(IE.NE.Z .AND. FNAME.NE.BLNK) ERR = ERR//NL//"THE GUESSED PREVIOUS INPUT FILE'S LINE THAT WAS READ AND MAY CONTAIN THE ERROR IS:"//BLN//'"'//TRIM(FNAME)//'"'//NL 
    END IF
    !
    IF(PRESENT(STAT)) THEN
                      ERR = ERR//NL//'THE FORTRAN ERROR STATUS CODE IS '//NUM2STR(STAT)//NL
                      !
                      IF(STAT<Z) ERR = ERR//NL//'    **NOTE THAT A STATUS CODE <0 INDICATES THAT THE END OF FILE WAS REACHED'//NL//        &
                                                '      OR A END OF RECORD CONDITION OCCURED'//NL//                                         &
                                                '      OR YOU DID NOT HAVE ENOUGH INPUT VALUES SPECIFIED ON LINE.'//NL//                   &
                                                '      NOTE THAT IF YOU HAVE THE CORRECT NUMBER OF VALUES ON THE LINE'//NL//               &
                                                '        AND USED THE KEWYORD INTERNAL TO LOAD THEM,'//NL//                                &
                                                '        TRY MOVING INPUT TO SEPARATE FILE AND USE OPEN/CLOSE TO LOAD DATA.'//NL//         &
                                                '        THE BUFFER FOR AN INTERNAL LOAD MAY NOT BE SUFFICIENT TO LOAD THE ENTIRE LINE.'//NL
    END IF
    !
    IF(    HAS_MSG .AND. HAS_MSG2 )THEN
                                          ERR = ERR//NL//'THE DESRIPTION OF THE ERROR IS:'//BLN// TRIM(MSG)//BLN//  TRIM(MSG2)//NL
    ELSEIF(HAS_MSG                )THEN
                                          ERR = ERR//NL//'THE DESRIPTION OF THE ERROR IS:'//BLN//TRIM(MSG )//NL
    ELSEIF(HAS_MSG2               )THEN
                                          ERR = ERR//NL//'THE DESRIPTION OF THE ERROR IS:'//BLN//TRIM(MSG2)//NL
    END IF
    !
    IF( .NOT. (HAS_LINE .OR. HAS_INFILE .OR. GET_LINE .OR. HAS_MSG .OR. HAS_MSG2) ) ERR = ERR//BLN//' --- SORRY UNKNOWN ERROR ---'//NL//NL
    !
    ! ----------------------------------------------------------------------------------------------------------------------------------------------
    !
    WRITE(*,   '(A/)') ERR  !WRITE TO CMD PROMPT FIRST
    !
    IOUT = Z
    IF(PRESENT(OUTPUT)) IOUT = OUTPUT
    !    
    IF(WARN_IU.NE.Z .AND. WARN_IU.NE.IOUT) THEN
                                           WRITE(WARN_IU,'(/A/)') ERR
                                           CALL EPIC_FAIL(IOUT)
    END IF
    !
    IF(IOUT.NE.Z) WRITE(IOUT,'(A/)') ERR
               !
    IF(IOUT.NE.Z) CALL GAME_OVER(IOUT)
    !
    ! ----------------------------------------------------------------------------------------------------------------------------------------------
    !
    ERROR STOP ! :(
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  SUBROUTINE FILE_IO_ERROR(IOSTAT,UNIT,FNAME,LINE,INFILE,OUTPUT,MSG,MSG2)
    ! IOSTAT  IS THE ASSOCIATED IOSTAT ERROR
    ! UNIT   IS THE FILE THAT IS BEING OPENED, READ FROM, OR WRITTEN TOO
    ! LINE   IS THE LINE THAT IS BEING PROCESSED EITHER FOR PARSING THE INPUT FILE, READING DATA, OR WRITING DATA
    ! INFILE IS THE FILE FROM WHICH LINE ORIGINATED FROM. IT CAN BE THE SAME FILE AS FNAME
    ! MSG    IS AN ADDITIONAL ERROR MESSAGE THAT IS APPEND TO THE END OF THE ERROR REPORT
    ! MSG2   IS AN ADDITIONAL ERROR MESSAGE THAT IS APPEND TO THE END OF MSG. USED IN CASE OF SUBROUTINE THAT CALLS FILE_IO_ERROR HAS ARGUMENT THAT IS MSG
    !
    INTEGER,     OPTIONAL:: IOSTAT, UNIT,INFILE,OUTPUT
    CHARACTER(*),OPTIONAL:: FNAME,LINE,MSG,MSG2  !MSG2 allows for 
    !
    INTEGER:: IU,IFILE,IOUT
    CHARACTER(QUIN):: LN
    CHARACTER(:),ALLOCATABLE:: ERRMSG,FN,ERRLINE,INLINE,MSGLINE, ERR_CODE
    LOGICAL::ISOPEN
    !
    IOUT=Z
    IF(PRESENT(OUTPUT)) IOUT=OUTPUT
    !
    IFILE=Z
    INLINE='UNKOWN FILE???'
    IF(PRESENT(INFILE)) THEN
        IF (INFILE.NE.Z) THEN
           IFILE=INFILE
           INQUIRE(INFILE,NAME=LN)
           INLINE=TRIM(ADJUSTL(LN))
        END IF
    END IF
    !
    IF(PRESENT(LINE))THEN
        IF(LINE.NE.BLNK) THEN
            ERRLINE=TRIM(ADJUSTL(LINE))
        ELSE
            ERRLINE='*** EMPTY/BLANK LINE LOADED ***'
        END IF
    ELSE
        ERRLINE='UNKOWN LINE???'
    END IF
    !
    IF(          PRESENT(FNAME).AND. .NOT. PRESENT(UNIT)) THEN
        FN=TRIM(ADJUSTL(FNAME))
        INQUIRE(FILE=FN,NUMBER=IU,OPENED=ISOPEN)
        IF(IU.EQ.-1) IU=Z
    ELSEIF(.NOT. PRESENT(FNAME).AND.       PRESENT(UNIT))THEN
        IU=UNIT
        INQUIRE(IU,NAME=LN,OPENED=ISOPEN)
        FN=TRIM(ADJUSTL(LN))
    ELSEIF(.NOT. PRESENT(FNAME).AND. .NOT. PRESENT(UNIT))THEN
        IU=Z
        FN=BLNK!' '
        ISOPEN=FALSE
    ELSE
        IU=UNIT
        FN=TRIM(ADJUSTL(FNAME))
        INQUIRE(IU, OPENED=ISOPEN)
        IF(.NOT. ISOPEN) INQUIRE(FILE=FN,OPENED=ISOPEN)
    END IF
    !
    IF(    PRESENT(MSG) .AND. PRESENT(MSG2) )THEN
                                             MSGLINE=TRIM(ADJUSTL(MSG)) //BLN// TRIM(ADJUSTL(MSG2))
    ELSEIF(PRESENT(MSG))THEN
                                             MSGLINE=TRIM(ADJUSTL(MSG))
    ELSEIF(PRESENT(MSG2))THEN
                                             MSGLINE=TRIM(ADJUSTL(MSG2))
    ELSE
        MSGLINE=BLNK
    END IF
    !
    IF(PRESENT(IOSTAT)) THEN
        IF(IOSTAT .NE. Z) THEN
            ERR_CODE='AND HAS THE FOLLOWING IOSTAT ERROR CODE: '//NUM2STR(IOSTAT)
            IF(ISOPEN) THEN
              IF(IOSTAT<Z) THEN
                  ERR_CODE=ERR_CODE//BLN//'    ERROR<0 INDICATES THAT THE END OF FILE WAS REACHED'//NL//'    OR A END OF RECORD CONDITION OCCURED'//NL//'    OR YOU DID NOT HAVE ENOUGH INPUT VALUES SPECIFIED ON LINE.'//NL//'    NOTE THAT IF YOU HAVE THE CORRECT NUMBER OF VALUES ON THE LINE'//NL//'      AND USED THE KEWYORD INTERNAL TO LOAD THEM,'//NL//'      TRY MOVING INPUT TO SEPARATE FILE AND USE OPEN/CLOSE TO LOAD DATA.'//NL//'      THE BUFFER FOR AN INTERNAL LOAD MAY NOT BE SUFFICIENT TO LOAD THE ENTIRE LINE.'
                      
              ELSE
                  ERR_CODE=ERR_CODE//BLN//'    ERROR>0 INDICATES THAT YOU HAVE TO LOOK UP THE SPECIFIC ERROR CONDITION SPECIFIED BY THE COMPILER.' 
              END IF
            END IF
            !
        ELSE
            ERR_CODE=BLNK
        END IF
    ELSE
            ERR_CODE=BLNK
    END IF
    !
    IF(IFILE.EQ.Z) THEN
       !
       !
       IF(ISOPEN) THEN
           ERRMSG=NL//'FILE I/O ERROR:'                                         //BLN//       &
           'FOR FILE UNIT '//NUM2STR(IU)                                         //BLN//       &
           'WHICH IS ASSOCIATED WITH FILE: '//FN                                 //BLN//       &
           'WHILE READING OR WRITING LINE '//NL//'"'//ERRLINE//'"'               //BLN//       &
            ERR_CODE
       ELSEIF( .NOT. ISOPEN .AND. (IU.NE.Z .OR. FN.NE.BLNK) )THEN
           IF(IU.EQ.Z) THEN
         ERRMSG=NL//'FILE I/O ERROR:'                                               //BLN//  &
                    'FOR AN UNKNOWN FILE UNIT [POSSIBLE FAILURE TO OPEN/FIND FILE]'  //BLN//  &
                    'FOR THE REQUESTED FILE NAME: '//FN                              //BLN//  &
                    ERR_CODE
           ELSE
         ERRMSG=NL//'FILE I/O ERROR:'                                                     //BLN//   &
                    'FOR FILE UNIT '//NUM2STR(IU)//' [POSSIBLE FAILURE TO OPEN/FIND FILE]' //BLN//   &
                    'WITH UNKNOWN FILE NAME'                                               //BLN//   &
                    ERR_CODE
           END IF          
       ELSE
         ERRMSG=NL//'FILE I/O ERROR:'                                                        //BLN//  &
                    'FOR AN UNKNOWN FILE UNIT AND FILE [POSSIBLE FAILURE TO OPEN/FIND FILE]'  //BLN//  &
                     ERR_CODE          //NL//  &
                    'FOR THE FOLLOWING LINE '//NL//'"'//ERRLINE//'"'
       END IF
       !
       !
    ELSE
       !
       !
       IF(ISOPEN) THEN
           ERRMSG=NL//'FILE I/O ERROR:'                                                      //BLN//        &
                      'FOR FILE UNIT '//NUM2STR(IU)                                          //BLN//        &
                      'WHICH IS ASSOCIATED WITH FILE: '//NL//FN                              //BLN//        &
                      'WHILE UTILIZING THE FOLLOWING LINE: '//NL//'"'//ERRLINE//'"'          //BLN//       &
                      'THAT IS ASSOCIATED WITH INPUT FILE: '//NL//'"'//INLINE//'"'           //BLN//       &
                      ERR_CODE                                                                
       ELSEIF( .NOT. ISOPEN .AND. (IU.NE.Z .OR. FN.NE.BLNK) )THEN
           IF(IU.EQ.Z) THEN
         ERRMSG=NL//'FILE I/O ERROR:'                                                //BLN//  &
                    'FOR AN UNKNOWN FILE UNIT [POSSIBLE FAILURE TO OPEN/FIND FILE]'  //BLN//  &
                    'FOR THE REQUESTED FILE NAME: '//NL//FN                          //BLN//  &
                    ERR_CODE                                                         //BLN//  &
                    'WHILE UTILIZING THE FOLLOWING LINE: '//NL//'"'//ERRLINE//'"'    //BLN//  &
                    'THAT IS ASSOCIATED WITH INPUT FILE: '//NL//'"'//INLINE//'"'
           ELSE
         ERRMSG=NL//'FILE I/O ERROR:'                                                      //BLN//  &
                    'FOR FILE UNIT '//NUM2STR(IU)//' [POSSIBLE FAILURE TO OPEN/FIND FILE]' //BLN//  &
                    'WITH UNKNOWN FILE NAME'                                               //BLN//  &
                    ERR_CODE                                                               //BLN//  &
                    'WHILE UTILIZING THE FOLLOWING LINE: '//NL//'"'//ERRLINE//'"'          //BLN// &
                    'THAT IS ASSOCIATED WITH INPUT FILE: '//NL//'"'//INLINE//'"'
           END IF          
       ELSE
         ERRMSG=NL//'FILE I/O ERROR:'                                                       //BLN//  &
                    'FOR AN UNKNOWN FILE UNIT AND FILE [POSSIBLE FAILURE TO OPEN/FIND FILE]' //BLN//  &
                    ERR_CODE                                                                 //BLN//  &
                    'WHILE UTILIZING THE FOLLOWING LINE: '//NL//'"'//ERRLINE//'"'            //BLN// &
                    'THAT IS ASSOCIATED WITH INPUT FILE: '//NL//'"'//INLINE//'"'
       END IF
       !
       !
    END IF
    !
    IF(MSGLINE.NE.BLNK) ERRMSG=ERRMSG//BLN//'THE FOLLOWING IS AN ADDITIONAL COMMENT INCLUDED WITH ERROR:'//BLN//MSGLINE
    !
    IF(WARN_IU.NE.Z .AND. WARN_IU.NE.IOUT) THEN
                                           WRITE(WARN_IU,'(/A/)') ERRMSG
                                           CALL EPIC_FAIL(WARN_IU)
    END IF
    !
    IF(IOUT.NE.Z) WRITE(IOUT,'(A)') ERRMSG
                  WRITE(*,   '(A)') ERRMSG
    !
    IF(IOUT.NE.Z) CALL GAME_OVER(IOUT)
    !
    ! ----------------------------------------------------------------------------------------------------------------------------------------------
    !
    ERROR STOP ! ;(
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  SUBROUTINE PAUSE(LINE)
    USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: STDIN=>INPUT_UNIT, STDOUT=>OUTPUT_UNIT
    CHARACTER(*), INTENT(IN), OPTIONAL:: LINE
    !
    IF(PRESENT(LINE)) THEN
        WRITE(STDOUT,'(/A/)') LINE
    ELSE
        WRITE(STDOUT,'(//A//)') 'PAUSED - Press Enter to Continue'
    END IF
    !
    READ(STDIN,*) 
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  SUBROUTINE CLOSE_WARNING_UNIT()
    INTEGER:: I
    IF(WARN_IU.NE.Z) CLOSE(WARN_IU, IOSTAT=I)
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE FUNCTION GET_WARN() RESULT(IU)
    INTEGER:: IU
    IU = WARN_IU
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  Parsing routines
  !
  PURE SUBROUTINE PARSE_WORD_UP(LN, LOC, ISTART, ISTOP, COM_STOP, FIND_NEXT, OLD_LOC, EOL)
    ! ASSUMES COMPILER CAN HANDEL LN(I:I-1) AND SETS IT TO BLANK STRING
    CHARACTER(*),      INTENT(INOUT):: LN
    INTEGER,           INTENT(INOUT):: LOC,ISTART,ISTOP
    LOGICAL, OPTIONAL, INTENT(IN   ):: COM_STOP, FIND_NEXT
    INTEGER, OPTIONAL, INTENT(INOUT):: OLD_LOC           !RETURN ORIGINAL LOC LOCATION
    LOGICAL, OPTIONAL, INTENT(  OUT):: EOL
    !
    CALL PARSE_WORD(LN, LOC, ISTART, ISTOP, COM_STOP, FIND_NEXT, OLD_LOC, EOL)
    !
    IF(ISTART.LE.ISTOP) CALL UPPER(LN(ISTART:ISTOP))
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE SUBROUTINE PARSE_WORD(LN, LOC, ISTART, ISTOP, COM_STOP, FIND_NEXT, OLD_LOC, EOL)!SIMPLE_WORD_PARSE
    ! ASSUMES COMPILER CAN HANDEL LN(I:I-1) AND SETS IT TO BLANK STRING
    CHARACTER(*),      INTENT(IN   ):: LN
    INTEGER,           INTENT(INOUT):: LOC,ISTART,ISTOP
    LOGICAL, OPTIONAL, INTENT(IN   ):: COM_STOP, FIND_NEXT
    INTEGER, OPTIONAL, INTENT(INOUT):: OLD_LOC           !RETURN ORIGINAL LOC LOCATION
    LOGICAL, OPTIONAL, INTENT(  OUT):: EOL
    INTEGER:: LINE_LEN, LINE_TRIM, LOC0
    !
    LOC0 = LEN_TRIM(LN)        !Temp use in case of COM_STOP
    !
    LINE_TRIM= LOC0 + ONE
    !
    IF(PRESENT(COM_STOP)) THEN
            IF(COM_STOP .AND. LOC0 > Z) THEN
                     !
                     LINE_LEN=INDEX(LN(:LOC0),'#')     !TMP VAR TO HOLD # POSITION
                  IF(LINE_LEN > Z) LINE_TRIM=LINE_LEN  !FOUND  # UPDATE LINE_TRIM TO BE ITS LENGTH
            END IF
    END IF
    !
    LOC0 = LOC  !Make backup of Loc
    !
    DO WHILE( LOC < LINE_TRIM ) 
                              IF(LN(LOC:LOC).NE.TAB .AND. LN(LOC:LOC).NE.BLNK .AND. LN(LOC:LOC).NE.',') EXIT
                              LOC = LOC+1
    END DO
    !
    IF( LOC >= LINE_TRIM ) THEN
               LINE_LEN = LEN(LN)
        LOC   =LINE_LEN+1
        ISTART=LINE_LEN
        ISTOP =LINE_LEN-1
        IF(PRESENT(EOL)) EOL = TRUE
    ELSE
        IF(LN(LOC:LOC)=='"') THEN
                                LOC = LOC+1
                                ISTART = LOC
                                DO WHILE( LOC < LINE_TRIM )
                                    IF( LN(LOC:LOC) == '"' ) EXIT
                                    LOC = LOC+1
                                END DO
                                ISTOP = LOC-1
                                LOC = LOC+1
        ELSEIF(LN(LOC:LOC)=="'") THEN
                                LOC = LOC+1
                                ISTART = LOC
                                DO WHILE( LOC < LINE_TRIM )
                                    IF( LN(LOC:LOC) == "'" ) EXIT
                                    LOC = LOC+1
                                END DO
                                ISTOP = LOC-1
                                LOC = LOC+1
            
        ELSE
                                ISTART = LOC
                                LOC = LOC+1
                                DO WHILE( LOC < LINE_TRIM )
                                    IF( LN(LOC:LOC)==TAB .OR. LN(LOC:LOC)==BLNK .OR. LN(LOC:LOC)==',') EXIT
                                    LOC = LOC+1
                                END DO
                                ISTOP = LOC-1
                                IF(ISTOP<ISTART) ISTOP=ISTART
        END IF
        !
        IF(PRESENT(FIND_NEXT)) THEN  !LOC MOVE TO NEXT WORD
        IF        (FIND_NEXT)  THEN
                                   DO WHILE( LOC < LINE_TRIM ) 
                                                             IF(LN(LOC:LOC).NE.TAB .AND. LN(LOC:LOC).NE.BLNK .AND. LN(LOC:LOC).NE.',') EXIT
                                                             LOC = LOC+1
                                   END DO
        END IF
        END IF
        !
        IF(PRESENT(EOL)) EOL = FALSE
    END IF
    !
    IF(PRESENT(OLD_LOC)) OLD_LOC = LOC0
    !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  Read Line routines
  !
  SUBROUTINE READ_TO_DATA(LINE,INFILE,ERROR,OUTPUT,CNT,EOL,EOF,NOSHIFT,BACK_UP)
    CHARACTER(*),    INTENT(INOUT):: LINE    !LINE TO LOAD DATA TOO
    INTEGER,         INTENT(IN   ):: INFILE  !UNIT OF FILE TO LOAD LINE FROM
    INTEGER,OPTIONAL,INTENT(IN   ):: ERROR   !UNIT TO WRITE ERROR MESSAGE TOO
    INTEGER,OPTIONAL,INTENT(IN   ):: OUTPUT  !UNIT TO WRITE TRANSCRIPT OF WHAT IS LOADED TOO
    INTEGER,OPTIONAL,INTENT(OUT  ):: CNT     !RETURNS A COUNT OF HOW MANY LINES WERE LOADED
    INTEGER,OPTIONAL,INTENT(OUT  ):: EOL     !LOCATIONS OF WHERE THE END OF LINE IS OR ONE SPACE BEFORE #
    LOGICAL,OPTIONAL,INTENT(OUT  ):: EOF     !SET TO TRUE IF END OF FILE IS REACHED
    LOGICAL,OPTIONAL,INTENT(IN   ):: NOSHIFT !SET TO TRUE TO NOT TO USE ADJUSTL
    LOGICAL,OPTIONAL,INTENT(IN   ):: BACK_UP !SET TO TRUE TO BACKSPACE 1 LINE AFTER READING LINK
    !
    !CHARACTER:: COM, BLNK
    INTEGER:: C, ERR, N,IOUT,IERR !,Z
    LOGICAL:: FIRST, TRANSCRIBE, SHIFT
    !
    !COM='#'
    !BLNK=' '
    !Z=0
    SHIFT = TRUE
    FIRST = TRUE
    !
    IF(PRESENT(ERROR))THEN
        IERR=ERROR
    ELSE
        IERR=Z
    END IF
    !
    IF(PRESENT(OUTPUT))THEN
        IOUT=OUTPUT
    ELSE
        IOUT=Z
    END IF
    !
    IF(PRESENT(EOF)) EOF=FALSE
    !
    IF(PRESENT(NOSHIFT)) SHIFT = .NOT. NOSHIFT
    !
    TRANSCRIBE = IOUT.NE.Z
    N=Z
    READ_LOOP: DO
          READ(INFILE,'(A)',IOSTAT=ERR) LINE
          IF    (ERR > Z) THEN                                   !LINE FAILED TO READ, THIS IS MOST LIKELY DUE TO END OF FILE LINE,INFILE,OUTPUT,MSG
                               CALL FILE_IO_ERROR(ERR,INFILE,LINE=LINE,INFILE=INFILE,OUTPUT=IERR, MSG='ERROR WHILE READING IN A LINE FROM INFILE "SUBROUTINE READ_TO_DATA"')
          ELSEIF(ERR < Z) THEN !EOF
                               LINE=BLNK
                               C=ONE
                               IF(PRESENT(EOF)) EOF=TRUE
                               BACKSPACE(INFILE) !NOTE THAT EOF COUNTS OF 1 READ, BUT MULTIPLE READS TO EOF WILL NOT MOVE ANY FURTHER, SO REPOSITION TO THE END OF THE FILE, BUT NOT ONE BEYOND TO KEEP N (THE READ COUNT) CORRET 
                               EXIT READ_LOOP
          END IF
          !
          CALL SPECIAL_BLANK_STRIP(LINE)   !FORTRAN TREATES TAB AS IF IT WAS CHARACTER--MAKE SPACES TO IMPROVE SEARCH --also remove dangling CR or LF
          !
          IF(LINE(1:1) == BLNK .AND. SHIFT) LINE = ADJUSTL(LINE)
          !
          N = N + ONE
          !
          C = COMMENT_INDEX(LINE)
          !INDEX(LINE,COM)
          !IF    (C == Z) THEN
          !                       C = LEN_TRIM(LINE)
          !ELSEIF(C >  1) THEN
          !                       C = C -1
          !END IF
          !
          IF(LINE(C:C) /= COM .AND. LINE(1:C) /= BLNK) EXIT READ_LOOP
          !
          IF(TRANSCRIBE) THEN
                IF(FIRST) THEN
                              WRITE(IOUT,'(/ A)') TRIM(LINE)
                              FIRST = FALSE
                ELSE
                              WRITE(IOUT,'(  A)') TRIM(LINE)
                END IF
          END IF
          !
    END DO READ_LOOP
    !
    IF(.NOT. FIRST) WRITE(IOUT,'(A)')
    !
    IF(PRESENT(CNT)) CNT=N
    !
    IF(PRESENT(EOL)) EOL = C
    !
    IF(PRESENT(BACK_UP)) THEN; IF(BACK_UP.AND.ERR==Z) BACKSPACE(INFILE)
    END IF
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE FUNCTION COMMENT_INDEX(LINE) RESULT(IDX)
    CHARACTER(*),INTENT(IN):: LINE
    INTEGER:: IDX
    !
    IDX=INDEX(LINE,'#')-ONE
    !
    IF (IDX  < Z) IDX=LEN_TRIM(LINE)     !NO # FOUND, SO USE ENTIRE STRING
    IF (IDX == Z) IDX=ONE                !# IS ON FIRST COLUMN OR LINE IS BLANK, SET TO 1
    !
    !IF (IDX > ONE) THEN
    !                   IF(LINE(IDX:IDX) == CR .OR. LINE(IDX:IDX) == LF) IDX=IDX-ONE  !HAS MIXED WINDOWS AND UNIX STYLE ENDING 
    !END IF
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  RECURSIVE FUNCTION MAX_LINE_LENGTH_UNIT(IU, INC, LINE) RESULT(MXCOL)
    INTEGER,               INTENT(IN   ):: IU
    LOGICAL, OPTIONAL, INTENT(IN):: INC   !IF TRUE, THEN CHECK FOR KEYWORD "BLOCK_INCLUDE" AND SEARCH THE FILE THAT IT WOULD OPEN, ALSO CHECK WITHIN SUBFILES FOR "BLOCK_INCLUDE".
    CHARACTER(*), OPTIONAL,INTENT(INOUT):: LINE !SCRATCH SPACE TO USE FOR FINDING THE FILE NAME
    INTEGER:: MXCOL
    CHARACTER(:),ALLOCATABLE:: FNAME
    !
    IF(IU.NE.Z) THEN
       IF(PRESENT(LINE)) THEN
           INQUIRE(IU, NAME=LINE)
           MXCOL=MAX_LINE_LENGTH_FILE(LINE,INC)
       ELSE
           CALL GET_FILE_NAME(IU,FNAME) 
           MXCOL=MAX_LINE_LENGTH_FILE(FNAME,INC)
           DEALLOCATE(FNAME)
       END IF
    ELSE
        MXCOL = Z
    END IF
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  RECURSIVE FUNCTION MAX_LINE_LENGTH_FILE(FNAME, INC) RESULT(MXLEN)
    !USE GENERIC_OPEN_INTERFACE, ONLY: GENERIC_OPEN
    CHARACTER(*),      INTENT(IN   ):: FNAME
    LOGICAL, OPTIONAL, INTENT(IN):: INC   !IF TRUE, THEN CHECK FOR KEYWORD "BLOCK_INCLUDE" AND SEARCH THE FILE THAT IT WOULD OPEN, ALSO CHECK WITHIN SUBFILES FOR "BLOCK_INCLUDE".
    INTEGER:: MXLEN
    INTEGER:: IU, WID, IERR, IBLNK
    CHARACTER:: TXT
    !NL = NEW_LINE(TXT)
    !
    MXLEN = Z
    !
    IF(PRESENT(INC)) THEN  !Check for BLOCK_INCLUDE WITHIN FILE, IF FOUND MAKE RECURSIVE CALL.
        IF(INC) THEN
                IU = Z
                CALL GENERIC_OPEN(FNAME, IU, Z, ACTION='READ', FORM='FORMATTED', ACCESS='SEQUENTIAL', STATUS='OLD', BUFFER_BLOCKSIZE=65536) !, WARN=GET_WARN()
                BLOCK
                    INTEGER:: LLOC, I, J, MXLEN2
                    CHARACTER(512):: LINE
                    LOGICAL::EOF
                    DO
                        CALL READ_TO_DATA(LINE,IU,EOF=EOF)
                        IF(EOF) EXIT
                        !
                        LLOC = ONE
                        CALL PARSE_WORD_UP(LINE,LLOC,I,J)
                        !
                        IF(LINE(I:J)=='BLOCK_INCLUDE') THEN              ! .OR. LINE(I:J)=='INCLUDE'
                           CALL PARSE_WORD(LINE,LLOC,I,J)
                           !
                           MXLEN2 = MAX_LINE_LENGTH_FILE(LINE(I:J), INC)
                           !
                           IF(MXLEN < MXLEN2 ) MXLEN = MXLEN2
                           !
                        END IF
                    END DO
                END BLOCK
                !
                CLOSE(IU)
        END IF
    END IF
    !
    ! Now start actual line width check
    !
    IU = Z
    CALL GENERIC_OPEN(FNAME, IU, Z, ACTION='READ', FORM='UNFORMATTED', ACCESS='STREAM', STATUS='OLD', BUFFER_BLOCKSIZE=65536)   !, WARN=GET_WARN()
    !
    IBLNK = Z
    WID = Z
    DO
        READ(IU,IOSTAT=IERR) TXT
        IF(IERR.NE.Z) EXIT
        !
        IF(TXT==NL) THEN
            !
            IF(MXLEN < WID) MXLEN = WID
            WID   = Z
            IBLNK = Z
            !
        ELSEIF(TXT==BLNK .OR. TXT==TAB) THEN
            !
            IBLNK = IBLNK + ONE
            !
        ELSEIF(TXT.NE.CR) THEN  !Is not a DOS Carriage Return, not a blank, and not a LineFeed (NL)
            WID = WID + IBLNK + ONE
            IBLNK = Z
        END IF
    END DO
    !
    IF(MXLEN < WID) MXLEN = WID
    !
    CLOSE(IU)
    !
  END FUNCTION
  !RECURSIVE FUNCTION MAX_LINE_LENGTH_FILE(FNAME, INC) RESULT(MXCOL)
  !  !USE GENERIC_OPEN_INTERFACE, ONLY: GENERIC_OPEN
  !  CHARACTER(*),      INTENT(IN):: FNAME
  !  LOGICAL, OPTIONAL, INTENT(IN):: INC   !IF TRUE, THEN CHECK FILES LOADED WITH BLOCK_INCLUDE OR INCLUDE
  !  INTEGER:: MXCOL
  !  INTEGER:: IU, WID, IERR, ISTOP, ISTART
  !  CHARACTER:: TXT
  !  !NL = NEW_LINE(TXT)
  !  !
  !  MXCOL = Z
  !  !
  !  IF(PRESENT(INC)) THEN
  !      IF(INC) THEN
  !              IU = Z
  !              CALL GENERIC_OPEN(FNAME, IU, Z, ACTION='READ', FORM='FORMATTED', ACCESS='SEQUENTIAL', STATUS='OLD', BUFFER_BLOCKSIZE=65536, WARN=GET_WARN())
  !              BLOCK
  !                  INTEGER:: LLOC, I, J, MXCOL2
  !                  CHARACTER(512):: LINE
  !                  LOGICAL::EOF
  !                  DO
  !                      CALL READ_TO_DATA(LINE,IU,EOF=EOF)
  !                      IF(EOF) EXIT
  !                      !
  !                      LLOC = ONE
  !                      CALL PARSE_WORD_UP(LINE,LLOC,I,J)
  !                      !
  !                      IF(LINE(I:J)=='BLOCK_INCLUDE') THEN              ! .OR. LINE(I:J)=='INCLUDE'
  !                         CALL PARSE_WORD(LINE,LLOC,I,J)
  !                         !
  !                         MXCOL2 = MAX_LINE_LENGTH_FILE(LINE(I:J), INC)
  !                         !
  !                         IF(MXCOL < MXCOL2 ) MXCOL = MXCOL2
  !                         !
  !                      END IF
  !                  END DO
  !              END BLOCK
  !              !
  !              CLOSE(IU)
  !      END IF
  !  END IF
  !  !
  !  IU = Z
  !  CALL GENERIC_OPEN(FNAME, IU, Z, ACTION='READ', FORM='UNFORMATTED', ACCESS='STREAM', STATUS='OLD', BUFFER_BLOCKSIZE=65536, WARN=GET_WARN())
  !  !
  !  INQUIRE(IU,POS=ISTART)
  !  DO
  !      READ(IU,IOSTAT=IERR) TXT
  !      IF(IERR.NE.Z) EXIT
  !      !
  !      IF(TXT==NL) THEN
  !          INQUIRE(IU,POS=ISTOP)
  !          WID = ISTOP-ISTART+ONE        !Note that unix format will have the correct length, but windows will be LEN+1
  !          IF(MXCOL < WID) MXCOL = WID
  !          ISTART=ISTOP+ONE
  !      END IF
  !  END DO
  !  !
  !  INQUIRE(IU,POS=ISTOP)
  !  WID = ISTOP-ISTART+ONE
  !  IF(MXCOL < WID) MXCOL = WID
  !  !
  !  CLOSE(IU)
  !  !
  !END FUNCTION
  !
  !######################################################################    
  !
  !!!RECURSIVE SUBROUTINE MAX_LINE_LENGTH_KEYWORD(IU, KEY, LINE, MXCOL) --INCOMPLETE/BAD CODE seb
  !!!  INTEGER,      INTENT(IN   ):: IU
  !!!  CHARACTER(*), INTENT(IN   ):: KEY  !KEYWORD TO INDICATE FILE SHOULD BE OPENED
  !!!  CHARACTER(*), INTENT(INOUT):: LINE !SCRATCH SPACE TO USE FOR FINDING THE FILE NAME
  !!!  INTEGER,      INTENT(INOUT):: MXCOL
  !!!  INTEGER:: ITMP, LLOC, I, J
  !!!  INTEGER:: WID, IERR
  !!!  CHARACTER:: TXT
  !!!  LOGICAL:: EOF
  !!!  !NL = NEW_LINE(TXT)
  !!!  !
  !!!  MXCOL = Z
  !!!  !
  !!!  REWIND(IU) 
  !!!  DO
  !!!      CALL READ_TO_DATA(LINE,IU,EOF=EOF)
  !!!      IF(EOF) EXIT
  !!!      !
  !!!      LLOC = ONE
  !!!      CALL PARSE_WORD_UP(LINE,LLOC,I,J)
  !!!      !
  !!!      IF(LINE(I:J)==KEY) THEN              ! .OR. LINE(I:J)=='INCLUDE'
  !!!         CALL PARSE_WORD(LINE,LLOC,I,J)
  !!!         ITMP = Z
  !!!         CALL GENERIC_OPEN(LINE(I:J), ITMP, Z, ACTION='READ', FORM='FORMATTED', ACCESS='SEQUENTIAL', STATUS='OLD', BUFFER_BLOCKSIZE=65536, WARN=GET_WARN())
  !!!         !
  !!!         CALL MAX_LINE_LENGTH_KEYWORD(ITMP, KEY, LINE, WID)
  !!!         !
  !!!         IF(MXCOL < WID) MXCOL = WID
  !!!         !
  !!!         CLOSE(ITMP)
  !!!         !
  !!!      END IF
  !!!  END DO
  !!!  !
  !!!  REWIND(IU)
  !!!  !
  !!!  INQUIRE(IU,POS=I)
  !!!  DO
  !!!      READ(IU,IOSTAT=IERR) TXT
  !!!      IF(IERR.NE.Z) EXIT
  !!!      !
  !!!      IF(TXT==NL) THEN
  !!!          INQUIRE(IU,POS=J)
  !!!          WID = J-I+ONE        !Note that unix format will have the correct length, but windows will be LEN+1
  !!!          IF(MXCOL < WID) MXCOL = WID
  !!!          I=J+ONE
  !!!      END IF
  !!!  END DO
  !!!  !
  !!!  INQUIRE(IU,POS=J)
  !!!  WID = J-I+ONE
  !!!  IF(MXCOL < WID) MXCOL = WID
  !!!  !
  !!!  REWIND(IU)
  !!!  !
  !!!END SUBROUTINE
  !
  !#########################################################################################################################
  !
  RECURSIVE FUNCTION MAX_UNCOMMENTED_LINE_LEN_UNIT(IU,LINE) RESULT(MXLEN)
    INTEGER,               INTENT(IN   ):: IU
    CHARACTER(*), OPTIONAL,INTENT(INOUT):: LINE !SCRATCH SPACE TO USE FOR FINDING THE FILE NAME
    INTEGER:: MXLEN
    CHARACTER(:),ALLOCATABLE:: FNAME
    !
    IF(IU.NE.Z) THEN
       IF(PRESENT(LINE)) THEN
           INQUIRE(IU, NAME=LINE)
           MXLEN=MAX_UNCOMMENTED_LINE_LEN(LINE)
       ELSE
           CALL GET_FILE_NAME(IU,FNAME) 
           MXLEN=MAX_UNCOMMENTED_LINE_LEN(FNAME)
           DEALLOCATE(FNAME)
       END IF
    ELSE
        MXLEN = Z
    END IF
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  RECURSIVE FUNCTION MAX_UNCOMMENTED_LINE_LEN_FILE(FNAME) RESULT(MXLEN)
    !USE GENERIC_OPEN_INTERFACE, ONLY: GENERIC_OPEN
    CHARACTER(*),      INTENT(IN   ):: FNAME
    INTEGER:: MXLEN
    INTEGER:: IU, WID, IERR, IBLNK
    CHARACTER:: TXT
    !NL = NEW_LINE(TXT)
    !
    MXLEN = Z
    !
    IU = Z
    CALL GENERIC_OPEN(FNAME, IU, Z, ACTION='READ', FORM='UNFORMATTED', ACCESS='STREAM', STATUS='OLD', BUFFER_BLOCKSIZE=65536)  !, WARN=GET_WARN()
    !
    IBLNK = Z
    WID = Z
    DO
        READ(IU,IOSTAT=IERR) TXT
        IF(IERR.NE.Z) EXIT
        !
        IF(TXT==NL) THEN
            !
            IF(MXLEN < WID) MXLEN = WID
            WID   = Z
            IBLNK = Z
            !
        ELSEIF(TXT==COM) THEN
            !
            DO  WHILE(IERR==Z .AND. TXT.NE.NL); READ(IU,IOSTAT=IERR) TXT
            END DO
            !
            IF(MXLEN < WID) MXLEN = WID
            WID = Z
            IBLNK = Z
            !
        ELSEIF(TXT==BLNK .OR. TXT==TAB) THEN
            !
            IBLNK = IBLNK + ONE
            !
        ELSEIF(TXT.NE.CR) THEN  !Is not a DOS Carriage Return, not a blank, and not a LineFeed (NL)
            WID = WID + IBLNK + ONE
            IBLNK = Z
        END IF
    END DO
    !
    IF(MXLEN < WID) MXLEN = WID
    !
    CLOSE(IU)
    !
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  ! IS_ODD(NUM), IS_EVEN(NUM)
  !
  PURE FUNCTION IS_ODD(NUM)
    INTEGER, INTENT(IN):: NUM
    LOGICAL:: IS_ODD
    IS_ODD = IAND(NUM,1) == 1
  END FUNCTION
  !
  !################################################################################
  !
  PURE FUNCTION IS_EVEN(NUM)
    INTEGER, INTENT(IN):: NUM
    LOGICAL:: IS_EVEN
    IS_EVEN = IAND(NUM,1) == 0
  END FUNCTION
  !
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  INT_POS and STR_POS =>
  !  
  PURE FUNCTION INT_POS_INTEGER(IVAL,VEC) RESULT(IDX)
    INTEGER,                           INTENT(IN):: IVAL
    INTEGER, CONTIGUOUS, DIMENSION(:), INTENT(IN):: VEC
    INTEGER:: IDX
    INTEGER:: I
    !
    IDX = Z
    DO I=ONE, SIZE(VEC)
        IF(IVAL == VEC(I)) THEN
            IDX = I
            EXIT
        END IF
    END DO
    !
  END FUNCTION
  !
  PURE ELEMENTAL FUNCTION INT_POS_INTEGER_VECTOR(IVAL,VEC) RESULT(IDX)
    INTEGER,              INTENT(IN):: IVAL
    TYPE(INTEGER_VECTOR), INTENT(IN):: VEC
    INTEGER:: IDX
    !
    IDX = VEC%FIND(IVAL)
    !
  END FUNCTION
  !
  !################################################################################
  !
  PURE FUNCTION STR_POS_CHARACTER(STR,VEC) RESULT(IDX)
    CHARACTER(*),                           INTENT(IN):: STR
    CHARACTER(*), CONTIGUOUS, DIMENSION(:), INTENT(IN):: VEC
    INTEGER:: IDX
    INTEGER:: I
    !
    IDX = Z
    DO I=ONE, SIZE(VEC)
        IF(STR == VEC(I)) THEN
            IDX = I
            EXIT
        END IF
    END DO
    !
  END FUNCTION
  !
  PURE FUNCTION STR_POS_CHARACTER_TYPE_CHAR(STR,VEC) RESULT(IDX)
    CHARACTER(*),                                   INTENT(IN):: STR
    TYPE(CHARACTER_TYPE), CONTIGUOUS, DIMENSION(:), INTENT(IN):: VEC
    INTEGER:: IDX
    INTEGER:: I
    !
    IDX = Z
    DO I=ONE, SIZE(VEC)
        IF(ALLOCATED(VEC(I)%STR)) THEN
              IF(STR == VEC(I)%STR) THEN
                  IDX = I
                  EXIT
              END IF
        END IF
    END DO
    !
  END FUNCTION
  !
  PURE FUNCTION STR_POS_CHAR_CHARACTER_TYPE(STR,VEC) RESULT(IDX)
    TYPE(CHARACTER_TYPE),                   INTENT(IN):: STR
    CHARACTER(*), CONTIGUOUS, DIMENSION(:), INTENT(IN):: VEC
    INTEGER:: IDX
    INTEGER:: I
    !
    IDX = Z
    IF(ALLOCATED(STR%STR)) THEN
       DO I=ONE, SIZE(VEC)
             IF(STR%STR == VEC(I)) THEN
                 IDX = I
                 EXIT
             END IF
       END DO
    END IF
    !
  END FUNCTION
  !
  PURE FUNCTION STR_POS_CHARACTER_TYPE_CHARACTER_TYPE(STR,VEC) RESULT(IDX)
    TYPE(CHARACTER_TYPE),                           INTENT(IN):: STR
    TYPE(CHARACTER_TYPE), CONTIGUOUS, DIMENSION(:), INTENT(IN):: VEC
    INTEGER:: IDX
    INTEGER:: I
    !
    IDX = Z
    IF(ALLOCATED(STR%STR)) THEN
       DO I=ONE, SIZE(VEC)
            IF(ALLOCATED(VEC(I)%STR)) THEN
                  IF(STR%STR == VEC(I)%STR) THEN
                      IDX = I
                      EXIT
                  END IF
            END IF
       END DO
    END IF
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  SUBROUTINE NAME_LIST_DUBLICATE_CHECK(NAMES,OUTPUT)
    CHARACTER(*),DIMENSION(:),CONTIGUOUS,INTENT(IN)::NAMES
    INTEGER,OPTIONAL:: OUTPUT
    !
    INTEGER:: I, IOUT
    !
    IF(PRESENT(OUTPUT)) THEN
        IOUT = OUTPUT
    ELSE
        IOUT = Z
    END IF
    !
    DO I=2, SIZE(NAMES)
        IF( ANY( NAMES(I-1) == NAMES(I:) ) )  CALL STOP_ERROR(OUTPUT=IOUT, MSG='UNIQUE NAME IDENTIFIER IS NOT UNIQUE. FOUND DUBLICATE IDENTIFIER FOR NAME: "'//TRIM(NAMES(I-1))//'"')
    END DO
    !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  GET routines
  !  
  SUBROUTINE GET_DATE_VAL(LN,LOC,ISTART,ISTOP,IOUT,IN,DATE,NO_PARSE_WORD,MSG, HAS_ERROR, FOUND_DATE,ONLY_DYEAR, NO_DATE, TIME_SPACE, IOSTAT)  !IF NO_PARSE_WORD=TRUE, THEN ASSUMES ISTART AND ISTOP ARE ALREADY SET TO CORRECT LOCATION
    CHARACTER(*),           INTENT(IN   ):: LN                ! LINE TO PARSE DOUBLE FROM
    INTEGER,                INTENT(INOUT):: LOC,ISTART,ISTOP  ! LOC => STARTING LOCATION TO FIND NUMBER, NUMBER AT EXIT IS LOCATED AT LN(ISTART:ISTOP) AND LOC = ISTOP+1
    INTEGER,                INTENT(IN   ):: IOUT, IN          ! ERROR UNIT TO WRITE TO, FILE UNIT THAT LN ORIGINATED FROM
    CLASS(DATE_OPERATOR),   INTENT(OUT  ):: DATE
    LOGICAL,      OPTIONAL, INTENT(IN   ):: NO_PARSE_WORD     ! INDCIATES THAT ISTART AND ISTOP ALREADY POINT TO NUMBER
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: MSG               ! ERROR MESSAGE PRINTED WHEN FAIL TO LOAD NUMBER AND STOP PROGRAM, IF "NOSTOP" THEN VAL IS SET TO NaN
    LOGICAL,      OPTIONAL, INTENT(  OUT):: HAS_ERROR         ! SET TO TRUE IF THERE IS AN ERROR
    LOGICAL,      OPTIONAL, INTENT(  OUT):: FOUND_DATE        ! SET TO TRUE IF THE DATE WAS FOUND AND NOT THE DOUBLE
    LOGICAL,      OPTIONAL, INTENT(IN   ):: ONLY_DYEAR        ! IF SET TO TRUE THEN ONLY THE DYEAR IS CALCLATED
    LOGICAL,      OPTIONAL, INTENT(IN   ):: NO_DATE           ! IF SET TO TRUE THEN AN ERROR IS *NOT* RAISED IF INPUT SPECIFED 'NO_DATE'
    LOGICAL,      OPTIONAL, INTENT(IN   ):: TIME_SPACE        ! IF TRUE then allow blank spaces/tabs to separte date and time in addition to Tt
    INTEGER,      OPTIONAL, INTENT(  OUT):: IOSTAT            ! SET to zero if there is no error, otherwise non-zero error code
    LOGICAL:: CHECK, TSPACE
    CHARACTER(:), ALLOCATABLE:: ERRMSG
    !
    IF(PRESENT(HAS_ERROR)) HAS_ERROR = FALSE
    !
    IF(PRESENT(NO_PARSE_WORD)) THEN
        CHECK = .NOT. NO_PARSE_WORD
    ELSE
        CHECK = TRUE
    END IF
    !
    IF(PRESENT(TIME_SPACE)) THEN
        TSPACE = TIME_SPACE
    ELSE
        TSPACE = FALSE
    END IF
    !
    IF(CHECK) CALL PARSE_WORD(LN,LOC,ISTART,ISTOP)
    !
    IF(TSPACE .AND. CHECK) THEN  !CHECK IF PARSE_WORD NEEDS TO BE ADJUSTED TO ACCOUNT FOR ANY BLANK SPACES BETWEEN DATE AND CLOCK
          BLOCK
               INTEGER:: I,J
               I = ISTART
               J = ISTOP
               CALL PARSE_WORD(LN,LOC,ISTART,ISTOP)
               !
               IF(INDEX(LN(ISTART:ISTOP),':') > Z) THEN
                   ISTART = I
               ELSE
                   ISTART = I
                   ISTOP  = J
               END IF
          END BLOCK
    END IF
    !
    CHECK = TRUE
    IF(PRESENT(NO_DATE)) THEN
       IF(NO_DATE) THEN
                   ALLOCATE(ERRMSG, SOURCE=LN(ISTART:ISTOP))
                   CALL UPPER(ERRMSG)
                   IF(ERRMSG == 'NO_DATE' .OR. ERRMSG == 'NODATE' .OR. ERRMSG == 'NAN' .OR. ERRMSG == 'SKIP') THEN
                       CALL DATE%INIT( 'NO_DATE', FOUND_DATE = FOUND_DATE )
                       RETURN !------------------------------------------^
                   ELSE
                       DEALLOCATE(ERRMSG)
                   END IF
       END IF
    END IF
    !
    CALL DATE%INIT( LN(ISTART:ISTOP), FOUND_DATE = FOUND_DATE, ONLY_DYEAR = ONLY_DYEAR )
    !
    IF( DATE%NOT_SET() ) THEN
          CHECK = TRUE
          IF(PRESENT(MSG)) THEN
               !
               IF (MSG=='NOSTOP') THEN
                   CHECK = FALSE
               END IF
               IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
          ELSE IF(PRESENT(IOSTAT)) THEN
                          IOSTAT = 163
                          CHECK  = FALSE
               IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
          ELSE IF(PRESENT(HAS_ERROR)) THEN
               !
               HAS_ERROR = TRUE
               CHECK  = FALSE
          END IF
          !
          IF(CHECK) THEN
              ERRMSG = 'GET_DATE READ UTILITY ERROR: FAILED TO CONVERT TEXT TO A CALENDAR DATE/DECIMAL YEAR.'//BLN//'THE FOLLOWING IS THE TEXT ATTEMPTED TO BE CONVERTED "'//LN(ISTART:ISTOP)//'".'//BLN//'THE ACCEPTED DATE FORMATS ARE "mm/dd/YYYY" OR "YYYY-mm-dd" AND THE FOLLOWING SETS THE DAY AUTOMATICALLY TO ONE: "mm/YYYY" OR "YYYY-mm"'//NL//'IT IS ALSO POSSIBLE TO WRITE OUT THE NAME OF THE MONTH WHERE mmm REFERS TO THE THREE LETTER MONTH ABBREVIATION OR FULL MONTH NAME: "mmm/dd/yyyy" OR "mmm-dd-yyyy"'//BLN//'FOR SOME SELECT INPUTS YOU MAY ALSO SPECIFY ONLY THE MONTH AND DAY, WHICH THEN AUTOMATICALLY APPENDS THE YEAR (OR IF NOT SUPPORED SETS THE YEAR TO ZERO). THIS FORMAT IS AS FOLLOWS: "mm\dd" OR "mmm-dd" OR "mmm/dd" OR SET THE DAY AUTOMATICALLY TO ONE WITH "mmm"'//BLN//'IF YOU WANT TO ADD A 24-HOUR TIME TO IT YOU MUST ADD TO THE DATE "Thh:mm:ss"'//NL//'(e.g. "YYYY-mm-ddThh:mm:ss")'
              IF(LN(ISTART:ISTOP)==BLNK) ERRMSG = ERRMSG//BLN//'THE POSSIBLE REASON FOR THIS ERROR IS DUE TO READING IN A BLANK/EMPTY LINE OR YOU DID NOT PROVIDE ENOUGH NUMBERS ON THE LINE.'
              IF(PRESENT(MSG)) ERRMSG = ERRMSG//BLN//'THE FOLLOWING IS AN ADDITIONAL COMMENT PASSED TO GET_NUMBER:'//BLN//TRIM(MSG)
              !
              CALL STOP_ERROR(LN, IN, IOUT, ERRMSG )
          END IF
    END IF
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  SUBROUTINE GET_DOUBLE_DATE(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,DATE,NO_PARSE_WORD,MSG,HAS_ERROR,FOUND_DATE,ONLY_DYEAR,TIME_SPACE, IOSTAT)  !IF NO_PARSE_WORD=TRUE, THEN ASSUMES ISTART AND ISTOP ARE ALREADY SET TO CORRECT LOCATION
    CHARACTER(*),           INTENT(IN   ):: LN                ! LINE TO PARSE DOUBLE FROM
    INTEGER,                INTENT(INOUT):: LOC,ISTART,ISTOP  ! LOC => STARTING LOCATION TO FIND NUMBER, NUMBER AT EXIT IS LOCATED AT LN(ISTART:ISTOP) AND LOC = ISTOP+1
    INTEGER,                INTENT(IN   ):: IOUT, IN          ! ERROR UNIT TO WRITE TO, FILE UNIT THAT LN ORIGINATED FROM
    DOUBLE PRECISION,       INTENT(OUT  ):: VAL               ! DOUBLE VALUE TO RETURN
    CLASS(DATE_OPERATOR),   INTENT(OUT  ):: DATE
    LOGICAL,      OPTIONAL, INTENT(IN   ):: NO_PARSE_WORD     ! INDCIATES THAT ISTART AND ISTOP ALREADY POINT TO NUMBER
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: MSG               ! ERROR MESSAGE PRINTED WHEN FAIL TO LOAD NUMBER AND STOP PROGRAM, IF "NOSTOP" THEN VAL IS SET TO NaN
    LOGICAL,      OPTIONAL, INTENT(  OUT):: HAS_ERROR         ! SET TO TRUE IF THERE IS AN ERROR
    LOGICAL,      OPTIONAL, INTENT(  OUT):: FOUND_DATE        ! SET TO TRUE IF THE DATE WAS FOUND AND NOT THE DOUBLE
    LOGICAL,      OPTIONAL, INTENT(IN   ):: ONLY_DYEAR        ! IF SET TO TRUE THEN ONLY THE DYEAR IS CALCLATED
    LOGICAL,      OPTIONAL, INTENT(IN   ):: TIME_SPACE        ! IF TRUE then allow blank spaces/tabs to separte date and time in addition to Tt
    INTEGER,      OPTIONAL, INTENT(  OUT):: IOSTAT            ! SET to zero if there is no error, otherwise non-zero error code
    !
    CALL GET_DATE_VAL(LN,LOC,ISTART,ISTOP,IOUT,IN,DATE,NO_PARSE_WORD,MSG, HAS_ERROR, FOUND_DATE,ONLY_DYEAR, TIME_SPACE=TIME_SPACE,IOSTAT=IOSTAT)
    !
    VAL = DATE%DYEAR
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  SUBROUTINE GET_REAL_DATE(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,DATE,NO_PARSE_WORD,MSG,HAS_ERROR,FOUND_DATE,ONLY_DYEAR,TIME_SPACE, IOSTAT)  !IF NO_PARSE_WORD=TRUE, THEN ASSUMES ISTART AND ISTOP ARE ALREADY SET TO CORRECT LOCATION
    CHARACTER(*),           INTENT(IN   ):: LN                ! LINE TO PARSE DOUBLE FROM
    INTEGER,                INTENT(INOUT):: LOC,ISTART,ISTOP  ! LOC => STARTING LOCATION TO FIND NUMBER, NUMBER AT EXIT IS LOCATED AT LN(ISTART:ISTOP) AND LOC = ISTOP+1
    INTEGER,                INTENT(IN   ):: IOUT, IN          ! ERROR UNIT TO WRITE TO, FILE UNIT THAT LN ORIGINATED FROM
    REAL(REAL32),           INTENT(OUT  ):: VAL               ! SINGLE PREC VALUE TO RETURN
    CLASS(DATE_OPERATOR),   INTENT(OUT  ):: DATE
    LOGICAL,      OPTIONAL, INTENT(IN   ):: NO_PARSE_WORD     ! INDCIATES THAT ISTART AND ISTOP ALREADY POINT TO NUMBER
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: MSG               ! ERROR MESSAGE PRINTED WHEN FAIL TO LOAD NUMBER AND STOP PROGRAM, IF "NOSTOP" THEN VAL IS SET TO NaN
    LOGICAL,      OPTIONAL, INTENT(  OUT):: HAS_ERROR         ! SET TO TRUE IF THERE IS AN ERROR
    LOGICAL,      OPTIONAL, INTENT(  OUT):: FOUND_DATE        ! SET TO TRUE IF THE DATE WAS FOUND AND NOT THE DOUBLE
    LOGICAL,      OPTIONAL, INTENT(IN   ):: ONLY_DYEAR        ! IF SET TO TRUE THEN ONLY THE DYEAR IS CALCLATED
    LOGICAL,      OPTIONAL, INTENT(IN   ):: TIME_SPACE        ! IF TRUE then allow blank spaces/tabs to separte date and time in addition to Tt
    INTEGER,      OPTIONAL, INTENT(  OUT):: IOSTAT            ! SET to zero if there is no error, otherwise non-zero error code
    !
    CALL GET_DATE_VAL(LN,LOC,ISTART,ISTOP,IOUT,IN,DATE,NO_PARSE_WORD,MSG, HAS_ERROR, FOUND_DATE,ONLY_DYEAR, TIME_SPACE=TIME_SPACE,IOSTAT=IOSTAT)
    !
    VAL = SNGL(DATE%DYEAR)
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  !SUBROUTINE GET_DOUBLE_DATE(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,DATE,NO_PARSE_WORD,MSG,ERROR_VAL,NODATE,HAS_ERROR,FOUND_DATE)  !IF NO_PARSE_WORD=TRUE, THEN ASSUMES ISTART AND ISTOP ARE ALREADY SET TO CORRECT LOCATION
  !  CHARACTER(*),           INTENT(IN   ):: LN                ! LINE TO PARSE DOUBLE FROM
  !  INTEGER,                INTENT(INOUT):: LOC,ISTART,ISTOP  ! LOC => STARTING LOCATION TO FIND NUMBER, NUMBER AT EXIT IS LOCATED AT LN(ISTART:ISTOP) AND LOC = ISTOP+1
  !  INTEGER,                INTENT(IN   ):: IOUT, IN          ! ERROR UNIT TO WRITE TO, FILE UNIT THAT LN ORIGINATED FROM
  !  DOUBLE PRECISION,       INTENT(OUT  ):: VAL               ! DOUBLE VALUE TO RETURN
  !  CLASS(DATE_OPERATOR),   INTENT(OUT  ):: DATE
  !  LOGICAL,      OPTIONAL, INTENT(IN   ):: NO_PARSE_WORD     ! INDCIATES THAT ISTART AND ISTOP ALREADY POINT TO NUMBER
  !  CHARACTER(*), OPTIONAL, INTENT(IN   ):: MSG               ! ERROR MESSAGE PRINTED WHEN FAIL TO LOAD NUMBER AND STOP PROGRAM, IF "NOSTOP" THEN VAL IS SET TO NaN
  !  DOUBLE PRECISION,OPTIONAL,INTENT(IN ):: ERROR_VAL         ! IF FAIL TO LOAD NUMBER, DO NOT STOP, BUT INSTEAD SET VAL =  ERROR_VAL
  !  LOGICAL,         OPTIONAL,INTENT(IN ):: NODATE
  !  LOGICAL,      OPTIONAL, INTENT(  OUT):: HAS_ERROR         ! SET TO TRUE IF THERE IS AN ERROR
  !  LOGICAL,      OPTIONAL, INTENT(  OUT):: FOUND_DATE        ! SET TO TRUE IF THE DATE WAS FOUND AND NOT THE DOUBLE
  !  LOGICAL:: GET_WORD, INCLUDE_DATE
  !  INTEGER:: IERR
  !  CHARACTER(:), ALLOCATABLE:: ERRMSG
  !  !
  !  IF(PRESENT(HAS_ERROR )) HAS_ERROR  = FALSE
  !  IF(PRESENT(FOUND_DATE)) FOUND_DATE = FALSE
  !  !
  !  IF(PRESENT(NODATE)) THEN
  !      INCLUDE_DATE = .NOT. NODATE
  !  ELSE
  !      INCLUDE_DATE = TRUE
  !  END IF
  !  !
  !  IF(PRESENT(NO_PARSE_WORD)) THEN
  !      GET_WORD = .NOT. NO_PARSE_WORD
  !  ELSE
  !      GET_WORD = TRUE
  !  END IF
  !  !
  !  IF(GET_WORD) CALL PARSE_WORD(LN,LOC,ISTART,ISTOP)
  !  !
  !  READ(LN(ISTART:ISTOP),*, IOSTAT=IERR) VAL
  !  !
  !  IF(IERR.NE.Z) THEN
  !                           CALL DATE%INIT( LN(ISTART:ISTOP) )
  !                           !
  !                           IF( DATE%IS_SET() ) THEN
  !                               VAL = DATE%DYEAR
  !                               IERR = Z
  !                           END IF
  !                           IF(PRESENT(FOUND_DATE)) FOUND_DATE = TRUE
  !  ELSEIF(INCLUDE_DATE) THEN
  !                           CALL DATE%INIT( VAL )
  !  END IF
  !  !
  !  IF(IERR.NE.Z .OR. LN(ISTART:ISTOP)==BLNK) THEN
  !        GET_WORD = TRUE
  !        IF(PRESENT(ERROR_VAL)) THEN
  !                 !
  !                 GET_WORD = FALSE
  !                 VAL = ERROR_VAL
  !                 DATE%DYEAR = ERROR_VAL
  !                 !
  !        ELSEIF(PRESENT(MSG)) THEN
  !             !
  !             IF (MSG=='NOSTOP') THEN
  !                 GET_WORD = FALSE
  !                 VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)  !SET VAL TO NaN WHEN THERE IS NOSTOP OPTION
  !             END IF
  !             IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
  !        ELSE IF(PRESENT(HAS_ERROR)) THEN
  !             !
  !             HAS_ERROR = TRUE
  !             GET_WORD  = FALSE
  !             VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)  !SET VAL TO NaN WHEN THERE IS NOSTOP OPTION
  !        END IF
  !        !
  !        IF(GET_WORD) THEN
  !            ERRMSG = 'GET_DOUBLE_DATE READ UTILITY ERROR: FAILED TO CONVERT TEXT TO DOUBLE PRECISION NUMBER OR TO A CALENDAR DATE/DECIMAL YEAR.'//BLN//'THE FOLLOWING IS THE TEXT ATTEMPTED TO BE CONVERTED "'//LN(ISTART:ISTOP)//'".'
  !            IF(PRESENT(MSG)) ERRMSG = ERRMSG//BLN//'THE FOLLOWING IS AN ADDITIONAL COMMENT PASSED TO GET_DOUBLE_DATE:'//BLN//TRIM(MSG)
  !            !
  !            CALL STOP_ERROR(LN, IN, IOUT, ERRMSG )
  !        END IF
  !  END IF
  !  !
  !END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  !SUBROUTINE GET_REAL_DATE(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,DATE,NO_PARSE_WORD,MSG,ERROR_VAL, NODATE, HAS_ERROR)  !IF NO_PARSE_WORD=TRUE, THEN ASSUMES ISTART AND ISTOP ARE ALREADY SET TO CORRECT LOCATION
  !  CHARACTER(*),           INTENT(IN   ):: LN                ! LINE TO PARSE DOUBLE FROM
  !  INTEGER,                INTENT(INOUT):: LOC,ISTART,ISTOP  ! LOC => STARTING LOCATION TO FIND NUMBER, NUMBER AT EXIT IS LOCATED AT LN(ISTART:ISTOP) AND LOC = ISTOP+1
  !  INTEGER,                INTENT(IN   ):: IOUT, IN          ! ERROR UNIT TO WRITE TO, FILE UNIT THAT LN ORIGINATED FROM
  !  REAL,                   INTENT(OUT  ):: VAL               ! REAL VALUE TO RETURN
  !  CLASS(DATE_OPERATOR),   INTENT(OUT  ):: DATE
  !  LOGICAL,      OPTIONAL, INTENT(IN   ):: NO_PARSE_WORD     ! INDCIATES THAT ISTART AND ISTOP ALREADY POINT TO NUMBER
  !  CHARACTER(*), OPTIONAL, INTENT(IN   ):: MSG               ! ERROR MESSAGE PRINTED WHEN FAIL TO LOAD NUMBER AND STOP PROGRAM, IF "NOSTOP" THEN VAL IS SET TO NaN
  !  REAL,         OPTIONAL, INTENT(IN   ):: ERROR_VAL         ! IF FAIL TO LOAD NUMBER, DO NOT STOP, BUT INSTEAD SET VAL =  ERROR_VAL
  !  LOGICAL,         OPTIONAL,INTENT(IN ):: NODATE
  !  LOGICAL,      OPTIONAL, INTENT(  OUT):: HAS_ERROR         ! SET TO TRUE IF THERE IS AN ERROR
  !  LOGICAL:: GET_WORD, INCLUDE_DATE
  !  INTEGER:: IERR
  !  CHARACTER(:), ALLOCATABLE:: ERRMSG
  !  !
  !  IF(PRESENT(HAS_ERROR)) HAS_ERROR = FALSE
  !  !
  !  IF(PRESENT(NODATE)) THEN
  !      INCLUDE_DATE = .NOT. NODATE
  !  ELSE
  !      INCLUDE_DATE = TRUE
  !  END IF
  !  !
  !  IF(PRESENT(NO_PARSE_WORD)) THEN
  !      GET_WORD = .NOT. NO_PARSE_WORD
  !  ELSE
  !      GET_WORD = TRUE
  !  END IF
  !  !
  !  IF(GET_WORD) CALL PARSE_WORD(LN,LOC,ISTART,ISTOP)
  !  !
  !  READ(LN(ISTART:ISTOP),*, IOSTAT=IERR) VAL
  !  !
  !  IF(IERR.NE.Z) THEN
  !                           CALL DATE%INIT( LN(ISTART:ISTOP) )
  !                           !
  !                           IF(DATE%IS_SET()) THEN
  !                               VAL = REAL(DATE%DYEAR)
  !                               IERR = Z
  !                           END IF
  !  ELSEIF(INCLUDE_DATE) THEN
  !                           CALL DATE%INIT( VAL )
  !  END IF
  !  !
  !  IF(IERR.NE.Z .OR. LN(ISTART:ISTOP)==BLNK) THEN
  !        GET_WORD = TRUE
  !        IF(PRESENT(ERROR_VAL)) THEN
  !                 !
  !                 GET_WORD = FALSE
  !                 VAL = ERROR_VAL
  !                 DATE%DYEAR = ERROR_VAL
  !                 !
  !        ELSEIF(PRESENT(MSG)) THEN
  !             !
  !             IF (MSG=='NOSTOP') THEN
  !                 GET_WORD = FALSE
  !                 VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)  !SET VAL TO NaN WHEN THERE IS NOSTOP OPTION
  !             END IF
  !             IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
  !        ELSE IF(PRESENT(HAS_ERROR)) THEN
  !             !
  !             HAS_ERROR = TRUE
  !             GET_WORD  = FALSE
  !             VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)  !SET VAL TO NaN WHEN THERE IS NOSTOP OPTION
  !        END IF
  !        !
  !        IF(GET_WORD) THEN
  !            ERRMSG = 'GET_DOUBLE_DATE READ UTILITY ERROR: FAILED TO CONVERT TEXT TO DOUBLE PRECISION NUMBER OR TO A CALENDAR DATE/DECIMAL YEAR.'//BLN//'THE FOLLOWING IS THE TEXT ATTEMPTED TO BE CONVERTED "'//LN(ISTART:ISTOP)//'".'
  !            IF(PRESENT(MSG)) ERRMSG = ERRMSG//BLN//'THE FOLLOWING IS AN ADDITIONAL COMMENT PASSED TO GET_NUMBER:'//BLN//TRIM(MSG)
  !            !
  !            CALL STOP_ERROR(LN, IN, IOUT, ERRMSG )
  !        END IF
  !  END IF
  !  !
  !END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  SUBROUTINE GET_DOUBLE_VEC(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,MSG,ERROR_VAL, HAS_ERROR, IOSTAT) 
    CHARACTER(*),                  INTENT(IN   ):: LN                ! LINE TO PARSE DOUBLE FROM
    INTEGER,                       INTENT(INOUT):: LOC,ISTART,ISTOP  ! LOC => STARTING LOCATION TO FIND NUMBER, NUMBER AT EXIT IS LOCATED AT LN(ISTART:ISTOP) AND LOC = ISTOP+1
    INTEGER,                       INTENT(IN   ):: IOUT, IN          ! ERROR UNIT TO WRITE TO, FILE UNIT THAT LN ORIGINATED FROM
    REAL(REAL64),    DIMENSION(:), INTENT(OUT  ):: VAL               ! DOUBLE VALUE TO RETURN
    CHARACTER(*),        OPTIONAL, INTENT(IN   ):: MSG               ! ERROR MESSAGE PRINTED WHEN FAIL TO LOAD NUMBER AND STOP PROGRAM, IF "NOSTOP" THEN VAL IS SET TO NaN
    REAL(REAL64),        OPTIONAL, INTENT(IN   ):: ERROR_VAL         ! IF FAIL TO LOAD NUMBER, DO NOT STOP, BUT INSTEAD SET VAL =  ERROR_VAL
    LOGICAL,             OPTIONAL, INTENT(  OUT):: HAS_ERROR         ! SET TO TRUE IF THERE IS AN ERROR
    INTEGER,             OPTIONAL, INTENT(  OUT):: IOSTAT            ! SET to zero if there is no error, otherwise non-zero error code
    CONTIGUOUS:: VAL
    LOGICAL:: MUST_STOP
    INTEGER:: IERR, I
    CHARACTER(:), ALLOCATABLE:: ERRMSG
    !
    IF(PRESENT(HAS_ERROR)) HAS_ERROR = FALSE
    !
    MUST_STOP = FALSE
    VAL  = DZ
    IERR = Z
    !
    DO I=ONE,SIZE(VAL) 
              CALL PARSE_WORD(LN,LOC,ISTART,ISTOP)
              !
              SELECT CASE(LN(ISTART:ISTOP))
              CASE('NAN',  'NaN', 'nan'); VAL(I) = IEEE_VALUE(VAL(I), IEEE_QUIET_NAN)
              CASE('INF',  'inf', 'Inf'); VAL(I) = inf
              CASE('-INF','-inf','-Inf'); VAL(I) = ninf
              CASE(  '-1', '-1.','-1.0'); VAL(I) = DNEG
              CASE(   '0',  '0.', '0.0'); VAL(I) = DZ
              CASE(   '1',  '1.', '1.0'); VAL(I) = UNO
              CASE DEFAULT
                          READ(LN(ISTART:ISTOP),*, IOSTAT=IERR) VAL(I)
              END SELECT
              !
              IF(IERR.NE.Z .OR. LN(ISTART:ISTOP)==BLNK) THEN
                    MUST_STOP = TRUE
                    IF(PRESENT(ERROR_VAL)) THEN
                             !
                             MUST_STOP = FALSE
                             VAL(I) = ERROR_VAL
                             !
                    ELSEIF(PRESENT(MSG)) THEN
                         !
                         IF (MSG=='NOSTOP') THEN
                             MUST_STOP = FALSE
                             VAL(I) = IEEE_VALUE(VAL(I), IEEE_QUIET_NAN)   !SET VAL(I) TO NaN WHEN THERE IS NOSTOP OPTION
                         END IF
                         IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
                         !
                    ELSEIF(PRESENT(IOSTAT)) THEN
                         !
                         IF(IERR == Z .AND. LN(ISTART:ISTOP)==BLNK) THEN
                                                                    IOSTAT = -1
                         ELSE
                                                                    IOSTAT = IERR
                         END IF
                         MUST_STOP = FALSE
                         VAL(I) = IEEE_VALUE(VAL(I), IEEE_QUIET_NAN)   !SET VAL(I) TO NaN WHEN THERE IS NOSTOP OPTION
                         IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
                    ELSE IF(PRESENT(HAS_ERROR)) THEN
                         !
                         MUST_STOP = FALSE
                         HAS_ERROR = TRUE
                         VAL(I)= IEEE_VALUE(VAL(I), IEEE_QUIET_NAN)  !SET VAL TO NaN WHEN THERE IS NOSTOP OPTION
                    END IF
                    !
                    IF(MUST_STOP) THEN
                        ERRMSG = 'GET_NUMBER READ UTILITY ERROR: FAILED TO CONVERT TEXT TO DOUBLE PRECISION NUMBER.'//BLN//'THE FOLLOWING IS THE TEXT ATTEMPTED TO BE CONVERTED "'//LN(ISTART:ISTOP)//'".'//NL//'(IF THIS IS BLANK/EMPTY THEN YOU MAY NOT HAVE ENOUGH NUMBERS SPECIFIED ON THE LINE)'
                        IF(LN(ISTART:ISTOP)==BLNK) ERRMSG = ERRMSG//BLN//'THE POSSIBLE REASON FOR THIS ERROR IS DUE TO READING IN A BLANK/EMPTY LINE OR YOU DID NOT PROVIDE ENOUGH NUMBERS ON THE LINE.'
                        IF(PRESENT(MSG)) ERRMSG = ERRMSG//BLN//'THE FOLLOWING IS AN ADDITIONAL COMMENT PASSED TO GET_NUMBER:'//BLN//TRIM(MSG)
                        !
                        CALL STOP_ERROR(LN, IN, IOUT, ERRMSG )
                    END IF
              END IF
    END DO
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  SUBROUTINE GET_DOUBLE_VAL(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,NO_PARSE_WORD,MSG,ERROR_VAL, HAS_ERROR, IOSTAT)  !IF NO_PARSE_WORD=TRUE, THEN ASSUMES ISTART AND ISTOP ARE ALREADY SET TO CORRECT LOCATION
    CHARACTER(*),           INTENT(IN   ):: LN                ! LINE TO PARSE DOUBLE FROM
    INTEGER,                INTENT(INOUT):: LOC,ISTART,ISTOP  ! LOC => STARTING LOCATION TO FIND NUMBER, NUMBER AT EXIT IS LOCATED AT LN(ISTART:ISTOP) AND LOC = ISTOP+1
    INTEGER,                INTENT(IN   ):: IOUT, IN          ! ERROR UNIT TO WRITE TO, FILE UNIT THAT LN ORIGINATED FROM
    REAL(REAL64),           INTENT(OUT  ):: VAL               ! DOUBLE VALUE TO RETURN
    LOGICAL,      OPTIONAL, INTENT(IN   ):: NO_PARSE_WORD     ! INDCIATES THAT ISTART AND ISTOP ALREADY POINT TO NUMBER
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: MSG               ! ERROR MESSAGE PRINTED WHEN FAIL TO LOAD NUMBER AND STOP PROGRAM, IF "NOSTOP" THEN VAL IS SET TO NaN
    REAL(REAL64), OPTIONAL, INTENT(IN   ):: ERROR_VAL         ! IF FAIL TO LOAD NUMBER, DO NOT STOP, BUT INSTEAD SET VAL =  ERROR_VAL
    LOGICAL,      OPTIONAL, INTENT(  OUT):: HAS_ERROR         ! SET TO TRUE IF THERE IS AN ERROR
    INTEGER,      OPTIONAL, INTENT(  OUT):: IOSTAT            ! SET to zero if there is no error, otherwise non-zero error code
    LOGICAL:: CHECK
    INTEGER:: IERR
    CHARACTER(:), ALLOCATABLE:: ERRMSG
    !
    IF(PRESENT(HAS_ERROR)) HAS_ERROR = FALSE
    !
    IF(PRESENT(NO_PARSE_WORD)) THEN
        CHECK = .NOT. NO_PARSE_WORD
    ELSE
        CHECK = TRUE
    END IF
    !
    IF(CHECK) CALL PARSE_WORD(LN,LOC,ISTART,ISTOP)
    !
    IERR = Z
    SELECT CASE(LN(ISTART:ISTOP))
    CASE('NAN',  'NaN', 'nan'); VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)
    CASE('INF',  'inf', 'Inf'); VAL = inf
    CASE('-INF','-inf','-Inf'); VAL = ninf
    CASE(  '-1', '-1.','-1.0'); VAL = DNEG
    CASE(   '0',  '0.', '0.0'); VAL = DZ
    CASE(   '1',  '1.', '1.0'); VAL = UNO
    CASE DEFAULT
                READ(LN(ISTART:ISTOP),*, IOSTAT=IERR) VAL
    END SELECT
    !
    
    !
    IF(IERR.NE.Z .OR. LN(ISTART:ISTOP)==BLNK) THEN
          CHECK = TRUE
          IF(PRESENT(ERROR_VAL)) THEN
                   !
                   CHECK = FALSE
                   VAL = ERROR_VAL
                   !
          ELSEIF(PRESENT(MSG)) THEN
               !
               IF (MSG=='NOSTOP') THEN
                   CHECK = FALSE
                   VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)  !SET VAL TO NaN WHEN THERE IS NOSTOP OPTION
               END IF
               IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
               !
          ELSEIF(PRESENT(IOSTAT)) THEN
               !
               IF(IERR == Z .AND. LN(ISTART:ISTOP)==BLNK) THEN
                                                          IOSTAT = -1
               ELSE
                                                          IOSTAT = IERR
               END IF
               CHECK  = FALSE
               VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)   !SET VAL(I) TO NaN WHEN THERE IS NOSTOP OPTION
               IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
          ELSE IF(PRESENT(HAS_ERROR)) THEN
               !
               HAS_ERROR = TRUE
               CHECK  = FALSE
               VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)  !SET VAL TO NaN WHEN THERE IS NOSTOP OPTION
          END IF
          !
          IF(CHECK) THEN
              ERRMSG = 'GET_NUMBER READ UTILITY ERROR: FAILED TO CONVERT TEXT TO DOUBLE PRECISION NUMBER.'//BLN//'THE FOLLOWING IS THE TEXT ATTEMPTED TO BE CONVERTED "'//LN(ISTART:ISTOP)//'".'
              IF(LN(ISTART:ISTOP)==BLNK) ERRMSG = ERRMSG//BLN//'THE POSSIBLE REASON FOR THIS ERROR IS DUE TO READING IN A BLANK/EMPTY LINE OR YOU DID NOT PROVIDE ENOUGH NUMBERS ON THE LINE.'
              IF(PRESENT(MSG)) ERRMSG = ERRMSG//BLN//'THE FOLLOWING IS AN ADDITIONAL COMMENT PASSED TO GET_NUMBER:'//BLN//TRIM(MSG)
              !
              CALL STOP_ERROR(LN, IN, IOUT, ERRMSG )
          END IF
    END IF
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  SUBROUTINE GET_INTEGER_VEC(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,MSG,ERROR_VAL, HAS_ERROR, IOSTAT)
    CHARACTER(*),                  INTENT(IN   ):: LN                ! LINE TO PARSE DOUBLE FROM
    INTEGER,                       INTENT(INOUT):: LOC,ISTART,ISTOP  ! LOC => STARTING LOCATION TO FIND NUMBER, NUMBER AT EXIT IS LOCATED AT LN(ISTART:ISTOP) AND LOC = ISTOP+1
    INTEGER,                       INTENT(IN   ):: IOUT, IN          ! ERROR UNIT TO WRITE TO, FILE UNIT THAT LN ORIGINATED FROM
    INTEGER,         DIMENSION(:), INTENT(OUT  ):: VAL               ! DOUBLE VALUE TO RETURN
    CHARACTER(*),        OPTIONAL, INTENT(IN   ):: MSG               ! ERROR MESSAGE PRINTED WHEN FAIL TO LOAD NUMBER AND STOP PROGRAM, IF "NOSTOP" THEN VAL IS SET TO NaN
    INTEGER,             OPTIONAL, INTENT(IN   ):: ERROR_VAL         ! IF FAIL TO LOAD NUMBER, DO NOT STOP, BUT INSTEAD SET VAL =  ERROR_VAL
    LOGICAL,             OPTIONAL, INTENT(  OUT):: HAS_ERROR         ! SET TO TRUE IF THERE IS AN ERROR
    INTEGER,             OPTIONAL, INTENT(  OUT):: IOSTAT            ! SET to zero if there is no error, otherwise non-zero error code
    CONTIGUOUS:: VAL
    LOGICAL:: MUST_STOP
    INTEGER:: IERR, I
    CHARACTER(:), ALLOCATABLE:: ERRMSG
    !
    IF(PRESENT(HAS_ERROR)) HAS_ERROR = FALSE
    !
    MUST_STOP = FALSE
    VAL = Z
    !
    DO I=ONE,SIZE(VAL) 
              CALL PARSE_WORD(LN,LOC,ISTART,ISTOP)
              !
              READ(LN(ISTART:ISTOP),*, IOSTAT=IERR) VAL(I)
              !
              IF(IERR.NE.Z .OR. LN(ISTART:ISTOP)==BLNK) THEN
                    MUST_STOP = TRUE
                    IF(PRESENT(ERROR_VAL)) THEN
                             !
                             MUST_STOP = FALSE
                             VAL(I) = ERROR_VAL
                             !
                    ELSEIF(PRESENT(MSG)) THEN
                         !
                         IF (MSG=='NOSTOP') THEN
                             MUST_STOP = FALSE
                             VAL(I) = inf_I  !SET VAL TO HUGE(I) WHEN THERE IS NOSTOP OPTION. NOTE NAN DOES NOT EXIST FOR INT
                         END IF
                         IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
                         !
                    ELSEIF(PRESENT(IOSTAT)) THEN
                         !
                         IF(IERR == Z .AND. LN(ISTART:ISTOP)==BLNK) THEN
                                                                    IOSTAT = -1
                         ELSE
                                                                    IOSTAT = IERR
                         END IF
                         MUST_STOP = FALSE
                         VAL(I) = inf_I  !SET VAL TO HUGE(I) WHEN THERE IS NOSTOP OPTION. NOTE NAN DOES NOT EXIST FOR INT
                         IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
                    ELSE IF(PRESENT(HAS_ERROR)) THEN
                         !
                         HAS_ERROR = TRUE
                         MUST_STOP = FALSE
                         VAL(I) = inf_I  !SET VAL TO HUGE(I) WHEN THERE IS NOSTOP OPTION. NOTE NAN DOES NOT EXIST FOR INT
                    END IF
                    !
                    IF(MUST_STOP) THEN
                        IERR = SIZE(VAL) 
                        ERRMSG = 'GET_INTEGER READ UTILITY ERROR: EXPECTED TO READ '//NUM2STR(IERR)//' INTEGERS, BUT FAILED TO CONVERT THE POSITION '//NUM2STR(I)//' TEXT TO INTEGER.'//BLN//'THE FOLLOWING IS THE TEXT ATTEMPTED TO BE CONVERTED "'//LN(ISTART:ISTOP)//'".'//NL//'(IF THIS IS BLANK/EMPTY THEN YOU MAY NOT HAVE ENOUGH NUMBERS SPECIFIED ON THE LINE)'
                        IF(LN(ISTART:ISTOP)==BLNK) ERRMSG = ERRMSG//BLN//'THE POSSIBLE REASON FOR THIS ERROR IS DUE TO READING IN A BLANK/EMPTY LINE OR YOU DID NOT PROVIDE ENOUGH NUMBERS ON THE LINE.'
                        IF(PRESENT(MSG)) ERRMSG = ERRMSG//BLN//'THE FOLLOWING IS AN ADDITIONAL COMMENT PASSED TO GET_INTEGER:'//BLN//TRIM(MSG)
                        !
                        CALL STOP_ERROR(LN, IN, IOUT, ERRMSG )
                    END IF
              END IF
    END DO
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  SUBROUTINE GET_INTEGER_VAL(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,NO_PARSE_WORD,MSG, ERROR_VAL, HAS_ERROR, IOSTAT)  !IF NO_PARSE_WORD=TRUE, THEN ASSUMES ISTART AND ISTOP ARE ALREADY SET TO CORRECT LOCATION
    CHARACTER(*),           INTENT(IN   ):: LN                ! LINE TO PARSE DOUBLE FROM
    INTEGER,                INTENT(INOUT):: LOC,ISTART,ISTOP  ! LOC => STARTING LOCATION TO FIND NUMBER, NUMBER AT EXIT IS LOCATED AT LN(ISTART:ISTOP) AND LOC = ISTOP+1
    INTEGER,                INTENT(IN   ):: IOUT, IN          ! ERROR UNIT TO WRITE TO, FILE UNIT THAT LN ORIGINATED FROM
    INTEGER,                INTENT(OUT  ):: VAL               ! DOUBLE VALUE TO RETURN
    LOGICAL,      OPTIONAL, INTENT(IN   ):: NO_PARSE_WORD     ! INDCIATES THAT ISTART AND ISTOP ALREADY POINT TO NUMBER
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: MSG               ! ERROR MESSAGE PRINTED WHEN FAIL TO LOAD NUMBER AND STOP PROGRAM, IF "NOSTOP" THEN VAL IS SET TO inf_I = HUGE(VAL)
    INTEGER,      OPTIONAL, INTENT(IN   ):: ERROR_VAL         ! IF FAIL TO LOAD NUMBER, DO NOT STOP, BUT INSTEAD SET VAL =  ERROR_VAL
    LOGICAL,      OPTIONAL, INTENT(  OUT):: HAS_ERROR         ! SET TO TRUE IF THERE IS AN ERROR
    INTEGER,      OPTIONAL, INTENT(  OUT):: IOSTAT            ! SET to zero if there is no error, otherwise non-zero error code
    LOGICAL:: CHECK
    INTEGER:: IERR
    CHARACTER(:), ALLOCATABLE:: ERRMSG
    !
    IF(PRESENT(HAS_ERROR)) HAS_ERROR = FALSE
    !
    IF(PRESENT(NO_PARSE_WORD)) THEN
        CHECK = .NOT. NO_PARSE_WORD
    ELSE
        CHECK = TRUE
    END IF
    !
    IF(CHECK) CALL PARSE_WORD(LN,LOC,ISTART,ISTOP)
    !
    READ(LN(ISTART:ISTOP),*, IOSTAT=IERR) VAL
    !
    IF(IERR.NE.Z .OR. LN(ISTART:ISTOP)==BLNK) THEN
          CHECK = TRUE
          IF(PRESENT(ERROR_VAL)) THEN
                   !
                   CHECK = FALSE
                   VAL = ERROR_VAL
                   !
          ELSEIF(PRESENT(MSG)) THEN
               !
               IF (MSG=='NOSTOP') THEN
                   CHECK = FALSE
                   VAL = inf_I  !SET VAL TO HUGE(I) WHEN THERE IS NOSTOP OPTION. NOTE NAN DOES NOT EXIST FOR INT
               END IF
               IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
               !
          ELSEIF(PRESENT(IOSTAT)) THEN
               !
               IF(IERR == Z .AND. LN(ISTART:ISTOP)==BLNK) THEN
                                                          IOSTAT = -1
               ELSE
                                                          IOSTAT = IERR
               END IF
               CHECK  = FALSE
               VAL = inf_I  !SET VAL TO HUGE(I) WHEN THERE IS NOSTOP OPTION. NOTE NAN DOES NOT EXIST FOR INT
               IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
          ELSE IF(PRESENT(HAS_ERROR)) THEN
               !
               HAS_ERROR = TRUE
               CHECK  = FALSE
               VAL = inf_I  !SET VAL TO HUGE(I) WHEN THERE IS NOSTOP OPTION. NOTE NAN DOES NOT EXIST FOR INT
          END IF
          !
          IF(CHECK) THEN
              ERRMSG = 'GET_INTEGER READ UTILITY ERROR: FAILED TO CONVERT TEXT TO INTEGER NUMBER.'//BLN//'THE FOLLOWING IS THE TEXT ATTEMPTED TO BE CONVERTED "'//LN(ISTART:ISTOP)//'".'
              IF(LN(ISTART:ISTOP)==BLNK) ERRMSG = ERRMSG//BLN//'THE POSSIBLE REASON FOR THIS ERROR IS DUE TO READING IN A BLANK/EMPTY LINE OR YOU DID NOT PROVIDE ENOUGH NUMBERS ON THE LINE.'
              IF(PRESENT(MSG)) ERRMSG = ERRMSG//BLN//'THE FOLLOWING IS AN ADDITIONAL COMMENT PASSED TO GET_INTEGER:'//BLN//TRIM(MSG)
              !
              CALL STOP_ERROR(LN, IN, IOUT, ERRMSG )
          END IF
    END IF
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  SUBROUTINE GET_REAL_VEC(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,MSG,ERROR_VAL, HAS_ERROR, IOSTAT) 
    CHARACTER(*),                  INTENT(IN   ):: LN                ! LINE TO PARSE DOUBLE FROM
    INTEGER,                       INTENT(INOUT):: LOC,ISTART,ISTOP  ! LOC => STARTING LOCATION TO FIND NUMBER, NUMBER AT EXIT IS LOCATED AT LN(ISTART:ISTOP) AND LOC = ISTOP+1
    INTEGER,                       INTENT(IN   ):: IOUT, IN          ! ERROR UNIT TO WRITE TO, FILE UNIT THAT LN ORIGINATED FROM
    REAL(REAL32),    DIMENSION(:), INTENT(OUT  ):: VAL               ! DOUBLE VALUE TO RETURN
    CHARACTER(*),        OPTIONAL, INTENT(IN   ):: MSG               ! ERROR MESSAGE PRINTED WHEN FAIL TO LOAD NUMBER AND STOP PROGRAM, IF "NOSTOP" THEN VAL IS SET TO NaN
    REAL(REAL32),        OPTIONAL, INTENT(IN   ):: ERROR_VAL         ! IF FAIL TO LOAD NUMBER, DO NOT STOP, BUT INSTEAD SET VAL =  ERROR_VAL
    LOGICAL,             OPTIONAL, INTENT(  OUT):: HAS_ERROR         ! SET TO TRUE IF THERE IS AN ERROR
    INTEGER,             OPTIONAL, INTENT(  OUT):: IOSTAT            ! SET to zero if there is no error, otherwise non-zero error code
    CONTIGUOUS:: VAL
    LOGICAL:: MUST_STOP
    INTEGER:: IERR, I
    CHARACTER(:), ALLOCATABLE:: ERRMSG
    !
    IF(PRESENT(HAS_ERROR)) HAS_ERROR = FALSE
    !
    MUST_STOP = FALSE
    VAL  = DZ
    IERR = Z
    !
    DO I=ONE,SIZE(VAL) 
              CALL PARSE_WORD(LN,LOC,ISTART,ISTOP)
              !
              SELECT CASE(LN(ISTART:ISTOP))
              CASE('NAN',  'NaN', 'nan'); VAL(I) = IEEE_VALUE(VAL(I), IEEE_QUIET_NAN)
              CASE('INF',  'inf', 'Inf'); VAL(I) =  inf_R
              CASE('-INF','-inf','-Inf'); VAL(I) = ninf_R
              CASE(  '-1', '-1.','-1.0'); VAL(I) = -1.0
              CASE(   '0',  '0.', '0.0'); VAL(I) =  0.0
              CASE(   '1',  '1.', '1.0'); VAL(I) =  1.0
              CASE DEFAULT
                          READ(LN(ISTART:ISTOP),*, IOSTAT=IERR) VAL(I)
              END SELECT
              !
              IF(IERR.NE.Z .OR. LN(ISTART:ISTOP)==BLNK) THEN
                    MUST_STOP = TRUE
                    IF(PRESENT(ERROR_VAL)) THEN
                             !
                             MUST_STOP = FALSE
                             VAL(I) = ERROR_VAL
                             !
                    ELSEIF(PRESENT(MSG)) THEN
                         !
                         IF (MSG=='NOSTOP') THEN
                             MUST_STOP = FALSE
                             VAL(I) = IEEE_VALUE(VAL(I), IEEE_QUIET_NAN)   !SET VAL(I) TO NaN WHEN THERE IS NOSTOP OPTION
                         END IF
                         IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
                         !
                    ELSEIF(PRESENT(IOSTAT)) THEN
                         !
                         IF(IERR == Z .AND. LN(ISTART:ISTOP)==BLNK) THEN
                                                                    IOSTAT = -1
                         ELSE
                                                                    IOSTAT = IERR
                         END IF
                         MUST_STOP = FALSE
                         VAL(I) = IEEE_VALUE(VAL(I), IEEE_QUIET_NAN)   !SET VAL(I) TO NaN WHEN THERE IS NOSTOP OPTION
                         IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
                    ELSE IF(PRESENT(HAS_ERROR)) THEN
                         !
                         MUST_STOP = FALSE
                         HAS_ERROR = TRUE
                         VAL(I)= IEEE_VALUE(VAL(I), IEEE_QUIET_NAN)  !SET VAL TO NaN WHEN THERE IS NOSTOP OPTION
                    END IF
                    !
                    IF(MUST_STOP) THEN
                        ERRMSG = 'GET_NUMBER READ UTILITY ERROR: FAILED TO CONVERT TEXT TO SINGLE PRECISION NUMBER.'//BLN//'THE FOLLOWING IS THE TEXT ATTEMPTED TO BE CONVERTED "'//LN(ISTART:ISTOP)//'".'//NL//'(IF THIS IS BLANK/EMPTY THEN YOU MAY NOT HAVE ENOUGH NUMBERS SPECIFIED ON THE LINE)'
                        IF(LN(ISTART:ISTOP)==BLNK) ERRMSG = ERRMSG//BLN//'THE POSSIBLE REASON FOR THIS ERROR IS DUE TO READING IN A BLANK/EMPTY LINE OR YOU DID NOT PROVIDE ENOUGH NUMBERS ON THE LINE.'
                        IF(PRESENT(MSG)) ERRMSG = ERRMSG//BLN//'THE FOLLOWING IS AN ADDITIONAL COMMENT PASSED TO GET_NUMBER:'//BLN//TRIM(MSG)
                        !
                        CALL STOP_ERROR(LN, IN, IOUT, ERRMSG )
                    END IF
              END IF
    END DO
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  SUBROUTINE GET_REAL_VAL(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,NO_PARSE_WORD,MSG,ERROR_VAL, HAS_ERROR, IOSTAT)  !IF NO_PARSE_WORD=TRUE, THEN ASSUMES ISTART AND ISTOP ARE ALREADY SET TO CORRECT LOCATION
    CHARACTER(*),           INTENT(IN   ):: LN                ! LINE TO PARSE DOUBLE FROM
    INTEGER,                INTENT(INOUT):: LOC,ISTART,ISTOP  ! LOC => STARTING LOCATION TO FIND NUMBER, NUMBER AT EXIT IS LOCATED AT LN(ISTART:ISTOP) AND LOC = ISTOP+1
    INTEGER,                INTENT(IN   ):: IOUT, IN          ! ERROR UNIT TO WRITE TO, FILE UNIT THAT LN ORIGINATED FROM
    REAL(REAL32),           INTENT(OUT  ):: VAL               ! DOUBLE VALUE TO RETURN
    LOGICAL,      OPTIONAL, INTENT(IN   ):: NO_PARSE_WORD     ! INDCIATES THAT ISTART AND ISTOP ALREADY POINT TO NUMBER
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: MSG               ! ERROR MESSAGE PRINTED WHEN FAIL TO LOAD NUMBER AND STOP PROGRAM, IF "NOSTOP" THEN VAL IS SET TO NaN
    REAL(REAL32), OPTIONAL, INTENT(IN   ):: ERROR_VAL         ! IF FAIL TO LOAD NUMBER, DO NOT STOP, BUT INSTEAD SET VAL =  ERROR_VAL
    LOGICAL,      OPTIONAL, INTENT(  OUT):: HAS_ERROR         ! SET TO TRUE IF THERE IS AN ERROR
    INTEGER,      OPTIONAL, INTENT(  OUT):: IOSTAT            ! SET to zero if there is no error, otherwise non-zero error code
    LOGICAL:: CHECK
    INTEGER:: IERR
    CHARACTER(:), ALLOCATABLE:: ERRMSG
    !
    IF(PRESENT(HAS_ERROR)) HAS_ERROR = FALSE
    !
    IF(PRESENT(NO_PARSE_WORD)) THEN
        CHECK = .NOT. NO_PARSE_WORD
    ELSE
        CHECK = TRUE
    END IF
    !
    IF(CHECK) CALL PARSE_WORD(LN,LOC,ISTART,ISTOP)
    !
    IERR = Z
    SELECT CASE(LN(ISTART:ISTOP))
    CASE('NAN',  'NaN', 'nan'); VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)
    CASE('INF',  'inf', 'Inf'); VAL =  inf_R
    CASE('-INF','-inf','-Inf'); VAL = ninf_R
    CASE(  '-1', '-1.','-1.0'); VAL = -1.0
    CASE(   '0',  '0.', '0.0'); VAL =  0.0
    CASE(   '1',  '1.', '1.0'); VAL =  1.0
    CASE DEFAULT
                READ(LN(ISTART:ISTOP),*, IOSTAT=IERR) VAL
    END SELECT
    !
    
    !
    IF(IERR.NE.Z .OR. LN(ISTART:ISTOP)==BLNK) THEN
          CHECK = TRUE
          IF(PRESENT(ERROR_VAL)) THEN
                   !
                   CHECK = FALSE
                   VAL = ERROR_VAL
                   !
          ELSEIF(PRESENT(MSG)) THEN
               !
               IF (MSG=='NOSTOP') THEN
                   CHECK = FALSE
                   VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)  !SET VAL TO NaN WHEN THERE IS NOSTOP OPTION
               END IF
               IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
               !
          ELSEIF(PRESENT(IOSTAT)) THEN
               !
               IF(IERR == Z .AND. LN(ISTART:ISTOP)==BLNK) THEN
                                                          IOSTAT = -1
               ELSE
                                                          IOSTAT = IERR
               END IF
               CHECK  = FALSE
               VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)   !SET VAL(I) TO NaN WHEN THERE IS NOSTOP OPTION
               IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
          ELSE IF(PRESENT(HAS_ERROR)) THEN
               !
               HAS_ERROR = TRUE
               CHECK  = FALSE
               VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)  !SET VAL TO NaN WHEN THERE IS NOSTOP OPTION
          END IF
          !
          IF(CHECK) THEN
              ERRMSG = 'GET_NUMBER READ UTILITY ERROR: FAILED TO CONVERT TEXT TO SINGLE PRECISION NUMBER.'//BLN//'THE FOLLOWING IS THE TEXT ATTEMPTED TO BE CONVERTED "'//LN(ISTART:ISTOP)//'".'
              IF(LN(ISTART:ISTOP)==BLNK) ERRMSG = ERRMSG//BLN//'THE POSSIBLE REASON FOR THIS ERROR IS DUE TO READING IN A BLANK/EMPTY LINE OR YOU DID NOT PROVIDE ENOUGH NUMBERS ON THE LINE.'
              IF(PRESENT(MSG)) ERRMSG = ERRMSG//BLN//'THE FOLLOWING IS AN ADDITIONAL COMMENT PASSED TO GET_NUMBER:'//BLN//TRIM(MSG)
              !
              CALL STOP_ERROR(LN, IN, IOUT, ERRMSG )
          END IF
    END IF
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  SUBROUTINE GET_QUAD_VEC(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,MSG,ERROR_VAL, HAS_ERROR, IOSTAT) 
    CHARACTER(*),                  INTENT(IN   ):: LN                ! LINE TO PARSE DOUBLE FROM
    INTEGER,                       INTENT(INOUT):: LOC,ISTART,ISTOP  ! LOC => STARTING LOCATION TO FIND NUMBER, NUMBER AT EXIT IS LOCATED AT LN(ISTART:ISTOP) AND LOC = ISTOP+1
    INTEGER,                       INTENT(IN   ):: IOUT, IN          ! ERROR UNIT TO WRITE TO, FILE UNIT THAT LN ORIGINATED FROM
    REAL(REAL128),   DIMENSION(:), INTENT(OUT  ):: VAL               ! DOUBLE VALUE TO RETURN
    CHARACTER(*),        OPTIONAL, INTENT(IN   ):: MSG               ! ERROR MESSAGE PRINTED WHEN FAIL TO LOAD NUMBER AND STOP PROGRAM, IF "NOSTOP" THEN VAL IS SET TO NaN
    REAL(REAL128),       OPTIONAL, INTENT(IN   ):: ERROR_VAL         ! IF FAIL TO LOAD NUMBER, DO NOT STOP, BUT INSTEAD SET VAL =  ERROR_VAL
    LOGICAL,             OPTIONAL, INTENT(  OUT):: HAS_ERROR         ! SET TO TRUE IF THERE IS AN ERROR
    INTEGER,             OPTIONAL, INTENT(  OUT):: IOSTAT            ! SET to zero if there is no error, otherwise non-zero error code
    CONTIGUOUS:: VAL
    LOGICAL:: MUST_STOP
    INTEGER:: IERR, I
    CHARACTER(:), ALLOCATABLE:: ERRMSG
    !
    IF(PRESENT(HAS_ERROR)) HAS_ERROR = FALSE
    !
    MUST_STOP = FALSE
    VAL  = DZ
    IERR = Z
    !
    DO I=ONE,SIZE(VAL) 
              CALL PARSE_WORD(LN,LOC,ISTART,ISTOP)
              !
              SELECT CASE(LN(ISTART:ISTOP))
              CASE('NAN',  'NaN', 'nan'); VAL(I) = IEEE_VALUE(VAL(I), IEEE_QUIET_NAN)
              CASE('INF',  'inf', 'Inf'); VAL(I) =  inf_R
              CASE('-INF','-inf','-Inf'); VAL(I) = ninf_R
              CASE(  '-1', '-1.','-1.0'); VAL(I) = -1.0
              CASE(   '0',  '0.', '0.0'); VAL(I) =  0.0
              CASE(   '1',  '1.', '1.0'); VAL(I) =  1.0
              CASE DEFAULT
                          READ(LN(ISTART:ISTOP),*, IOSTAT=IERR) VAL(I)
              END SELECT
              !
              IF(IERR.NE.Z .OR. LN(ISTART:ISTOP)==BLNK) THEN
                    MUST_STOP = TRUE
                    IF(PRESENT(ERROR_VAL)) THEN
                             !
                             MUST_STOP = FALSE
                             VAL(I) = ERROR_VAL
                             !
                    ELSEIF(PRESENT(MSG)) THEN
                         !
                         IF (MSG=='NOSTOP') THEN
                             MUST_STOP = FALSE
                             VAL(I) = IEEE_VALUE(VAL(I), IEEE_QUIET_NAN)   !SET VAL(I) TO NaN WHEN THERE IS NOSTOP OPTION
                         END IF
                         IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
                         !
                    ELSEIF(PRESENT(IOSTAT)) THEN
                         !
                         IF(IERR == Z .AND. LN(ISTART:ISTOP)==BLNK) THEN
                                                                    IOSTAT = -1
                         ELSE
                                                                    IOSTAT = IERR
                         END IF
                         MUST_STOP = FALSE
                         VAL(I) = IEEE_VALUE(VAL(I), IEEE_QUIET_NAN)   !SET VAL(I) TO NaN WHEN THERE IS NOSTOP OPTION
                         IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
                    ELSE IF(PRESENT(HAS_ERROR)) THEN
                         !
                         MUST_STOP = FALSE
                         HAS_ERROR = TRUE
                         VAL(I)= IEEE_VALUE(VAL(I), IEEE_QUIET_NAN)  !SET VAL TO NaN WHEN THERE IS NOSTOP OPTION
                    END IF
                    !
                    IF(MUST_STOP) THEN
                        ERRMSG = 'GET_NUMBER READ UTILITY ERROR: FAILED TO CONVERT TEXT TO SINGLE PRECISION NUMBER.'//BLN//'THE FOLLOWING IS THE TEXT ATTEMPTED TO BE CONVERTED "'//LN(ISTART:ISTOP)//'".'//NL//'(IF THIS IS BLANK/EMPTY THEN YOU MAY NOT HAVE ENOUGH NUMBERS SPECIFIED ON THE LINE)'
                        IF(LN(ISTART:ISTOP)==BLNK) ERRMSG = ERRMSG//BLN//'THE POSSIBLE REASON FOR THIS ERROR IS DUE TO READING IN A BLANK/EMPTY LINE OR YOU DID NOT PROVIDE ENOUGH NUMBERS ON THE LINE.'
                        IF(PRESENT(MSG)) ERRMSG = ERRMSG//BLN//'THE FOLLOWING IS AN ADDITIONAL COMMENT PASSED TO GET_NUMBER:'//BLN//TRIM(MSG)
                        !
                        CALL STOP_ERROR(LN, IN, IOUT, ERRMSG )
                    END IF
              END IF
    END DO
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  SUBROUTINE GET_QUAD_VAL(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,NO_PARSE_WORD,MSG,ERROR_VAL, HAS_ERROR, IOSTAT)  !IF NO_PARSE_WORD=TRUE, THEN ASSUMES ISTART AND ISTOP ARE ALREADY SET TO CORRECT LOCATION
    CHARACTER(*),           INTENT(IN   ):: LN                ! LINE TO PARSE DOUBLE FROM
    INTEGER,                INTENT(INOUT):: LOC,ISTART,ISTOP  ! LOC => STARTING LOCATION TO FIND NUMBER, NUMBER AT EXIT IS LOCATED AT LN(ISTART:ISTOP) AND LOC = ISTOP+1
    INTEGER,                INTENT(IN   ):: IOUT, IN          ! ERROR UNIT TO WRITE TO, FILE UNIT THAT LN ORIGINATED FROM
    REAL(REAL128),          INTENT(OUT  ):: VAL               ! DOUBLE VALUE TO RETURN
    LOGICAL,      OPTIONAL, INTENT(IN   ):: NO_PARSE_WORD     ! INDCIATES THAT ISTART AND ISTOP ALREADY POINT TO NUMBER
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: MSG               ! ERROR MESSAGE PRINTED WHEN FAIL TO LOAD NUMBER AND STOP PROGRAM, IF "NOSTOP" THEN VAL IS SET TO NaN
    REAL(REAL128),OPTIONAL, INTENT(IN   ):: ERROR_VAL         ! IF FAIL TO LOAD NUMBER, DO NOT STOP, BUT INSTEAD SET VAL =  ERROR_VAL
    LOGICAL,      OPTIONAL, INTENT(  OUT):: HAS_ERROR         ! SET TO TRUE IF THERE IS AN ERROR
    INTEGER,      OPTIONAL, INTENT(  OUT):: IOSTAT            ! SET to zero if there is no error, otherwise non-zero error code
    LOGICAL:: CHECK
    INTEGER:: IERR
    CHARACTER(:), ALLOCATABLE:: ERRMSG
    !
    IF(PRESENT(HAS_ERROR)) HAS_ERROR = FALSE
    !
    IF(PRESENT(NO_PARSE_WORD)) THEN
        CHECK = .NOT. NO_PARSE_WORD
    ELSE
        CHECK = TRUE
    END IF
    !
    IF(CHECK) CALL PARSE_WORD(LN,LOC,ISTART,ISTOP)
    !
    IERR = Z
    SELECT CASE(LN(ISTART:ISTOP))
    CASE('NAN',  'NaN', 'nan'); VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)
    CASE('INF',  'inf', 'Inf'); VAL =  inf_R
    CASE('-INF','-inf','-Inf'); VAL = ninf_R
    CASE(  '-1', '-1.','-1.0'); VAL = -1.0
    CASE(   '0',  '0.', '0.0'); VAL =  0.0
    CASE(   '1',  '1.', '1.0'); VAL =  1.0
    CASE DEFAULT
                READ(LN(ISTART:ISTOP),*, IOSTAT=IERR) VAL
    END SELECT
    !
    
    !
    IF(IERR.NE.Z .OR. LN(ISTART:ISTOP)==BLNK) THEN
          CHECK = TRUE
          IF(PRESENT(ERROR_VAL)) THEN
                   !
                   CHECK = FALSE
                   VAL = ERROR_VAL
                   !
          ELSEIF(PRESENT(MSG)) THEN
               !
               IF (MSG=='NOSTOP') THEN
                   CHECK = FALSE
                   VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)  !SET VAL TO NaN WHEN THERE IS NOSTOP OPTION
               END IF
               IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
               !
          ELSEIF(PRESENT(IOSTAT)) THEN
               !
               IF(IERR == Z .AND. LN(ISTART:ISTOP)==BLNK) THEN
                                                          IOSTAT = -1
               ELSE
                                                          IOSTAT = IERR
               END IF
               CHECK  = FALSE
               VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)   !SET VAL(I) TO NaN WHEN THERE IS NOSTOP OPTION
               IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
          ELSE IF(PRESENT(HAS_ERROR)) THEN
               !
               HAS_ERROR = TRUE
               CHECK  = FALSE
               VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)  !SET VAL TO NaN WHEN THERE IS NOSTOP OPTION
          END IF
          !
          IF(CHECK) THEN
              ERRMSG = 'GET_NUMBER READ UTILITY ERROR: FAILED TO CONVERT TEXT TO SINGLE PRECISION NUMBER.'//BLN//'THE FOLLOWING IS THE TEXT ATTEMPTED TO BE CONVERTED "'//LN(ISTART:ISTOP)//'".'
              IF(LN(ISTART:ISTOP)==BLNK) ERRMSG = ERRMSG//BLN//'THE POSSIBLE REASON FOR THIS ERROR IS DUE TO READING IN A BLANK/EMPTY LINE OR YOU DID NOT PROVIDE ENOUGH NUMBERS ON THE LINE.'
              IF(PRESENT(MSG)) ERRMSG = ERRMSG//BLN//'THE FOLLOWING IS AN ADDITIONAL COMMENT PASSED TO GET_NUMBER:'//BLN//TRIM(MSG)
              !
              CALL STOP_ERROR(LN, IN, IOUT, ERRMSG )
          END IF
    END IF
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  !SUBROUTINE GET_REAL_VAL(LN,LOC,ISTART,ISTOP,IOUT,IN,VAL,NO_PARSE_WORD,MSG,ERROR_VAL, HAS_ERROR)  !IF NO_PARSE_WORD=TRUE, THEN ASSUMES ISTART AND ISTOP ARE ALREADY SET TO CORRECT LOCATION
  !  CHARACTER(*),           INTENT(IN   ):: LN                ! LINE TO PARSE DOUBLE FROM
  !  INTEGER,                INTENT(INOUT):: LOC,ISTART,ISTOP  ! LOC => STARTING LOCATION TO FIND NUMBER, NUMBER AT EXIT IS LOCATED AT LN(ISTART:ISTOP) AND LOC = ISTOP+1
  !  INTEGER,                INTENT(IN   ):: IOUT, IN          ! ERROR UNIT TO WRITE TO, FILE UNIT THAT LN ORIGINATED FROM
  !  REAL(REAL32),           INTENT(OUT  ):: VAL               ! REAL VALUE TO RETURN
  !  LOGICAL,      OPTIONAL, INTENT(IN   ):: NO_PARSE_WORD     ! INDCIATES THAT ISTART AND ISTOP ALREADY POINT TO NUMBER
  !  CHARACTER(*), OPTIONAL, INTENT(IN   ):: MSG               ! ERROR MESSAGE PRINTED WHEN FAIL TO LOAD NUMBER AND STOP PROGRAM, IF "NOSTOP" THEN VAL IS SET TO NaN
  !  REAL(REAL32), OPTIONAL, INTENT(IN   ):: ERROR_VAL         ! IF FAIL TO LOAD NUMBER, DO NOT STOP, BUT INSTEAD SET VAL =  ERROR_VAL
  !  LOGICAL,      OPTIONAL, INTENT(  OUT):: HAS_ERROR         ! SET TO TRUE IF THERE IS AN ERROR
  !  LOGICAL:: CHECK
  !  INTEGER:: IERR
  !  CHARACTER(:), ALLOCATABLE:: ERRMSG
  !  !
  !  IF(PRESENT(HAS_ERROR)) HAS_ERROR = FALSE
  !  !
  !  IF(PRESENT(NO_PARSE_WORD)) THEN
  !      CHECK = .NOT. NO_PARSE_WORD
  !  ELSE
  !      CHECK = TRUE
  !  END IF
  !  !
  !  IF(CHECK) CALL PARSE_WORD(LN,LOC,ISTART,ISTOP)
  !  !
  !  READ(LN(ISTART:ISTOP),*, IOSTAT=IERR) VAL
  !  !
  !  IF(IERR.NE.Z .OR. LN(ISTART:ISTOP)==BLNK) THEN
  !        CHECK = TRUE
  !        IF(PRESENT(ERROR_VAL)) THEN
  !                 !
  !                 CHECK = FALSE
  !                 VAL = ERROR_VAL
  !                 !
  !        ELSEIF(PRESENT(MSG)) THEN
  !             !
  !             IF (MSG=='NOSTOP') THEN
  !                 CHECK = FALSE
  !                 VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)  !SET VAL TO NaN WHEN THERE IS NOSTOP OPTION
  !             END IF
  !             IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
  !        ELSE IF(PRESENT(HAS_ERROR)) THEN
  !             !
  !             HAS_ERROR = TRUE
  !             CHECK  = FALSE
  !             VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)  !SET VAL TO NaN WHEN THERE IS NOSTOP OPTION
  !        END IF
  !        !
  !        IF(CHECK) THEN
  !            ERRMSG = 'GET_NUMBER READ UTILITY ERROR: FAILED TO CONVERT TEXT TO SINGLE PRECISION NUMBER.'//BLN//'THE FOLLOWING IS THE TEXT ATTEMPTED TO BE CONVERTED "'//LN(ISTART:ISTOP)//'".'
  !            IF(LN(ISTART:ISTOP)==BLNK) ERRMSG = ERRMSG//BLN//'THE POSSIBLE REASON FOR THIS ERROR IS DUE TO READING IN A BLANK/EMPTY LINE OR YOU DID NOT PROVIDE ENOUGH NUMBERS ON THE LINE.'
  !            IF(PRESENT(MSG)) ERRMSG = ERRMSG//BLN//'THE FOLLOWING IS AN ADDITIONAL COMMENT PASSED TO GET_NUMBER:'//BLN//TRIM(MSG)
  !            !
  !            CALL STOP_ERROR(LN, IN, IOUT, ERRMSG )
  !        END IF
  !  END IF
  !  !
  !END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  SUBROUTINE GET_WORD_ASSUM(WORD,LN,LOC,OLD_LOC,COM_STOP,NO_UPCASE)  ! SETS WORD TO PARSED WORD, SETS IT TO "" IF END OF LINE OR NO WORD PARSED
    CHARACTER(*),           INTENT(IN   ):: LN                ! LINE TO PARSE WORD FROM
    INTEGER,                INTENT(INOUT):: LOC               ! LOC => STARTING LOCATION TO FIND WORD
    CHARACTER(*),           INTENT(  OUT):: WORD              ! RETURN WORD
    LOGICAL,      OPTIONAL, INTENT(IN   ):: NO_UPCASE         !SET IF YOU WANT TO LEAVE WORD ALONE
    INTEGER,      OPTIONAL, INTENT(INOUT):: OLD_LOC           !RETURN ORIGINAL LOC LOCATION
    LOGICAL,      OPTIONAL, INTENT(IN   ):: COM_STOP
    INTEGER:: LOC0,ISTART,ISTOP
    !
    LOC0=LOC
    CALL PARSE_WORD(LN,LOC,ISTART,ISTOP,COM_STOP)
    !
    IF(ISTART.LE.ISTOP) THEN
        !
        WORD = LN(ISTART:ISTOP)
        !
        IF(PRESENT(NO_UPCASE)) THEN
            IF(.NOT. NO_UPCASE) CALL UPPER(WORD)
        ELSE
                                CALL UPPER(WORD)
        END IF
    ELSE
        WORD = BLNK
    END IF
    !
    IF(PRESENT(OLD_LOC)) OLD_LOC = LOC0  !HAS TO BE AT END BECAUSE LOC COULD BE ALSO PASSED IN AS OLD_LOC
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  SUBROUTINE GET_WORD_ALLOC(WORD,LN,LOC,IS_ALLOC,OLD_LOC,COM_STOP,NO_UPCASE)  ! SETS WORD TO PARSED WORD, SETS IT TO "" IF END OF LINE OR NO WORD PARSED
    CHARACTER(*),             INTENT(IN   ):: LN                ! LINE TO PARSE WORD FROM
    INTEGER,                  INTENT(INOUT):: LOC               ! LOC => STARTING LOCATION TO FIND WORD
    CHARACTER(:),ALLOCATABLE, INTENT(INOUT):: WORD              ! RETURN WORD
    LOGICAL,                  INTENT(IN   ):: IS_ALLOC
    LOGICAL,      OPTIONAL,   INTENT(IN   ):: NO_UPCASE         !SET IF YOU WANT TO LEAVE WORD ALONE
    INTEGER,      OPTIONAL,   INTENT(INOUT):: OLD_LOC           !RETURN ORIGINAL LOC LOCATION
    LOGICAL,      OPTIONAL,   INTENT(IN   ):: COM_STOP
    INTEGER:: LOC0,ISTART,ISTOP
    !
    LOC0=LOC
    CALL PARSE_WORD(LN,LOC,ISTART,ISTOP,COM_STOP)
    !
    IF(ISTART.LE.ISTOP) THEN
        !
        IF(IS_ALLOC) THEN
           IF(ALLOCATED(WORD)) DEALLOCATE(WORD)
           ALLOCATE(WORD, SOURCE=LN(ISTART:ISTOP))
        ELSE
            WORD=LN(ISTART:ISTOP)
        END IF
        !
        IF(PRESENT(NO_UPCASE)) THEN
            IF(.NOT. NO_UPCASE) CALL UPPER(WORD)
        ELSE
                                CALL UPPER(WORD)
        END IF
    ELSE
        IF(IS_ALLOC) THEN
           IF(ALLOCATED(WORD)) DEALLOCATE(WORD)
           ALLOCATE(WORD, SOURCE=BLNK)
        ELSE
            WORD=BLNK
        END IF
    END IF
    !
    IF(PRESENT(OLD_LOC)) OLD_LOC = LOC0  !HAS TO BE AT END BECAUSE LOC COULD BE ALSO PASSED IN AS OLD_LOC
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  SUBROUTINE GET_WORD_ASSUM_ISTART(LN,LOC,ISTART,ISTOP,WORD,OLD_LOC,COM_STOP,NO_UPCASE)  ! SETS WORD TO PARSED WORD, SETS IT TO "" IF END OF LINE OR NO WORD PARSED
    CHARACTER(*),           INTENT(IN   ):: LN                ! LINE TO PARSE WORD FROM
    INTEGER,                INTENT(INOUT):: LOC               ! LOC => STARTING LOCATION TO FIND WORD
    INTEGER,                INTENT(INOUT):: ISTART,ISTOP
    CHARACTER(*),           INTENT(  OUT):: WORD              ! RETURN WORD
    LOGICAL,      OPTIONAL, INTENT(IN   ):: NO_UPCASE         !SET IF YOU WANT TO LEAVE WORD ALONE
    INTEGER,      OPTIONAL, INTENT(INOUT):: OLD_LOC           !RETURN ORIGINAL LOC LOCATION
    LOGICAL,      OPTIONAL, INTENT(IN   ):: COM_STOP
    INTEGER:: LOC0
    !
    LOC0=LOC
    CALL PARSE_WORD(LN,LOC,ISTART,ISTOP,COM_STOP)
    !
    IF(ISTART.LE.ISTOP) THEN
        !
        WORD = LN(ISTART:ISTOP)
        !
        IF(PRESENT(NO_UPCASE)) THEN
            IF(.NOT. NO_UPCASE) CALL UPPER(WORD)
        ELSE
                                CALL UPPER(WORD)
        END IF
    ELSE
        WORD = BLNK
    END IF
    !
    IF(PRESENT(OLD_LOC)) OLD_LOC = LOC0  !HAS TO BE AT END BECAUSE LOC COULD BE ALSO PASSED IN AS OLD_LOC
    !
    END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  SUBROUTINE GET_WORD_ALLOC_ISTART(LN,LOC,ISTART,ISTOP,WORD,IS_ALLOC,OLD_LOC,COM_STOP,NO_UPCASE)  ! SETS WORD TO PARSED WORD, SETS IT TO "" IF END OF LINE OR NO WORD PARSED
    CHARACTER(*),             INTENT(IN   ):: LN                ! LINE TO PARSE WORD FROM
    INTEGER,                  INTENT(INOUT):: LOC               ! LOC => STARTING LOCATION TO FIND WORD
    INTEGER,                  INTENT(INOUT):: ISTART,ISTOP
    CHARACTER(:),ALLOCATABLE, INTENT(  OUT):: WORD              ! RETURN WORD
    LOGICAL,                  INTENT(IN   ):: IS_ALLOC
    LOGICAL,      OPTIONAL,   INTENT(IN   ):: NO_UPCASE         !SET IF YOU WANT TO LEAVE WORD ALONE
    INTEGER,      OPTIONAL,   INTENT(INOUT):: OLD_LOC           !RETURN ORIGINAL LOC LOCATION
    LOGICAL,      OPTIONAL,   INTENT(IN   ):: COM_STOP
    INTEGER:: LOC0
    !
    LOC0=LOC
    CALL PARSE_WORD(LN,LOC,ISTART,ISTOP,COM_STOP)
    !
    IF(ISTART.LE.ISTOP) THEN
        !
        IF(IS_ALLOC) THEN
           IF(ALLOCATED(WORD)) DEALLOCATE(WORD)
           ALLOCATE(WORD, SOURCE=LN(ISTART:ISTOP))
        ELSE
            WORD=LN(ISTART:ISTOP)
        END IF
        !
        IF(PRESENT(NO_UPCASE)) THEN
            IF(.NOT. NO_UPCASE) CALL UPPER(WORD)
        ELSE
                                CALL UPPER(WORD)
        END IF
    ELSE
        IF(IS_ALLOC) THEN
           IF(ALLOCATED(WORD)) DEALLOCATE(WORD)
           ALLOCATE(WORD, SOURCE=BLNK)
        ELSE
            WORD=BLNK
        END IF
    END IF
    !
    IF(PRESENT(OLD_LOC)) OLD_LOC = LOC0  !HAS TO BE AT END BECAUSE LOC COULD BE ALSO PASSED IN AS OLD_LOC
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  SUBROUTINE GET_FILE_NAME(IU,FNAME,EXIST,IOUT,IN,MSG,HAS_ERROR, LINE) 
    INTEGER,                 INTENT(IN   ):: IU                ! UNIT NUMBER TO LOOK FILE NAME UP FROM
    CHARACTER(:),ALLOCATABLE,INTENT(OUT  ):: FNAME             ! FILE NAME ASSOCIATED WITH UNIT NUMBER
    LOGICAL, OPTIONAL,       INTENT(OUT  ):: EXIST             ! RETURN TRUE IF UNIT NUMBER IS ATTACHED TO A FILE THAT EXISTS
    INTEGER, OPTIONAL,       INTENT(IN   ):: IOUT, IN          ! ERROR UNIT TO WRITE TO, FILE UNIT THAT LN ORIGINATED FROM -- FOR ERROR REPORTING
    CHARACTER(*), OPTIONAL,  INTENT(IN   ):: MSG               ! ERROR MESSAGE PRINTED WHEN FAIL TO LOAD NUMBER AND STOP PROGRAM, IF "NOSTOP" THEN VAL IS SET TO NaN
    LOGICAL,      OPTIONAL,  INTENT(  OUT):: HAS_ERROR         ! SET TO TRUE IF THERE IS AN ERROR
    CHARACTER(*), OPTIONAL,  INTENT(IN   ):: LINE              !CURRENT INPUT LINE FOR ERROR MSG
    CHARACTER(:), ALLOCATABLE:: FNAM
    INTEGER:: I, SIZ
    LOGICAL:: CHECK
    !
    IF(PRESENT(HAS_ERROR)) HAS_ERROR = FALSE
    !
    IF(IU == Z) THEN
        FNAME = '"INTERNAL FILE" with zero unit number. Did you use "INTERNAL" when you should specify a file name?'
        IF(PRESENT(EXIST)) EXIST = FALSE
        RETURN
    END IF
    !
    ALLOCATE(CHARACTER(256):: FNAM)
    INQUIRE(IU, NAME=FNAM, EXIST=CHECK)
    !
    IF(CHECK) THEN
          INQUIRE(FILE=FNAM, EXIST=CHECK)  !CHECK IF FILE NAME SIZE IS BIG ENOUGH
          IF(.NOT. CHECK) THEN
                DO I=ONE, 15
                  IF(CHECK) THEN
                                EXIT
                  ELSE
                      SIZ = 600 * I
                      DEALLOCATE(FNAM)
                      ALLOCATE(CHARACTER(SIZ):: FNAM)
                      INQUIRE(IU, NAME=FNAM)
                      INQUIRE(FILE=FNAM, EXIST=CHECK)  !CHECK IF FILE NAME SIZE IS BIG ENOUGH
                  END IF
                END DO
          END IF
          !
          IF(.NOT. CHECK) THEN
                CHECK = TRUE          !IF STAYS TRUE THEN STOP EXECUTION
                IF(PRESENT(MSG)) THEN
                     !
                     IF (MSG=='NOSTOP') CHECK = FALSE
                     IF(PRESENT(HAS_ERROR)) HAS_ERROR = TRUE
                ELSE IF(PRESENT(HAS_ERROR)) THEN
                     !
                     HAS_ERROR = TRUE
                     CHECK  = FALSE
                END IF
                !
                IF(CHECK) THEN
                    FNAM = 'GET_FILE_NAME READ UTILITY ERROR: FAILED TO IDENFITY FILE NAME FROM PROVIDED UNIT NUMBER.'//BLN//'THE UNIT NUMBER THAT IS BEING LOOKED UP IS '//NUM2STR(IU)
                    IF(PRESENT(MSG)) FNAM = FNAM//BLN//'THE FOLLOWING IS AN ADDITIONAL COMMENT PASSED TO GET_FILE_NAME:'//BLN//TRIM(MSG)
                    !
                    CALL STOP_ERROR(LINE, IN, IOUT, FNAM )
                ELSE
                    CHECK = FALSE
                    FNAM = 'GET_FILE_NAME ERROR: Failed to identy file name from unit number '//NUM2STR(IU)
                END IF
          END IF
          !
          I = LEN_TRIM(FNAM)
          ALLOCATE(FNAME, SOURCE=FNAM(ONE:I))
    ELSE
        FNAME = '"UNKNOWN FILE" Failed to identy file name from unit number '//NUM2STR(IU)
    END IF
    !
    IF(PRESENT(EXIST)) EXIST = CHECK
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  SUBROUTINE FILENAME_TO_UNIT(FNAME,IU) 
    CHARACTER(*),            INTENT(IN   ):: FNAME 
    INTEGER,                 INTENT(INOUT):: IU
    !
    CHARACTER(:),ALLOCATABLE:: FN
    LOGICAL::ISOPEN, EXIST
    !
    INQUIRE(FILE=FNAME,NUMBER=IU,OPENED=ISOPEN, EXIST=EXIST)
    !
    IF(.NOT. ISOPEN) THEN
        IU = Z
        IF(EXIST) THEN
            !
            CALL GENERIC_OPEN(FNAME, IU, ACTION='READ', FORM='FORMATTED', ACCESS='SEQUENTIAL', STATUS='OLD', ASYNC='NO', BUFFER_BLOCKSIZE=0, BUFFER_COUNT=0, ERROR=EXIST)
            !
            IF(EXIST) THEN !ERROR FOUND
                IU = Z
            ELSE
                CALL GET_FILE_NAME(IU,FN,HAS_ERROR=EXIST) 
                IF(EXIST) THEN !ERROR FOUND
                    IU = Z
                ELSE
                    CALL FORCE_UNIT_CLOSE(IU)
                    !
                    INQUIRE(FILE=FN,NUMBER=IU,OPENED=ISOPEN) !COULD BE A CHANCE THAT IT DETECTS THE FILE FROM GENERIC_OPEN
                    IF(.NOT. ISOPEN) IU = Z
                END IF
            END IF
        END IF
    END IF
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  SUBROUTINE FILENAME_TO_FULLNAME(FNAME,FULL,ISNEW) 
    CHARACTER(*),            INTENT(IN   ):: FNAME
    CHARACTER(:),ALLOCATABLE,INTENT(OUT  ):: FULL
    LOGICAL,        OPTIONAL,INTENT(OUT  ):: ISNEW
    !
    INTEGER:: IU
    LOGICAL:: EXIST
    !
    INQUIRE(FILE=FNAME, EXIST=EXIST)
    !
    IF(EXIST) THEN
        !
        IU = Z
        CALL GENERIC_OPEN(FNAME, IU, ACTION='READ', FORM='FORMATTED', ACCESS='SEQUENTIAL', STATUS='OLD', ASYNC='NO', BUFFER_BLOCKSIZE=0, BUFFER_COUNT=0, ERROR=EXIST)
        !
        IF(EXIST) THEN !ERROR FOUND
            FULL = FNAME
        ELSE
            CALL GET_FILE_NAME(IU,FULL,HAS_ERROR=EXIST)
            !
            IF(EXIST) FULL = FNAME
        END IF
    ELSE
        FULL = FNAME
    END IF
    !
    IF(PRESENT(ISNEW)) ISNEW = FULL .NE. FNAME
    !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  Cell ID routines
  !  
  PURE ELEMENTAL SUBROUTINE CELLID_TO_LRC(ID, LAY, ROW, COL, NLAY, NROW, NCOL)
    INTEGER, INTENT(IN ):: ID
    INTEGER, INTENT(OUT):: LAY, ROW, COL
    INTEGER, INTENT(IN ):: NLAY, NROW, NCOL
    INTEGER:: RC, I
    !
    I = ID
    RC = NCOL * NROW
    !
    LAY = I / RC
    IF (MOD(I,RC) .NE. Z) LAY = LAY + ONE
    !
    I = I - RC*(LAY-ONE)
    !
    ROW = I / NCOL
    IF (MOD(I,NCOL) .NE. Z) ROW = ROW + ONE
    !
    COL = I - NCOL*(ROW-1)
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE ELEMENTAL SUBROUTINE LRC_TO_CELLID(ID, LAY, ROW, COL, NLAY, NROW, NCOL)
    INTEGER, INTENT(OUT):: ID
    INTEGER, INTENT(IN ):: LAY, ROW, COL
    INTEGER, INTENT(IN ):: NLAY, NROW, NCOL
    !
    ID = COL + NCOL*(ROW-1) + NCOL*NROW*(LAY-1)
    !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  Relaxation and Dampening routines
  !
  PURE FUNCTION RELAXER_DBLE(NEW, OLD, RELAX) RESULT(REL)
    REAL(REAL64), INTENT(IN):: NEW, OLD, RELAX
    REAL(REAL64):: REL
    !
    IF(RELAX == UNO) THEN
        REL = NEW
    ELSE
        REL = OLD + RELAX*(NEW-OLD)
    END IF
    !
  END FUNCTION
  !
  !#############################################################################################################################################################
  !
  PURE FUNCTION RELAXER_SNGL(NEW, OLD, RELAX) RESULT(REL)
    REAL(REAL32), INTENT(IN):: NEW, OLD
    REAL(REAL64), INTENT(IN):: RELAX
    REAL(REAL32):: REL
    !
    IF(RELAX == UNO) THEN
        REL = NEW
    ELSE
        REL = OLD + RELAX*(NEW-OLD)
    END IF
    !
  END FUNCTION
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE RELAX_IT_DBLE(NEW, OLD, RELAX)
    REAL(REAL64), INTENT(INOUT):: NEW
    REAL(REAL64), INTENT(IN   ):: OLD, RELAX
    !
    IF(RELAX < SUB_ONE .OR. RELAX > NEAR_ONE) NEW = OLD + RELAX*(NEW-OLD)
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE RELAX_IT_SNGL(NEW, OLD, RELAX)
    REAL(REAL32), INTENT(INOUT):: NEW
    REAL(REAL32), INTENT(IN   ):: OLD
    REAL(REAL64), INTENT(IN   ):: RELAX
    !
    IF(RELAX < SUB_ONE .OR. RELAX > NEAR_ONE) NEW = OLD + RELAX*(NEW-OLD)
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE RELAX_IT2_DBLE(NEW2, NEW, OLD, RELAX)
    REAL(REAL64), INTENT(  OUT):: NEW2
    REAL(REAL64), INTENT(IN   ):: NEW, OLD, RELAX
    !
    IF(SUB_ONE < RELAX .AND. RELAX < NEAR_ONE) THEN
        NEW2 = NEW
    ELSE
        NEW2 = OLD + RELAX*(NEW-OLD)
    END IF
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE RELAX_IT2_SNGL(NEW2, NEW, OLD, RELAX)
    REAL(REAL32), INTENT(  OUT):: NEW2
    REAL(REAL32), INTENT(IN   ):: NEW, OLD, RELAX
    !
    IF(SUB_ONE < RELAX .AND. RELAX < NEAR_ONE) THEN
        NEW2 = NEW
    ELSE
        NEW2 = OLD + RELAX*(NEW-OLD)
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE DAMP_IT_DBLE(NEW, OLD, OLD2, DAMP, RELAX) !Based off of Mehl and Hill 2001
    REAL(REAL64), INTENT(INOUT):: NEW
    REAL(REAL64), INTENT(IN   ):: OLD, OLD2, DAMP
    REAL(REAL64), INTENT(IN   ), OPTIONAL:: RELAX
    REAL(REAL64):: DMP
    !
    IF( ABS(OLD-OLD2) > NEARZERO_29 .AND. DAMP < UNO) THEN
        DMP = (NEW-OLD)/(DAMP*(OLD-OLD2))
        IF(DMP < DNEG) THEN
                             DMP = HALF / (DNEG * DMP)  !=1/(2*ABS(DMP))
        ELSEIF(DMP < -0.015D0) THEN
                             DMP = (TRES + DMP)/(TRES - DMP)
        ELSE
                             DMP = 0.99D0
        END IF
        !
        IF(PRESENT(RELAX)) DMP = DMP * RELAX
        !
        NEW = OLD + DMP*(NEW-OLD)
    END IF
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE DAMP_IT_SNGL(NEW, OLD, OLD2, DAMP, RELAX) !Based off of Mehl and Hill 2001
    REAL(REAL32), INTENT(INOUT):: NEW
    REAL(REAL32), INTENT(IN   ):: OLD, OLD2, DAMP
    REAL(REAL64), INTENT(IN   ), OPTIONAL:: RELAX
    REAL(REAL32):: DMP
    !
    IF( ABS(OLD-OLD2) > NEARZERO_29 .AND. DAMP < UNO) THEN
        DMP = (NEW-OLD)/(DAMP*(OLD-OLD2))
        IF(DMP < DNEG) THEN
                             DMP = HALF / (DNEG * DMP)  !=1/(2*ABS(DMP))
        ELSEIF(DMP < -0.015D0) THEN
                             DMP = (TRES + DMP)/(TRES - DMP)
        ELSE
                             DMP = 0.99D0
        END IF
        !
        IF(PRESENT(RELAX)) DMP = DMP * RELAX
        !
        NEW = OLD + DMP*(NEW-OLD)
    END IF
    !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  Zero, 0-1 Range, and Close routines
  !
  PURE ELEMENTAL FUNCTION ZERO_OR_GREATER(VAR)
    DOUBLE PRECISION, INTENT(IN):: VAR
    DOUBLE PRECISION:: ZERO_OR_GREATER
    IF(VAR < DZ) THEN
        ZERO_OR_GREATER = DZ
    ELSE
        ZERO_OR_GREATER = VAR
    END IF
  END FUNCTION
  !
  PURE ELEMENTAL FUNCTION ZERO_OR_LESS(VAR)
    DOUBLE PRECISION, INTENT(IN):: VAR
    DOUBLE PRECISION:: ZERO_OR_LESS
    IF(VAR > DZ) THEN
        ZERO_OR_LESS = DZ
    ELSE
        ZERO_OR_LESS = VAR
    END IF
  END FUNCTION
  !
  !#############################################################################################################################################################
  !
  PURE ELEMENTAL SUBROUTINE MAKE_ZERO_IF_NEG(VAR)
    DOUBLE PRECISION, INTENT(INOUT):: VAR
    !
    IF(VAR < DZ)  VAR = DZ
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MAKE_ZERO_IF_POS(VAR)
    DOUBLE PRECISION, INTENT(INOUT):: VAR
    !
    IF(VAR > DZ)  VAR = DZ
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE ELEMENTAL SUBROUTINE ONLY_ZERO_TO_ONE_RANGE(VAR)
    DOUBLE PRECISION, INTENT(INOUT):: VAR
    !
    IF    (VAR < DZ) THEN
           VAR = DZ
    ELSEIF(VAR > UNO) THEN
           VAR = UNO
    END IF
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE ELEMENTAL FUNCTION RELATIVE_CLOSE(VAR1,VAR2,TOL)
    DOUBLE PRECISION,           INTENT(IN):: VAR1, VAR2
    DOUBLE PRECISION, OPTIONAL, INTENT(IN):: TOL
    LOGICAL:: RELATIVE_CLOSE
    DOUBLE PRECISION:: CHK, DIFF
    !
    IF(VAR1 > VAR2) THEN
        !
        IF    (VAR2 >= DZ) THEN           ! Solve CHK = MIN(ABS(VAR1), ABS(VAR2))
                           CHK = VAR2
        ELSEIF(VAR1 <= DZ) THEN 
                           CHK = DNEG*VAR1
        ELSEIF(DNEG*VAR2 > VAR1) THEN         !Only here if VAR1 > 0 and VAR2 < 0
                           CHK = VAR1
        ELSE
                           CHK = DNEG*VAR2
        END IF
        !
        DIFF  = VAR1 - VAR2
    ELSE
        IF    (VAR1 >= DZ) THEN           ! Solve CHK = MIN(ABS(VAR1), ABS(VAR2))
                           CHK = VAR1
        ELSEIF(VAR2 <= DZ) THEN 
                           CHK = DNEG*VAR2
        ELSEIF(DNEG*VAR1 > VAR2) THEN         !Only here if VAR2 > 0 and VAR1 < 0 and VAR2 > VAR1
                           CHK = VAR2
        ELSE
                           CHK = DNEG*VAR1
        END IF
        !
        DIFF   = VAR2 - VAR1
    END IF
    !
    IF(PRESENT(TOL)) THEN
        CHK = CHK * TOL
    ELSE
        CHK = CHK * NEARZERO_6  !COMPARE AGAINST 7th DIGIT (SINGLE PRECISION)
    END IF
    !
    RELATIVE_CLOSE = DIFF <= CHK
    !
  END FUNCTION
  !
  !#############################################################################################################################################################
  !
  PURE ELEMENTAL FUNCTION IS_CLOSE(VAR1,VAR2,RTOL,ATOL) !Default RTOL=1E-6,ATOL=1E-10 - Match 7 digits or less than 1E-10
    DOUBLE PRECISION,           INTENT(IN):: VAR1, VAR2
    DOUBLE PRECISION, OPTIONAL, INTENT(IN):: RTOL,ATOL
    LOGICAL:: IS_CLOSE
    DOUBLE PRECISION:: CHK, DIFF
    !ABS(VAR1-VAR2) <= (ATOL + RTOL * ABS(VAR2))
    !
    IF(VAR1.NE.VAR1 .OR. VAR2.NE.VAR2) THEN
        IS_CLOSE = FALSE
    ELSE
        IF(VAR1 > VAR2) THEN
            !
            IF    (VAR2 >= DZ) THEN           ! Solve CHK = MIN(ABS(VAR1), ABS(VAR2))
                               CHK = VAR2
            ELSEIF(VAR1 <= DZ) THEN 
                               CHK = DNEG*VAR1
            ELSEIF(DNEG*VAR2 > VAR1) THEN         !Only here if VAR1 > 0 and VAR2 < 0 and VAR1 > VAR2
                               CHK = VAR1
            ELSE
                               CHK = DNEG*VAR2
            END IF
            !
            DIFF  = VAR1 - VAR2
        ELSE
            IF    (VAR1 >= DZ) THEN           ! Solve CHK = MIN(ABS(VAR1), ABS(VAR2))
                               CHK = VAR1
            ELSEIF(VAR2 <= DZ) THEN 
                               CHK = DNEG*VAR2
            ELSEIF(DNEG*VAR1 > VAR2) THEN         !Only here if VAR2 > 0 and VAR1 < 0 and VAR2 > VAR1
                               CHK = VAR2
            ELSE
                               CHK = DNEG*VAR1
            END IF
            !
            DIFF   = VAR2 - VAR1
        END IF
        !
        IF(PRESENT(RTOL)) THEN
            CHK = CHK * RTOL
        ELSE
            CHK = CHK * NEARZERO_6  !COMPARE AGAINST 7th DIGIT (SINGLE PRECISION)
        END IF
       !
       IF(PRESENT(ATOL)) THEN
           IS_CLOSE = DIFF <= ATOL + CHK
       ELSE
           IS_CLOSE = DIFF <= NEARZERO_10 + CHK
       END IF
       !
    END IF
    !
  END FUNCTION
  !
  !#############################################################################################################################################################
  !
  PURE ELEMENTAL SUBROUTINE SET_NEAR_ZERO(VAR,TOL)
    DOUBLE PRECISION,           INTENT(INOUT):: VAR
    DOUBLE PRECISION, OPTIONAL, INTENT(IN   ):: TOL
    !
    IF(NEAR_ZERO(VAR,TOL)) VAR = DZ
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE ELEMENTAL FUNCTION NEAR_ZERO(VAR,TOL)
    DOUBLE PRECISION,           INTENT(IN):: VAR
    DOUBLE PRECISION, OPTIONAL, INTENT(IN):: TOL
    LOGICAL:: NEAR_ZERO
    !
    IF(PRESENT(TOL)) THEN
        IF(VAR > TOL) THEN
            NEAR_ZERO = FALSE
        ELSEIF(VAR < TOL*DNEG) THEN
            NEAR_ZERO = FALSE
        ELSE
            NEAR_ZERO = TRUE
        END IF
    ELSE
        IF(VAR > NEARZERO_30) THEN
            NEAR_ZERO = FALSE
        ELSEIF(VAR < NEGNEARZERO_30) THEN
            NEAR_ZERO = FALSE
        ELSE
            NEAR_ZERO = TRUE
        END IF
    END IF
    !
  END FUNCTION
  !
  !#############################################################################################################################################################
  !
  PURE ELEMENTAL FUNCTION NOT_NEAR_ZERO(VAR,TOL)
    DOUBLE PRECISION,           INTENT(IN):: VAR
    DOUBLE PRECISION, OPTIONAL, INTENT(IN):: TOL
    LOGICAL:: NOT_NEAR_ZERO
    !
    IF(PRESENT(TOL)) THEN
        IF(VAR > TOL) THEN
            NOT_NEAR_ZERO = TRUE
        ELSEIF(VAR < TOL*DNEG) THEN
            NOT_NEAR_ZERO = TRUE
        ELSE
            NOT_NEAR_ZERO = FALSE
        END IF
    ELSE
        IF(VAR > NEARZERO_30) THEN
            NOT_NEAR_ZERO = TRUE
        ELSEIF(VAR < NEGNEARZERO_30) THEN
            NOT_NEAR_ZERO = TRUE
        ELSE
            NOT_NEAR_ZERO = FALSE
        END IF
    END IF
    !
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  ASCII routines
  !
  PURE SUBROUTINE ASCII_CHECK_LOGICAL(LN, IS_ASCII)
      CHARACTER(*),INTENT(IN   ):: LN
      LOGICAL,     INTENT(INOUT):: IS_ASCII
      INTEGER::I
      !
      IS_ASCII = TRUE
      !
      DO I = ONE, LEN_TRIM(LN)  !CHECK FOR BAD ASCII CODES
          IF ( ICHAR( LN(I:I) ) > 126 ) THEN
              !
              IS_ASCII = FALSE
              !
              EXIT
          END IF
      END DO
      !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  SUBROUTINE ASCII_CHECK_STOP(LN, IOUT) !CLONE OF UTIL_INTERFACE SUBROUTINE OF SAME NAME  --ASSUME ALL IS CASE CORRECT
      CHARACTER(*),                        INTENT(IN   ):: LN
      INTEGER,                             INTENT(IN   ):: IOUT
      INTEGER::I
      !
      DO I = ONE, LEN_TRIM(LN)  !CHECK FOR BAD ASCII CODES
          IF ( ICHAR( LN(I:I) ) > 126 ) THEN
              !
              CALL STOP_ERROR( LINE=LN, OUTPUT=IOUT, MSG= 'FOUND NON-ASCII CHARACTER IN LINE.'//BLN//'THIS INPUT ONLY ALLOWS FOR STANDARD ENGLISH ASCII CHARACTERS (ASCII CODES 1 TO 126)'//NL//'THE CHARACTER THAT IS A PROBLEM IS "'//LN(I:I)//'".'//BLN//'THIS CAN HAPPEN IF YOU COPY/PAST FROM AN ADVANCED EDITOR LIKE MS-WORD.'//NL//'AN EASY FIX IS TO REWRITE YOUR EQUATION IN AN ASCII/UNICODE BASIC TEXT EDITOR.' )
              !
          END IF
      END DO
      !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE ASCII_CHECK_CHAR(LN, NON_ASCII) !CLONE OF UTIL_INTERFACE SUBROUTINE OF SAME NAME  --ASSUME ALL IS CASE CORRECT
      CHARACTER(*),                        INTENT(IN   ):: LN
      CHARACTER(:),           ALLOCATABLE, INTENT(INOUT):: NON_ASCII
      LOGICAL:: NOT_ASCII
      INTEGER::I
      !
      IF(ALLOCATED(NON_ASCII)) DEALLOCATE(NON_ASCII)
      NON_ASCII = BLNK 
      !
      NOT_ASCII = FALSE
      !
      DO I = ONE, LEN_TRIM(LN)  !CHECK FOR BAD ASCII CODES
          IF ( ICHAR( LN(I:I) ) > 126 ) THEN
              !
              NOT_ASCII = TRUE
              !
              NON_ASCII = NON_ASCII//', "'//LN(I:I)//'"'
              !
          END IF
      END DO
      !
      IF(NOT_ASCII) THEN
          NON_ASCII = NON_ASCII(FOUR:)
      ELSE
          DEALLOCATE(NON_ASCII)
      END IF
      !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  IS_ routines
  !
  PURE FUNCTION IS_BLANK(LN) RESULT(EMPTY)
    CHARACTER(*),      INTENT(IN):: LN
    LOGICAL:: EMPTY
    INTEGER:: I
    !
    EMPTY = TRUE
    DO I=ONE, LEN_TRIM(LN)
        IF(LN(I:I).NE.BLNK .AND. LN(I:I).NE.TAB .AND. LN(I:I).NE.COM ) THEN
            EMPTY = FALSE
            EXIT
        END IF
    END DO
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE ELEMENTAL FUNCTION IS_ASCII(LN)
      CHARACTER(*),INTENT(IN):: LN
      LOGICAL:: IS_ASCII
      INTEGER::I
      !
      IS_ASCII = TRUE
      !
      DO I = ONE, LEN_TRIM(LN)  !CHECK FOR BAD ASCII CODES
          IF ( ICHAR( LN(I:I) ) > 126 ) THEN
              !
              IS_ASCII = FALSE
              !
              EXIT
          END IF
      END DO
      !
  END FUNCTION
  !
  !#############################################################################################################################################################
  !
  PURE ELEMENTAL FUNCTION IS_INTEGER(VAR)
    CHARACTER(*), INTENT(IN):: VAR
    LOGICAL:: IS_INTEGER
    INTEGER:: I, N, ISTART
    !
    N = LEN_TRIM(VAR)
    ISTART = N+1
    DO I=ONE, N
        IF(VAR(I:I).NE.' ') THEN
            ISTART = I
            IF(VAR(I:I)=='+' .OR. VAR(I:I) =='-') ISTART = ISTART + ONE
            EXIT
        END IF
    END DO
    !
    IF( ISTART <= N ) THEN
       IS_INTEGER = TRUE
       DO I=ISTART, N
           IF( INDEX('0123456789',VAR(I:I)) == Z ) THEN ! DID NOT FIND A NUMBER, SO NOT AN INTEGER
               IS_INTEGER = FALSE
               EXIT
           END IF
       END DO
    ELSE
        IS_INTEGER = FALSE
    END IF
    !
  END FUNCTION
  !
  !#############################################################################################################################################################
  !
  PURE ELEMENTAL FUNCTION IS_NUMBER(VAR)
    CHARACTER(*), INTENT(IN):: VAR
    LOGICAL:: IS_NUMBER
    INTEGER:: I, N, ISTART
    CHARACTER(17),PARAMETER:: VALID='0123456789EeDd+-.'
    CHARACTER(10),PARAMETER:: NUM='0123456789'
    CHARACTER(4), PARAMETER:: ED = 'EeDd'
    CHARACTER(2), PARAMETER:: PM = '+-'
    CHARACTER,    PARAMETER:: P  = '.'
    !
    N = LEN_TRIM(VAR)
    ISTART = N+1
    DO I=ONE, N
        IF(VAR(I:I).NE.' ') THEN
            ISTART = I
            EXIT
        END IF
    END DO
    !
    DO I=ISTART, N
        IF(VAR(I:I)==' ') THEN !NO BLANK SPACES ALLOWED
            IS_NUMBER = FALSE
            RETURN !--------------------------------------------------------
        END IF
    END DO
    !
    IF    ( ISTART > N) THEN
                             IS_NUMBER = FALSE                                                ! BLANK LINE
    ELSEIF( ISTART == N) THEN
                             IS_NUMBER = SCAN(NUM,VAR(N:N)) > Z                               ! SIZE = 1, MUST BE NUMBER
    ELSE
        IS_NUMBER = TRUE
        !
        IF(VAR(ISTART:ISTART)=='+' .OR. VAR(ISTART:ISTART) == '-') ISTART = ISTART + ONE      !IF FIRST IS SIGN,  THEN MOVE FORWARD
        IF(VAR(ISTART:ISTART)=='.') THEN                                                      !IF FIRST IS POINT, THEN MOVE FORWARD  --NOTE YOU CAN HAVE -.5
            ISTART = ISTART + ONE
            IF(ISTART > N) THEN
                IS_NUMBER = FALSE
            ELSEIF(INDEX(VAR(ISTART:N),P) > Z)  THEN! NO SECOND . ALLOWED
                IS_NUMBER = FALSE
            ELSE
                IS_NUMBER = INDEX(NUM,VAR(ISTART:ISTART)) > Z  !START WITH . MUST PROCEDE WITH NUMBER
            END IF
        ELSEIF(SCAN(NUM,VAR(ISTART:ISTART)) == Z) THEN  !NO NUMBER IN FIRST LOCATION ATER +-
            IS_NUMBER = FALSE
        ELSE
            I = INDEX(VAR(ISTART:N),P)
            IF ( I > Z) THEN
               IS_NUMBER = I == INDEX(VAR(ISTART:N),P, BACK=TRUE)  !AT MOST ONE POINT "."
               IF(IS_NUMBER) THEN
                   I = INDEX(VAR(:N),P) - ONE
                   IS_NUMBER = INDEX(NUM,VAR(I:I)) > Z  !MUST PRECEDE BY NUMBER IF NOT IN FIRST LOCATION
               END IF
            END IF
            ISTART = ISTART + ONE  !MOVE PAST FIRST NUMBER
        END IF
        !
        IF(ISTART > N) RETURN !--------------------------------------------------------
        !
        IF(IS_NUMBER) THEN
            I = SCAN(VAR(:N),ED)
            IF(I == N) THEN
                      IS_NUMBER = FALSE
            ELSEIF( I > Z ) THEN
                  IF( I .NE. SCAN(VAR(:N),ED, BACK=TRUE)) THEN
                      IS_NUMBER = FALSE
                  ELSE
                      IF (VAR(I-ONE:I-ONE) == P) THEN !!MUST PRECEDE BY NUMBER OR .
                          IS_NUMBER = INDEX(NUM,VAR(I-TWO:I-TWO)) > Z 
                      ELSE
                          IS_NUMBER = INDEX(NUM,VAR(I-ONE:I-ONE)) > Z 
                      END IF
                  END IF
            END IF
        END IF
        !
        IF(IS_NUMBER) THEN
            I = SCAN(VAR(ISTART:N),PM)
            IF( I > Z ) THEN
                  IF( I .NE. SCAN(VAR(ISTART:N),PM, BACK=TRUE)) THEN
                      IS_NUMBER = FALSE
                  ELSE
                      I = SCAN(VAR(:N),PM, BACK=TRUE) - ONE
                      IS_NUMBER = INDEX(ED,VAR(I:I)) > Z .AND. INDEX(NUM,VAR(I+TWO:I+TWO)) > Z  ! MUST BE PRECEDED BY a D or E AND PROCEDE WITH A NUM
                  END IF
            END IF
        END IF
        !
        IF(IS_NUMBER) THEN
            I = ISTART
            DO WHILE (IS_NUMBER .AND. I <= N)
                  IS_NUMBER = INDEX(VALID,VAR(I:I)) > Z
                  I = I + ONE
            END DO
        END IF
    END IF
    !
  END FUNCTION
  !
!!!  PURE ELEMENTAL FUNCTION IS_NUMBER(VAR)
!!!    CHARACTER(*), INTENT(IN):: VAR
!!!    LOGICAL:: IS_NUMBER
!!!    INTEGER:: I, N, ISTART
!!!    CHARACTER(10),PARAMETER:: NUM='0123456789'
!!!    CHARACTER(4),PARAMETER:: ED = 'EeDd'
!!!    CHARACTER(2),PARAMETER:: PM = '+-'
!!!    CHARACTER, PARAMETER:: P='.'
!!!    !
!!!    N = LEN_TRIM(VAR)
!!!    ISTART = N+1
!!!    DO I=ONE, N
!!!        IF(VAR(I:I).NE.' ') THEN
!!!            ISTART = I
!!!            EXIT
!!!        END IF
!!!    END DO
!!!    !
!!!    IF    ( ISTART > N) THEN
!!!                             IS_NUMBER = FALSE                                                ! BLANK LINE
!!!    ELSEIF( ISTART == N) THEN
!!!                             IS_NUMBER = SCAN(NUM,VAR(N:N)) > Z                               ! SIZE = 1, MUST BE NUMBER
!!!    ELSE
!!!        IF(VAR(ISTART:ISTART)=='+' .OR. VAR(ISTART:ISTART) == '-') ISTART = ISTART + ONE      !IF FIRST IS SIGN, THEN MOVE FORWARD
!!!        !
!!!        IS_NUMBER = SCAN(NUM,VAR(ISTART:ISTART)) > Z                                          !FIRST POSITION MUST BE NUMBER
!!!        !
!!!        I=ISTART+ONE
!!!        DO WHILE (IS_NUMBER .AND. I <= N)
!!!              IF(BLNK == VAR(I:I)) THEN                                          !SHOULD NOT HAVE A BLANK SPACE WITHIN
!!!                  IS_NUMBER = FALSE
!!!              ELSEIF(P == VAR(I:I)) THEN
!!!                  IF(I<N      ) IS_NUMBER = SCAN(VAR(I+ONE:),P) == Z             ! NO SECOND .
!!!                  IF(IS_NUMBER) IS_NUMBER = SCAN(NUM,VAR(I-ONE:I-ONE)) > Z       ! MUST PRECEDE BY NUMBER
!!!              ELSEIF(SCAN(PM,VAR(I:I)) > Z ) THEN
!!!                      IF(I<N      ) IS_NUMBER = SCAN(VAR(I+ONE:),PM) == Z .AND. SCAN(NUM,VAR(I+ONE:I+ONE)) > Z  !NO SECOND +- AND MOST PROCEDDE BY NUMBER
!!!                      IF(IS_NUMBER) IS_NUMBER = SCAN(ED,VAR(I-ONE:I-ONE)) > Z                                   !MUST PRECEDE BY E or D
!!!              ELSEIF(SCAN(ED,VAR(I:I)) > Z ) THEN
!!!                      IF(I<N      ) IS_NUMBER = SCAN(VAR(I+ONE:),ED) == Z                                       !NO SECOND E or D
!!!                      IF(IS_NUMBER) IS_NUMBER = SCAN(NUM,VAR(I-ONE:I-ONE)) > Z .OR. VAR(I-ONE:I-ONE) == P       !MUST PRECEDE BY NUMBER OR .
!!!              ELSE
!!!                  IS_NUMBER = SCAN(NUM,VAR(I:I)) > Z                                                            !MUST BE A NUMBER
!!!              END IF
!!!              !
!!!              I = I + ONE
!!!              !
!!!        END DO
!!!    END IF
!!!    !
!!!  END FUNCTION
        !IF(IS_NUMBER) THEN
        !    !
        !    DO I=ISTART+ONE, N
        !        IF(BLNK == VAR(I:I)) THEN                                          !SHOULD NOT HAVE A BLANK SPACE WITHIN
        !            IS_NUMBER = FALSE
        !        ELSEIF(P == VAR(I:I)) THEN
        !            IF(I<N      ) IS_NUMBER = SCAN(VAR(I+ONE:),P) == Z             ! NO SECOND .
        !            IF(IS_NUMBER) IS_NUMBER = SCAN(NUM,VAR(I-ONE:I-ONE)) > Z       ! MUST PRECEDE BY NUMBER
        !        ELSEIF(SCAN(PM,VAR(I:I)) > Z ) THEN
        !                IF(I<N      ) IS_NUMBER = SCAN(VAR(I+ONE:),PM) == Z .AND. SCAN(NUM,VAR(I+ONE:I+ONE)) > Z  !NO SECOND +- AND MOST PROCEDDE BY NUMBER
        !                IF(IS_NUMBER) IS_NUMBER = SCAN(ED,VAR(I-ONE:I-ONE)) > Z                                   !MUST PRECEDE BY E or D
        !        ELSEIF(SCAN(ED,VAR(I:I)) > Z ) THEN
        !                IF(I<N      ) IS_NUMBER = SCAN(VAR(I+ONE:),ED) == Z                                       !NO SECOND E or D
        !                IF(IS_NUMBER) IS_NUMBER = SCAN(NUM,VAR(I-ONE:I-ONE)) > Z .OR. VAR(I-ONE:I-ONE) == P       !MUST PRECEDE BY NUMBER OR .
        !        ELSE
        !            IS_NUMBER = SCAN(NUM,VAR(I:I)) > Z                                                            !MUST BE A NUMBER
        !        END IF
        !        !
        !        IF(.NOT. IS_NUMBER) EXIT
        !        !
        !    END DO
        !    !
        !END IF
  !
  !#############################################################################################################################################################
  !
  PURE ELEMENTAL FUNCTION IS_NAN_OR(VAR,OP,VAL)
    DOUBLE PRECISION,             INTENT(IN):: VAR
    CHARACTER(2),     INTENT(IN), OPTIONAL:: OP
    DOUBLE PRECISION, INTENT(IN), OPTIONAL:: VAL
    LOGICAL:: IS_NAN_OR
    !
    IS_NAN_OR = IEEE_IS_NAN(VAR)
    !
    IF(.NOT. IS_NAN_OR) THEN
       IF(PRESENT(OP)) THEN
                           SELECT CASE(OP)
                           CASE('GE','>='); IS_NAN_OR = VAR >=  VAL
                           CASE('GT','>' ); IS_NAN_OR = VAR >   VAL
                           CASE('LE','<='); IS_NAN_OR = VAR <=  VAL
                           CASE('LT','<' ); IS_NAN_OR = VAR <   VAL
                           CASE('EQ','=='); IS_NAN_OR = VAR ==  VAL
                           CASE('NE','/='); IS_NAN_OR = VAR /=  VAL
                           END SELECT
       END IF
    END IF
    !
  END FUNCTION
  !
  !#############################################################################################################################################################
  !
  PURE ELEMENTAL FUNCTION IS_NOT_NAN_OR(VAR,OP,VAL)
    DOUBLE PRECISION,             INTENT(IN):: VAR
    CHARACTER(2),     INTENT(IN), OPTIONAL:: OP
    DOUBLE PRECISION, INTENT(IN), OPTIONAL:: VAL
    LOGICAL:: IS_NOT_NAN_OR
    !
    IS_NOT_NAN_OR = .NOT. IEEE_IS_NAN(VAR)
    !
    IF(IS_NOT_NAN_OR) THEN
       IF(PRESENT(OP)) THEN
                           SELECT CASE(OP)
                           CASE('GE','>='); IS_NOT_NAN_OR = VAR >=  VAL
                           CASE('GT','>' ); IS_NOT_NAN_OR = VAR >   VAL
                           CASE('LE','<='); IS_NOT_NAN_OR = VAR <=  VAL
                           CASE('LT','<' ); IS_NOT_NAN_OR = VAR <   VAL
                           CASE('EQ','=='); IS_NOT_NAN_OR = VAR ==  VAL
                           CASE('NE','/='); IS_NOT_NAN_OR = VAR /=  VAL
                           END SELECT
       END IF
    END IF
    !
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  SET Array routines
  !
  PURE SUBROUTINE POSITION_SET_ARRAY_2D_DBL(DIM1, DIM2, SRCH, ARR1, SET, ARR2)
    INTEGER,                            INTENT(IN   ):: DIM1, DIM2, SRCH
    INTEGER,      DIMENSION(DIM1,DIM2), INTENT(IN   ):: ARR1
    REAL(REAL64),                       INTENT(IN   ):: SET
    REAL(REAL64), DIMENSION(DIM1,DIM2), INTENT(  OUT):: ARR2
    INTEGER:: I,J
    !
    DO CONCURRENT(I=1:DIM1, J=1:DIM2, ARR1(I,J)==SRCH); ARR2(I,J) = SET
    END DO
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE SET_ARRAY_3D3D_DBL(DIM1, DIM2, DIM3, ARR1, ARR2)
    INTEGER,                                 INTENT(IN   ):: DIM1, DIM2, DIM3
    REAL(REAL64), DIMENSION(DIM1,DIM2,DIM3), INTENT(IN   ):: ARR1
    REAL(REAL64), DIMENSION(DIM1,DIM2,DIM3), INTENT(  OUT):: ARR2
    INTEGER:: I,J,K
    !
    DO CONCURRENT(I=1:DIM1, J=1:DIM2, K=1:DIM3); ARR2(I,J,K) = ARR1(I,J,K)
    END DO
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE SET_ARRAY_0D3D_DBL(DIM1, DIM2, DIM3, VAL, ARR2)
    INTEGER,                                 INTENT(IN   ):: DIM1, DIM2, DIM3
    REAL(REAL64),                            INTENT(IN   ):: VAL
    REAL(REAL64), DIMENSION(DIM1,DIM2,DIM3), INTENT(  OUT):: ARR2
    INTEGER:: I,J,K
    !
    DO CONCURRENT(I=1:DIM1, J=1:DIM2, K=1:DIM3); ARR2(I,J,K) = VAL
    END DO
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE SET_ARRAY_3D3D_INT(DIM1, DIM2, DIM3, ARR1, ARR2)
    INTEGER,                            INTENT(IN   ):: DIM1, DIM2, DIM3
    INTEGER, DIMENSION(DIM1,DIM2,DIM3), INTENT(IN   ):: ARR1
    INTEGER, DIMENSION(DIM1,DIM2,DIM3), INTENT(  OUT):: ARR2
    INTEGER:: I,J,K
    !
    DO CONCURRENT(I=1:DIM1, J=1:DIM2, K=1:DIM3); ARR2(I,J,K) = ARR1(I,J,K)
    END DO
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE SET_ARRAY_0D3D_INT(DIM1, DIM2, DIM3, VAL, ARR2)
    INTEGER,                            INTENT(IN   ):: DIM1, DIM2, DIM3
    INTEGER,                            INTENT(IN   ):: VAL
    INTEGER, DIMENSION(DIM1,DIM2,DIM3), INTENT(  OUT):: ARR2
    INTEGER:: I,J,K
    !
    DO CONCURRENT(I=1:DIM1, J=1:DIM2, K=1:DIM3); ARR2(I,J,K) = VAL
    END DO
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE SET_ARRAY_2D2D_DBL(DIM1, DIM2, ARR1, ARR2)
    INTEGER,                            INTENT(IN   ):: DIM1, DIM2
    REAL(REAL64), DIMENSION(DIM1,DIM2), INTENT(IN   ):: ARR1
    REAL(REAL64), DIMENSION(DIM1,DIM2), INTENT(  OUT):: ARR2
    INTEGER:: I,J
    !
    DO CONCURRENT(I=1:DIM1, J=1:DIM2); ARR2(I,J) = ARR1(I,J)
    END DO
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE SET_ARRAY_0D2D_DBL(DIM1, DIM2, VAL, ARR2)
    INTEGER,                            INTENT(IN   ):: DIM1, DIM2
    REAL(REAL64),                       INTENT(IN   ):: VAL
    REAL(REAL64), DIMENSION(DIM1,DIM2), INTENT(  OUT):: ARR2
    INTEGER:: I,J
    !
    DO CONCURRENT(I=1:DIM1, J=1:DIM2); ARR2(I,J) = VAL
    END DO
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE SET_ARRAY_2D2D_INT(DIM1, DIM2, ARR1, ARR2)
    INTEGER,                       INTENT(IN   ):: DIM1, DIM2
    INTEGER, DIMENSION(DIM1,DIM2), INTENT(IN   ):: ARR1
    INTEGER, DIMENSION(DIM1,DIM2), INTENT(  OUT):: ARR2
    INTEGER:: I,J
    !
    DO CONCURRENT(I=1:DIM1, J=1:DIM2); ARR2(I,J) = ARR1(I,J)
    END DO
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE SET_ARRAY_0D2D_INT(DIM1, DIM2, VAL, ARR2)
    INTEGER,                       INTENT(IN   ):: DIM1, DIM2
    INTEGER,                       INTENT(IN   ):: VAL
    INTEGER, DIMENSION(DIM1,DIM2), INTENT(  OUT):: ARR2
    INTEGER:: I,J
    !
    DO CONCURRENT(I=1:DIM1, J=1:DIM2); ARR2(I,J) = VAL
    END DO
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE SET_ARRAY_1D1D_DBL(DIM1, ARR1, ARR2)
    INTEGER,                       INTENT(IN   ):: DIM1
    REAL(REAL64), DIMENSION(DIM1), INTENT(IN   ):: ARR1
    REAL(REAL64), DIMENSION(DIM1), INTENT(  OUT):: ARR2
    INTEGER:: I
    !
    DO CONCURRENT(I=1:DIM1); ARR2(I) = ARR1(I)
    END DO
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE SET_ARRAY_0D1D_DBL(DIM1, VAL, ARR2)
    INTEGER,                       INTENT(IN   ):: DIM1
    REAL(REAL64),                  INTENT(IN   ):: VAL
    REAL(REAL64), DIMENSION(DIM1), INTENT(  OUT):: ARR2
    INTEGER:: I
    !
    DO CONCURRENT(I=1:DIM1); ARR2(I) = VAL
    END DO
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE SET_ARRAY_1D1D_INT(DIM1, ARR1, ARR2)
    INTEGER,                  INTENT(IN   ):: DIM1
    INTEGER, DIMENSION(DIM1), INTENT(IN   ):: ARR1
    INTEGER, DIMENSION(DIM1), INTENT(  OUT):: ARR2
    INTEGER:: I
    !
    DO CONCURRENT(I=1:DIM1); ARR2(I) = ARR1(I)
    END DO
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE SET_ARRAY_0D1D_INT(DIM1, VAL, ARR2)
    INTEGER,                  INTENT(IN   ):: DIM1
    INTEGER,                  INTENT(IN   ):: VAL
    INTEGER, DIMENSION(DIM1), INTENT(  OUT):: ARR2
    INTEGER:: I
    !
    DO CONCURRENT(I=1:DIM1); ARR2(I) = VAL
    END DO
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE SET_ARRAY_SEQUENTIAL_1D_INT(DIM1, ARR2)
    INTEGER,                  INTENT(IN   ):: DIM1
    INTEGER, DIMENSION(DIM1), INTENT(  OUT):: ARR2
    INTEGER:: I
    !
    DO CONCURRENT(I=1:DIM1); ARR2(I) = I
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_ARRAY_SEQUENTIAL_1D_INT_START(DIM1, ARR2, START)
    INTEGER,                  INTENT(IN   ):: DIM1
    INTEGER,                  INTENT(IN   ):: START
    INTEGER, DIMENSION(DIM1), INTENT(  OUT):: ARR2
    INTEGER:: I, STRT
    !
    STRT = START
    DO I=ONE, DIM1
                ARR2(I) = STRT
                STRT = STRT + ONE
    END DO
    !
  END SUBROUTINE
  !
  !#############################################################################################################################################################
  !
  PURE SUBROUTINE SET_ARRAY_SEQUENTIAL_1D_INT_INC(DIM1, ARR2, START, INC)
    INTEGER,                  INTENT(IN   ):: DIM1
    INTEGER,                  INTENT(IN   ):: START, INC
    INTEGER, DIMENSION(DIM1), INTENT(  OUT):: ARR2
    INTEGER:: I, STRT
    !
    STRT = START
    DO I=ONE, DIM1
                ARR2(I) = STRT
                STRT = STRT + INC
    END DO
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  LOG2 routines
  !
  FUNCTION LOG2_DBLE( X ) RESULT(LOG2)
    REAL(REAL64), INTENT(IN):: X
    REAL(REAL64):: LOG2
    !
    IF( X > 0D0) THEN
                 LOG2 = LOG(X) / LOG_2
    ELSE
                 LOG2 = ninf
    END IF
    !
  END FUNCTION
  !
  FUNCTION LOG2_SNLG( X ) RESULT(LOG2)
    REAL(REAL32), INTENT(IN):: X
    REAL(REAL32):: LOG2
    !
    IF( X > 0.0) THEN
                 LOG2 = LOG(X) / LOG_2_R
    ELSE
                 LOG2 = ninf_R
    END IF
    !
  END FUNCTION
  !
  FUNCTION LOG2_INT32( X ) RESULT( LOG2 )
    INTEGER(INT32), INTENT(IN) :: X
    INTEGER(INT32)             :: LOG2
    INTEGER(INT32)             :: IVAL
    !
    LOG2 = -1 
    !
    IF ( X > 0 ) THEN
        !
        IVAL = X
        DO WHILE (IVAL > 0)
                          LOG2 = LOG2 + 1
                          IVAL = SHIFTR( IVAL, 1 )  !Drop out the right most bit
        ENDDO
    END IF
  END FUNCTION
  !
  FUNCTION LOG2_INT64( X ) RESULT( LOG2 )
    INTEGER(INT64), INTENT(IN) :: X
    INTEGER(INT64)             :: LOG2
    INTEGER(INT64)             :: IVAL
    !
    LOG2 = -1 
    !
    IF ( X > 0 ) THEN
        !
        IVAL = X
        DO WHILE (IVAL > 0)
                          LOG2 = LOG2 + 1
                          IVAL = SHIFTR( IVAL, 1 )  !Drop out the right most bit
        ENDDO
    END IF
  END FUNCTION
  !
  FUNCTION LOG2_INT8( X ) RESULT( LOG2 )
    INTEGER(INT8), INTENT(IN) :: X
    INTEGER(INT8)             :: LOG2
    INTEGER(INT8)             :: IVAL
    !
    LOG2 = -1 
    !
    IF ( X > 0 ) THEN
        !
        IVAL = X
        DO WHILE (IVAL > 0)
                          LOG2 = LOG2 + 1
                          IVAL = SHIFTR( IVAL, 1 )  !Drop out the right most bit
        ENDDO
    END IF
  END FUNCTION
  !
  FUNCTION LOG2_INT16( X ) RESULT( LOG2 )
    INTEGER(INT16), INTENT(IN) :: X
    INTEGER(INT16)             :: LOG2
    INTEGER(INT16)             :: IVAL
    !
    LOG2 = -1 
    !
    IF ( X > 0 ) THEN
        !
        IVAL = X
        DO WHILE (IVAL > 0)
                          LOG2 = LOG2 + 1
                          IVAL = SHIFTR( IVAL, 1 )  !Drop out the right most bit
        ENDDO
    END IF
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  Vector Max Min adjustment routines
  !
  PURE SUBROUTINE VEC_ADJUST_MAXSUM(VEC, MAXSUM, ORDER)
    DOUBLE PRECISION, DIMENSION(:),CONTIGUOUS,INTENT(INOUT):: VEC
    DOUBLE PRECISION,                         INTENT(IN   ):: MAXSUM
    INTEGER, OPTIONAL,DIMENSION(:),CONTIGUOUS,INTENT(IN   ):: ORDER
    INTEGER:: I,N
    DOUBLE PRECISION:: TOT
    !
    N = SIZE(VEC)
    TOT = SUM(VEC)
    !
    IF(PRESENT(ORDER)) THEN
        DO I=ONE, N
           ASSOCIATE(J=>ORDER(I))
                IF(TOT > MAXSUM) THEN
                    !
                    VEC(J) = VEC(J) + MAXSUM - TOT
                    !
                    IF(VEC(J) < DZ) VEC(J) = DZ
                    !
                    TOT = SUM(VEC)
                ELSE
                    EXIT
                END IF
           END ASSOCIATE
        END DO
    ELSE
        DO I=ONE, N
              IF(TOT > MAXSUM) THEN
                  !
                  VEC(I) = VEC(I) + MAXSUM - TOT
                  !
                  IF(VEC(I) < DZ) VEC(I) = DZ
                  !
                  TOT = SUM(VEC)
              ELSE
                  EXIT
              END IF
        END DO
    END IF
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  SUBROUTINE REDUCE_SUM_BY(VEC, REDUCER, ORDER) !REDUCES BY THE REDUCER -- If Negative, nothing happens
    DOUBLE PRECISION, DIMENSION(:),CONTIGUOUS,INTENT(INOUT):: VEC
    DOUBLE PRECISION,                         INTENT(IN   ):: REDUCER
    INTEGER, OPTIONAL,DIMENSION(:),CONTIGUOUS,INTENT(IN   ):: ORDER
    DOUBLE PRECISION:: RED
    INTEGER:: I
    !
    IF(REDUCER > DZ) THEN
        !
        RED = DNEG*REDUCER  !MAKE NEGATIVE
        !
        IF(PRESENT(ORDER)) THEN
            DO I=ONE, SIZE(VEC)
                ASSOCIATE(J=>ORDER(I))
                                     VEC(J) = VEC(J) + RED
                                     IF( VEC(J) < DZ ) THEN
                                         RED = VEC(J) 
                                         VEC(J) = DZ
                                     ELSE
                                         !RED = DZ
                                         EXIT
                                     END IF
                END ASSOCIATE
            END DO
        ELSE
            DO I=ONE, SIZE(VEC)
                VEC(I) = VEC(I) + RED
                IF( VEC(I) < DZ ) THEN
                    RED = VEC(I) 
                    VEC(I) = DZ
                ELSE
                    !RED = DZ
                    EXIT
                END IF
            END DO
        END IF
    END IF
    !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  String routines
  !
  PURE ELEMENTAL SUBROUTINE COMMA_STRIP(LINE)    
    CHARACTER(*), INTENT(INOUT):: LINE
    INTEGER:: I
    !
    DO CONCURRENT (I=1:LEN_TRIM(LINE), LINE(I:I)==',') 
        LINE(I:I)=BLNK
    END DO
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE ELEMENTAL SUBROUTINE TAB_STRIP(LINE)
    CHARACTER(*), INTENT(INOUT):: LINE
    INTEGER:: I
    !
    DO CONCURRENT (I=1:LEN_TRIM(LINE), LINE(I:I)==TAB)  !TAB = CHAR(9)
        LINE(I:I)=BLNK
    END DO
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE ELEMENTAL SUBROUTINE SPECIAL_BLANK_STRIP(LINE)
    CHARACTER(*), INTENT(INOUT):: LINE
    INTEGER:: I
    !
    DO CONCURRENT (I=1:LEN_TRIM(LINE), LINE(I:I)==TAB .OR. LINE(I:I)==CR .OR. LINE(I:I)==LF)  !TAB = CHAR(9)
        LINE(I:I)=BLNK
    END DO
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE FUNCTION IS_IN_STR(SUB,LINE,COM_STOP,UPCASE) RESULT(FOUND)
    CHARACTER(*),      INTENT(IN):: SUB
    CHARACTER(*),      INTENT(IN):: LINE
    LOGICAL, OPTIONAL, INTENT(IN):: COM_STOP, UPCASE
    INTEGER:: I
    LOGICAL:: FOUND
    !
    FOUND = FALSE
    IF(PRESENT(COM_STOP)) FOUND = COM_STOP
    !
    IF(FOUND) THEN
        I = COMMENT_INDEX(LINE)
    ELSE
        I = LEN_TRIM(LINE)
    END IF
    !
    IF(PRESENT(UPCASE)) THEN
        IF(UPCASE) THEN!
                         FOUND = INDEX(GO_UP(LINE(:I)),GO_UP(SUB)) > Z
        ELSE
                         FOUND = INDEX(LINE(:I),SUB) > Z
        END IF
    ELSE
                         FOUND = INDEX(LINE(:I),SUB) > Z
    END IF
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE FUNCTION GO_UP(LINE,NOTRIM) RESULT(UPLINE)
    CHARACTER(*),      INTENT(IN):: LINE
    LOGICAL, OPTIONAL, INTENT(IN):: NOTRIM
    CHARACTER(:), ALLOCATABLE:: UPLINE
    !
    IF(PRESENT(NOTRIM)) THEN
        IF(NOTRIM) THEN
                       ALLOCATE(UPLINE, SOURCE=LINE)
        ELSE
                       ALLOCATE(UPLINE, SOURCE=TRIM(LINE))
        END IF
    ELSE
                       ALLOCATE(UPLINE, SOURCE=TRIM(LINE))
    END IF
    !
    CALL UPPER(UPLINE)
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE ELEMENTAL SUBROUTINE UPPER(LN)
    CHARACTER(*),INTENT(INOUT):: LN
    INTEGER, PARAMETER:: IDIFF=ICHAR('a')-ICHAR('A')
    INTEGER::I
    !
    DO CONCURRENT(I=1:LEN(LN), LN(I:I).GE.'a' .AND. LN(I:I).LE.'z');  LN(I:I)=CHAR(ICHAR(LN(I:I))-IDIFF)
    END DO
    !
  END SUBROUTINE
  !
  !#########################################################################################################################
  !
  PURE FUNCTION JOIN_TXT(TXT,JOIN,ENDING) RESULT(LN)
    CHARACTER(*),DIMENSION(:),CONTIGUOUS,INTENT(IN):: TXT
    CHARACTER(*),                        INTENT(IN):: JOIN
    CHARACTER(*), OPTIONAL,              INTENT(IN):: ENDING
    CHARACTER(:),                       ALLOCATABLE:: LN
    INTEGER::I
    !
    LN=TRIM(ADJUSTL(TXT(ONE)))
    DO I=TWO, SIZE(TXT)
                      LN=LN//JOIN//TRIM(ADJUSTL(TXT(I)))
    END DO
    !
    IF(PRESENT(ENDING)) LN=LN//ENDING
    !
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  IS_UNIQUE  routines
  !
  PURE FUNCTION STR_IS_UNIQUE(VAL, VEC, UPCASE) RESULT (UNI)
    CHARACTER(*),                         INTENT(IN):: VAL
    CHARACTER(*),DIMENSION(:),CONTIGUOUS, INTENT(IN):: VEC
    LOGICAL,                              INTENT(IN):: UPCASE
    LOGICAL:: UNI
    CHARACTER(LEN_TRIM(VAL)):: SUB
    CHARACTER(LEN(VEC)):: STR
    INTEGER:: I
    !
    IF(UPCASE) THEN
       SUB = VAL
       CALL UPPER(SUB)
       !
       DO I=ONE, SIZE(VEC)
           UNI = TRUE
           STR = VEC(I)
           CALL UPPER(STR)
           IF(SUB==STR) THEN
               UNI=FALSE
               EXIT
           END IF
       END DO
    ELSE
        UNI = STR_CASE_IS_UNIQUE(VAL, VEC)
    END IF
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE FUNCTION STR_CASE_IS_UNIQUE(VAL, VEC, IQNORE) RESULT (UNI)
    CHARACTER(*),                         INTENT(IN):: VAL
    CHARACTER(*),DIMENSION(:),CONTIGUOUS, INTENT(IN):: VEC
    CHARACTER(*),OPTIONAL,                INTENT(IN):: IQNORE
    LOGICAL:: UNI
    INTEGER:: I
    !
    IF(PRESENT(IQNORE)) THEN
        UNI = TRUE
        DO I=ONE, SIZE(VEC)
            IF(VAL==VEC(I) .AND. VEC(I).NE.IQNORE) THEN
                UNI=FALSE
                EXIT
            END IF
        END DO
    ELSE
                UNI = ALL(VAL.NE.VEC)
    END IF
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE FUNCTION INT_IS_UNIQUE(VAL, VEC) RESULT (UNI)
    INTEGER,                         INTENT(IN):: VAL
    INTEGER,DIMENSION(:),CONTIGUOUS, INTENT(IN):: VEC
    LOGICAL:: UNI
    !
    UNI = ALL(VAL.NE.VEC)
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE FUNCTION REAL_IS_UNIQUE(VAL, VEC, TOL) RESULT (UNI)
    REAL(REAL32),                         INTENT(IN):: VAL
    REAL(REAL32),DIMENSION(:),CONTIGUOUS, INTENT(IN):: VEC
    REAL(REAL32), OPTIONAL,               INTENT(IN):: TOL
    LOGICAL:: UNI
    INTEGER:: I
    !
    IF(PRESENT(TOL)) THEN
        UNI = TRUE
        DO I=ONE, SIZE(VEC)
            IF(ABS(VAL-VEC(I))<TOL) THEN
                UNI=FALSE
                EXIT
            END IF
        END DO
    ELSE
                UNI = ALL(VAL.NE.VEC)
    END IF
    !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE FUNCTION DBLE_IS_UNIQUE(VAL, VEC, TOL) RESULT (UNI)
    DOUBLE PRECISION,                         INTENT(IN):: VAL
    DOUBLE PRECISION,DIMENSION(:),CONTIGUOUS, INTENT(IN):: VEC
    DOUBLE PRECISION, OPTIONAL,               INTENT(IN):: TOL
    LOGICAL:: UNI
    INTEGER:: I
    !
    IF(PRESENT(TOL)) THEN
        UNI = TRUE
        DO I=ONE, SIZE(VEC)
            IF(ABS(VAL-VEC(I))<TOL) THEN
                UNI=FALSE
                EXIT
            END IF
        END DO
    ELSE
                UNI = ALL(VAL.NE.VEC)
    END IF
    !
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  TO_SNGL  routines
  !
  PURE ELEMENTAL FUNCTION SNGL_TO_SNGL(X) RESULT(RES)
     REAL(REAL32), INTENT(IN):: X
     REAL(REAL32):: RES
     !
     RES = X
     !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE ELEMENTAL FUNCTION DBLE_TO_SNGL(X) RESULT(RES)
     REAL(REAL64), INTENT(IN):: X
     REAL(REAL32):: RES
     !
     IF    (X < SNGL_ninf) THEN
                               RES = SNGL_ninf_R
     ELSEIF(SNGL_inf < X ) THEN
                               RES = SNGL_inf_R
     ELSE
                               RES = REAL(X, REAL32)
     END IF
     !
  END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE ELEMENTAL FUNCTION QUAD_TO_SNGL(X) RESULT(RES)
     REAL(REAL128), INTENT(IN):: X
     REAL(REAL32):: RES
     !
     IF    (X < REAL(SNGL_ninf,REAL128)) THEN
                                             RES = SNGL_ninf_R
     ELSEIF(REAL(SNGL_inf,REAL128) < X ) THEN
                                             RES = SNGL_inf_R
     ELSE
                                             RES = REAL(X, REAL32)
     END IF
     !
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  CHECK_FOR_POST_KEY  routine
  !
  SUBROUTINE CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,BUF,SPLIT,SCALE,FILSTAT,FILACT,ASYN, BINARY, NOPRINT, GO_TO_TOP, DIM, OLDLOC, MSG)
    CHARACTER(*),     INTENT(IN   ):: LN                  !LN IS NOT MODIFIED, BUT NEEDS INOUT TO PASS TO PARSEWORD
    INTEGER,          INTENT(IN   ):: IN, IOUT            !INFILE THAT LN CAME FROM, ERROR UNIT TO WRITE TOO
    INTEGER,          INTENT(INOUT):: LLOC, BUF, SPLIT    !BUF=Returned buffer size, SPLIT=Returned Split size
    DOUBLE PRECISION, INTENT(INOUT), OPTIONAL:: SCALE     !IS RETURNED IF A SCALE FACTOR IS FOUND
    CHARACTER(*),     INTENT(INOUT), OPTIONAL:: FILSTAT, FILACT, ASYN   !RETURNS ACTIONS THAT WERE TAKEN TO FILE
    LOGICAL,          INTENT(INOUT), OPTIONAL:: BINARY, NOPRINT  !BINARY IS SET TO TRUE IF KEYWORD FOUND, OTHERWISE LEFT ALONE
    LOGICAL,          INTENT(  OUT), OPTIONAL:: GO_TO_TOP
    INTEGER,          INTENT(INOUT), OPTIONAL:: DIM
    INTEGER,          INTENT(  OUT), OPTIONAL:: OLDLOC
    CHARACTER(*),     INTENT(IN   ), OPTIONAL:: MSG
    CHARACTER(32):: KEY
    CHARACTER(:), ALLOCATABLE:: ERR
    INTEGER::I, ISTART, ISTOP, LLOC_BAK, IERR, C, OLD_LOC !,Z
    DOUBLE PRECISION:: SF
    !
    !Z = 0
    IF(PRESENT(SCALE    )) SCALE    = UNO
    IF(PRESENT(FILSTAT  )) FILSTAT  = 'UNKNOWN'
    IF(PRESENT(FILACT   )) FILACT   = 'READWRITE'
    IF(PRESENT(ASYN     )) ASYN     = 'NO'
    IF(PRESENT(NOPRINT  )) NOPRINT  = FALSE
    IF(PRESENT(GO_TO_TOP)) GO_TO_TOP= FALSE
    !
    OLD_LOC = LLOC
    ERR = NL
    !
    C = INDEX(LN,COM)   !COM = '#'
    IF( C==Z ) C = MIN( LEN_TRIM(LN)+ONE, LEN(LN) )   !NO # FOUND, SO GET THE SMALLER OF THE TWO LENGTHS
    !
    LLOC_BAK = LLOC
    DO WHILE (LLOC < C)
      !
      CALL PARSE_WORD(LN(:C),LLOC,ISTART,ISTOP)   !CHECK FOR BUFFER OR SPLIT FLAG
      !
      IF(LN(ISTART:ISTOP) == BLNK .OR. LN(ISTART:ISTOP) == COM) EXIT
      !
      KEY=LN(ISTART:ISTOP)
      CALL UPPER(KEY)
      !
      SELECT CASE (KEY)
      CASE( 'BUFFER', 'BUFER', 'BUF', 'BUFF' )
                      LLOC_BAK = LLOC
                      CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
                      !
                      READ(LN(ISTART:ISTOP),*,IOSTAT=IERR) BUF
                      !
                      IF(IERR.NE.Z .OR. LN(ISTART:ISTOP)==BLNK) THEN
                                                   BUF = 65536    ! 64KB x2 = 128KB  --1048576 = 1MB   --NOTE THAT TWO THREADS ARE USED PER BUFFER SO ACTUAL SPACE IS TWICE AS BIG
                                                   LLOC = LLOC_BAK
                      ELSEIF( BUF == THOU ) THEN
                                                   BUF = 524288   ! 512KB x2 = 1MB
                      ELSEIF( BUF == QUIN ) THEN
                                                   BUF = 262144   ! 256KB x2 = 0.5MB
                      ELSEIF( BUF > SEV   ) THEN
                                                   BUF = 4096*(BUF/EIGHT)  !Make sure it is a multiple of 8  -- 4096=512*8
                      ELSEIF( BUF > Z ) THEN
                                                   BUF = 512*BUF
                      ELSE
                                                   BUF = Z
                      END IF
                      LLOC_BAK = LLOC
                      !
      CASE( 'SPLIT' )
                      LLOC_BAK = LLOC
                      CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
                      !
                      READ(LN(ISTART:ISTOP),*,IOSTAT=IERR) SPLIT
                      !
                      IF(IERR.NE.Z .OR. LN(ISTART:ISTOP)==BLNK) THEN
                                                   SPLIT = 2048     !NOTE MOST OS HAVE 4GB file size limit
                                                   LLOC = LLOC_BAK
                      ELSEIF( SPLIT == THOU ) THEN
                                                   SPLIT = 1024

                      ELSEIF( SPLIT == QUIN ) THEN
                                                   SPLIT = 512
                      ELSEIF( SPLIT > EIGHT ) THEN
                                                   SPLIT = 8*(SPLIT/8)  !Make sure it is a multiple of 8
                      ELSEIF( SPLIT > FOUR  ) THEN
                                                   SPLIT = 8
                      ELSEIF( SPLIT > TWO   ) THEN
                                                   SPLIT = 4
                      ELSEIF( SPLIT > Z ) THEN
                                                   SPLIT = 2
                      ELSE
                                                   SPLIT = Z
                      END IF
                      LLOC_BAK = LLOC
      CASE( 'SF', 'SCALE' )
                      CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
                      !
                      IF(PRESENT(SCALE)) THEN
                          SF = UNO
                          READ(LN(ISTART:ISTOP),*, IOSTAT=I) SF
                          IF(I.NE.Z) THEN
                              ERR = 'FOUND KEYWORD "SF" OR "SCALE", BUT FAILED TO CONVERT SCALE FACTOR TO FLOATING POINT NUMBER.'
                              IF(PRESENT(MSG))  ERR=ERR//BLN//'THE FOLLOWING MESSAGE WAS PASSED TO CHECK_FOR_POST_KEY:'//BLN//MSG
                              CALL STOP_ERROR(LN,IN,IOUT,ERR)
                          END IF
                          IF(SF.NE.DZ) SCALE = SCALE * SF
                      ELSE
                          ERR = 'FOUND KEYWORD "SF" OR "SCALE", BUT THIS MODEL FEATURE DOES NOT ALLOW SCALE FACTORS. PLEASE REMOVE KEYWORD SF OR SCALE.'
                          IF(PRESENT(MSG))  ERR=ERR//BLN//'THE FOLLOWING MESSAGE WAS PASSED TO CHECK_FOR_POST_KEY:'//BLN//MSG
                          CALL STOP_ERROR(LN,IN,IOUT,ERR)
                      END IF
                      !
                      LLOC_BAK = LLOC
      CASE( 'OLD', 'READ' )
                      IF(PRESENT(FILSTAT  )) FILSTAT  = 'OLD'
                      IF(PRESENT(FILACT   )) FILACT   = 'READ'
                                             LLOC_BAK =  LLOC
      CASE( 'REPLACE', 'WRITE' )
                      IF(PRESENT(FILSTAT  )) FILSTAT  = 'REPLACE'
                      IF(PRESENT(FILACT   )) FILACT   = 'WRITE'
                                             LLOC_BAK =  LLOC
      CASE( 'BINARY' )
                      IF(PRESENT(BINARY)) THEN
                          BINARY = TRUE
                      ELSE
                          ERR = ERR//'FOUND KEYWORD "BINARY", BUT THIS INPUT/OUTPUT LINE DOES NOT SUPPORT THE "BINARY" KEYWORD. IT WILL BE IGNORED.'//NL
                          !WRITE(IOUT,'(/A,/A,/A/)') 'CHECK_FOR_POST_KEY WARNING: WHILE PROCESSING LINE: ',TRIM(LN),'FOUND KEYWORD "BINARY", BUT THIS INPUT/OUTPUT LINE DOES NOT SUPPORT THE "BINARY" KEYWORD. IT WILL BE IGNORED.'
                      END IF
                      LLOC_BAK =  LLOC
      CASE( 'ASYNC' )
                      ASYN='YES'
                      LLOC_BAK =  LLOC
      CASE( 'NOPRINT' )
                      LLOC_BAK =  LLOC
                      IF(PRESENT(NOPRINT)) THEN
                          NOPRINT = TRUE
                          RETURN
                      ELSE
                          ERR = ERR//'FOUND KEYWORD "NOPRINT", BUT THIS INPUT/OUTPUT LINE DOES NOT SUPPORT THE NOPRINT KEYWORD. IT WILL BE IGNORED.'//NL
                          !WRITE(IOUT,'(/A,/A,/A)') 'CHECK_FOR_POST_KEY WARNING: WHILE PROCESSING LINE: ',TRIM(LN),'FOUND KEYWORD "NOPRINT", BUT THIS INPUT/OUTPUT LINE DOES NOT SUPPORT THE NOPRINT KEYWORD. IT WILL BE IGNORED.'
                      END IF
      CASE( 'REWIND', 'GO_TO_TOP' )
                      LLOC_BAK =  LLOC
                      IF(PRESENT(GO_TO_TOP)) THEN
                          GO_TO_TOP = TRUE
                      ELSE
                          ERR = ERR//'FOUND KEYWORD "'//TRIM(KEY)//'", BUT THIS INPUT/OUTPUT LINE DOES NOT SUPPORT REWINDING THE FILE TO THE FIRST LINE. IT WILL BE IGNORED.'//NL
                          !WRITE(IOUT,'(/A,/A,/A)') 'CHECK_FOR_POST_KEY WARNING: WHILE PROCESSING LINE: ',TRIM(LN),'FOUND KEYWORD "'//TRIM(KEY)//'", BUT THIS INPUT/OUTPUT LINE DOES NOT SUPPORT REWINDING THE FILE TO THE FIRST LINE. IT WILL BE IGNORED.'
                      END IF

      CASE ('DIM','DIMENSION')
                      CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
                      !
                      IF(PRESENT(DIM)) THEN
                          READ(LN(ISTART:ISTOP),*, IOSTAT=I) DIM
                          IF(I.NE.Z) THEN
                             ERR = 'FOUND KEYWORD "'//TRIM(KEY)//'", WHICH MUST BE FOLLOWED BY AN INTEGER THAT REPRESENTS THE NUMBER OF ROWS TO LOAD, BUT FAILED TO CONVERT THE DIMENSION TO AN INTEGER (NUMBER FOLLOWING KEYWORD).'
                             IF(PRESENT(MSG))  ERR=ERR//BLN//'THE FOLLOWING MESSAGE WAS PASSED TO CHECK_FOR_POST_KEY:'//BLN//MSG
                             CALL STOP_ERROR(LN,IN,IOUT,ERR)
                          END IF
                      ELSE
                          ERR = ERR//'FOUND KEYWORD "'//TRIM(KEY)//'", BUT THIS MODEL FEATURE DOES NOT USE A USER SPECIFIED DIMENSION. IT WILL BE IGNORED.'//NL
                          !CALL WARNING_MESSAGE(LN,IN,IOUT,'FOUND KEYWORD "'//TRIM(KEY)//'", BUT THIS MODEL FEATURE DOES NOT USE A USER SPECIFIED DIMENSION. IT WILL BE IGNORED.')
                      END IF
                      !
                      LLOC_BAK = LLOC
      CASE ('AUTO','AUTOCOUNT','AUTO-COUNT')
                      IF(PRESENT(DIM)) THEN
                            DIM=Z
                      ELSE
                          ERR = ERR//'FOUND KEYWORD "'//TRIM(KEY)//'", BUT THIS MODEL FEATURE DOES NOT SUPPORT AUTOMATIC DIMENSION CALCULATION. IT WILL BE IGNORED.'
                          !CALL WARNING_MESSAGE(LN,IN,IOUT,'FOUND KEYWORD "'//TRIM(KEY)//'", BUT THIS MODEL FEATURE DOES NOT SUPPORT AUTOMATIC DIMENSION CALCULATION. IT WILL BE IGNORED.')
                      END IF
      CASE DEFAULT
                      I = ONE
                      IF(PRESENT(SCALE)) THEN
                          SF = UNO
                          READ(LN(ISTART:ISTOP),*, IOSTAT=I) SF
                          IF(I==Z .AND. SF.NE.DZ) SCALE = SCALE * SF
                      END IF
                      !
                      IF(I.NE.Z) THEN
                          ERR = ERR//'FAILED TO IDENTIFY THE FOLLOWING POST-KEYWORD: '//BLN//'"'//TRIM(KEY)//'"'//BLN//'IT WILL BE IGNORED AND NO FURTHER KEYWORDS WILL BE CHECKED/INCLUDED TO THE RIGHT OF IT.'//NL//'TO SUPRESS THIS WARNING PLEASE PLACE A "#" SYMBOL TO THE LEFT OF THE WORD TO INDICATE EVERYTHING TO THE RIGHT OF THE # IS A COMMENT'
                          !CALL WARNING_MESSAGE(LN,IN,IOUT,MSG='CHECK_FOR_POST_KEY: FAILED TO IDENTIFY THE FOLLOWING POST-KEYWORD: '//BLN//'"'//TRIM(KEY)//'"'//BLN//'IT WILL BE IGNORED AND NO FURTHER KEYWORDS WILL BE CHECKED/INCLUDED TO THE RIGHT OF IT.'//NL//'TO SUPRESS THIS WARNING PLEASE PLACE A "#" SYMBOL TO THE LEFT OF THE WORD TO INDICATE EVERYTHING TO THE RIGHT OF THE # IS A COMMENT')
                          EXIT
                      ELSE
                          LLOC_BAK =  LLOC
                      END IF
      END SELECT
    END DO
    !
    LLOC = LLOC_BAK
    !
    IF(PRESENT(OLDLOC)) OLDLOC = OLD_LOC
    !
    IF(ERR.NE.NL) CALL WARNING_MESSAGE(LN,IN,IOUT,MSG='...CHECK_FOR_POST_KEY WARNINGS...'//NL//' THE FOLLOWING MESSAGES WERE PASSED WHILE CHECKING FOR ANY ADDITIONAL KEYWORDS ON LOADED LINE.'//BLN//ERR)
    !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  MISMATCH and OVERFLOW  routine
  !
  PURE FUNCTION DIM_MISMATCH_1D(VEC,N) RESULT(TF)
    CLASS(*), DIMENSION(:,:), ALLOCATABLE, INTENT(IN):: VEC
    INTEGER, INTENT(IN):: N
    LOGICAL:: TF
    !
    IF(ALLOCATED(VEC)) THEN
                         TF = SIZE(VEC,1)==N
    ELSE
                         TF = TRUE
    END IF
  END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE FUNCTION DIM_MISMATCH_2D(ARR,N,M) RESULT(TF)
    CLASS(*), DIMENSION(:,:), ALLOCATABLE, INTENT(IN):: ARR
    INTEGER, INTENT(IN):: N,M
    LOGICAL:: TF
    !
    IF(ALLOCATED(ARR)) THEN
                         TF = SIZE(ARR,1)==N .AND. SIZE(ARR,2)==M
    ELSE
                         TF = TRUE
    END IF
  END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE FUNCTION DIM_OVERFLOW_1D(VEC,N) RESULT(TF)
    CLASS(*), DIMENSION(:,:), ALLOCATABLE, INTENT(IN):: VEC
    INTEGER, INTENT(IN):: N
    LOGICAL:: TF
    !
    IF(ALLOCATED(VEC)) THEN
                         TF = SIZE(VEC,1) <= N
    ELSE
                         TF = TRUE
    END IF
  END FUNCTION
  !
  !#########################################################################################################################
  !
  PURE FUNCTION DIM_OVERFLOW_2D(ARR,N,M) RESULT(TF)
    CLASS(*), DIMENSION(:,:), ALLOCATABLE, INTENT(IN):: ARR
    INTEGER, INTENT(IN):: N,M
    LOGICAL:: TF
    !
    IF(ALLOCATED(ARR)) THEN
                         TF = SIZE(ARR,1) <= N .AND. SIZE(ARR,2) <= M
    ELSE
                         TF = TRUE
    END IF
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !  
  !  GAME_OVER  routine
  !
  SUBROUTINE GAME_OVER(IOUT)
    INTEGER, INTENT(IN):: IOUT
    !
    IF(IOUT.NE.Z) WRITE(IOUT,'(///A)')                                                                                                                   &
    '             GGGGGGGGGGGGG                    AAA                    MMMMMMMM               MMMMMMMM     EEEEEEEEEEEEEEEEEEEEEE'//NL//  &
    '          GGG::::::::::::G                   A:::A                   M:::::::M             M:::::::M     E::::::::::::::::::::E'//NL//  &
    '        GG:::::::::::::::G                  A:::::A                  M::::::::M           M::::::::M     E::::::::::::::::::::E'//NL//  &
    '       G:::::GGGGGGGG::::G                 A:::::::A                 M:::::::::M         M:::::::::M     EE::::::EEEEEEEEE::::E'//NL//  &
    '      G:::::G       GGGGGG                A:::::::::A                M::::::::::M       M::::::::::M       E:::::E       EEEEEE'//NL//  &
    '     G:::::G                             A:::::A:::::A               M:::::::::::M     M:::::::::::M       E:::::E             '//NL//  &
    '     G:::::G                            A:::::A A:::::A              M:::::::M::::M   M::::M:::::::M       E::::::EEEEEEEEEE   '//NL//  &
    '     G:::::G    GGGGGGGGGG             A:::::A   A:::::A             M::::::M M::::M M::::M M::::::M       E:::::::::::::::E   '//NL//  &
    '     G:::::G    G::::::::G            A:::::A     A:::::A            M::::::M  M::::M::::M  M::::::M       E:::::::::::::::E   '//NL//  &
    '     G:::::G    GGGGG::::G           A:::::AAAAAAAAA:::::A           M::::::M   M:::::::M   M::::::M       E::::::EEEEEEEEEE   '//NL//  &
    '     G:::::G        G::::G          A:::::::::::::::::::::A          M::::::M    M:::::M    M::::::M       E:::::E             '//NL//  &
    '      G:::::G       G::::G         A:::::AAAAAAAAAAAAA:::::A         M::::::M     MMMMM     M::::::M       E:::::E       EEEEEE'//NL//  &
    '       G:::::GGGGGGGG::::G        A:::::A             A:::::A        M::::::M               M::::::M     EE::::::EEEEEEEE:::::E'//NL//  &
    '        GG:::::::::::::::G       A:::::A               A:::::A       M::::::M               M::::::M     E::::::::::::::::::::E'//NL//  &
    '          GGG::::::GGG:::G      A:::::A                 A:::::A      M::::::M               M::::::M     E::::::::::::::::::::E'//NL//  &
    '             GGGGGG   GGGG     AAAAAAA                   AAAAAAA     MMMMMMMM               MMMMMMMM     EEEEEEEEEEEEEEEEEEEEEE'//NL//  &
    ' '//NL//  &
    ' '//NL//  &
    ' '//NL//  &
    ' '//NL//  &
    ' '//NL//  &
    ' '//NL//  &
    ' '//NL//  &
    ' '//NL//  &
    ' '//NL//  &
    '          OOOOOOOOO               VVVVVVVV           VVVVVVVV          EEEEEEEEEEEEEEEEEEEEEE          RRRRRRRRRRRRRRRRR       '//NL//  &
    '        OO:::::::::OO             V::::::V           V::::::V          E::::::::::::::::::::E          R::::::::::::::::R      '//NL//  &
    '      OO:::::::::::::OO           V::::::V           V::::::V          E::::::::::::::::::::E          R::::::RRRRRR:::::R     '//NL//  &
    '     O:::::::OOO:::::::O          V::::::V           V::::::V          EE::::::EEEEEEEEE::::E          RR:::::R     R:::::R    '//NL//  &
    '     O::::::O   O::::::O           V:::::V           V:::::V             E:::::E       EEEEEE            R::::R     R:::::R    '//NL//  &
    '     O:::::O     O:::::O            V:::::V         V:::::V              E:::::E                         R::::R     R:::::R    '//NL//  &
    '     O:::::O     O:::::O             V:::::V       V:::::V               E::::::EEEEEEEEEE               R::::RRRRRR:::::R     '//NL//  &
    '     O:::::O     O:::::O              V:::::V     V:::::V                E:::::::::::::::E               R:::::::::::::RR      '//NL//  &
    '     O:::::O     O:::::O               V:::::V   V:::::V                 E:::::::::::::::E               R::::RRRRRR:::::R     '//NL//  &
    '     O:::::O     O:::::O                V:::::V V:::::V                  E::::::EEEEEEEEEE               R::::R     R:::::R    '//NL//  &
    '     O:::::O     O:::::O                 V:::::V:::::V                   E:::::E                         R::::R     R:::::R    '//NL//  &
    '     O::::::O   O::::::O                  V:::::::::V                    E:::::E       EEEEEE            R::::R     R:::::R    '//NL//  &
    '     O:::::::OOO:::::::O                   V:::::::V                   EE::::::EEEEEEEE:::::E          RR:::::R     R:::::R    '//NL//  &
    '      OO:::::::::::::OO                     V:::::V                    E::::::::::::::::::::E          R::::::R     R:::::R    '//NL//  &
    '        OO:::::::::OO                        V:::V                     E::::::::::::::::::::E          R::::::R     R:::::R    '//NL//  &
    '          OOOOOOOOO                           VVV                      EEEEEEEEEEEEEEEEEEEEEE          RRRRRRRR     RRRRRRR    '

  END SUBROUTINE
  !
  !  EPIC_FAIL  routine
  !
  SUBROUTINE EPIC_FAIL(IOUT)
    INTEGER, INTENT(IN):: IOUT
    !
    IF(IOUT.NE.Z) WRITE(IOUT,'(///A)')                                                                     &
     "    .----------------.     .----------------.     .----------------.     .----------------. "//NL//  &
     "   | .--------------. |   | .--------------. |   | .--------------. |   | .--------------. |"//NL//  &
     "   | |  _________   | |   | |   ______     | |   | |     _____    | |   | |     ______   | |"//NL//  &
     "   | | |_   ___  |  | |   | |  |_   __ \   | |   | |    |_   _|   | |   | |   .' ___  |  | |"//NL//  &
     "   | |   | |_  \_|  | |   | |    | |__) |  | |   | |      | |     | |   | |  / .'   \_|  | |"//NL//  &
     "   | |   |  _|  _   | |   | |    |  ___/   | |   | |      | |     | |   | |  | |         | |"//NL//  &
     "   | |  _| |___/ |  | |   | |   _| |_      | |   | |     _| |_    | |   | |  \ `.___.'\  | |"//NL//  &
     "   | | |_________|  | |   | |  |_____|     | |   | |    |_____|   | |   | |   `._____.'  | |"//NL//  &
     "   | |              | |   | |              | |   | |              | |   | |              | |"//NL//  &
     "   | '--------------' |   | '--------------' |   | '--------------' |   | '--------------' |"//NL//  &
     "    '----------------'     '----------------'     '----------------'     '----------------' "//NL//  &
     " "//NL//  &
     "                                                  .----------------.     .----------------.     .----------------.     .----------------. "//NL//  &
     "                                                 | .--------------. |   | .--------------. |   | .--------------. |   | .--------------. |"//NL//  &
     "                                                 | |  _________   | |   | |      __      | |   | |     _____    | |   | |   _____      | |"//NL//  &
     "                                                 | | |_   ___  |  | |   | |     /  \     | |   | |    |_   _|   | |   | |  |_   _|     | |"//NL//  &
     "                                                 | |   | |_  \_|  | |   | |    / /\ \    | |   | |      | |     | |   | |    | |       | |"//NL//  &
     "                                                 | |   |  _|      | |   | |   / ____ \   | |   | |      | |     | |   | |    | |   _   | |"//NL//  &
     "                                                 | |  _| |_       | |   | | _/ /    \ \_ | |   | |     _| |_    | |   | |   _| |__/ |  | |"//NL//  &
     "                                                 | | |_____|      | |   | ||____|  |____|| |   | |    |_____|   | |   | |  |________|  | |"//NL//  &
     "                                                 | |              | |   | |              | |   | |              | |   | |              | |"//NL//  &
     "                                                 | '--------------' |   | '--------------' |   | '--------------' |   | '--------------' |"//NL//  &
     "                                                  '----------------'     '----------------'     '----------------'     '----------------' "//NL



  END SUBROUTINE
  !
END MODULE 
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
 !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   
! TEST VERSION WITH TO DIMENSION
      

!MODULE TIME_SERIES_INSTRUCTION!, ONLY: TIME_SERIES_FILE
!  USE CONSTANTS
!  USE DATE_OPERATOR_INSTRUCTION, ONLY: DATE_OPERATOR
!  USE UTIL_INTERFACE,             ONLY: READ_TO_DATA, PARSE_WORD, GET_WORD, GET_DATE, GET_NUMBER, GET_INTEGER, STOP_ERROR
!  USE WARNING_TYPE_INSTRUCTION,  ONLY: WARNING_TYPE
!  USE GENERIC_INPUT_FILE_INSTRUCTION,     ONLY: GENERIC_INPUT_FILE
!  USE GENERIC_BLOCK_READER_INSTRUCTION, ONLY: GENERIC_BLOCK_READER
!  IMPLICIT NONE
!  PRIVATE
!  PUBLIC:: TIME_SERIES_FILE, TIME_SERIES_FILE_GROUP, LOAD_TIME_SERIES_BLOCK, LOAD_TIME_SERIES_BLOCK_POINTER
!  !
!  TYPE TSF_DATA
!    TYPE(DATE_OPERATOR):: DATE
!    DOUBLE PRECISION   :: TIM=DZ
!    DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE:: DAT
!    !
!    CONTAINS
!    !
!    PROCEDURE, PASS(TSF):: INIT    => INITILIZATE_TSF_DATA(NDAT)
!    PROCEDURE, PASS(TSF):: DESTROY => DESTROY_TSF_DATA
!    FINAL:: FINAL_TSF_DATA
!  END TYPE
!  !
!  TYPE TIME_SERIES_FILE
!      INTEGER:: P         = Z     !CURRENT LINE, IS SET TO ZERO IF WHEN NOT INITIALIZED
!      LOGICAL:: BINARY    = FALSE
!      LOGICAL:: AT_NEXT   = FALSE
!      LOGICAL:: MONTHDAY  = FALSE
!      INTEGER:: OPT= Z   ! OPT => 0=INTERP; 1=STEP, 2=NEAR
!      INTEGER:: N  = Z   ! SIZE OF FILE
!      INTEGER:: NDAT = Z ! SIZE OF TSF_DATA%DAT
!      INTEGER:: IOUT = Z
!      CHARACTER(:), ALLOCATABLE:: NAM
!      CHARACTER(:), ALLOCATABLE:: LINE !USED FOR LOADING LINE
!      !
!      DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE:: T500
!      INTEGER:: N500 = Z
!      !
!      !INTEGER::          CHK     = inf_I ! INDEX TO CHECK IF FASTER TO MOVE TO START OF FILE
!      !DOUBLE PRECISION:: CHK_TIM = ninf  !TIME TO CHECK AGAINST IF FASTER TO MOVE TO FRONT OF FILE
!      !
!      TYPE(GENERIC_INPUT_FILE):: FL
!      !TYPE(DATE_OPERATOR):: DATE  !SCRATCH SPACE FOR LOADING TIME VALUE --Made availible to each location
!      !
!      DOUBLE PRECISION:: SFAC = UNO
!      TYPE(TSF_DATA), POINTER:: PREV => NULL()
!      TYPE(TSF_DATA), POINTER:: CUR  => NULL()
!      TYPE(TSF_DATA), POINTER:: NEXT => NULL()
!      !
!      TYPE(TSF_DATA), POINTER:: TMP => NULL()
!      !
!      CONTAINS
!      !
!      GENERIC::              INIT     => INITIALIZE_TIME_SERIES_FILE, INITIALIZE_TIME_SERIES_FILE_LINE, INITIALIZE_TIME_SERIES_FILE_VALUE!(LINE,LLOC,IOUT,IN,READ_NAME) or (LINE,READ_NAME) or (VALUE)
!      PROCEDURE, PASS(TSF):: OPENED   => TIME_SERIES_FILE_IN_USE
!      PROCEDURE, PASS(TSF):: MOVE     => MOVE_TIME_SERIES_TOO
!      GENERIC::              GET      => LOOKUP_TIME_SERIES_VALUE_DATE, LOOKUP_TIME_SERIES_VALUE_DYEAR
!      PROCEDURE, PASS(TSF):: TIME_MEAN   !(TIME0, TIME, VALUE)
!      PROCEDURE, PASS(TSF):: TIME_SUM    !(TIME0, TIME, VAL, DELT)
!      PROCEDURE, PASS(TSF):: TIME_MAX    !(TIME0, TIME, VALUE)
!      PROCEDURE, PASS(TSF):: TIME_MIN    !(TIME0, TIME, VALUE)
!      PROCEDURE, PASS(TSF):: INTERVAL_SUM!(TIME0, TIME, VALUE)
!      PROCEDURE, PASS(TSF):: SET_OPTION  !(OPT)
!      PROCEDURE, PASS(TSF):: GET_N_SET_OPTION !(LINE, LLOC, ISTART, ISTOP, [CONST])
!      PROCEDURE, PASS(TSF):: GET_OPTION       !(LINE, LLOC, ISTART, ISTOP, [CONST])
!      PROCEDURE, PASS(TSF):: PRINT_OPTION !([OPT])
!      !
!      PROCEDURE, PASS(TSF),PRIVATE::     LOOKUP_TIME_SERIES_VALUE_DATE   !(DATE, VALUE)
!      PROCEDURE, PASS(TSF),PRIVATE::     LOOKUP_TIME_SERIES_VALUE_DYEAR  !(TIME, VALUE)
!      PROCEDURE, PASS(TSF),PRIVATE::     INITIALIZE_TIME_SERIES_FILE      !(LINE,LLOC,IOUT,IN)
!      PROCEDURE, PASS(TSF),PRIVATE::     INITIALIZE_TIME_SERIES_FILE_LINE !(LINE)
!      PROCEDURE, PASS(TSF),PRIVATE::     INITIALIZE_TIME_SERIES_FILE_VALUE!VALUE
!      !
!      PROCEDURE, PASS(TSF):: DESTROY  => DEALLOCATE_TIME_SERIES_FILE
!      FINAL:: FINAL_DEALLOCATE_TIME_SERIES_FILE
!      !
!  END TYPE
!  !
!  TYPE TIME_SERIES_FILE_GROUP
!      INTEGER:: NFIL = Z
!      TYPE(TIME_SERIES_FILE),DIMENSION(:),ALLOCATABLE:: TSF
!      INTEGER,               DIMENSION(:),ALLOCATABLE:: ID
!      !
!      CONTAINS
!      !
!      PROCEDURE, PASS(TSG):: INIT    => INITIALIZE_TIME_SERIES_GROUP
!      PROCEDURE, PASS(TSG):: DESTROY => DEALLOCATE_TIME_SERIES_GROUP
!      FINAL::                FINAL_DEALLOCATE_TIME_SERIES_GROUP
!  END TYPE
!  !  
!  CONTAINS 
!  !
!  PURE ELEMENTAL SUBROUTINE INITILIZATE_TSF_DATA(TSD,NDAT)
!    CLASS(TSF_DATA), INTENT(INOUT):: TSD
!    INTEGER,         INTENT(IN   ):: NDAT
!    !
!    CALL DESTROY_TSF_DATA(TSD)
!    !
!    ALLOCATE(TSD%DAT(NDAT),SOURCE=DZ)
!    !
!  END SUBROUTINE
!  !
!  PURE ELEMENTAL SUBROUTINE DESTROY_TSF_DATA(TSD)
!    CLASS(TSF_DATA), INTENT(INOUT):: TSD
!    !
!    IF(ALLOCATED(TSD%DAT)) DEALLOCATE(TSD%DAT)
!    TSD%TIM=DZ
!    CALL TSD%DATE%DESTROY()
!    !
!  END SUBROUTINE
!  !
!  PURE ELEMENTAL SUBROUTINE FINAL_TSF_DATA(TSD)
!    TYPE(TSF_DATA), INTENT(INOUT):: TSD
!    !
!    CALL DESTROY_TSF_DATA(TSD)
!    !
!  END SUBROUTINE
!  !
!  SUBROUTINE INITIALIZE_TIME_SERIES_GROUP(TSG, BL, READ_ID, READ_NAME, NDAT)
!    CLASS(TIME_SERIES_FILE_GROUP), INTENT(INOUT):: TSG
!    CLASS(GENERIC_BLOCK_READER),   INTENT(INOUT):: BL
!    LOGICAL, OPTIONAL,             INTENT(IN   ):: READ_ID, READ_NAME
!    INTEGER, OPTIONAL,             INTENT(IN   ):: NDAT
!    !
!    INTEGER:: I, LLOC,ISTART,ISTOP
!    !
!    CALL DEALLOCATE_TIME_SERIES_GROUP(TSG)
!    !
!    TSG%NFIL = BL%NLINE
!    !
!    IF(TSG%NFIL > Z) THEN
!       !
!       ALLOCATE(TSG%TSF(TSG%NFIL))
!       !
!       IF(PRESENT(READ_ID)) THEN; IF(READ_ID) ALLOCATE(TSG%ID(TSG%NFIL))
!       END IF
!       !
!       CALL BL%START()
!       !
!       DO I = ONE, TSG%NFIL
!                       !
!                       LLOC=ONE
!                       IF(PRESENT(READ_ID)) THEN; IF(READ_ID) CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,TSG%ID(I),MSG='TIME SERIES FILE FAILED TO LOAD INTEGER ID BEFORE TIME SERIES FILE ITSELF. THIS INPUT REQUIRES YOU SPECIFY AN INTEGER FIRST, THEN THE ACTUAL TIME SERIES FILE.')
!                       END IF
!                       !
!                       CALL TSG%TSF(I)%INIT(BL%LINE,LLOC,BL%IOUT,BL%IU,READ_NAME=READ_NAME)
!                       !
!                       CALL BL%NEXT()    !NOVE TO NEXT TIME SERIES FILE
!       END DO
!    END IF
!    !
!  END SUBROUTINE
!  !
!  IMPURE ELEMENTAL SUBROUTINE DEALLOCATE_TIME_SERIES_GROUP(TSG)
!    CLASS(TIME_SERIES_FILE_GROUP), INTENT(INOUT):: TSG
!    TSG%NFIL = Z
!    IF(ALLOCATED(TSG%TSF)) DEALLOCATE(TSG%TSF)
!    IF(ALLOCATED(TSG%ID )) DEALLOCATE(TSG%ID)
!  END SUBROUTINE
!  !
!  IMPURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_TIME_SERIES_GROUP(TSG)
!    TYPE(TIME_SERIES_FILE_GROUP), INTENT(INOUT):: TSG
!    CALL DEALLOCATE_TIME_SERIES_GROUP(TSG)
!  END SUBROUTINE
!  !
!  SUBROUTINE LOAD_TIME_SERIES_BLOCK(BL,TSF, NFIL, ID, READ_NAME)
!    CLASS(GENERIC_BLOCK_READER),                     INTENT(INOUT):: BL
!    TYPE(TIME_SERIES_FILE),DIMENSION(:),ALLOCATABLE, INTENT(INOUT):: TSF
!    INTEGER,                                         INTENT(  OUT):: NFIL
!    INTEGER, OPTIONAL,     DIMENSION(:),ALLOCATABLE, INTENT(  OUT):: ID
!    LOGICAL, OPTIONAL,                               INTENT(IN   ):: READ_NAME
!    !
!    INTEGER:: I, LLOC,ISTART,ISTOP
!    !
!    NFIL = BL%NLINE
!    !
!    IF(NFIL > Z) THEN
!       IF(ALLOCATED(TSF)) DEALLOCATE(TSF)
!       !
!       ALLOCATE(TSF(NFIL))
!       IF(PRESENT(ID)) THEN
!           IF(ALLOCATED(ID)) DEALLOCATE(ID)
!           ALLOCATE(ID(NFIL))
!       END IF
!       !
!       CALL BL%START()
!       !
!       DO I = ONE, NFIL
!                       !
!                       LLOC=ONE
!                       IF(PRESENT(ID)) CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,ID(I),MSG='TIME SERIES FILE FAILED TO LOAD INTEGER ID BEFORE TIME SERIES FILE ITSELF. THIS INPUT REQUIRES YOU SPECIFY AN INTEGER FIRST, THEN THE ACTUAL TIME SERIES FILE.')
!                       !
!                       CALL TSF(I)%INIT(BL%LINE,LLOC,BL%IOUT,BL%IU,READ_NAME=READ_NAME)
!                       !
!                       CALL BL%NEXT()    !NOVE TO NEXT TIME SERIES FILE
!       END DO
!    ELSE
!       NFIL = Z
!       IF(ALLOCATED(TSF)) DEALLOCATE(TSF)
!       IF(PRESENT(ID)) THEN; IF(ALLOCATED(ID)) DEALLOCATE(ID)
!       END IF
!    END IF
!    !
!  END SUBROUTINE
!  !
!  SUBROUTINE LOAD_TIME_SERIES_BLOCK_POINTER(BL,TSF, NFIL, ID, READ_NAME)
!    CLASS(GENERIC_BLOCK_READER),                             INTENT(INOUT):: BL
!    TYPE(TIME_SERIES_FILE),DIMENSION(:),POINTER, CONTIGUOUS, INTENT(INOUT):: TSF
!    INTEGER,                                                 INTENT(  OUT):: NFIL
!    INTEGER, OPTIONAL,     DIMENSION(:),POINTER, CONTIGUOUS, INTENT(  OUT):: ID
!    LOGICAL, OPTIONAL,                                       INTENT(IN   ):: READ_NAME
!    !
!    INTEGER:: I, LLOC,ISTART,ISTOP
!    !
!    NFIL = BL%NLINE
!    !
!    IF(NFIL > Z) THEN
!       IF(ASSOCIATED(TSF)) DEALLOCATE(TSF,STAT=I)
!       !
!       ALLOCATE(TSF(NFIL))
!       IF(PRESENT(ID)) THEN
!           IF(ASSOCIATED(ID)) DEALLOCATE(ID,STAT=I)
!           ALLOCATE(ID(NFIL))
!       END IF
!       !
!       CALL BL%START()
!       !
!       DO I = ONE, NFIL
!                       !
!                       LLOC=ONE
!                       IF(PRESENT(ID)) CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,ID(I),MSG='TIME SERIES FILE FAILED TO LOAD INTEGER ID BEFORE TIME SERIES FILE ITSELF. THIS INPUT REQUIRES YOU SPECIFY AN INTEGER FIRST, THEN THE ACTUAL TIME SERIES FILE.')
!                       !
!                       CALL TSF(I)%INIT(BL%LINE,LLOC,BL%IOUT,BL%IU,READ_NAME=READ_NAME)
!                       !
!                       CALL BL%NEXT()    !NOVE TO NEXT TIME SERIES FILE
!       END DO
!    ELSE
!       NFIL = Z
!       IF(ASSOCIATED(TSF)) DEALLOCATE(TSF,STAT=I)
!       IF(PRESENT(ID)) THEN; IF(ASSOCIATED(ID)) DEALLOCATE(ID,STAT=I)
!       END IF
!    END IF
!    !
!  END SUBROUTINE
!  !  
!  IMPURE ELEMENTAL SUBROUTINE INITIALIZE_TIME_SERIES_FILE_VALUE(TSF,VALUE,NDAT)
!  CLASS(TIME_SERIES_FILE),  INTENT(INOUT):: TSF
!  DOUBLE PRECISION,OPTIONAL,INTENT(IN   ):: VALUE
!  INTEGER,         OPTIONAL,INTENT(IN   ):: NDAT
!  INTEGER:: LLOC
!  !
!  LLOC = ONE
!  CALL INITIALIZE_TIME_SERIES_FILE(TSF,'SKIP',LLOC,Z,Z,FALSE,NDAT,VALUE)
!  !
!  END SUBROUTINE
!  !  
!  IMPURE ELEMENTAL SUBROUTINE INITIALIZE_TIME_SERIES_FILE_LINE(TSF,LINE,READ_NAME,NDAT)
!  CLASS(TIME_SERIES_FILE),  INTENT(INOUT):: TSF
!  CHARACTER(*),             INTENT(IN   ):: LINE
!  LOGICAL,                  INTENT(IN   ):: READ_NAME
!  INTEGER,         OPTIONAL,INTENT(IN   ):: NDAT
!  INTEGER:: LLOC
!  !
!  LLOC = ONE
!  CALL INITIALIZE_TIME_SERIES_FILE(TSF,LINE,LLOC,Z,Z,READ_NAME,NDAT)
!  !
!  END SUBROUTINE
!  !  
!  IMPURE ELEMENTAL SUBROUTINE INITIALIZE_TIME_SERIES_FILE(TSF,LINE,LLOC,IOUT,IN,READ_NAME,NDAT,VALUE)
!  CLASS(TIME_SERIES_FILE),  INTENT(INOUT):: TSF
!  CHARACTER(*),             INTENT(IN   ):: LINE
!  INTEGER,                  INTENT(INOUT):: LLOC
!  INTEGER,                  INTENT(IN   ):: IOUT,IN
!  LOGICAL,                  INTENT(IN   ):: READ_NAME
!  !
!  INTEGER,         OPTIONAL,INTENT(IN   ):: NDAT
!  DOUBLE PRECISION,OPTIONAL,INTENT(IN   ):: VALUE   !IF PRESENT THEN TIME SERIES ONLY SEES THIS VALUE
!  !
!  INTEGER:: I, K, ISTART,ISTOP
!  DOUBLE PRECISION:: CONST
!  LOGICAL:: EOF
!  !
!  CONST = DZ
!  !
!  CALL DEALLOCATE_TIME_SERIES_FILE(TSF)
!  !
!  ALLOCATE(TSF%PREV, TSF%CUR, TSF%NEXT)
!  TSF%IOUT = IOUT
!  !
!  IF(PRESENT(NDAT)) THEN
!      TSF%NDAT = NDAT
!  ELSE
!      TSF%NDAT = ONE
!  END IF
!  !
!  CALL TSF%PREV%INIT(TSF%NDAT)
!  CALL TSF%CUR %INIT(TSF%NDAT)
!  CALL TSF%NEXT%INIT(TSF%NDAT)
!  !
!  IF(READ_NAME) THEN
!                    CALL GET_WORD(LINE,LLOC,ISTART,ISTOP,TSF%NAM,IS_ALLOC=TRUE,COM_STOP=TRUE)
!  ELSE
!                    ALLOCATE(TSF%NAM, SOURCE = 'n')
!  END IF
!  !
!  CALL GET_N_SET_OPTION(TSF, LINE, LLOC, ISTART, ISTOP, IN, CONST)
!  !
!  IF(TSF%OPT > NEG) THEN
!      CALL TSF%FL%OPEN(LLOC,LINE,IOUT,IN,SFAC=TSF%SFAC,NO_INTERNAL=TRUE)
!  ELSE
!      TSF%FL%SKIP = TRUE
!  END IF
!  !
!  IF(TSF%FL%SKIP.OR.PRESENT(VALUE)) THEN
!      TSF%OPT  = ONE   !USE STEP_FUNCTION OPTION --NEVER ACTUALLY USED
!      TSF%N    = THREE
!      TSF%P    = THREE
!      TSF%SFAC = UNO
!      TSF%N500 = Z
!      IF(PRESENT(VALUE)) CONST = VALUE
!      !
!      TSF%MONTHDAY = FALSE
!      TSF%AT_NEXT  = TRUE
!      !
!      TSF%PREV%TIM = ninf  
!      TSF%PREV%DAT = CONST
!      TSF%CUR %TIM = ninf
!      TSF%CUR %DAT = CONST
!      TSF%NEXT%TIM = ninf 
!      TSF%NEXT%DAT = CONST
!  ELSE
!      !
!      CALL TSF%FL%COUNT_LINES(TSF%N)
!      !
!      IF(TSF%N == Z) CALL STOP_ERROR( LINE=LINE, INFILE=IN, OUTPUT=IOUT, MSG= 'TIME SERIES INPUT ERROR: THE TIME SERIES FILE APPEARS TO BE EMPTY?') 
!      !
!      TSF%N500 = TSF%N / QUIN
!      !
!      IF(TSF%N500 > Z)  ALLOCATE(TSF%T500(TSF%N500+ONE), SOURCE=inf)
!      !
!      !ALLOCATE(CHARACTER(75)::TSF%LINE)
!      !
!      CALL TSF%FL%READ(TSF%LINE) !MOVE TO FIRST LOCATION
!      !
!      !CHECK IF MONTH/DAY TIME INPUT
!      !
!      LLOC = ONE
!      CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%PREV%DATE, ONLY_DYEAR=TRUE, MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
!      TSF%MONTHDAY = TSF%PREV%DATE%MONTH_DAY
!      !
!      ! CHECK FOR CONTIGUOUS INPUT
!      !
!      DO ISTART=TWO, TSF%N !ALREADY LOADED FIRST LINE
!          CALL TSF%FL%READ(TSF%LINE,CNT=ISTOP,EOF=EOF,NOSHIFT=TRUE)
!          !CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,IOUT,CNT=ISTOP,EOF=EOF,NOSHIFT=TRUE)
!          IF(EOF .OR. ISTOP > ONE) THEN
!              CALL STOP_ERROR( LINE=TSF%LINE, INFILE=TSF%FL%IU, OUTPUT=IOUT, &
!                                         MSG= 'TIME SERIES INPUT ERROR: NO COMMENTS OR BLANK LINES ARE ALLOWED WITHIN THE TIME SERIES DATA.'//NL//      &
!                                              'THEY ARE ALLOWED AT THE TOP OF A TIME SERIES FILE BEFORE THE FIRST DATA ENTRY (e.g. TIME DATA),'//NL//   &
!                                              'AFTER THE LAST DATA ENTRY AND TO THE RIGHT OF A DATA ENTRY.'//BLN//                                      &
!                                              'THE FOLLOWING IS AN AN EXAMPLE OF WHAT IS ALLOWED:'//BLN//REPEAT('-',50)//NL//                         &
!                                              '# COMMENT '//NL//'   '//NL//'  # START OF DATA'//NL//'12/31/1999  1.0'//NL//                             &
!                                              '1/1/2000  2.0   # Y2K'//NL//'1/5/2000  2.00   # Comment'//NL//'  '//NL//                                 &
!                                              '# end of data input'//NL//' '//NL//'#comment'//NL//REPEAT('-',50)//BLN//                                                     &
!                                              'THE FOLLOWING IS AN EXAMPLE OF WHAT WILL NOT WORK DUE TO BAD COMMENT AND BAD BLANK LINE LOCATION:'//BLN//REPEAT('-',50)//NL//  &
!                                              '# START OF DATA'//NL//'12/31/1999  1.0'//NL//'# BAD COMMENT LOCATION'//NL//'2000  2.0   # Y2K'//NL//'  '//NL//'1/5/2000  2.00'//NL//REPEAT('-',50) ) 
!          END IF
!      END DO
!      !
!      ! CHECK FOR DATES IN PROPERT SEQUENCE
!      !
!      CALL TSF%FL%REWIND()
!      !
!      ! CHECK FOR CONTIGUOUS INPUT AND SET UP N500 POINTERS
!      !
!      CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,IOUT)
!      LLOC = ONE
!      CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%PREV%DATE, ONLY_DYEAR=TRUE, MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
!      !
!      K = ONE
!      DO I = TWO, TSF%N !ALREADY LOADED FIRST LINE
!          CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,IOUT)
!          LLOC = ONE
!          CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%CUR%DATE, ONLY_DYEAR=TRUE, MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
!          !
!          IF(TSF%CUR%DATE < TSF%PREV%DATE) THEN
!              CALL STOP_ERROR( LINE=TSF%LINE, INFILE=TSF%FL%IU, OUTPUT=IOUT, MSG= 'TIME SERIES INPUT ERROR: THE TIME COLUMN (FIRST COLUMN) MUST BE IN CHRONOLOGICAL ORDER.'//NL//'THE PRESENTED ERROR LINE CONTAINS A DATE THAT IS EARLIAR THEN THE PREVIOUS LINE.'//NL//'IF ONLY USING MONTH AND DAY OR DECIMAL YEAR, THEN THOSE MUST BE IN CHRONOLOGICAL ORDER TOO!.') 
!          END IF
!          !
!          IF(I > 499) THEN
!              !
!              IF(MOD(I, QUIN) == Z) THEN
!                    TSF%T500(K) = TSF%CUR%DATE%DYEAR
!                    K = K + ONE
!              END IF
!          END IF
!          !
!          TSF%TMP  => TSF%PREV
!          !
!          TSF%PREV => TSF%CUR
!          TSF%CUR  => TSF%TMP
!          !
!          TSF%TMP  => NULL()
!          !
!      END DO
!      !
!      !
!      CALL MOVE_TO_START_OF_FILE(TSF)
!      !
!      !IF(TSF%N > 200) THEN                    !CHECK FOR ACCELERATION IMPROVEMENT
!      !    TSF%CHK = TSF%N - TSF%N/FOUR - ONE  !UPPER QUARTER IS WHERE CHECKS BEGIN
!      !    CALL GO_TO_TIME_SERIES_POSITION(TSF, TSF%N/TWO) !MOVE TO FRONT OF FILE IF TIME LESS THEN UPPER HALF OF FILE
!      !    TSF%CHK_TIM = TSF%NEXT%TIM
!      !ELSE
!      !    TSF%CHK     = TSF%N + ONE   
!      !    TSF%CHK_TIM = ninf
!      !END IF
!      !
!  END IF
!  !
!  END SUBROUTINE
!  !
!  PURE SUBROUTINE SET_OPTION(TSF, OPT)
!    CLASS(TIME_SERIES_FILE),  INTENT(INOUT):: TSF
!    INTEGER, INTENT(IN):: OPT
!    TSF%OPT = OPT
!  END SUBROUTINE
!  !
!  SUBROUTINE GET_N_SET_OPTION(TSF, LINE, LLOC, ISTART, ISTOP, IN, CONST)
!    CLASS(TIME_SERIES_FILE),  INTENT(INOUT):: TSF
!    CHARACTER(*),             INTENT(IN   ):: LINE
!    INTEGER,                  INTENT(INOUT):: LLOC, ISTART, ISTOP
!    INTEGER,         OPTIONAL,INTENT(IN   ):: IN
!    DOUBLE PRECISION,OPTIONAL,INTENT(INOUT):: CONST
!    CHARACTER(:), ALLOCATABLE:: WORD
!    !
!    CALL GET_OPTION(TSF, LINE, LLOC, ISTART, ISTOP, TSF%OPT, CONST)
!    !CALL SET_OPTION(TSF, OPT)
!    !
!    IF(TSF%OPT == -2) CALL STOP_ERROR( LINE=LINE, INFILE=IN, OUTPUT=TSF%IOUT, MSG= 'TIME SERIES INPUT ERROR: YOU MUST SPECIFY KEYWORD "INTERPOLATE", OR "STEP_FUNCTION", "TIME_MEAN", "NEXT_VALUE",  "NEAREST", or "TIME_MEAN" BEFORE SPECIXJY THE FILE LOCATION/NAME.') 
!    !
!  END SUBROUTINE
!  !
!  SUBROUTINE GET_OPTION(TSF, LINE, LLOC, ISTART, ISTOP, OPT, CONST)
!    CLASS(TIME_SERIES_FILE),  INTENT(IN   ):: TSF
!    CHARACTER(*),             INTENT(IN   ):: LINE
!    INTEGER,                  INTENT(INOUT):: LLOC, ISTART, ISTOP
!    INTEGER,         OPTIONAL,INTENT(INOUT):: OPT
!    DOUBLE PRECISION,OPTIONAL,INTENT(INOUT):: CONST
!    CHARACTER(:), ALLOCATABLE:: WORD
!    !
!    CALL GET_WORD(LINE,LLOC,ISTART,ISTOP,WORD,IS_ALLOC=TRUE,COM_STOP=TRUE)
!     !
!     SELECT CASE(WORD)
!     CASE('INTERP','INTERPOLATE'   ); OPT = Z
!     CASE('STEP','STEP_FUNCTION'   ); OPT = ONE
!     CASE('NEXT','NEXT_VALUE'      ); OPT = TWO
!     CASE('NEAR','NEAREST'         ); OPT = THREE
!     CASE('TIME_MEAN'              ); OPT = TEN
!     CASE('MAX'                    ); OPT = 11
!     CASE('MIN'                    ); OPT = 12
!     CASE('SUM'                    ); OPT = 13
!     CASE('DAY_SUM'                ); OPT = 14
!     CASE('SKIP','NAN','NULL','NUL'); OPT = NEG
!     CASE('CONSTANT')
!                                      OPT = NEG
!                                      IF(PRESENT(CONST)) THEN
!                                          CALL GET_NUMBER(LINE,LLOC,ISTART,ISTOP,TSF%IOUT,Z,CONST,MSG='FAILED TO LOAD CONSTANT VALUE AFTER KEYWORD "CONSTANT".')
!                                      ELSE
!                                          OPT = -2
!                                      END IF
!     CASE DEFAULT
!                                      OPT = -2  !DID NOT IDENTIFY NAME
!     END SELECT 
!     !
!     DEALLOCATE(WORD)
!  END SUBROUTINE
!  !
!  FUNCTION PRINT_OPTION(TSF,OPT) RESULT (WORD)
!    CLASS(TIME_SERIES_FILE),  INTENT(IN):: TSF
!    INTEGER,         OPTIONAL,INTENT(IN):: OPT
!    CHARACTER(:), ALLOCATABLE:: WORD
!    INTEGER:: OP
!    !
!    IF(PRESENT(OPT)) THEN
!        OP = OPT
!    ELSE
!        OP = TSF%OPT
!    END IF
!    !
!    SELECT CASE(OP)
!    CASE(Z    ); WORD = 'INTERPOLATE'   
!    CASE(ONE  ); WORD = 'STEP_FUNCTION' 
!    CASE(TWO  ); WORD = 'NEXT_VALUE'    
!    CASE(THREE); WORD = 'NEAREST'       
!    CASE(TEN  ); WORD = 'TIME_MEAN'   
!    CASE(11   ); WORD = 'MAX'           
!    CASE(12   ); WORD = 'MIN'           
!    CASE(13   ); WORD = 'SUM'
!    CASE(14   ); WORD = 'DAY_SUM'
!    CASE(NEG  ); WORD = 'SKIP'         
!    CASE(-2   ); WORD = 'OPT_ERROR'
!    END SELECT
!    !
!  END FUNCTION
!  !
!  SUBROUTINE LOOKUP_TIME_SERIES_VALUE_DATE(TSF, DATE, VALUE, DATE0)
!  CLASS(TIME_SERIES_FILE),      INTENT(INOUT):: TSF
!  TYPE(DATE_OPERATOR),          INTENT(IN   ):: DATE
!  DOUBLE PRECISION,             INTENT(  OUT):: VALUE
!  TYPE(DATE_OPERATOR),OPTIONAL, INTENT(IN   ):: DATE0
!  !
!  CALL LOOKUP_TIME_SERIES_VALUE_DYEAR(TSF, DATE%DYEAR, VALUE, DATE0%DYEAR)
!  !
!  END SUBROUTINE
!  !
!  SUBROUTINE LOOKUP_TIME_SERIES_VALUE_DYEAR(TSF, TIME, VALUE,TIME0)
!  CLASS(TIME_SERIES_FILE),  INTENT(INOUT):: TSF
!  DOUBLE PRECISION,         INTENT(IN   ):: TIME
!  DOUBLE PRECISION,         INTENT(  OUT):: VALUE
!  DOUBLE PRECISION,OPTIONAL,INTENT(IN   ):: TIME0
!  INTEGER:: OPT
!  LOGICAL:: EOF
!  !
!  IF(TSF%N == Z) THEN
!      VALUE = DZ
!      RETURN
!  END IF
!  !
!  OPT = TSF%OPT
!  IF(OPT >= TEN .AND. .NOT. PRESENT(TIME0))  OPT = ONE
!  IF(OPT >= TEN) THEN
!      IF(ABS(TIME - TIME0) < YEARTOL_5    )  OPT = ONE !WITHIN 5 SECONDS OF EACH OTHER
!  END IF
!  !
!  
!  IF(OPT < TEN) THEN
!      ! MOVE WINDOW TO CORRECT LOCATION
!      IF(TSF%MONTHDAY) THEN
!          CALL MOVE_MONTHDAY_WINDOW_TO(TSF, TIME) 
!      ELSE
!          CALL MOVE_TIME_WINDOW_TO(TSF, TIME) 
!      END IF
!      !
!      IF    (ABS(TIME - TSF%PREV%TIM) < YEARTOL_5) THEN; VALUE = TSF%PREV%DAT  !WITHIN 5 SECONDS OF REQUESTED TIME
!      ELSEIF(ABS(TIME - TSF%CUR%TIM ) < YEARTOL_5) THEN; VALUE = TSF%CUR %DAT
!      ELSEIF(ABS(TIME - TSF%NEXT%TIM) < YEARTOL_5) THEN; VALUE = TSF%NEXT%DAT
!      ELSEIF(TIME < TSF%CUR%TIM ) THEN
!                                   CALL INTERP(TSF%OPT, TSF%PREV%TIM, TSF%PREV%DAT, TSF%CUR%TIM, TSF%CUR%DAT,  TIME, VALUE)
!      ELSE
!                                   CALL INTERP(TSF%OPT, TSF%CUR%TIM,  TSF%CUR%DAT, TSF%NEXT%TIM, TSF%NEXT%DAT, TIME, VALUE)
!      END IF
!  ELSE
!      SELECT CASE(OPT)
!      CASE(TEN);       CALL TIME_MEAN(   TSF, TIME0, TIME, VALUE)
!      CASE(11);        CALL TIME_MAX(    TSF, TIME0, TIME, VALUE)
!      CASE(12);        CALL TIME_MIN(    TSF, TIME0, TIME, VALUE)
!      CASE(13);        CALL INTERVAL_SUM(TSF, TIME0, TIME, VALUE)
!      CASE(14);        CALL TIME_SUM(    TSF, TIME0, TIME, VALUE)
!      END SELECT
!  END IF
!  !
!  IF(TSF%SFAC.NE.UNO) VALUE = VALUE*TSF%SFAC
!  !
!  END SUBROUTINE
!  !
!  PURE SUBROUTINE INTERP(OPT, TIM1, VAL1, TIM2, VAL2, TIM, VAL)
!    INTEGER,          INTENT(IN   ):: OPT
!    DOUBLE PRECISION, INTENT(IN   ):: TIM1, VAL1, TIM2, VAL2, TIM
!    DOUBLE PRECISION, INTENT(  OUT):: VAL
!    !
!    ! OPT = 0 INTERPOLATE
!    ! OPT = 1 STEP_FUNCTION
!    ! OPT = 2 NEAREST VALUE
!    !
!    IF(OPT==Z) THEN !INTERPOLATE
!        !
!        VAL = VAL1 + (TIM - TIM1) * (VAL2-VAL1) / (TIM2-TIM1)
!        !
!    ELSEIF(TIM <= TIM1) THEN
!        !
!        VAL = VAL1
!        !
!    ELSEIF( TIM >= TIM2 ) THEN
!        !
!        VAL = VAL2
!        !
!    ELSEIF(OPT==ONE) THEN !STEP_FUNCTION
!        !
!        VAL = VAL1
!        !
!    ELSEIF(OPT==TWO) THEN !NEXT_VALUE
!        !
!        VAL = VAL2
!        !
!    ELSEIF(OPT==THREE) THEN !NEAREST DATUE
!        !
!        IF( TIM - TIM1 > TIM2 - TIM) THEN  !CLOSE RTO TIM2 IF TIM2-TIM IS SMALLER
!            VAL = VAL2
!        ELSE
!            VAL = VAL1
!        END IF
!        !
!    END IF
!    !
!  END SUBROUTINE
!  !
!  PURE SUBROUTINE SET_MONTHDAY(TSF, YR)
!    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
!    INTEGER,        INTENT(IN   ):: YR
!    !
!    CALL TSF%PREV%DATE%SET_YEAR(YR)
!    TSF%PREV%TIM = TSF%PREV%DATE%DYEAR 
!    !
!    CALL TSF%CUR%DATE%SET_YEAR(YR)
!    TSF%CUR%TIM = TSF%CUR%DATE%DYEAR 
!    !
!    CALL TSF%NEXT%DATE%SET_YEAR(YR)
!    TSF%NEXT%TIM = TSF%NEXT%DATE%DYEAR 
!    !
!  END SUBROUTINE
!  !
!  SUBROUTINE TIME_MEAN(TSF, TIME0, TIME1, VAL)
!    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
!    DOUBLE PRECISION,TARGET, INTENT(IN   ):: TIME0, TIME1
!    DOUBLE PRECISION,        INTENT(  OUT):: VAL
!    DOUBLE PRECISION:: DELT, DT
!    DOUBLE PRECISION, POINTER:: TIM0, TIM1
!    INTEGER:: YR
!    LOGICAL:: EOF
!    !
!    IF (TIME0 > TIME1) THEN
!        TIM0  => TIME1
!        TIM1  => TIME0
!    ELSE
!        TIM0  => TIME0
!        TIM1  => TIME1
!    END IF
!    !
!    IF(INT(TIM0) .NE. INT(TIM1) ) THEN  !TIME FRAME SPANS MULTIPLE YEARS SO NEED TO TAKE INTO ACCOUNT LEAP YEARS --NOTE DELT IS IN DAYS
!          !
!          CALL TIME_SUM(TSF, TIM0, TIM1, VAL, DELT)
!          !
!    ELSE
!          ! USE DECIMAL YEARS AS WEIGHTING FUNCTION SINCE TIME FRAME IS WITHIN THE SAME YEAR
!          !
!          ! MOVE WINDOW TO CORRECT LOCATION
!          !
!          IF(TSF%MONTHDAY) THEN
!              CALL MOVE_MONTHDAY_WINDOW_TO(TSF, TIM0)
!              YR = INT(TSF%NEXT%TIM)
!          ELSE
!              CALL MOVE_TIME_WINDOW_TO(TSF, TIM0) 
!          END IF
!          !
!          DELT = DZ
!          VAL  = DZ
!          IF    (TIM1 < TSF%CUR%TIM) THEN
!                                     DT   = TIM1 - TIM0
!                                     VAL  = VAL + (TSF%PREV%DAT*DT)
!                                     DELT = DELT + DT
!                                     EOF  = TRUE
!          ELSEIF(TIM0 < TSF%CUR%TIM) THEN
!                                     DT   = TSF%CUR%TIM - TIM0
!                                     VAL  = VAL + (TSF%PREV%DAT*DT)
!                                     DELT = DELT + DT
!                                     !
!                                     IF(TIM1 < TSF%NEXT%TIM) THEN
!                                         DT   = TIM1 - TSF%CUR%TIM
!                                         VAL  = VAL + (TSF%CUR%DAT*DT)
!                                         DELT = DELT + DT
!                                         EOF  = TRUE
!                                     ELSE
!                                         EOF = FALSE
!                                     END IF
!          ELSEIF(TIM1 < TSF%NEXT%TIM) THEN
!                                     DT   = TIM1 - TIM0
!                                     VAL  = VAL + (TSF%CUR%DAT*DT)
!                                     DELT = DELT + DT
!                                     EOF  = TRUE
!          ELSE
!                                     DT   = TSF%NEXT%TIM - TIM0
!                                     VAL  = VAL + (TSF%CUR%DAT*DT)
!                                     DELT = DELT + DT
!                                     IF(TSF%MONTHDAY) THEN
!                                         CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                                     ELSE
!                                         CALL READ_NEXT_ROW(TSF, EOF)
!                                     END IF
!                                     EOF  = FALSE
!          END IF
!          !
!          DO WHILE (.NOT. EOF) 
!                                     IF(TIM1 < TSF%NEXT%TIM) THEN
!                                         DT   = TIM1 - TSF%CUR%TIM
!                                         VAL  = VAL + (TSF%CUR%DAT*DT)
!                                         DELT = DELT + DT
!                                         EOF  = TRUE
!                                     ELSE
!                                         DT   = TSF%NEXT%TIM - TSF%CUR%TIM
!                                         VAL  = VAL + (TSF%CUR%DAT*DT)
!                                         DELT = DELT + DT
!                                         IF(TSF%MONTHDAY) THEN
!                                             CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                                         ELSE
!                                             CALL READ_NEXT_ROW(TSF, EOF)
!                                         END IF
!                                     END IF
!          END DO
!          !
!          IF(TIM1 > TSF%NEXT%TIM) THEN
!              IF(.NOT. TSF%MONTHDAY) THEN
!                                         DT   = TIM1 - TSF%NEXT%TIM
!                                         VAL  = VAL + (TSF%NEXT%DAT*DT)
!                                         DELT = DELT + DT
!              ELSE
!                    DO WHILE(TIM1 > TSF%NEXT%TIM)
!                        YR = YR + ONE
!                        CALL MOVE_TO_START_OF_FILE(TSF)
!                        CALL SET_MONTHDAY(TSF, YR) !SET PREV, CUR, NEXT TO MONTH DAY YEAR
!                        !
!                        IF(TIM1 < TSF%CUR%TIM) THEN
!                                     DT   = TIM1 - TSF%PREV%TIM
!                                     VAL  = VAL + (TSF%PREV%DAT*DT)
!                                     DELT = DELT + DT
!                                     EXIT
!                        ELSE
!                                     DT   = TSF%CUR%TIM - TSF%PREV%TIM
!                                     VAL  = VAL + (TSF%PREV%DAT*DT)
!                                     DELT = DELT + DT
!                        END IF
!                        !
!                        IF(TIM1 < TSF%NEXT%TIM) THEN
!                            DT   = TIM1 - TSF%CUR%TIM
!                            VAL  = VAL + (TSF%CUR%DAT*DT)
!                            DELT = DELT + DT
!                            EXIT
!                        ELSE
!                            EOF = FALSE
!                            DO WHILE (.NOT. EOF) 
!                                     IF(TIM1 < TSF%NEXT%TIM) THEN
!                                         DT   = TIM1 - TSF%CUR%TIM
!                                         VAL  = VAL + (TSF%CUR%DAT*DT)
!                                         DELT = DELT + DT
!                                         EOF  = TRUE
!                                     ELSE
!                                         DT   = TSF%NEXT%TIM - TSF%CUR%TIM
!                                         VAL  = VAL + (TSF%CUR%DAT*DT)
!                                         DELT = DELT + DT
!                                         CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                                     END IF
!                            END DO
!                        END IF
!                    END DO
!              END IF
!          END IF
!    END IF
!    !
!    IF (DELT > NEARZERO_29) THEN
!        VAL = VAL/DELT
!    ELSE
!        VAL = DZ
!    END IF
!    !
!    NULLIFY(TIM0, TIM1)
!    !
!  END SUBROUTINE
!  !
!  SUBROUTINE INTERVAL_SUM(TSF, TIME0, TIME1, VAL)
!    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
!    DOUBLE PRECISION,TARGET, INTENT(IN   ):: TIME0, TIME1
!    DOUBLE PRECISION,        INTENT(  OUT):: VAL
!    DOUBLE PRECISION, POINTER:: TIM0, TIM1
!    INTEGER:: YR
!    LOGICAL:: EOF
!    !
!    IF (TIME0 > TIME1) THEN
!        TIM0  => TIME1
!        TIM1  => TIME0
!    ELSE
!        TIM0  => TIME0
!        TIM1  => TIME1
!    END IF
!    !
!    ! MOVE WINDOW TO CORRECT LOCATION
!    !
!    IF(TSF%MONTHDAY) THEN
!        CALL MOVE_MONTHDAY_WINDOW_TO(TSF, TIM0)
!        YR = INT(TSF%NEXT%TIM)
!    ELSE
!        CALL MOVE_TIME_WINDOW_TO(TSF, TIM0) 
!    END IF
!    !
!    VAL  = DZ
!    IF    (TIM1 < TSF%CUR%TIM) THEN
!                               VAL  = VAL + TSF%PREV%DAT
!                               EOF  = TRUE
!    ELSEIF(TIM0 < TSF%CUR%TIM) THEN
!                               VAL  = VAL + TSF%PREV%DAT
!                               !
!                               IF(TIM1 < TSF%NEXT%TIM) THEN
!                                   VAL  = VAL + TSF%CUR%DAT
!                                   EOF  = TRUE
!                               ELSE
!                                   EOF = FALSE
!                               END IF
!    ELSEIF(TIM1 < TSF%NEXT%TIM) THEN
!                               VAL  = VAL + TSF%CUR%DAT
!                               EOF  = TRUE
!    ELSE
!                               VAL  = VAL + TSF%CUR%DAT
!                               IF(TSF%MONTHDAY) THEN
!                                   CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                               ELSE
!                                   CALL READ_NEXT_ROW(TSF, EOF)
!                               END IF
!                               EOF  = FALSE
!    END IF
!    !
!    DO WHILE (.NOT. EOF) 
!                               IF(TIM1 < TSF%NEXT%TIM) THEN
!                                   VAL  = VAL + TSF%CUR%DAT
!                                   EOF  = TRUE
!                               ELSE
!                                   VAL  = VAL + TSF%CUR%DAT
!                                   IF(TSF%MONTHDAY) THEN
!                                       CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                                   ELSE
!                                       CALL READ_NEXT_ROW(TSF, EOF)
!                                   END IF
!                               END IF
!    END DO
!    !
!    IF(TIM1 > TSF%NEXT%TIM) THEN
!        IF(.NOT. TSF%MONTHDAY) THEN
!                                   VAL  = VAL + TSF%NEXT%DAT
!        ELSE
!              DO WHILE(TIM1 > TSF%NEXT%TIM)
!                  YR = YR + ONE
!                  CALL MOVE_TO_START_OF_FILE(TSF)
!                  CALL SET_MONTHDAY(TSF, YR) !SET PREV, CUR, NEXT TO MONTH DAY YEAR
!                  !
!                  IF(TIM1 < TSF%CUR%TIM) THEN
!                               VAL  = VAL + TSF%PREV%DAT
!                               EXIT
!                  ELSE
!                               VAL  = VAL + TSF%PREV%DAT
!                  END IF
!                  !
!                  VAL  = VAL + TSF%CUR%DAT
!                  IF(TIM1 < TSF%NEXT%TIM) THEN
!                      EXIT
!                  ELSE
!                      CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                      DO WHILE (.NOT. EOF) 
!                               VAL  = VAL + TSF%CUR%DAT
!                               IF(TIM1 < TSF%NEXT%TIM) THEN
!                                   EOF  = TRUE
!                               ELSE
!                                   CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                               END IF
!                      END DO
!                  END IF
!              END DO
!        END IF
!    END IF
!    !
!    NULLIFY(TIM0, TIM1)
!    !
!  END SUBROUTINE
!  !
!  SUBROUTINE TIME_SUM(TSF, TIME0, TIME1, VAL, DAY_DELT)
!    CLASS(TIME_SERIES_FILE),    INTENT(INOUT):: TSF
!    DOUBLE PRECISION, TARGET,   INTENT(IN   ):: TIME0, TIME1
!    DOUBLE PRECISION,           INTENT(  OUT):: VAL
!    DOUBLE PRECISION, OPTIONAL, INTENT(  OUT):: DAY_DELT
!    DOUBLE PRECISION, POINTER:: TIM0, TIM1
!    DOUBLE PRECISION:: DELT, DT
!    TYPE(DATE_OPERATOR):: DT0,DT1
!    INTEGER:: YR
!    LOGICAL:: EOF
!    !
!    IF (TIME0 > TIME1) THEN
!        TIM0  => TIME1
!        TIM1  => TIME0
!    ELSE
!        TIM0  => TIME0
!        TIM1  => TIME1
!    END IF
!    !
!    ! MOVE WINDOW TO CORRECT LOCATION
!    !
!    IF(TSF%MONTHDAY) THEN
!        CALL MOVE_MONTHDAY_WINDOW_TO(TSF, TIM0)
!        YR = INT(TSF%NEXT%TIM)
!    ELSE
!        CALL MOVE_TIME_WINDOW_TO(TSF, TIM0) 
!        !
!        CALL TSF%CUR %DATE%DYEAR_MAKE_DATE() !IN CASE DATE WAS NOT STORED FOR SPEED PURPOSES
!        CALL TSF%NEXT%DATE%DYEAR_MAKE_DATE()
!    END IF
!    !
!    CALL DT0%INIT_DYEAR(TIM0)
!    CALL DT1%INIT_DYEAR(TIM1)
!    !
!    DELT = DZ
!    VAL  = DZ
!    IF    (TIM1 < TSF%CUR%TIM) THEN
!                               DT   = DT1 - DT0
!                               VAL  = VAL + (TSF%PREV%DAT*DT)
!                               DELT = DELT + DT
!                               EOF  = TRUE
!    ELSEIF(TIM0 < TSF%CUR%TIM) THEN
!                               DT   = TSF%CUR%DATE - DT0
!                               VAL  = VAL + (TSF%PREV%DAT*DT)
!                               DELT = DELT + DT
!                               !
!                               IF(TIM1 < TSF%NEXT%TIM) THEN
!                                   DT   = DT1 - TSF%CUR%DATE
!                                   VAL  = VAL + (TSF%CUR%DAT*DT)
!                                   DELT = DELT + DT
!                                   EOF  = TRUE
!                               ELSE
!                                   EOF = FALSE
!                               END IF
!    ELSEIF(TIM1 < TSF%NEXT%TIM) THEN
!                               DT   = DT1 - DT0
!                               VAL  = VAL + (TSF%CUR%DAT*DT)
!                               DELT = DELT + DT
!                               EOF  = TRUE
!    ELSE
!                               DT   = TSF%NEXT%DATE - DT0
!                               VAL  = VAL + (TSF%CUR%DAT*DT)
!                               DELT = DELT + DT
!                               IF(TSF%MONTHDAY) THEN
!                                   CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                               ELSE
!                                   CALL READ_NEXT_ROW(TSF, EOF)
!                                   CALL TSF%NEXT%DATE%DYEAR_MAKE_DATE()
!                               END IF
!                               EOF  = FALSE
!    END IF
!    !
!    DO WHILE (.NOT. EOF) 
!                               IF(TIM1 < TSF%NEXT%TIM) THEN
!                                   DT   = DT1 - TSF%CUR%DATE
!                                   VAL  = VAL + (TSF%CUR%DAT*DT)
!                                   DELT = DELT + DT
!                                   EOF  = TRUE
!                               ELSE
!                                   DT   = TSF%NEXT%DATE - TSF%CUR%DATE
!                                   VAL  = VAL + (TSF%CUR%DAT*DT)
!                                   DELT = DELT + DT
!                                   IF(TSF%MONTHDAY) THEN
!                                       CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                                   ELSE
!                                       CALL READ_NEXT_ROW(TSF, EOF)
!                                       CALL TSF%NEXT%DATE%DYEAR_MAKE_DATE()
!                                   END IF
!                               END IF
!    END DO
!    !
!    IF(TIM1 > TSF%NEXT%TIM) THEN
!        IF(.NOT. TSF%MONTHDAY) THEN
!                                   DT   = DT1 - TSF%NEXT%DATE
!                                   VAL  = VAL + (TSF%NEXT%DAT*DT)
!                                   DELT = DELT + DT
!        ELSE
!              DO WHILE(TIM1 > TSF%NEXT%TIM)
!                  YR = YR + ONE
!                  CALL MOVE_TO_START_OF_FILE(TSF)
!                  CALL SET_MONTHDAY(TSF, YR) !SET PREV, CUR, NEXT TO MONTH DAY YEAR
!                  CALL TSF%CUR %DATE%DYEAR_MAKE_DATE() !IN CASE DATE WAS NOT STORED FOR SPEED PURPOSES
!                  CALL TSF%NEXT%DATE%DYEAR_MAKE_DATE()
!                  !
!                  IF(TIM1 < TSF%CUR%TIM) THEN
!                               DT   = DT1 - TSF%PREV%DATE
!                               VAL  = VAL + (TSF%PREV%DAT*DT)
!                               DELT = DELT + DT
!                               EXIT
!                  ELSE
!                               DT   = TSF%CUR%DATE - TSF%PREV%DATE
!                               VAL  = VAL + (TSF%PREV%DAT*DT)
!                               DELT = DELT + DT
!                  END IF
!                  !
!                  IF(TIM1 < TSF%NEXT%TIM) THEN
!                      DT   = DT1 - TSF%CUR%DATE
!                      VAL  = VAL + (TSF%CUR%DAT*DT)
!                      DELT = DELT + DT
!                      EXIT
!                  ELSE
!                      EOF = FALSE
!                      DO WHILE (.NOT. EOF) 
!                               IF(TIM1 < TSF%NEXT%TIM) THEN
!                                   DT   = DT1 - TSF%CUR%DATE
!                                   VAL  = VAL + (TSF%CUR%DAT*DT)
!                                   DELT = DELT + DT
!                                   EOF  = TRUE
!                               ELSE
!                                   DT   = TSF%NEXT%DATE - TSF%CUR%DATE
!                                   VAL  = VAL + (TSF%CUR%DAT*DT)
!                                   DELT = DELT + DT
!                                   CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                               END IF
!                      END DO
!                  END IF
!              END DO
!        END IF
!    END IF
!    !
!    IF(PRESENT(DAY_DELT)) DAY_DELT = DELT
!    !
!    NULLIFY(TIM0, TIM1)
!    !
!  END SUBROUTINE
!  !
!  !SUBROUTINE TIME_SUM(TSF, TIM0, TIM1, VAL, TMULT)
!  !  CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
!  !  DOUBLE PRECISION,        INTENT(IN   ):: TIM0, TIM1
!  !  DOUBLE PRECISION,        INTENT(  OUT):: VAL
!  !  LOGICAL,                 INTENT(IN   ):: TMULT
!  !  DOUBLE PRECISION:: DT
!  !  LOGICAL:: EOF
!  !  !
!  !  ! MOVE WINDOW TO CORRECT LOCATION
!  !  !
!  !  CALL MOVE_TIME_WINDOW_TO(TSF, TIM0)
!  !  !
!  !  DT   = UNO
!  !  VAL  = DZ
!  !  IF(TIM0 < TSF%CUR%TIM) THEN
!  !                             IF(TMULT) DT = TSF%CUR%TIM - TIM0
!  !                             VAL  = VAL + (TSF%PREV%DAT*DT)
!  !                             !
!  !                             IF(TIM1 < TSF%NEXT%TIM) THEN
!  !                                 IF(TMULT) DT = TIM1 - TSF%CUR%TIM
!  !                                 VAL  = VAL + (TSF%CUR%DAT*DT)
!  !                                 EOF  = TRUE
!  !                             ELSE
!  !                                 IF(TMULT) DT = TSF%NEXT%TIM - TSF%CUR%TIM
!  !                                 VAL  = VAL + (TSF%CUR%DAT*DT)
!  !                                 CALL READ_NEXT_ROW(TSF, EOF)
!  !                             END IF
!  !  ELSE
!  !        EOF  = FALSE
!  !  END IF
!  !  !    
!  !  DO WHILE (.NOT. EOF) 
!  !                             IF(TIM1 < TSF%NEXT%TIM) THEN
!  !                                 IF(TMULT) DT = TIM1 - TSF%CUR%TIM
!  !                                 VAL  = VAL + (TSF%CUR%DAT*DT)
!  !                                 EOF  = TRUE
!  !                             ELSE
!  !                                 IF(TMULT) DT = TSF%NEXT%TIM - TSF%CUR%TIM
!  !                                 VAL  = VAL + (TSF%CUR%DAT*DT)
!  !                                 CALL READ_NEXT_ROW(TSF, EOF)
!  !                             END IF
!  !  END DO
!  !  !
!  !  IF(TIM1 > TSF%NEXT%TIM) THEN
!  !                                 IF(TMULT) DT = TIM1 - TSF%NEXT%TIM
!  !                                 VAL  = VAL + (TSF%NEXT%DAT*DT)
!  !  END IF
!  !  !
!  !END SUBROUTINE
!  !
!  SUBROUTINE TIME_MAX(TSF, TIM0, TIM1, VAL)
!    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
!    DOUBLE PRECISION,        INTENT(IN   ):: TIM0, TIM1
!    DOUBLE PRECISION,        INTENT(  OUT):: VAL
!    !
!    CALL TIME_MAXMIN(TSF, TIM0, TIM1, VAL, TRUE)
!    !
!  END SUBROUTINE
!  !
!  SUBROUTINE TIME_MIN(TSF, TIM0, TIM1, VAL)
!    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
!    DOUBLE PRECISION,        INTENT(IN   ):: TIM0, TIM1
!    DOUBLE PRECISION,        INTENT(  OUT):: VAL
!    !
!    CALL TIME_MAXMIN(TSF, TIM0, TIM1, VAL, FALSE)
!    !
!  END SUBROUTINE
!  !
!  SUBROUTINE TIME_MAXMIN(TSF, TIME0, TIME1, VAL, ISMAX)
!    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
!    DOUBLE PRECISION,TARGET, INTENT(IN   ):: TIME0, TIME1
!    DOUBLE PRECISION,        INTENT(  OUT):: VAL
!    LOGICAL,                 INTENT(IN   ):: ISMAX
!    DOUBLE PRECISION, POINTER:: TIM0, TIM1
!    INTEGER:: YR
!    LOGICAL:: EOF
!    !
!    IF (TIME0 > TIME1) THEN
!        TIM0  => TIME1
!        TIM1  => TIME0
!    ELSE
!        TIM0  => TIME0
!        TIM1  => TIME1
!    END IF
!    !
!    ! MOVE WINDOW TO CORRECT LOCATION
!    !
!    IF(TSF%MONTHDAY) THEN
!        CALL MOVE_MONTHDAY_WINDOW_TO(TSF, TIM0)
!        YR = INT(TSF%NEXT%TIM)
!    ELSE
!        CALL MOVE_TIME_WINDOW_TO(TSF, TIM0) 
!    END IF
!    !
!    !IF(ISMAX) THEN
!    !              VAL  = ninf
!    !ELSE
!    !              VAL  = inf
!    !END IF
!    !
!    IF    (TIM1 < TSF%CUR%TIM) THEN
!                               VAL  = TSF%PREV%DAT
!                               EOF  = TRUE
!    ELSEIF(TIM0 < TSF%CUR%TIM) THEN
!                               VAL  = TSF%PREV%DAT
!                               !
!                               IF(TIM1 < TSF%NEXT%TIM) THEN
!                                   IF(ISMAX) THEN
!                                                 IF(VAL < TSF%CUR%DAT ) VAL = TSF%CUR%DAT
!                                   ELSE
!                                                 IF(VAL > TSF%CUR%DAT ) VAL = TSF%CUR%DAT
!                                   END IF
!                                   EOF  = TRUE
!                               ELSE
!                                   EOF = FALSE
!                               END IF
!    ELSEIF(TIM1 < TSF%NEXT%TIM) THEN
!                               VAL  = TSF%CUR%DAT
!                               EOF  = TRUE
!    ELSE
!                               VAL  = TSF%CUR%DAT
!                               IF(TSF%MONTHDAY) THEN
!                                   CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                               ELSE
!                                   CALL READ_NEXT_ROW(TSF, EOF)
!                               END IF
!                               EOF  = FALSE
!    END IF
!    !
!    DO WHILE (.NOT. EOF)
!                               IF(ISMAX) THEN
!                                             IF(VAL < TSF%CUR%DAT ) VAL = TSF%CUR%DAT
!                               ELSE
!                                             IF(VAL > TSF%CUR%DAT ) VAL = TSF%CUR%DAT
!                               END IF 
!                               !
!                               IF(TIM1 < TSF%NEXT%TIM) THEN
!                                   EOF  = TRUE
!                               ELSE
!                                   IF(TSF%MONTHDAY) THEN
!                                       CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                                   ELSE
!                                       CALL READ_NEXT_ROW(TSF, EOF)
!                                   END IF
!                               END IF
!    END DO
!    !
!    IF(TIM1 > TSF%NEXT%TIM) THEN
!        IF(.NOT. TSF%MONTHDAY) THEN
!                               IF(ISMAX) THEN
!                                             IF(VAL < TSF%NEXT%DAT ) VAL = TSF%NEXT%DAT
!                               ELSE
!                                             IF(VAL > TSF%NEXT%DAT ) VAL = TSF%NEXT%DAT
!                               END IF 
!        ELSE
!              DO WHILE(TIM1 > TSF%NEXT%TIM)
!                  YR = YR + ONE
!                  CALL MOVE_TO_START_OF_FILE(TSF)
!                  CALL SET_MONTHDAY(TSF, YR) !SET PREV, CUR, NEXT TO MONTH DAY YEAR
!                  !
!                  IF(ISMAX) THEN
!                                IF(VAL < TSF%PREV%DAT ) VAL = TSF%PREV%DAT
!                  ELSE
!                                IF(VAL > TSF%PREV%DAT ) VAL = TSF%PREV%DAT
!                  END IF
!                  !
!                  IF(TIM1 < TSF%CUR%TIM)  EXIT
!                  !
!                  IF(ISMAX) THEN
!                                IF(VAL < TSF%CUR%DAT ) VAL = TSF%CUR%DAT
!                  ELSE
!                                IF(VAL > TSF%CUR%DAT ) VAL = TSF%CUR%DAT
!                  END IF 
!                  !
!                  IF(TIM1 < TSF%NEXT%TIM) THEN
!                      EXIT
!                  ELSE
!                      CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                      DO WHILE (.NOT. EOF)
!                               IF(ISMAX) THEN
!                                             IF(VAL < TSF%CUR%DAT ) VAL = TSF%CUR%DAT
!                               ELSE
!                                             IF(VAL > TSF%CUR%DAT ) VAL = TSF%CUR%DAT
!                               END IF  
!                               IF(TIM1 < TSF%NEXT%TIM) THEN
!                                   EOF  = TRUE
!                               ELSE
!                                   CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                               END IF
!                      END DO
!                  END IF
!              END DO
!        END IF
!    END IF
!    !
!    NULLIFY(TIM0, TIM1)
!    !
!  END SUBROUTINE
!    
!!  SUBROUTINE TIME_MAXMIN(TSF, TIM0, TIM1, VAL, ISMAX)
!!    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
!!    DOUBLE PRECISION,        INTENT(IN   ):: TIM0, TIM1
!!    DOUBLE PRECISION,        INTENT(  OUT):: VAL
!!    LOGICAL,                 INTENT(IN   ):: ISMAX
!!    INTEGER:: YR
!!    LOGICAL:: EOF
!!    !
!!    ! MOVE WINDOW TO CORRECT LOCATION
!!    !
!!    IF(TSF%MONTHDAY) THEN
!!        CALL MOVE_MONTHDAY_WINDOW_TO(TSF, TIM0) 
!!    ELSE
!!        CALL MOVE_TIME_WINDOW_TO(TSF, TIM0) 
!!    END IF
!!    !
!!    IF(ISMAX) THEN
!!                  VAL  = ninf
!!    ELSE
!!                  VAL  = inf
!!    END IF
!!    IF(TIM0 < TSF%CUR%TIM) THEN
!!                               IF(ISMAX) THEN
!!                                             IF(VAL < TSF%PREV%DAT) VAL = TSF%PREV%DAT
!!                                             IF(VAL < TSF%CUR%DAT ) VAL = TSF%CUR%DAT
!!                               ELSE
!!                                             IF(VAL > TSF%PREV%DAT) VAL = TSF%PREV%DAT
!!                                             IF(VAL > TSF%CUR%DAT ) VAL = TSF%CUR%DAT
!!                               END IF
!!                               !
!!                               IF(TIM1 < TSF%NEXT%TIM) THEN
!!                                   EOF  = TRUE
!!                               ELSEIF(TSF%MONTHDAY) THEN
!!                                       YR = INT(TSF%NEXT%TIM)
!!                                       CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!!                               ELSE
!!                                       CALL READ_NEXT_ROW(TSF, EOF)
!!                               END IF
!!    ELSE
!!                               EOF  = FALSE
!!    END IF
!!    !    
!!    IF(TSF%MONTHDAY) YR = INT(TSF%NEXT%TIM)
!!    DO WHILE (.NOT. EOF) 
!!                               IF(ISMAX) THEN
!!                                             IF(VAL < TSF%CUR%DAT ) VAL = TSF%CUR%DAT
!!                               ELSE
!!                                             IF(VAL > TSF%CUR%DAT ) VAL = TSF%CUR%DAT
!!                               END IF
!!                               !
!!                               IF(TIM1 < TSF%NEXT%TIM) THEN
!!                                   EOF  = TRUE
!!                               ELSEIF(TSF%MONTHDAY) THEN
!!                                       CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!!                               ELSE
!!                                       CALL READ_NEXT_ROW(TSF, EOF)
!!                               END IF
!!    END DO
!!    !
!!    IF(TIM1 > TSF%NEXT%TIM) THEN
!!                               IF(ISMAX) THEN
!!                                             IF(VAL < TSF%NEXT%DAT ) VAL = TSF%NEXT%DAT
!!                               ELSE
!!                                             IF(VAL > TSF%NEXT%DAT ) VAL = TSF%NEXT%DAT
!!                               END IF
!!    END IF
!!    !
!!  END SUBROUTINE
!  !
!  SUBROUTINE MOVE_TO_START_OF_FILE(TSF)
!    CLASS(TIME_SERIES_FILE),  INTENT(INOUT):: TSF
!    INTEGER:: LLOC, ISTART, ISTOP
!    LOGICAL:: EOF
!    !
!    IF(TSF%N == Z) RETURN
!    !
!    REWIND(TSF%FL%IU)
!    CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
!    !
!    ! GET FIRST ROW
!    LLOC = ONE
!    CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%PREV%DATE, ONLY_DYEAR=TRUE ,MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
!    TSF%PREV%TIM = TSF%PREV%DATE%DYEAR
!    !
!    CALL GET_NUMBER(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%PREV%DAT,MSG='FAILED TO LOAD DATA/VALUE PART (SECOND NUMBER) OF THE TIME SERIES INPUT FILE.')
!    !
!    CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT,EOF=EOF)
!    !
!    ! GET SECOND ROW
!    IF(EOF) THEN
!        TSF%CUR%TIM  = TSF%PREV%TIM
!        TSF%CUR%DAT  = TSF%PREV%DAT
!    ELSE
!        LLOC = ONE
!        CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%CUR%DATE, ONLY_DYEAR=TRUE ,MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
!        TSF%CUR%TIM = TSF%CUR%DATE%DYEAR
!        !
!        CALL GET_NUMBER(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%CUR%DAT,MSG='FAILED TO LOAD DATA/VALUE PART (SECOND NUMBER) OF THE TIME SERIES INPUT FILE.')
!        !
!        CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT,EOF=EOF)
!    END IF
!    !
!    ! GET THIRD ROW
!    IF(EOF) THEN
!        TSF%NEXT%TIM = TSF%CUR%TIM
!        TSF%NEXT%DAT = TSF%CUR%DAT
!    ELSE
!        LLOC = ONE
!        CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%NEXT%DATE, ONLY_DYEAR=TRUE ,MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
!        TSF%NEXT%TIM = TSF%NEXT%DATE%DYEAR
!        !
!        CALL GET_NUMBER(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%NEXT%DAT,MSG='FAILED TO LOAD DATA/VALUE PART (SECOND NUMBER) OF THE TIME SERIES INPUT FILE.')
!    END IF
!    !
!    TSF%AT_NEXT   = TRUE
!    TSF%P         = THREE              ! POSITION LOCATED AFTER ROW 3
!    IF(EOF) TSF%N = THREE              ! NOW HAVE THREE DATA POINTS
!    !!!BACKSPACE(TSF%FL%IU) !POSITIONED AT FIRST LINE OF INPUT DATA
!    !!!!
!    !!!TSF%AT_NEXT = TRUE  !NOW LOAD FIRST THREE VALUES
!    !!!!
!    !!!IF(TSF%N > TWO) THEN            !LOAD FIRST THREE VALUES
!    !!!    CALL READ_NEXT_ROW(TSF, EOF)
!    !!!    CALL READ_NEXT_ROW(TSF, EOF)
!    !!!    CALL READ_NEXT_ROW(TSF, EOF)
!    !!!ELSEIF(TSF%N == TWO) THEN
!    !!!    TSF%P = NINER               !JUST TO GET PAST END OF FILE CHECKS
!    !!!    CALL READ_NEXT_ROW(TSF, EOF)
!    !!!    CALL READ_NEXT_ROW(TSF, EOF)
!    !!!    TSF%PREV%TIM = TSF%CUR%TIM
!    !!!    TSF%PREV%DAT = TSF%CUR%DAT
!    !!!    TSF%CUR %TIM = TSF%NEXT%TIM
!    !!!    TSF%CUR %DAT = TSF%NEXT%DAT
!    !!!    TSF%N = THREE              ! NOW HAVE THREE DATA POINTS
!    !!!    TSF%P = THREE
!    !!!ELSE!IF(TSF%N == ONE) THEN
!    !!!    !
!    !!!    TSF%P = NINER               ! JUST TO GET PAST END OF FILE CHECKS
!    !!!    CALL READ_NEXT_ROW(TSF, EOF)
!    !!!    TSF%PREV%TIM = TSF%NEXT%TIM
!    !!!    TSF%PREV%DAT = TSF%NEXT%DAT
!    !!!    TSF%CUR %TIM = TSF%NEXT%TIM
!    !!!    TSF%CUR %DAT = TSF%NEXT%DAT
!    !!!    TSF%N = THREE              ! NOW HAVE THREE DATA POINTS
!    !!!    TSF%P = THREE
!    !!!END IF
!  END SUBROUTINE
!  !
!  SUBROUTINE MOVE_TIME_WINDOW_TO(TSF, TIME)
!    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
!    DOUBLE PRECISION,        INTENT(IN   ):: TIME
!    INTEGER:: POS, I, J, K
!    LOGICAL:: EOF
!    !
!    EOF = FALSE
!    IF(TSF%PREV%TIM <= TIME .AND. TIME <= TSF%NEXT%TIM) THEN
!                                                             CONTINUE !DO NOTHING CAUSE WINDOW IS WHERE IT NEEDS TO BE
!    ELSEIF(TSF%N500 < TWO) THEN
!        IF    (TIME < TSF%PREV%TIM) THEN
!                                        DO WHILE(.NOT. EOF .AND. TIME <= TSF%PREV%TIM)
!                                                                                    CALL READ_PREV_ROW(TSF, EOF)
!                                        END DO
!        ELSEIF(TIME > TSF%NEXT%TIM ) THEN
!                                        DO WHILE(.NOT. EOF .AND. TIME >= TSF%NEXT%TIM)
!                                                                                    CALL READ_NEXT_ROW(TSF, EOF)
!                                        END DO
!        END IF
!    ELSEIF(TIME <= TSF%T500(TWO)) THEN
!        !
!        IF(TSF%P > HUND) CALL MOVE_TO_START_OF_FILE(TSF)
!        !
!        IF    (TIME < TSF%PREV%TIM) THEN
!                                        DO WHILE(.NOT. EOF .AND. TIME <= TSF%PREV%TIM)
!                                                                                    CALL READ_PREV_ROW(TSF, EOF)
!                                        END DO
!        ELSEIF(TIME > TSF%NEXT%TIM ) THEN
!                                        DO WHILE(.NOT. EOF .AND. TIME >= TSF%NEXT%TIM)
!                                                                                    CALL READ_NEXT_ROW(TSF, EOF)
!                                        END DO
!        END IF
!    ELSE
!        IF    (TIME < TSF%PREV%TIM) THEN
!                                        POS = TSF%P / QUIN
!                                        IF(POS < ONE) POS = ONE
!                                        !
!                                        IF(TIME < TSF%T500(POS) .OR. POS > QUIN) THEN  !MORE THAN 500 AWAY FOR AT LEAST LINE 250,000
!                                            !
!                                            CALL MOVE_TO_START_OF_FILE(TSF)
!                                            !
!                                            POS = Z
!                                            DO I=TWO, TSF%N500+ONE
!                                                IF(TIME < TSF%T500(I)) THEN
!                                                    POS = (I - ONE)*QUIN - TEN
!                                                    EXIT
!                                                END IF
!                                            END DO
!                                            IF(POS > Z .AND. TSF%P < POS) THEN !P = 5   POS =8
!                                                DO I = TSF%P + ONE, POS
!                                                                       READ(TSF%FL%IU, *)
!                                                END DO
!                                                TSF%P = POS
!                                                CALL READ_NEXT_ROW(TSF, EOF)  !LOUD INTO MEMORY THE NEXT THREE LINES
!                                                CALL READ_NEXT_ROW(TSF, EOF)
!                                                CALL READ_NEXT_ROW(TSF, EOF)
!                                            END IF
!                                            !
!                                            DO WHILE(.NOT. EOF .AND. TIME >= TSF%NEXT%TIM)
!                                                                                        CALL READ_NEXT_ROW(TSF, EOF)
!                                            END DO
!                                        ELSE
!                                            DO WHILE(.NOT. EOF .AND. TIME <= TSF%PREV%TIM)
!                                                                                        CALL READ_PREV_ROW(TSF, EOF)
!                                            END DO
!                                        END IF
!        ELSEIF(TIME > TSF%NEXT%TIM ) THEN
!                                        IF(.NOT. TSF%AT_NEXT) THEN
!                                            READ(TSF%FL%IU, *)
!                                            READ(TSF%FL%IU, *)
!                                            !CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
!                                            !CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
!                                            TSF%AT_NEXT = TRUE
!                                            TSF%P = TSF%P + TWO 
!                                        END IF
!                                        !
!                                        POS = TSF%P / QUIN + ONE
!                                        IF(TIME > TSF%T500(POS)) THEN  !TIME < TSF%T500(TSF%N500) .AND. 
!                                            POS = Z
!                                            DO I=TWO, TSF%N500+ONE
!                                                IF(TIME < TSF%T500(I)) THEN
!                                                    POS = (I - ONE)*QUIN - TEN
!                                                    EXIT
!                                                END IF
!                                            END DO
!                                            IF(POS > Z .AND. TSF%P < POS) THEN !P = 5   POS =8
!                                                DO I = TSF%P + ONE, POS
!                                                                       READ(TSF%FL%IU, *)
!                                                END DO
!                                                TSF%P = POS
!                                                CALL READ_NEXT_ROW(TSF, EOF)  !LOUD INTO MEMORY THE NEXT THREE LINES
!                                                CALL READ_NEXT_ROW(TSF, EOF)
!                                                CALL READ_NEXT_ROW(TSF, EOF)
!                                            END IF
!                                        END IF
!                                        !
!                                        DO WHILE(.NOT. EOF .AND. TIME >= TSF%NEXT%TIM)
!                                                                                    CALL READ_NEXT_ROW(TSF, EOF)
!                                        END DO
!        END IF
!    END IF
!    !
!  END SUBROUTINE
!  !
!  SUBROUTINE MOVE_MONTHDAY_WINDOW_TO(TSF, TIME)
!    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
!    DOUBLE PRECISION,        INTENT(IN   ):: TIME
!    INTEGER:: POS, I, J, K, YR
!    TYPE(DATE_OPERATOR), ALLOCATABLE:: DT
!    LOGICAL:: EOF
!    !
!    YR = INT(TIME)
!    !
!    CALL SET_MONTHDAY(TSF, YR) !SET PREV, CUR, NEXT TO MONTH DAY YEAR
!    !
!    EOF = FALSE
!    IF(TSF%PREV%TIM <= TIME .AND. TIME <= TSF%NEXT%TIM) THEN
!                                                             CONTINUE !DO NOTHING CAUSE WINDOW IS WHERE IT NEEDS TO BE
!    ELSEIF(TSF%N <= HUND) THEN
!        IF    (TIME < TSF%PREV%TIM) THEN
!                                        DO WHILE(.NOT. EOF .AND. TIME <= TSF%PREV%TIM)
!                                                                                    CALL READ_PREV_ROW_MONTHDAY(TSF, EOF, YR)
!                                        END DO
!        ELSEIF(TIME > TSF%NEXT%TIM ) THEN
!                                        DO WHILE(.NOT. EOF .AND. TIME >= TSF%NEXT%TIM)
!                                                                                    CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                                        END DO
!        END IF
!    ELSE
!        IF( YR .NE. INT(TSF%T500(ONE)) ) THEN
!           !
!           ALLOCATE(DT)
!           DO I = ONE, TSF%N500
!                              CALL DT%INIT(TSF%T500(I))
!                              CALL DT%SET_YEAR(YR)
!                              TSF%T500(I) = DT%DYEAR
!           END DO
!           DEALLOCATE(DT)
!        END IF
!        !
!        IF(TIME <= TSF%T500(TWO)) THEN
!            !
!            IF(TSF%P > HUND) THEN
!                CALL MOVE_TO_START_OF_FILE(TSF)
!                CALL SET_MONTHDAY(TSF, YR) !SET PREV, CUR, NEXT TO MONTH DAY YEAR
!            END IF
!            !
!            IF    (TIME < TSF%PREV%TIM) THEN
!                                            DO WHILE(.NOT. EOF .AND. TIME <= TSF%PREV%TIM)
!                                                                                        CALL READ_PREV_ROW_MONTHDAY(TSF, EOF, YR)
!                                            END DO
!            ELSEIF(TIME > TSF%NEXT%TIM ) THEN
!                                            DO WHILE(.NOT. EOF .AND. TIME >= TSF%NEXT%TIM)
!                                                                                        CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                                            END DO
!            END IF
!        ELSE
!            IF    (TIME < TSF%PREV%TIM) THEN
!                                            POS = TSF%P / QUIN
!                                            IF(POS < ONE) POS = ONE
!                                            !
!                                            IF(TIME < TSF%T500(POS) .OR. POS > QUIN) THEN  !MORE THAN 500 AWAY OR BEYOND LINE 250,000
!                                                !
!                                                CALL MOVE_TO_START_OF_FILE(TSF)
!                                                CALL SET_MONTHDAY(TSF, YR) !SET PREV, CUR, NEXT TO MONTH DAY YEAR
!                                                !
!                                                POS = Z
!                                                DO I=TWO, TSF%N500+ONE
!                                                    IF(TIME < TSF%T500(I)) THEN
!                                                        POS = (I - ONE)*QUIN - TEN
!                                                        EXIT
!                                                    END IF
!                                                END DO
!                                                IF(POS > Z .AND. TSF%P < POS) THEN !P = 5   POS =8
!                                                    DO I = TSF%P + ONE, POS
!                                                                           READ(TSF%FL%IU, *)
!                                                    END DO
!                                                    TSF%P = POS
!                                                    CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)  !LOUD INTO MEMORY THE NEXT THREE LINES
!                                                    CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                                                    CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                                                END IF
!                                                !
!                                                DO WHILE(.NOT. EOF .AND. TIME >= TSF%NEXT%TIM)
!                                                                                            CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                                                END DO
!                                            ELSE
!                                                DO WHILE(.NOT. EOF .AND. TIME <= TSF%PREV%TIM)
!                                                                                            CALL READ_PREV_ROW_MONTHDAY(TSF, EOF, YR)
!                                                END DO
!                                            END IF
!            ELSEIF(TIME > TSF%NEXT%TIM ) THEN
!                                            IF(.NOT. TSF%AT_NEXT) THEN
!                                                READ(TSF%FL%IU, *)
!                                                READ(TSF%FL%IU, *)
!                                                !CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
!                                                !CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
!                                                TSF%AT_NEXT = TRUE
!                                                TSF%P = TSF%P + TWO 
!                                            END IF
!                                            !
!                                            POS = TSF%P / QUIN + ONE
!                                            IF(TIME > TSF%T500(POS)) THEN  !TIME < TSF%T500(TSF%N500) .AND. 
!                                                POS = Z
!                                                DO I=TWO, TSF%N500+ONE
!                                                    IF(TIME < TSF%T500(I)) THEN
!                                                        POS = (I - ONE)*QUIN - TEN
!                                                        EXIT
!                                                    END IF
!                                                END DO
!                                                IF(POS > Z .AND. TSF%P < POS) THEN !P = 5   POS =8
!                                                    DO I = TSF%P + ONE, POS
!                                                                           READ(TSF%FL%IU, *)
!                                                    END DO
!                                                    TSF%P = POS
!                                                    CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)  !LOUD INTO MEMORY THE NEXT THREE LINES
!                                                    CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                                                    CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                                                END IF
!                                            END IF
!                                            !
!                                            DO WHILE(.NOT. EOF .AND. TIME >= TSF%NEXT%TIM)
!                                                                                        CALL READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!                                            END DO
!            END IF
!        END IF
!    END IF
!    !
!  END SUBROUTINE
!  !
!  SUBROUTINE GO_TO_TIME_SERIES_POSITION(TSF, POS)
!  CLASS(TIME_SERIES_FILE),  INTENT(INOUT):: TSF
!  INTEGER,                  INTENT(IN   ):: POS
!  INTEGER:: P
!  LOGICAL:: EOF
!  !
!  P = POS
!  IF(P > TSF%N  ) P = TSF%N
!  IF(P < THREE  ) P = THREE
!  !
!  CALL MOVE_TO_START_OF_FILE(TSF)
!  !
!  DO WHILE (TSF%P < P .OR. TSF%P .NE. TSF%N)
!        CALL READ_NEXT_ROW(TSF, EOF)
!  END DO
!  !
!  END SUBROUTINE
!  !
!  SUBROUTINE READ_NEXT_ROW(TSF, EOF)
!  CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
!  LOGICAL,                 INTENT(OUT  ):: EOF
!  INTEGER:: LLOC, ISTART, ISTOP
!  !
!  IF(TSF%P == TSF%N .OR. (TSF%P == TSF%N - TWO .AND. .NOT. TSF%AT_NEXT) .OR. TSF%N == Z) THEN
!      EOF = TRUE
!  ELSE
!      EOF = FALSE
!      IF(.NOT. TSF%AT_NEXT) THEN
!          CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
!          CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
!          TSF%AT_NEXT = TRUE
!          TSF%P = TSF%P + TWO 
!      END IF
!      !
!      CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
!      !
!      TSF%P = TSF%P + ONE 
!      !
!      TSF%TMP => TSF%PREV
!      !
!      TSF%PREV => TSF%CUR
!      TSF%CUR  => TSF%NEXT
!      TSF%NEXT => TSF%TMP
!      !
!      TSF%TMP  => NULL()
!      !
!      LLOC = ONE
!      CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%NEXT%DATE, ONLY_DYEAR=TRUE ,MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
!      TSF%NEXT%TIM = TSF%NEXT%DATE%DYEAR
!      !
!      CALL GET_NUMBER(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%NEXT%DAT,MSG='FAILED TO LOAD DATA/VALUE PART (SECOND NUMBER) OF THE TIME SERIES INPUT FILE.')
!      TSF%NEXT%DAT = TSF%NEXT%DAT
!      !
!  END IF
!  !
!  END SUBROUTINE
!  !
!  SUBROUTINE READ_PREV_ROW(TSF, EOF)
!  CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
!  LOGICAL,                 INTENT(OUT  ):: EOF
!  INTEGER:: LLOC, ISTART, ISTOP
!  !
!  IF(TSF%P == ONE .OR. (TSF%P == THREE .AND. TSF%AT_NEXT) .OR. TSF%N == Z) THEN
!      EOF = TRUE
!  ELSE
!      EOF = FALSE
!      IF(TSF%AT_NEXT) THEN
!          BACKSPACE(TSF%FL%IU)
!          BACKSPACE(TSF%FL%IU)
!          TSF%AT_NEXT = FALSE
!          TSF%P = TSF%P - TWO 
!      END IF
!      !
!      BACKSPACE(TSF%FL%IU)
!      BACKSPACE(TSF%FL%IU)
!      CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
!      !
!      TSF%P = TSF%P - ONE 
!      !
!      TSF%TMP => TSF%NEXT
!      !
!      TSF%NEXT => TSF%CUR
!      TSF%CUR  => TSF%PREV
!      TSF%PREV => TSF%TMP
!      !
!      TSF%TMP  => NULL()
!      !
!      LLOC = ONE
!      CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%PREV%DATE, ONLY_DYEAR=TRUE ,MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
!      TSF%PREV%TIM = TSF%PREV%DATE%DYEAR
!      !
!      CALL GET_NUMBER(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%PREV%DAT,MSG='FAILED TO LOAD DATA/VALUE PART (SECOND NUMBER) OF THE TIME SERIES INPUT FILE.')
!      TSF%PREV%DAT = TSF%PREV%DAT
!  END IF
!  !
!  END SUBROUTINE
!  !
!  SUBROUTINE READ_NEXT_ROW_MONTHDAY(TSF, EOF, YR)
!  CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
!  LOGICAL,                 INTENT(  OUT):: EOF
!  INTEGER,                 INTENT(IN   ):: YR
!  INTEGER:: LLOC, ISTART, ISTOP
!  !
!  IF(TSF%P == TSF%N .OR. (TSF%P == TSF%N - TWO .AND. .NOT. TSF%AT_NEXT) .OR. TSF%N == Z) THEN
!      EOF = TRUE
!  ELSE
!      EOF = FALSE
!      IF(.NOT. TSF%AT_NEXT) THEN
!          CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
!          CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
!          TSF%AT_NEXT = TRUE
!          TSF%P = TSF%P + TWO 
!      END IF
!      !
!      CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
!      !
!      TSF%P = TSF%P + ONE 
!      !
!      TSF%TMP => TSF%PREV
!      !
!      TSF%PREV => TSF%CUR
!      TSF%CUR  => TSF%NEXT
!      TSF%NEXT => TSF%TMP
!      !
!      TSF%TMP  => NULL()
!      !
!      LLOC = ONE
!      CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%NEXT%DATE ,MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
!      !
!      CALL TSF%NEXT%DATE%SET_YEAR( YR )
!      TSF%NEXT%TIM = TSF%NEXT%DATE%DYEAR
!      !
!      CALL GET_NUMBER(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%NEXT%DAT,MSG='FAILED TO LOAD DATA/VALUE PART (SECOND NUMBER) OF THE TIME SERIES INPUT FILE.')
!      TSF%NEXT%DAT = TSF%NEXT%DAT
!      !
!  END IF
!  !
!  END SUBROUTINE
!  !
!  SUBROUTINE READ_PREV_ROW_MONTHDAY(TSF, EOF, YR)
!  CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
!  LOGICAL,                 INTENT(OUT  ):: EOF
!  INTEGER,                 INTENT(IN   ):: YR
!  INTEGER:: LLOC, ISTART, ISTOP
!  !
!  IF(TSF%P == ONE .OR. (TSF%P == THREE .AND. TSF%AT_NEXT) .OR. TSF%N == Z) THEN
!      EOF = TRUE
!  ELSE
!      EOF = FALSE
!      IF(TSF%AT_NEXT) THEN
!          BACKSPACE(TSF%FL%IU)
!          BACKSPACE(TSF%FL%IU)
!          TSF%AT_NEXT = FALSE
!          TSF%P = TSF%P - TWO 
!      END IF
!      !
!      BACKSPACE(TSF%FL%IU)
!      BACKSPACE(TSF%FL%IU)
!      CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
!      !
!      TSF%P = TSF%P - ONE 
!      !
!      TSF%TMP => TSF%NEXT
!      !
!      TSF%NEXT => TSF%CUR
!      TSF%CUR  => TSF%PREV
!      TSF%PREV => TSF%TMP
!      !
!      TSF%TMP  => NULL()
!      !
!      LLOC = ONE
!      CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%PREV%DATE, ONLY_DYEAR=TRUE ,MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
!      !
!      CALL TSF%PREV%DATE%SET_YEAR( YR )
!      TSF%PREV%TIM = TSF%PREV%DATE%DYEAR
!      !
!      CALL GET_NUMBER(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%PREV%DAT,MSG='FAILED TO LOAD DATA/VALUE PART (SECOND NUMBER) OF THE TIME SERIES INPUT FILE.')
!      TSF%PREV%DAT = TSF%PREV%DAT
!  END IF
!  !
!  END SUBROUTINE
!  !  
!  PURE ELEMENTAL FUNCTION TIME_SERIES_FILE_IN_USE(TSF) RESULT(ANS)
!  CLASS(TIME_SERIES_FILE),  INTENT(IN):: TSF
!  LOGICAL:: ANS
!  !
!  ANS = TSF%N > Z
!  !
!  END FUNCTION
!  !
!  IMPURE ELEMENTAL SUBROUTINE MOVE_TIME_SERIES_TOO(TSF, TSF2)
!    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
!    CLASS(TIME_SERIES_FILE), INTENT(  OUT):: TSF2
!    !
!    CALL DEALLOCATE_TIME_SERIES_FILE(TSF2)
!    !
!    ALLOCATE(TSF2%PREV, TSF2%CUR, TSF2%NEXT)
!    TSF2%IOUT = TSF2%IOUT
!    IF(ALLOCATED(TSF%NAM)) THEN
!        ALLOCATE(TSF2%NAM, SOURCE = TSF%NAM)
!    ELSE
!        ALLOCATE(TSF2%NAM, SOURCE = 'n')
!    END IF
!    !
!    TSF2%OPT      = TSF%OPT
!    TSF2%MONTHDAY = TSF%MONTHDAY
!    TSF2%N        = TSF%N
!    TSF2%IOUT     = TSF%IOUT
!    TSF2%SFAC     = TSF%SFAC
!    TSF2%OPT      = TSF%OPT
!    TSF2%P        = TSF%P
!    TSF2%N500     = TSF%N500
!    !
!    IF(TSF2%N500 > Z) ALLOCATE(TSF2%T500, SOURCE=TSF%T500)
!    !
!    IF(TSF%FL%SKIP) THEN
!        TSF2%FL%SKIP = TRUE
!        TSF2%AT_NEXT = TRUE
!        !
!        TSF2%PREV%TIM = ninf  
!        TSF2%PREV%DAT = TSF%PREV%DAT
!        TSF2%CUR %TIM = ninf
!        TSF2%CUR %DAT = TSF%CUR %DAT
!        TSF2%NEXT%TIM = ninf 
!        TSF2%NEXT%DAT = TSF%NEXT%DAT
!    ELSE
!        CALL TSF%FL%MOVE( TSF2%FL )
!        !
!        CALL MOVE_TO_START_OF_FILE(TSF2)
!    END IF
!    !
!    CALL DEALLOCATE_TIME_SERIES_FILE(TSF)
!    !
!  END SUBROUTINE
!  !  
!  IMPURE ELEMENTAL SUBROUTINE DEALLOCATE_TIME_SERIES_FILE(TSF)
!    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
!    !
!    IF(ASSOCIATED(TSF%PREV)) DEALLOCATE(TSF%PREV)
!    IF(ASSOCIATED(TSF%CUR )) DEALLOCATE(TSF%CUR )
!    IF(ASSOCIATED(TSF%NEXT)) DEALLOCATE(TSF%NEXT)
!    TSF%PREV => NULL()
!    TSF%CUR  => NULL()
!    TSF%NEXT => NULL()
!    TSF%TMP  => NULL()
!    !
!    IF(ALLOCATED (TSF%NAM )) DEALLOCATE(TSF%NAM )
!    !
!    CALL TSF%FL%CLOSE()
!    !
!    IF(ALLOCATED(TSF%T500)) DEALLOCATE(TSF%T500)
!    TSF%N500 = Z
!    !
!    TSF%AT_NEXT  = FALSE
!    TSF%MONTHDAY = FALSE
!    TSF%BINARY   = FALSE
!    TSF%IOUT = Z
!    TSF%SFAC = UNO
!    TSF%N    = Z
!    TSF%OPT  = Z
!    TSF%P    = Z
!    TSF%NDAT = Z
!    !TSF%CHK  = inf_I   
!    !TSF%CHK_TIM = ninf
!    !
!  END SUBROUTINE
!  !
!  IMPURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_TIME_SERIES_FILE(TSF)
!    TYPE(TIME_SERIES_FILE), INTENT(INOUT):: TSF
!    CALL DEALLOCATE_TIME_SERIES_FILE(TSF)
!  END SUBROUTINE
!END MODULE

 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
!   *** SUPERSEDED BY GENERIC_INPUT OR GENERIC_OUTPUT DATA TYPES
!
!MODULE READ_FILE_LOCATION_INTERFACE !,ONLY: READ_FILE_LOCATION  
!!CHECKS FOR INTERNAL, EXTERNAL, OPEN/CLOSE AND RETURNS UNIT NUMBER -- AUTO-CLOSES IF OPEN/CLOSE IS USED
!!SET KEY_FOUND=TRUE AND IU=0 FOR INTERNAL FLAG
!!SET KEY_FOUND=TRUE AND IU=X FOR EXTERNAL X
!!SET KEY_FOUND=TRUE AND IU=X FOR OPEN/CLOSE FILE NAME WITH X BEING THE OPENED UNIT NUMBER.
!!CHECKS FOR SFAC KEYWORD AND RETURNS HAS_SFAC=TRUE IF FOUND (NO FILE OPENED).
!  USE CONSTANTS, ONLY:BLNK,NL,TAB,COM,Z,ONE,TWO,TEN,DZ,UNO,DOS,DIEZ,TRUE,FALSE
!  USE UTIL_INTERFACE, ONLY: FILE_IO_ERROR, PARSE_WORD
!  IMPLICIT NONE
!  PRIVATE
!  PUBLIC:: READ_FILE_LOCATION
!  !
!  TYPE READ_FILE_LOCATION
!      INTEGER:: IU               !IU = 0 FOR INTERNAL, IU.NE.0 MEANS EXTERNAL FILE
!      LOGICAL:: KEY_FOUND
!      LOGICAL:: OPENCLOSE =FALSE
!      LOGICAL:: HAS_SFAC
!      !
!      CONTAINS
!      !
!      PROCEDURE, PASS(FLOC):: GET_UNIT => CHECK_FOR_FLAG_AND_GET_UNIT
!      FINAL::                             CLOSE_OPENCLOSE_FILE
!  END TYPE
!  !
!  CONTAINS
!  !
!  SUBROUTINE CHECK_FOR_FLAG_AND_GET_UNIT(FLOC, LN, IN, IOUT, NOSTOP)
!    CLASS(READ_FILE_LOCATION), INTENT(INOUT):: FLOC
!    CHARACTER(*),              INTENT(INOUT):: LN
!    INTEGER,                   INTENT(IN   ):: IN, IOUT
!    LOGICAL, OPTIONAL,         INTENT(IN   ):: NOSTOP
!    INTEGER:: I, LLOC, ISTART, ISTOP, IERR
!    INTEGER:: ONE, Z
!    LOGICAL:: NO_STOP
!    REAL:: R
!    !
!    IF(PRESENT(NOSTOP)) THEN
!        NO_STOP = NOSTOP
!    ELSE
!        NO_STOP = FALSE
!    END IF
!    !
!    IF(FLOC%OPENCLOSE) CLOSE(FLOC%IU)
!    !
!    FLOC%HAS_SFAC = FALSE
!    FLOC%OPENCLOSE = FALSE
!    FLOC%KEY_FOUND = TRUE
!    LLOC = ONE
!    CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,TRUE)
!    !  
!    SELECT CASE ( LN(ISTART:ISTOP) )
!    CASE ("SFAC")
!                         FLOC%HAS_SFAC = TRUE
!                         RETURN
!    CASE ("INTERNAL");   FLOC%IU = Z
!    CASE ("EXTERNAL");   CALL URWORD(LN,LLOC,ISTART,ISTOP,2,FLOC%IU,R,IOUT,IN)
!    CASE ("OPEN/CLOSE")
!                         CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
!                         OPEN(NEWUNIT=FLOC%IU, FILE=LN(ISTART:ISTOP), ACTION='READ', IOSTAT=IERR, POSITION='REWIND')
!                         IF(IERR.NE.Z) CALL FILE_IO_ERROR( IERR,IN, LINE=LN, OUTPUT=IOUT, MSG= 'KEYWORD ERROR "OPEN/CLOSE" FAILED TO OPEN FILE SPECIXJED.')
!                         FLOC%OPENCLOSE=TRUE
!    CASE DEFAULT
!                         IF (NO_STOP) THEN
!                             FLOC%IU = Z
!                             FLOC%KEY_FOUND = FALSE
!                         ELSE
!                             CALL FILE_IO_ERROR(Z,IN,LINE=LN,OUTPUT=IOUT,MSG='KEYWORD ERROR. FAILED TO IDENTIFY KEYWORD "INTERNAL", "EXTERNAL" OR "OPEN/CLOSE"')
!                         END IF
!    END SELECT
!    !
!  END SUBROUTINE
!  !
!  SUBROUTINE CLOSE_OPENCLOSE_FILE(FLOC)
!    TYPE(READ_FILE_LOCATION):: FLOC
!    !
!    IF(FLOC%OPENCLOSE) CLOSE(FLOC%IU)
!    !
!  END SUBROUTINE
!  !
!END MODULE
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!      
!    
!PURE ELEMENTAL SUBROUTINE STR2DBLE(STR,VAL)
!  CHARACTER(*),     INTENT(IN):: STR
!  DOUBLE PRECISION, INTENT(OUT):: VAL
!  !
!  SELECT CASE(LOCAL_LINE)
!  CASE('NAN',  'NaN', 'nan'); VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)
!  CASE('INF',  'inf', 'Inf'); VAL = inf
!  CASE('-INF','-inf','-Inf'); VAL = ninf
!  CASE('-1','-1.','-1.0');  VAL = DNEG
!  CASE('0',  '0.', '0.0');  VAL = DZ
!  CASE('1',  '1.', '1.0');  VAL = UNO
!  CASE('2',  '2.', '2.0');  VAL = DOS
!  CASE('3',  '3.', '3.0');  VAL = TRES
!  CASE('4',  '4.', '4.0');  VAL = QUAD
!  CASE('5',  '5.', '5.0');  VAL = CINCO
!  CASE('6 ', '6.', '6.0');  VAL = 6D0
!  CASE('7 ', '7.', '7.0');  VAL = 7D0
!  CASE('8 ', '8.', '8.0');  VAL = 8D0
!  CASE('9 ', '9.', '9.0');  VAL = 9D0
!  CASE('10','10.','10.0');  VAL = DIEZ
!  CASE('20','20.','20.0');  VAL = VIGINTI
!  CASE('25','25.','25.0');  VAL = 25D0
!  CASE('50','50.','50.0');  VAL = 50D0
!  CASE('60','60.','60.0');  VAL = SEXAGEN
!  CASE('100','100.','100.0');  ANS = HECTO
!  CASE('1000','1000.','1000.0');  ANS = KILO
!  CASE DEFAULT
!  
!  END SELECT
!  !
!END SUBROUTINE
    
    
    
    
!!!      SUBROUTINE CHECK_DATAFILES()
!!!          USE GENERIC_INPUT_OUTPUT_DATAFILES, ONLY: DATAFILE_UNIT_NUMBER
!!!          INTEGER:: IJ
!!!          LOGICAL:: ISOPEN
!!!          ASSOCIATE(DF=>DATAFILE_UNIT_NUMBER)
!!!          DO IJ=1, DF%IU%N
!!!              INQUIRE(DF%IU%INT(IJ),OPENED=ISOPEN)
!!!              IF(.NOT. ISOPEN) THEN
!!!                  CONTINUE
!!!              END IF
!!!          END DO
!!!          END ASSOCIATE
!!!      END SUBROUTINE
    
    
    
    
    
    
    
!
! Version that used Parameterized Data Type, but does not compile with gfortran
! 
!!!MODULE CYCLING_TEXT_FILE_INTERFACE!, ONLY: CYCLING_TEXT_FILE
!!!  !OPENS AN FILE FOR WRITING. PROVIDES GENERIC INTERFACING FOR WRITTING TO FILE. IF OPEN/CLOSE AUOTMATICALLY CLOSES FILES
!!!  !
!!!  USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: REAL32, REAL64, REAL128
!!!  !
!!!  USE ARRAY_DATA_TYPES, ONLY: CHARACTER_TYPE
!!!  USE GENERIC_OPEN_INTERFACE, ONLY: GENERIC_OPEN, FORCE_UNIT_CLOSE
!!!  USE UTIL_INTERFACE,            ONLY: FILE_IO_ERROR, WARNING_MESSAGE, CHECK_FOR_POST_KEY, UPPER, PARSE_WORD, GET_INTEGER, NUM2STR, GET_FILE_NAME
!!!  USE GENERIC_INPUT_OUTPUT_DATAFILES, ONLY: DATAFILE_UNIT_NUMBER
!!!  USE CONSTANTS,                     ONLY: BLNK,NL,BLN,TAB,COM,Z,ONE,TWO,TEN,DZ,UNO,DOS,DIEZ,TRUE,FALSE
!!!  IMPLICIT NONE
!!!  PRIVATE
!!!  PUBLIC:: CYCLING_TEXT_FILE
!!!  !
!!!  TYPE CYCLING_TEXT_FILE (RECLEN)
!!!      INTEGER, LEN  :: RECLEN
!!!      CHARACTER(RECLEN):: REC
!!!      !
!!!      INTEGER:: HEDLEN = Z
!!!      CHARACTER(:),ALLOCATABLE:: HED
!!!      !
!!!      INTEGER:: IU = Z
!!!      LOGICAL:: IS_OPEN   = FALSE
!!!      LOGICAL:: OPENCLOSE = FALSE
!!!      LOGICAL:: ERROR
!!!      INTEGER:: IN, IOUT
!!!      CHARACTER(:),ALLOCATABLE:: FNAME
!!!      !
!!!      INTEGER:: NVAL=Z, VPOS = ONE, RPOS = ONE
!!!      INTEGER,              DIMENSION(:), ALLOCATABLE:: NSPACE
!!!      TYPE(CHARACTER_TYPE), DIMENSION(:), ALLOCATABLE:: FMT
!!!      !
!!!      CONTAINS
!!!      !
!!!      PROCEDURE, PASS(FL):: OPEN        => OPEN_CYCLING_TEXT_FILE !(LLOC,LN,IOUT,IN,NOSTOP,REQKEY,IU,BUFFER, KEY, NVAL, HED)
!!!      PROCEDURE, PASS(FL):: SET_HEADER  => CYCLING_TEXT_FILE_SET_HEADER!(HEADER, [NOWRITE]) --WILL REWIND FILE AND WRITE HEADER
!!!      PROCEDURE, PASS(FL):: REWIND      => REWIND_CYCLING_TEXT_FILE
!!!      PROCEDURE, PASS(FL):: WRITE       => WRITE_RECORD_CYCLING_TEXT_FILE
!!!      PROCEDURE, PASS(FL):: SET_NVAL
!!!      GENERIC::             SET_FMT     => SET_SINGLE_FMT, SET_MULTI_FMT !(FMT,NSPACE,[POS])
!!!      GENERIC::             SET_REC     => SET_SINGLE_REC, SET_MULTI_REC !(VAL,[POS])
!!!      PROCEDURE, PASS(FL):: BACK        => BACKSPACE_TEXT_FILE !(FL, NLINE)
!!!      PROCEDURE, PASS(FL):: NEXT        => NEXTLINE_TEXT_FILE  !(FL, NLINE)
!!!      PROCEDURE, PASS(FL):: MOVE        => MOVE_CYCLING_TEXT_FILE !(FL_NEW)
!!!      PROCEDURE, PASS(FL):: CLOSE       => CLOSE_CYCLING_TEXT_FILE
!!!      PROCEDURE, PASS(FL):: SET_FNAME   => SET_FILE_NAME_CYCLING_TEXT_FILE
!!!      PROCEDURE, PASS(FL), PRIVATE:: SET_SINGLE_FMT
!!!      PROCEDURE, PASS(FL), PRIVATE:: SET_MULTI_FMT
!!!      PROCEDURE, PASS(FL), PRIVATE:: SET_SINGLE_REC
!!!      PROCEDURE, PASS(FL), PRIVATE:: SET_MULTI_REC
!!!      !
!!!      FINAL::                            FINAL_CLOSE_CYCLING_TEXT_FILE
!!!  END TYPE
!!!  !
!!!  CONTAINS
!!!  !
!!!  PURE SUBROUTINE MOVE_CYCLING_TEXT_FILE(FL, FL_NEW)
!!!    CLASS(CYCLING_TEXT_FILE(*)),  INTENT(INOUT):: FL
!!!    CLASS(CYCLING_TEXT_FILE(*)),  INTENT(INOUT):: FL_NEW
!!!    !
!!!    FL_NEW%IU         =  FL%IU
!!!    FL_NEW%OPENCLOSE  =  FL%OPENCLOSE
!!!    FL_NEW%ERROR      =  FL%ERROR
!!!    FL_NEW%IN         =  FL%IN
!!!    FL_NEW%IOUT       =  FL%IOUT
!!!    FL_NEW%IS_OPEN    =  FL%IS_OPEN
!!!    FL_NEW%HEDLEN     =  FL%HEDLEN
!!!    FL_NEW%NVAL       =  FL%NVAL
!!!    FL_NEW%VPOS       =  FL%VPOS
!!!    FL_NEW%RPOS       =  FL%RPOS
!!!    !
!!!    FL%OPENCLOSE  =FALSE
!!!    FL%IS_OPEN    =FALSE
!!!    !
!!!    IF(ALLOCATED(FL%FNAME)) THEN
!!!        CALL MOVE_ALLOC(FL%FNAME,FL_NEW%FNAME)
!!!    END IF
!!!    !
!!!    IF(ALLOCATED(FL%HED)) THEN
!!!        CALL MOVE_ALLOC(FL%HED, FL_NEW%HED)
!!!    END IF
!!!    !
!!!    IF(ALLOCATED(FL%FMT   )) THEN
!!!        ALLOCATE(FL_NEW%FMT(FL%NVAL) )
!!!        CALL FL%FMT%MOVE(FL_NEW%FMT)
!!!        DEALLOCATE(FL%FMT)
!!!    END IF
!!!    IF(ALLOCATED(FL%NSPACE)) CALL MOVE_ALLOC(FL%NSPACE,FL_NEW%NSPACE)
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  IMPURE ELEMENTAL SUBROUTINE REWIND_CYCLING_TEXT_FILE(FL)
!!!    CLASS(CYCLING_TEXT_FILE(*)), INTENT(INOUT):: FL
!!!    !
!!!    IF(FL%IU.NE.Z) THEN
!!!        REWIND(FL%IU)
!!!        IF(ALLOCATED(FL%HED))  WRITE(FL%IU) FL%HED
!!!    END IF
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  SUBROUTINE WRITE_RECORD_CYCLING_TEXT_FILE(FL)
!!!    CLASS(CYCLING_TEXT_FILE(*)), INTENT(INOUT):: FL
!!!    !
!!!    IF(FL%IU.NE.Z) WRITE(FL%IU) FL%REC, NL
!!!    !
!!!    FL%RPOS = ONE
!!!    FL%VPOS = ONE
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  SUBROUTINE SET_NVAL(FL,NVAL)
!!!    CLASS(CYCLING_TEXT_FILE(*)), INTENT(INOUT):: FL
!!!    INTEGER,                     INTENT(IN   ):: NVAL
!!!    !
!!!    IF(FL%NVAL < NVAL) THEN
!!!        !
!!!        FL%NVAL = NVAL
!!!        !
!!!        IF(ALLOCATED(FL%FMT   )) DEALLOCATE(FL%FMT   )
!!!        IF(ALLOCATED(FL%NSPACE)) DEALLOCATE(FL%NSPACE)
!!!        !
!!!        ALLOCATE(FL%FMT   (FL%NVAL))
!!!        ALLOCATE(FL%NSPACE(FL%NVAL), SOURCE=Z)
!!!        !
!!!    ELSEIF(NVAL < ONE) THEN
!!!        FL%NVAL = Z
!!!        IF(ALLOCATED(FL%FMT   )) DEALLOCATE(FL%FMT   )
!!!        IF(ALLOCATED(FL%NSPACE)) DEALLOCATE(FL%NSPACE)
!!!    END IF
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  SUBROUTINE SET_SINGLE_FMT(FL,FMT,NSPACE,POS)
!!!    CLASS(CYCLING_TEXT_FILE(*)), INTENT(INOUT):: FL
!!!    CHARACTER(*),                INTENT(IN   ):: FMT
!!!    INTEGER,                     INTENT(IN   ):: NSPACE
!!!    INTEGER,                     INTENT(IN   ):: POS
!!!    !
!!!    IF(FL%NVAL > Z .AND. POS > Z .AND. POS <= FL%NVAL) THEN
!!!        FL%FMT   (POS) = FMT
!!!        FL%NSPACE(POS) = NSPACE
!!!    ELSE
!!!        WRITE(*,'(A)') 'CODE ERROR -- CYCLING_TEXT_FILE%SET_SINGLE_FMT NOT SET UP CORRECTLY'
!!!    END IF
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  SUBROUTINE SET_MULTI_FMT(FL,FMT,NSPACE,POS)
!!!    CLASS(CYCLING_TEXT_FILE(*)), INTENT(INOUT):: FL
!!!    CHARACTER(*),DIMENSION(:),   INTENT(IN   ):: FMT
!!!    INTEGER,     DIMENSION(:),   INTENT(IN   ):: NSPACE
!!!    INTEGER,     OPTIONAL,       INTENT(IN   ):: POS
!!!    INTEGER:: I, J, P, N
!!!    !
!!!    P = ONE
!!!    IF(PRESENT(POS)) P = POS
!!!    !
!!!    N = P+SIZE(NSPACE)-ONE
!!!    !
!!!    IF(FL%NVAL > Z .AND.N <= FL%NVAL) THEN
!!!        J = Z
!!!        DO I = P, N
!!!                     J = J + ONE
!!!                     FL%FMT   (I) = FMT   (J)
!!!                     FL%NSPACE(I) = NSPACE(J)
!!!        END DO
!!!    ELSE
!!!        WRITE(*,'(A)') 'CODE ERROR -- CYCLING_TEXT_FILE%SET_SINGLE_FMT NOT SET UP CORRECTLY'
!!!    END IF
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  SUBROUTINE SET_SINGLE_REC(FL,VAL,POS)
!!!    CLASS(CYCLING_TEXT_FILE(*)), INTENT(INOUT):: FL
!!!    CLASS(*),                    INTENT(IN   ):: VAL
!!!    INTEGER,     OPTIONAL,       INTENT(IN   ):: POS
!!!    !
!!!    ASSOCIATE(P => FL%VPOS, LOC => FL%RPOS)
!!!       !
!!!       IF(PRESENT(POS)) THEN
!!!                        P = POS
!!!                        IF    (P==ONE) THEN
!!!                                                 LOC = ONE
!!!                        ELSEIF(P <= FL%NVAL) THEN
!!!                                                 LOC = SUM(FL%NSPACE(1:POS-1)) + ONE
!!!                        END IF
!!!       END IF
!!!       !
!!!       IF(LOC <= FL%RECLEN .AND. P <= FL%NVAL) THEN
!!!           SELECT TYPE (VAL)
!!!           TYPE IS (INTEGER       ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL      
!!!           TYPE IS (CHARACTER(*)  ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL 
!!!           TYPE IS (REAL(REAL64)  ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL
!!!           TYPE IS (REAL(REAL32)  ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL
!!!           TYPE IS (REAL(REAL128) ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL
!!!           TYPE IS (CHARACTER_TYPE); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL%STR
!!!           END SELECT
!!!           !
!!!           LOC = LOC + FL%NSPACE(P)
!!!           P = P + ONE
!!!       ELSE
!!!           WRITE(*,'(A)') 'CODE ERROR -- CYCLING_TEXT_FILE%SET_SINGLE_FMT NOT SET UP CORRECTLY'
!!!       END IF
!!!       !
!!!    END ASSOCIATE
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  SUBROUTINE SET_MULTI_REC(FL,VAL,POS)
!!!    CLASS(CYCLING_TEXT_FILE(*)), INTENT(INOUT):: FL
!!!    CLASS(*),    DIMENSION(:),   INTENT(IN   ):: VAL
!!!    INTEGER,     OPTIONAL,       INTENT(IN   ):: POS
!!!    INTEGER:: I, J, P, N
!!!    !
!!!    ASSOCIATE(P => FL%VPOS, LOC => FL%RPOS)
!!!       !
!!!       IF(PRESENT(POS)) THEN
!!!                        P = POS
!!!                        IF    (P==ONE) THEN
!!!                                                 LOC = ONE
!!!                        ELSEIF(P <= FL%NVAL) THEN
!!!                                                 LOC = SUM(FL%NSPACE(1:POS-1)) + ONE
!!!                        END IF
!!!       END IF
!!!       !
!!!       J = Z
!!!       N = P + SIZE(VAL) - ONE
!!!       !
!!!       IF(N>FL%NVAL) N = FL%NVAL
!!!       !
!!!       DO I=P, N
!!!           !
!!!           IF(LOC <= FL%RECLEN .AND. P <= FL%NVAL) THEN
!!!               J = J + ONE
!!!               SELECT TYPE (VAL)
!!!               TYPE IS (INTEGER       ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL(J)      
!!!               TYPE IS (CHARACTER(*)  ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL(J) 
!!!               TYPE IS (REAL(REAL64)  ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL(J)
!!!               TYPE IS (REAL(REAL32)  ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL(J)
!!!               TYPE IS (REAL(REAL128) ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL(J)
!!!               TYPE IS (CHARACTER_TYPE); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL(J)%STR
!!!               END SELECT
!!!               !
!!!               LOC = LOC + FL%NSPACE(I)
!!!           ELSE
!!!               WRITE(*,'(A)') 'CODE ERROR -- CYCLING_TEXT_FILE%SET_SINGLE_FMT NOT SET UP CORRECTLY'
!!!           END IF
!!!       END DO
!!!       !
!!!       P = P + SIZE(VAL)
!!!       !
!!!    END ASSOCIATE
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  SUBROUTINE OPEN_CYCLING_TEXT_FILE(FL,LLOC,LN,IOUT,IN,NOSTOP,REQKEY,IU,BUFFER, KEY, DIM, NVAL, HED)
!!!    ! ATTEMPTS TO READ KEYWORDS AND CREATE A FILE FOR WRITTING TO. 
!!!    ! FILE ASSUMES CONSTANT CHRACTER(RECLEN) RECORD LENGTH PER LINE
!!!    ! SETS ERROR=TRUE IF FILE FAILED TO IDENTIFY OR OPEN A FILE/UNIT.
!!!    !
!!!    ! THE ORDER THAT THE FILE IS ATTEMPTED TO BE IDENTIFIED IS:
!!!    ! 1) READ SINGLE UNIT NUMBER
!!!    ! 2) CHECK FOR OPTIONAL KEYWORD "BINARY" --ADDED TO OPEN FILE
!!!    ! 4) CHECK FOR KEYWORD "INTERNAL", "LIST", OR THE REST OF HTE LINE IS BLANK TO INDICATE THAT OUTPUT IS WRITTEN TO LIST FILE
!!!    ! 5) CHECK FOR KEYWORD EXTERNAL FOLLOWED BY UNIT NUMBER
!!!    ! 6) CHECK FOR KEYWORD OPEN/CLOSE AND THEN OPENS FILE SPECIFIED
!!!    ! 7) CHEKS IF THE LINE CONTAINS A FILE THAT CAN BE OPENED (SAME AS IF OPEN/CLOSE WAS NOT PRESENT)
!!!    !
!!!    ! LLOC   is the starting location of the line to look for KEYWORD/NAME
!!!    ! LN     is the line to process the KEYWORDS/UNIT/NAME
!!!    ! IOUT   is where to write error messages too
!!!    ! IN     is the input file that LN originated from
!!!    ! NOSTOP optional, when present and is true will prevent the program from stopping if the file fails to open. ERROR will be set to TRUE
!!!    ! REQKEY optional, when present and is true indicates that a keyword is required to open file (viz. no reading a single number or just a file name)
!!!    ! IU     optional, when present is the unit number used when a file is opened by OPEN/CLOSE or by NAME
!!!    ! BUFFER optional, when present sets the buffer size in KB. --131072 = 128KB is the default and 1048576 = 1MB  --BUFFER USES TWO THREADS SO ACTUAL BUFFER IS TWICE THE VALUE (eg. 256KB)
!!!    ! 
!!!    CLASS(CYCLING_TEXT_FILE(*)),  INTENT(INOUT):: FL
!!!    INTEGER,                      INTENT(INOUT):: LLOC
!!!    CHARACTER(*),                 INTENT(IN   ):: LN
!!!    INTEGER,                      INTENT(IN   ):: IOUT, IN
!!!    LOGICAL,      OPTIONAL,       INTENT(IN   ):: NOSTOP
!!!    LOGICAL,      OPTIONAL,       INTENT(IN   ):: REQKEY
!!!    INTEGER,      OPTIONAL,       INTENT(IN   ):: IU
!!!    INTEGER,      OPTIONAL,       INTENT(IN   ):: BUFFER
!!!    CHARACTER(*), OPTIONAL,       INTENT(  OUT):: KEY  !SHOULD BE CHARACTER(10)
!!!    INTEGER,      OPTIONAL,       INTENT(INOUT):: DIM
!!!    INTEGER,      OPTIONAL,       INTENT(IN   ):: NVAL
!!!    CHARACTER(*), OPTIONAL,       INTENT(IN   ):: HED
!!!    LOGICAL:: ISOPEN, ALLOW_ERROR, NOREQKEY, DATAFILE, FOUND_KEY
!!!    CHARACTER(10):: EXT
!!!    CHARACTER(13):: FORM_CHK, ACC_CHCK
!!!    CHARACTER(:), ALLOCATABLE:: FNAME, ERR_MSG
!!!    INTEGER:: I, ISTART, ISTOP, IERR, BUF, IU_READ, SPLIT
!!!    !
!!!    IERR = Z
!!!    IU_READ = Z
!!!    FL%ERROR     = FALSE
!!!    FL%IS_OPEN   = FALSE
!!!    DATAFILE     = FALSE
!!!    FOUND_KEY    = FALSE
!!!    !
!!!    FL%REC = BLNK
!!!    !
!!!    FL%RPOS = ONE
!!!    FL%VPOS = ONE
!!!    FL%NVAL = Z
!!!    IF(PRESENT(NVAL)) FL%NVAL = NVAL
!!!    !
!!!    IF(ALLOCATED(FL%FNAME )) DEALLOCATE(FL%FNAME )
!!!    IF(ALLOCATED(FL%FMT   )) DEALLOCATE(FL%FMT   )
!!!    IF(ALLOCATED(FL%NSPACE)) DEALLOCATE(FL%NSPACE)
!!!    !
!!!    IF(FL%NVAL > Z) THEN
!!!        ALLOCATE(FL%FMT   (FL%NVAL))
!!!        ALLOCATE(FL%NSPACE(FL%NVAL), SOURCE=Z)
!!!    END IF
!!!    !
!!!    IF(FL%OPENCLOSE) CLOSE(FL%IU)
!!!    FL%OPENCLOSE = FALSE
!!!    !
!!!    FL%IOUT = IOUT
!!!    FL%IU = Z
!!!    !
!!!    ISOPEN = FALSE
!!!    IF(PRESENT(IU)) THEN
!!!        IF(IU.NE.Z) THEN
!!!                        INQUIRE(IU, OPENED=ISOPEN)
!!!                        IF(ISOPEN) FL%IU = IU
!!!        END IF
!!!    END IF
!!!    !
!!!    IF(PRESENT(NOSTOP)) THEN
!!!        ALLOW_ERROR = .NOT. NOSTOP
!!!    ELSE
!!!        ALLOW_ERROR = TRUE
!!!    END IF
!!!    !
!!!    IF(PRESENT(REQKEY)) THEN
!!!        NOREQKEY = .NOT. REQKEY
!!!    ELSE
!!!        NOREQKEY = TRUE
!!!    END IF
!!!    !
!!!    BUF = 16384 != 16KB x2 = 32KB  --1048576 = 1MB   --NOTE THAT TWO THREADS ARE USED PER BUFFER SO ACTUAL SPACE IS TWICE AS BIG
!!!    IF(PRESENT(BUFFER)) BUF = BUFFER
!!!    !
!!!    IF(ISOPEN) THEN
!!!        !
!!!        CALL STREAM_FILE_CHECK(FL, BUF, LN)
!!!        !
!!!        IF(FL%ERROR) THEN
!!!            FL%IU = Z
!!!        ELSE
!!!            REWIND(FL%IU)
!!!        END IF
!!!        !
!!!    ELSE!IF(.NOT. ISOPEN) THEN
!!!            CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
!!!            IF (NOREQKEY .AND. LN(ISTART:ISTOP).NE.BLNK) THEN
!!!                              READ(LN(ISTART:ISTOP),*,IOSTAT=IERR) IU_READ
!!!            ELSE
!!!                IERR=69
!!!            END IF
!!!            !
!!!            IF (IERR .EQ. Z) THEN
!!!                !
!!!                FL%IU = IU_READ 
!!!                CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,BUF,SPLIT,DIM=DIM)
!!!                !
!!!                IF (FL%IU == Z) THEN
!!!                    CALL CLOSE_CYCLING_TEXT_FILE(FL)
!!!                    CALL WARNING_MESSAGE(LN,IN,IOUT,MSG='GENERIC_OUTPUT_FILE_INSTRUCTION: SUCESSFULLY LOADED A UNIT NUMBER ON LINE,'//NL//'BUT THE UNIT NUMBER WAS ZERO, SO IT IS ASSUMED THAT NO OUTPUT IS MEANT TO BE WRITTEN.')
!!!                    IF(PRESENT(KEY)) KEY = 'NOKEY'
!!!                    RETURN
!!!                END IF
!!!                !
!!!                CALL STREAM_FILE_CHECK(FL, BUF, LN)
!!!            ELSE
!!!                IERR= Z
!!!                !
!!!                EXT = LN(ISTART:ISTOP)
!!!                CALL UPPER(EXT)
!!!                !
!!!                IF(EXT == 'BINARY') THEN
!!!                                        CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
!!!                                        EXT = LN(ISTART:ISTOP)
!!!                                        CALL UPPER(EXT)
!!!                END IF
!!!                !
!!!                IF    (EXT == 'NOPRINT' .OR. EXT == 'SKIP' .OR. EXT == 'NUL' .OR. EXT == 'NULL') THEN
!!!                                                 CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,BUF,SPLIT,DIM=DIM)
!!!                                                 CALL CLOSE_CYCLING_TEXT_FILE(FL)
!!!                                                 FL%IU = Z
!!!                                                 IF(PRESENT(KEY)) KEY = ADJUSTL(EXT)
!!!                                                 IF(PRESENT(DIM)) DIM = Z
!!!                                                 RETURN
!!!                ELSEIF(EXT == 'INTERNAL'.OR. EXT == 'LIST' .OR. EXT==BLNK) THEN  !WILL RAISE ERROR LATER
!!!                                                     FL%IU = IOUT
!!!                ELSEIF(EXT == 'EXTERNAL' .OR. EXT=='DATAUNIT') THEN
!!!                                                 CALL GET_INTEGER(LN,LLOC,ISTART,ISTOP,IOUT,IN,FL%IU,MSG='GENERIC_OUTPUT_FILE_INSTRUCTION ERROR: FROUND KEYWORD "'//TRIM(EXT)//'" WHICH SHOULD BE FOLLOWED BY AN INTEGER REPRESENTING THE UNIT NUMBER TO USE.')
!!!                                                 CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,BUF,SPLIT,DIM=DIM)
!!!                                                 FOUND_KEY=TRUE
!!!                                                 CALL STREAM_FILE_CHECK(FL, BUF, LN)
!!!                ELSE
!!!                      !
!!!                      IF (EXT == 'OPEN/CLOSE' .OR. EXT=='DATAFILE') THEN  ! OPEN/CLOSE KEYWORD
!!!                                                 DATAFILE = EXT=='DATAFILE'
!!!                                                 CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)   !MOVE TO NEXT WORD WHICH IS THE FILE NAME
!!!                                                 FL%OPENCLOSE = TRUE
!!!                                                 FOUND_KEY    = TRUE
!!!                      ELSEIF(NOREQKEY) THEN
!!!                                                 FL%OPENCLOSE = TRUE
!!!                      END IF
!!!                      !
!!!                      ALLOCATE( FNAME, SOURCE = LN(ISTART:ISTOP) )
!!!                      !
!!!                      CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,BUF,SPLIT,DIM=DIM)  !FL%BINARY IS ONLY SET TO TRUE IF BINARY FLAG FOUND, OTHERWISE IGNORED
!!!                      !
!!!                      INQUIRE(FILE=FNAME, NUMBER=I, OPENED=ISOPEN)
!!!                      !
!!!                      IF(ISOPEN .AND. PRESENT(IU)) THEN; IF (I.NE.IU) ISOPEN = FALSE
!!!                      END IF
!!!                      !
!!!                      IF( DATAFILE .AND. ISOPEN) THEN
!!!                                                 FL%IU = I
!!!                                                 CALL STREAM_FILE_CHECK(FL, BUF, LN)
!!!                      ELSEIF(FL%OPENCLOSE) THEN
!!!                                                 INQUIRE(FILE=FNAME,NUMBER=FL%IU,OPENED=ISOPEN)
!!!                                                 IF(ISOPEN) THEN
!!!                                                     CALL WARNING_MESSAGE(LN,IN,IOUT,MSG='GENERIC_OUTPUT FILE OPEN: OPEN/CLOSE FILE WITH FILENAME:'//NL//TRIM(FNAME)//NL//'HAS ALREADY BEEN OPENED/ASSOCIATED WITH A FORTRAN UNIT NUMBER.'//NL//'OUTPUT TO THIS FILE MAY CONTAIN INFORMATION FROM MULTIPLE SOURCES.'//NL//'(THIS IS JUST A WARNING AS YOU MAY BE INTENTIONALY DOING THIS.)')
!!!                                                     CALL STREAM_FILE_CHECK(FL, BUF, LN)
!!!                                                     FL%OPENCLOSE = FALSE
!!!                                                 ELSE
!!!                                                     FL%IU = Z
!!!                                                     IF(PRESENT(IU)) FL%IU = IU
!!!                                                     !
!!!                                                     CALL GENERIC_OPEN(FNAME, FL%IU, IOUT, ACTION='WRITE', FORM='UNFORMATTED', ACCESS='STREAM', STATUS='REPLACE', ASYNC='NO', BUFFER_BLOCKSIZE=BUF, BUFFER_COUNT=2, LINE=LN, INFILE=IN, ERROR=FL%ERROR)
!!!                                                     !
!!!                                                     IF     (FL%ERROR) THEN
!!!                                                                           FL%OPENCLOSE = FALSE
!!!                                                     ELSEIF (DATAFILE) THEN
!!!                                                                           FL%OPENCLOSE = FALSE
!!!                                                                           CALL DATAFILE_UNIT_NUMBER%ADD(FL%IU)
!!!                                                     END IF
!!!                                                 END IF
!!!                      ELSE
!!!                                                 FL%ERROR = TRUE  !DID NOT FIND OPEN/CLOSE KEYWORD AND REQKEY=TRUE
!!!                      END IF
!!!                END IF
!!!            END IF
!!!    END IF
!!!    !
!!!    IF((FL%IU == Z .OR. FL%IU == IOUT) .AND. .NOT. FL%ERROR) THEN
!!!            !
!!!            FL%ERROR = TRUE
!!!            !
!!!            IF(ALLOW_ERROR) THEN
!!!                  !
!!!                  IF( EXT=='INTERNAL') CALL FILE_IO_ERROR(Z,IN,LINE=LN,OUTPUT=IOUT,MSG='CYCLING_TEXT_FILE ERROR: FOUND KEYWORD "INTERNAL" BUT THIS OUTPUT DATA ITEM DOES NOT ALLOW FOR INTERNAL KEYWORD.'//BLN//'PLEASE WRITE OUTPUT TO SEPARATE FILE AND USE EITHER OPEN/CLOSE, DATAFILE, DATAUNIT, OR EXTERNAL.')
!!!                  IF( EXT=='LIST')     CALL FILE_IO_ERROR(Z,IN,LINE=LN,OUTPUT=IOUT,MSG='CYCLING_TEXT_FILE ERROR: FOUND KEYWORD "LIST" BUT THIS OUTPUT DATA ITEM DOES NOT ALLOW FOR INTERNAL KEYWORD.'//BLN//'PLEASE WRITE OUTPUT TO SEPARATE FILE AND USE EITHER OPEN/CLOSE, DATAFILE, DATAUNIT, OR EXTERNAL.')
!!!                  IF( FL%IU == Z .OR. EXT==BLNK) CALL FILE_IO_ERROR(Z,IN,LINE=LN,OUTPUT=IOUT,MSG='CYCLING_TEXT_FILE ERROR: THIS OUTPUT DATA ITEM DOES NOT ALLOW WRITING TO LIST FILE (NO KEYWORD FOUND, SO ASSUMING YOU MEANT THE LIST FILE).'//NL//'PLEASE WRITE OUTPUT TO SEPARATE FILE AND USE EITHER OPEN/CLOSE, DATAFILE, DATAUNIT, OR EXTERNAL.')
!!!            END IF
!!!    END IF
!!!    !
!!!    IF(.NOT. FL%ERROR) THEN
!!!                           IF( FL%IU .NE. Z) THEN
!!!                                                 INQUIRE(FL%IU, OPENED=ISOPEN) 
!!!                           ELSE
!!!                                                 ISOPEN = FALSE
!!!                           END IF
!!!                           !
!!!                           IF(.NOT. ISOPEN) FL%ERROR =TRUE !FILE IS NOT INTERNAL, NOR UNIT WAS ASSOCIATED WITH A FILE, NOR WAS IT SUCCESFULLY OPENED.
!!!    END IF
!!!    !
!!!    IF (FL%ERROR .AND. ALLOW_ERROR) THEN
!!!        IF(EXT == 'INTERNAL'.OR. EXT == 'LIST' .OR. EXT==BLNK) THEN
!!!            IF(EXT == 'INTERNAL') THEN
!!!                ERR_MSG = NL//'FOUND KEYWORD "INTERNAL",'
!!!            ELSEIF( EXT == 'LIST') THEN
!!!                ERR_MSG = NL//'FOUND KEYWORD "LIST",'
!!!            ELSE
!!!                ERR_MSG = NL//'NO KEYWORD FOUND, ASSUMING THAT OUTPUT IS WRITTEN TO LIST.'
!!!            END IF
!!!            ERR_MSG = ERR_MSG//NL//'HOWEVER THE LIST FILE UNIT WAS NOT PASSED TO SUBROUTINE. THIS INDICATES THAT LIST WRITING IS NOT SUPPORTED FOR THIS OneWater OUTPUT OPTION.'//NL//'PLEASE CHOSE A DIFFERENT OUTPUT LOCATION (eg OPEN/CLOSE OR EXTERNAL).'
!!!        ELSEIF(ALLOCATED(FNAME)) THEN
!!!            IF(EXT == 'OPEN/CLOSE') THEN
!!!                ERR_MSG = NL//'FOUND KEYWORD "OPEN/CLOSE",'
!!!            ELSEIF( EXT == 'DATAFILE') THEN
!!!                ERR_MSG = NL//'FOUND KEYWORD "DATAFILE",'
!!!            ELSE
!!!                ERR_MSG = NL//'NO KEYWORD FOUND, ASSUMING FILE NAME IS JUST SPECIFIED ON CURRENT LINE,'
!!!            END IF
!!!            ERR_MSG = ERR_MSG//NL//'BUT FAILED TO OPEN THE FOLLOWING FILE FOR WRITING:'//BLN//'"'//FNAME//'"'//BLN//'PLEASE CHECK TO SEE IF THE PATH AND FILE NAME CORRECT.'//BLN//' ***NOTE THAT THE "/" WORKS FOR BOTH WINDOWS AND LINUX,' //NL//'    BUT THE "\" ONLY WORKS ON WINDOWS.'
!!!        ELSE
!!!            IF(EXT == 'EXTERNAL') THEN
!!!                ERR_MSG = NL//'FOUND KEYWORD "EXTERNAL",'
!!!            ELSEIF( EXT == 'DATAUNIT') THEN
!!!                ERR_MSG = NL//'FOUND KEYWORD "DATAUNIT",'
!!!            ELSE
!!!                ERR_MSG = NL//'NO KEYWORD FOUND AND A UNIT NUMBER WAS SUCCESSFULLY READ,'//NL//'SO IT WAS ASSUMED TO BE A UNIT SPECIFIED IN THE NAME FILE OR ALREADY OPEN,'
!!!            END IF
!!!            ERR_MSG = ERR_MSG//NL//'BUT UNIT NUMBER WAS NOT ASSOCIATED WITH ANY FILE (NOT OPEN) FOR WRITING.'//NL//'THIS PROBABLY IS BECAUSE IT WAS NOT SPECIFIED IN THE NAME FILE,'//NL//'FILE WAS CLOSED AT SOME POINT,'//NL//'OR EVEN NEVER SUCESSFULLY OPENED.'//BLN//'THE FOLLOWING IS THE UNIT NUMBER SEARCHED FOR: "'//NUM2STR(FL%IU)//'"'//BLN//'PLEASE CHECK TO SEE IF UNIT IS SPECIFIED IN THE NAME FILE WITH DATA OR DATA(BINARY) KEYWORDS.'
!!!        END IF
!!!        !
!!!        ERR_MSG = 'FAILED TO OPEN FILE WITH GENERIC_OUTPUT_FILE_INSTRUCTION.'//BLN//ERR_MSG
!!!        CALL FILE_IO_ERROR(IERR,IN,LINE=LN,OUTPUT=IOUT,MSG=ERR_MSG)
!!!    END IF
!!!    IF (FL%ERROR) FL%IU = Z
!!!    !
!!!    IF(PRESENT(KEY)) THEN
!!!          IF(FOUND_KEY) THEN
!!!                             KEY = ADJUSTL(EXT)
!!!          ELSE
!!!                             KEY = 'NOKEY'
!!!          END IF
!!!    END IF
!!!    !
!!!    FL%IS_OPEN = FL%IU.NE.Z
!!!    !
!!!    IF(FL%IS_OPEN) REWIND(FL%IU)
!!!    !
!!!    IF(PRESENT(HED)) CALL CYCLING_TEXT_FILE_SET_HEADER(FL, HED)
!!!    !
!!!    END SUBROUTINE
!!!    !
!!!  SUBROUTINE STREAM_FILE_CHECK(FL, BUF, LINE)
!!!    CLASS(CYCLING_TEXT_FILE(*)),  INTENT(INOUT):: FL
!!!    INTEGER:: BUF, IN
!!!    CHARACTER(*), INTENT(IN):: LINE
!!!    CHARACTER(13):: FORM_CHK, ACC_CHCK
!!!    !
!!!    INQUIRE(FL%IU, FORM=FORM_CHK, ACCESS=ACC_CHCK)
!!!    !
!!!    IF( (FORM_CHK == 'UNFORMATTED' .OR. FORM_CHK == 'BINARY') .AND. ACC_CHCK == 'STREAM' ) THEN
!!!        !
!!!        IF(.NOT. ALLOCATED(FL%FNAME)) CALL GET_FILE_NAME(FL%IU,FL%FNAME,IOUT=FL%IOUT,IN=FL%IN, MSG='CYCLING_TEXT_FILE_INTERFACE ERROR: UNKNOWN ERROR WHILE TRYING TO INDENTIFY THE FILE NAME.', LINE=LINE)
!!!        CALL FORCE_UNIT_CLOSE(FL%IU)
!!!        CALL GENERIC_OPEN(FL%FNAME, FL%IU, FL%IOUT, ACTION='WRITE', FORM='UNFORMATTED', ACCESS='STREAM', STATUS='REPLACE', ASYNC='NO', BUFFER_BLOCKSIZE=BUF, BUFFER_COUNT=2, LINE=LINE, INFILE=FL%IN, ERROR=FL%ERROR)
!!!    END IF
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  SUBROUTINE CYCLING_TEXT_FILE_SET_HEADER(FL, HEADER, NOWRITE)
!!!    CLASS(CYCLING_TEXT_FILE(*)), INTENT(INOUT):: FL
!!!    CHARACTER(*),             INTENT(IN   ):: HEADER
!!!    LOGICAL,     OPTIONAL,    INTENT(IN   ):: NOWRITE
!!!    LOGICAL:: WRITE_HED
!!!    !
!!!    IF(ALLOCATED(FL%HED)) DEALLOCATE(FL%HED)
!!!                            ALLOCATE(FL%HED, SOURCE=HEADER//NL)
!!!    !
!!!    WRITE_HED = TRUE
!!!    IF(PRESENT(NOWRITE)) WRITE_HED = .NOT. NOWRITE
!!!    !
!!!    IF(WRITE_HED .AND. FL%IU.NE.Z) THEN
!!!        REWIND(FL%IU)
!!!        WRITE(FL%IU) FL%HED
!!!    END IF
!!!    !
!!!    FL%HEDLEN = LEN(FL%HED)
!!!    !
!!!    FL%VPOS = ONE
!!!    FL%RPOS = ONE
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  SUBROUTINE BACKSPACE_TEXT_FILE(FL, NLINE)
!!!    CLASS(CYCLING_TEXT_FILE(*)), INTENT(INOUT):: FL
!!!    INTEGER,     OPTIONAL,    INTENT(IN   ):: NLINE
!!!    INTEGER:: N, P
!!!    !
!!!    P = Z
!!!    !
!!!    IF(FL%IU.NE.Z) THEN
!!!       N = ONE
!!!       IF(PRESENT(NLINE)) N = NLINE
!!!       !
!!!       N = N * (FL%RECLEN+ONE)
!!!       !
!!!       INQUIRE(FL%IU, POS=P)
!!!       !
!!!       IF(P - N > FL%HEDLEN ) THEN
!!!           P = P - N
!!!           WRITE(FL%IU,POS=P)
!!!       ELSE
!!!           CALL REWIND_CYCLING_TEXT_FILE(FL)
!!!       END IF
!!!    END IF
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  SUBROUTINE NEXTLINE_TEXT_FILE(FL, NLINE)
!!!    CLASS(CYCLING_TEXT_FILE(*)), INTENT(INOUT):: FL
!!!    INTEGER,     OPTIONAL,    INTENT(IN   ):: NLINE
!!!    INTEGER:: N, P
!!!    !
!!!    P = Z
!!!    !
!!!    IF(FL%IU.NE.Z) THEN
!!!       N = ONE
!!!       IF(PRESENT(NLINE)) N = NLINE
!!!       !
!!!       N = N * (FL%RECLEN+ONE)
!!!       !
!!!       INQUIRE(FL%IU, POS=P)
!!!       !
!!!       P = P + N - 1
!!!       WRITE(FL%IU,POS=P)
!!!    END IF
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  IMPURE ELEMENTAL SUBROUTINE SET_FILE_NAME_CYCLING_TEXT_FILE(FL)
!!!    CLASS(CYCLING_TEXT_FILE(*)), INTENT(INOUT):: FL
!!!    LOGICAL:: EXIST
!!!    !
!!!    IF(FL%IU.NE.Z) THEN
!!!        IF(.NOT. ALLOCATED(FL%FNAME)) THEN
!!!              CALL GET_FILE_NAME(FL%IU,FL%FNAME,EXIST,FL%IOUT,FL%IN,MSG='CYCLING_TEXT_FILE_INTERFACE ERROR: FROUND KEYWORD "EXTERNAL" OR "DATAUNIT", BUT FAILED TO IDENTIFY THE FILE (IN PARTICULAR ITS NAME) THAT IS ASSOCAITED WITH IT.')
!!!        END IF
!!!    ELSEIF(ALLOCATED(FL%FNAME)) THEN
!!!        DEALLOCATE(FL%FNAME)
!!!    END IF
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  SUBROUTINE CLOSE_CYCLING_TEXT_FILE(FL)
!!!    CLASS(CYCLING_TEXT_FILE(*)), INTENT(INOUT):: FL
!!!    !
!!!    IF(FL%OPENCLOSE) CLOSE(FL%IU)
!!!    IF(ALLOCATED(FL%FNAME)) DEALLOCATE(FL%FNAME)
!!!    !
!!!    FL%IU  = Z
!!!    FL%OPENCLOSE = FALSE
!!!    FL%IS_OPEN   = FALSE
!!!    !
!!!    FL%NVAL = Z
!!!    FL%VPOS = ONE
!!!    FL%RPOS = ONE
!!!    IF(ALLOCATED(FL%FMT)) DEALLOCATE(FL%FMT)
!!!    !
!!!    IF(ALLOCATED(FL%NSPACE)) DEALLOCATE(FL%NSPACE)
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  SUBROUTINE FINAL_CLOSE_CYCLING_TEXT_FILE(FL)
!!!    TYPE( CYCLING_TEXT_FILE(*) ), INTENT(INOUT):: FL
!!!    !
!!!    CALL CLOSE_CYCLING_TEXT_FILE(FL)
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!END MODULE
!
!!
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
!
MODULE  WARNING_TYPE_INSTRUCTION!, ONLY: WARNING_TYPE
  !
  USE CONSTANTS,        ONLY: TRUE, FALSE, NL, Z, ONE, TWO, QUIN
  USE UTIL_INTERFACE,   ONLY: WARNING_MESSAGE, STOP_ERROR
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: WARNING_TYPE, WARNING_TYPE_DEPOINT    ! XX_DEPOINT only necessary as workaround for gfortran compiler error
  !
  TYPE:: WARNING_TYPE
      LOGICAL:: RAISED  = FALSE
      INTEGER:: MAX_ADD = QUIN                    !Note limit of 500 message adds
      INTEGER:: CNT     = Z
      !
      CHARACTER(:), ALLOCATABLE::STR
      CONTAINS
      PROCEDURE, PASS(WRN):: INIT  => INITIALIZE_WARNING_TYPE !([SET_STR], [MAX])
      PROCEDURE, PASS(WRN):: ADD   => ADD_WARNING_MESSAGE     !(LINE)
      PROCEDURE, PASS(WRN):: CHECK => CHECK_IF_RAISE_WARNING  !(HED, INFILE, OUTPUT, INLINE, CMD_PRINT, KILL, TAIL, NO_NL, INIT, SET_STR)  <-- all optional
      FINAL:: FINAL_WARNING_TYPE
  END TYPE
  !
  CONTAINS
  !
  ELEMENTAL PURE SUBROUTINE INITIALIZE_WARNING_TYPE(WRN, SET_STR, MAX)
    CLASS(WARNING_TYPE),    INTENT(INOUT):: WRN
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: SET_STR
    INTEGER,      OPTIONAL, INTENT(IN   ):: MAX
    !
    WRN%CNT = Z
    !
    WRN%RAISED=FALSE
    !
    IF(ALLOCATED(WRN%STR)) DEALLOCATE(WRN%STR)
    !
    IF(PRESENT(SET_STR)) THEN;  ALLOCATE(WRN%STR, SOURCE=SET_STR)
    ELSE;                       ALLOCATE(WRN%STR, SOURCE=NL     )
    END IF
    !
    IF(PRESENT(MAX)) THEN
        WRN%MAX_ADD = MAX
    ELSE
        WRN%MAX_ADD = QUIN
    END IF
    !
    WRN%CNT = Z
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE ADD_WARNING_MESSAGE(WRN,LINE)
    CLASS(WARNING_TYPE),   INTENT(INOUT):: WRN
    CHARACTER(*),          INTENT(IN   ):: LINE
    !
    WRN%RAISED=TRUE
    !
    WRN%CNT = WRN%CNT + ONE
    !
    IF(WRN%CNT <= WRN%MAX_ADD .AND. LEN(WRN%STR) < 50000)  THEN
        IF(ALLOCATED(WRN%STR)) THEN
                                   WRN%STR = WRN%STR//LINE
        ELSE
                          ALLOCATE(WRN%STR, SOURCE=LINE)
        END IF
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE CHECK_IF_RAISE_WARNING(WRN, HED, INFILE, OUTPUT, INLINE, CMD_PRINT, KILL, TAIL, NO_NL, INIT, SET_STR)
    CLASS(WARNING_TYPE),    INTENT(INOUT):: WRN
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: HED
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: TAIL
    INTEGER, OPTIONAL,      INTENT(IN   ):: OUTPUT
    INTEGER, OPTIONAL,      INTENT(IN   ):: INFILE
    LOGICAL, OPTIONAL,      INTENT(IN   ):: INLINE       !IF TRUE, WARNING IS  WRITTEN TO ONE LINE
    LOGICAL, OPTIONAL,      INTENT(IN   ):: CMD_PRINT    !IF TRUE, WARNING IS  WRITTEN TO CMD PROMPT
    LOGICAL, OPTIONAL,      INTENT(IN   ):: KILL         !IF TRUE, WARNING IS CANGED TO STOP PROGRAM
    LOGICAL, OPTIONAL,      INTENT(IN   ):: NO_NL        !IF TRUE, THE NL AT THE START OF THE WARNING STRING IS REMOVED.
    LOGICAL, OPTIONAL,      INTENT(IN   ):: INIT
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: SET_STR
    LOGICAL:: KILL_PROG
    INTEGER:: MAX, I
    !
    IF(WRN%RAISED)  THEN
         !
         KILL_PROG = FALSE
         IF(PRESENT(KILL)) KILL_PROG = KILL
         !
         MAX = WRN%MAX_ADD
         !
         IF(WRN%CNT > WRN%MAX_ADD .OR. LEN(WRN%STR) >= 50000)  THEN
             WRN%STR = WRN%STR//NL//'   ***Note that warning message was truncated do to excessive length***'//NL
         END IF
         !
         I = ONE
         IF(PRESENT(NO_NL)) THEN
             IF(NO_NL .AND. WRN%STR(ONE:ONE)==NL .AND. LEN(WRN%STR) > ONE) I = TWO
         END IF
         !
         IF(PRESENT(HED) .AND. PRESENT(TAIL)) THEN
             IF(KILL_PROG) THEN
                                CALL STOP_ERROR(INFILE=INFILE,OUTPUT=OUTPUT,MSG=HED//NL//WRN%STR(I:)//TAIL)
             ELSE
                                CALL WARNING_MESSAGE(INFILE=INFILE,OUTPUT=OUTPUT,MSG=HED//NL//WRN%STR(I:)//TAIL, INLINE=INLINE, CMD_PRINT=CMD_PRINT)
             END IF
         ELSEIF(PRESENT(HED)) THEN
             IF(KILL_PROG) THEN
                                CALL STOP_ERROR(INFILE=INFILE,OUTPUT=OUTPUT,MSG=HED//NL//WRN%STR(I:)//NL)
             ELSE
                                CALL WARNING_MESSAGE(INFILE=INFILE,OUTPUT=OUTPUT,MSG=HED//NL//WRN%STR(I:), INLINE=INLINE, CMD_PRINT=CMD_PRINT)
             END IF
         ELSEIF(PRESENT(TAIL)) THEN
             IF(KILL_PROG) THEN
                                CALL STOP_ERROR(INFILE=INFILE,OUTPUT=OUTPUT,MSG=WRN%STR(I:)//TAIL)
             ELSE
                                   CALL WARNING_MESSAGE(INFILE=INFILE,OUTPUT=OUTPUT,MSG=WRN%STR(I:)//TAIL, INLINE=INLINE, CMD_PRINT=CMD_PRINT)
             END IF
         ELSE
             IF(KILL_PROG) THEN
                                CALL STOP_ERROR(INFILE=INFILE,OUTPUT=OUTPUT,MSG=WRN%STR(I:))
             ELSE
                                   CALL WARNING_MESSAGE(INFILE=INFILE,OUTPUT=OUTPUT,MSG=WRN%STR(I:), INLINE=INLINE, CMD_PRINT=CMD_PRINT)
             END IF
         END IF
         !
         IF    (PRESENT(SET_STR)) THEN
                                       CALL INITIALIZE_WARNING_TYPE(WRN,SET_STR,MAX)
         ELSEIF(PRESENT(INIT   )) THEN 
                              IF(INIT) CALL INITIALIZE_WARNING_TYPE(WRN,SET_STR,MAX)
         END IF
         !
    END IF
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE FINAL_WARNING_TYPE(WRN)
    TYPE(WARNING_TYPE), INTENT(INOUT):: WRN
    !
    !!!WRN%RAISED  = FALSE  -- unnessary cause its not used again
    !!!WRN%MAX_ADD = QUIN 
    !!!WRN%CNT     = Z
    !
    IF(ALLOCATED(WRN%STR)) DEALLOCATE(WRN%STR)
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE WARNING_TYPE_DEPOINT(WRN)
    TYPE(WARNING_TYPE),POINTER,INTENT(INOUT):: WRN
    INTEGER:: I
    !
    DEALLOCATE(WRN, STAT=I)
    NULLIFY(WRN)
    !
  END SUBROUTINE
  !
END MODULE
!!
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
!
!   GENERIC_BLOCK_READER_INSTRUCTION
!                           DATA TYPE
!                                    GENERIC_BLOCK_READER
!                           SUBROUTINES
!                                    BL%LOAD                --LOADS BLOCK INTO A LINKED LIST OF LINES, REMOVES ALL COMMENTS
!                                    BL%MAKE_SCRATCH_FILE   --DUMPS BLOCK TO SCRATCH FILE SO THAT TOOLS THAT REQUIRE FILE INPUT CAN LOAD IT.!
!
!
!                FILE_INCREMENTER_INTERFACE
!                           DATA TYPE
!                                    FILE_INCREMENTER
!                           SUBROUTINES
!                                    FI%INIT
!                                    FI%SIZE_CHECK --NOTE THIS MAY CHANGE FI%IU --DUE TO COMPILER BUG
!                                    FI%SET_HEADER
!                                    FI%MOVE
!       
!   GENERIC_INPUT_FILE_INSTRUCTION
!                           DATA TYPE
!                                    GENERIC_INPUT_FILE
!                           SUBROUTINES
!                                    FL%OPEN   
!                                    FL%READ   
!                                    FL%REWIND 
!                                    FL%MOVE   
!                                    FL%CLOSE
!                                    FL%COUNT_LINES
!       
!   GENERIC_OUTPUT_FILE_INSTRUCTION
!                           DATA TYPE
!                                    GENERIC_OUTPUT_FILE
!                           SUBROUTINES
!                                    FL%OPEN      
!                                    FL%SET_HEADER
!                                    FL%SIZE_CHECK --NOTE THIS MAY CHANGE FI%IU --DUE TO COMPILER BUG
!                                    FL%MOVE      
!                                    FL%CLOSE     
!                                    FL%WRITE     
!    
!
MODULE FILE_INCREMENTER_INTERFACE!, ONLY: FILE_INCREMENTER
  USE UTIL_INTERFACE, ONLY: GET_WARN
  USE CONSTANTS,      ONLY: BLNK,NL,TAB,COM,Z,ONE,TWO,TEN,DZ,UNO,DOS,DIEZ,TRUE,FALSE
  USE GENERIC_OPEN_INTERFACE
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: FILE_INCREMENTER
  !  
  TYPE FILE_INCREMENTER
      CHARACTER(:),ALLOCATABLE:: FILE           !FILE BASENAME
      CHARACTER(:),ALLOCATABLE:: EXT            !FILE EXTENSION
      CHARACTER(:),ALLOCATABLE:: HED            !FILE HEADER PLACED ON FIRST LINE
      INTEGER:: NUM                             !COUNTER FOR THE FILE NUMBER TO ADD TO END OF FILENAME
      INTEGER:: MAXSIZE                         !MAXIMUM FILE SIZE IN KB, FOR RUTINE INIT IT ARRIVES IN MB AND CONVERTED TO KB
      !INTEGER:: LINECOUNT, MAXCOUNT
      INTEGER:: IU                              !FILE UNIT NUMBER
      INTEGER:: BUF                             !IF >0 THEN BUFFER FILE OUTPUT. THIS MAY MAKE SPLIT A BIT MORE INACCURATE, BUT FASTER WRITE.
      INTEGER:: COUNTER  = Z                    ! KEEPS TRACK OF WHEN SIZE CHECK IS MADE
      INTEGER:: MAXCOUNT = TEN                  ! WHEN COUNTER REACHES THIS VALUE IT DOES AN ACTUAL SIZE CHECK
      CHARACTER(15):: FORM                      !BINARY, UNFORMATTED, FORMATTED
      CHARACTER(10):: ACCESS
      LOGICAL:: BINARY
      LOGICAL:: OPENCLOSE
      !
    CONTAINS
      !NOTE THAT PASSED IN MAXSIZE IS IN MB, BUT INTERNALLY USED AS KB
      GENERIC:: INIT                      => INITIALIZE_FILE_INCREMENTER_UNIT_FILE, INITIALIZE_FILE_INCREMENTER_FILE, INITIALIZE_FILE_INCREMENTER_UNIT !(MAXSIZE, [FILE], [UNIT], [BUFFER])  --BUFFER REQUIRED FOR BOTH
      PROCEDURE, PASS(FI):: SIZE_CHECK    => FILE_INCREMENTER_SIZE_CHECK !([LINE])  --NOTE THIS CHANGES FI%IU DUE TO COMPILER BUG
      PROCEDURE, PASS(FI):: SET_HEADER    => FILE_INCREMENTER_SET_HEADER !(HEADER, [NOWRITE])
      PROCEDURE, PASS(FI):: MOVE          => MOVE_FILE_INCREMENTER_FILE  !(FI_NEW)
      PROCEDURE, PASS(FI):: DESTROY       => DEALLOCATE_FILE_INCREMENTER !()
      GENERIC            :: ASSIGNMENT(=) => COPY_FILE_INCREMENTER_FILE
      !
      !PROCEDURE, PASS(FI),PRIVATE:: INITIALIZE_FILE_INCREMENTER
      PROCEDURE, PASS(FI),PRIVATE:: INITIALIZE_FILE_INCREMENTER_FILE
      PROCEDURE, PASS(FI),PRIVATE:: INITIALIZE_FILE_INCREMENTER_UNIT
      PROCEDURE, PASS(FI),PRIVATE:: INITIALIZE_FILE_INCREMENTER_UNIT_FILE
      PROCEDURE,          PRIVATE:: COPY_FILE_INCREMENTER_FILE
      !PROCEDURE, PASS(FI),PRIVATE:: INITIALIZE_FILE_INCREMENTER_BOTH
      !
      FINAL::                       FINAL_DEALLOCATE_FILE_INCREMENTER
    END TYPE
      
    CONTAINS
    !
  SUBROUTINE COPY_FILE_INCREMENTER_FILE(FI_OUT, FI_IN)
    CLASS(FILE_INCREMENTER), INTENT(OUT):: FI_OUT
    CLASS(FILE_INCREMENTER), INTENT(IN ):: FI_IN
    !
    CALL DEALLOCATE_FILE_INCREMENTER(FI_OUT)
    !
    IF(ALLOCATED(FI_IN%FILE)) ALLOCATE(FI_OUT%FILE, SOURCE = FI_IN%FILE)
    IF(ALLOCATED(FI_IN%EXT )) ALLOCATE(FI_OUT%EXT , SOURCE = FI_IN%EXT )
    IF(ALLOCATED(FI_IN%HED )) ALLOCATE(FI_OUT%HED , SOURCE = FI_IN%HED )
    !
    FI_OUT%NUM       = FI_IN%NUM                
    FI_OUT%MAXSIZE   = FI_IN%MAXSIZE       
    FI_OUT%IU        = FI_IN%IU                  
    FI_OUT%BUF       = FI_IN%BUF                 
    FI_OUT%FORM      = FI_IN%FORM          
    FI_OUT%ACCESS    = FI_IN%ACCESS
    FI_OUT%OPENCLOSE = FI_IN%OPENCLOSE 
    FI_OUT%COUNTER   = FI_IN%COUNTER
    FI_OUT%MAXCOUNT  = FI_IN%MAXCOUNT
    !
  END SUBROUTINE
    !
  SUBROUTINE MOVE_FILE_INCREMENTER_FILE(FI, FI_NEW)
    CLASS(FILE_INCREMENTER), INTENT(INOUT):: FI, FI_NEW
    !
    CALL DEALLOCATE_FILE_INCREMENTER(FI_NEW)
    !
    IF(ALLOCATED(FI%FILE)) CALL MOVE_ALLOC(FI%FILE, FI_NEW%FILE)
    IF(ALLOCATED(FI%EXT )) CALL MOVE_ALLOC(FI%EXT , FI_NEW%EXT )
    IF(ALLOCATED(FI%HED )) CALL MOVE_ALLOC(FI%HED , FI_NEW%HED )
    !
    FI_NEW%NUM       = FI%NUM                
    FI_NEW%MAXSIZE   = FI%MAXSIZE       
    FI_NEW%IU        = FI%IU                  
    FI_NEW%BUF       = FI%BUF                 
    FI_NEW%FORM      = FI%FORM          
    FI_NEW%ACCESS    = FI%ACCESS
    FI_NEW%OPENCLOSE = FI%OPENCLOSE
    FI_NEW%COUNTER    = FI%COUNTER 
    FI_NEW%MAXCOUNT   = FI%MAXCOUNT
    !
    FI%OPENCLOSE = FALSE
    !
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_FILE_INCREMENTER_FILE(FI, MAXSIZE, FILE, BUFFER, MAXCOUNT)
    CLASS(FILE_INCREMENTER), INTENT(INOUT):: FI
    INTEGER,     INTENT(IN):: MAXSIZE
    CHARACTER(*),INTENT(IN):: FILE
    INTEGER,     INTENT(IN), OPTIONAL:: BUFFER
    INTEGER,     INTENT(IN), OPTIONAL:: MAXCOUNT
    INTEGER:: BUF, MXCNT
    IF(PRESENT(BUFFER)) THEN
                            BUF = BUFFER
    ELSE
                            BUF = Z
    END IF
    IF(PRESENT(MAXCOUNT)) THEN
                            MXCNT = MAXCOUNT
    ELSE
                            MXCNT = 10
    END IF
    !
    CALL INITIALIZE_FILE_INCREMENTER(FI, MAXSIZE, FILE=FILE, BUFFER=BUF, MAXCOUNT=MXCNT)
    !
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_FILE_INCREMENTER_UNIT(FI, MAXSIZE, UNIT, BUFFER, MAXCOUNT)
    CLASS(FILE_INCREMENTER), INTENT(INOUT):: FI
    INTEGER,     INTENT(IN):: MAXSIZE
    INTEGER,     INTENT(IN):: UNIT
    INTEGER,     INTENT(IN), OPTIONAL:: BUFFER
    INTEGER,     INTENT(IN), OPTIONAL:: MAXCOUNT
    INTEGER:: BUF, MXCNT
    IF(PRESENT(BUFFER)) THEN
                            BUF = BUFFER
    ELSE
                            BUF = Z
    END IF
    IF(PRESENT(MAXCOUNT)) THEN
                            MXCNT = MAXCOUNT
    ELSE
                            MXCNT = 10
    END IF
    !
    CALL INITIALIZE_FILE_INCREMENTER(FI, MAXSIZE, UNIT=UNIT, BUFFER=BUF, MAXCOUNT=MXCNT)
    !
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_FILE_INCREMENTER_UNIT_FILE(FI, MAXSIZE, UNIT, FILE,  BUFFER, MAXCOUNT)
    CLASS(FILE_INCREMENTER), INTENT(INOUT):: FI
    INTEGER,     INTENT(IN):: MAXSIZE
    INTEGER,     INTENT(IN):: UNIT
    CHARACTER(*),INTENT(IN):: FILE
    INTEGER,     INTENT(IN), OPTIONAL:: BUFFER
    INTEGER,     INTENT(IN), OPTIONAL:: MAXCOUNT
    INTEGER:: BUF, MXCNT
    IF(PRESENT(BUFFER)) THEN
                            BUF = BUFFER
    ELSE
                            BUF = Z
    END IF
    IF(PRESENT(MAXCOUNT)) THEN
                            MXCNT = MAXCOUNT
    ELSE
                            MXCNT = 10
    END IF
    !
    IF (UNIT.NE.Z)  THEN
        CALL INITIALIZE_FILE_INCREMENTER(FI, MAXSIZE, FILE, UNIT, BUFFER=BUF, MAXCOUNT=MXCNT)
    ELSE
        CALL INITIALIZE_FILE_INCREMENTER(FI, MAXSIZE, FILE=FILE, BUFFER=BUF, MAXCOUNT=MXCNT)
    END IF
    !
  END SUBROUTINE
  !
  !SUBROUTINE INITIALIZE_FILE_INCREMENTER_BOTH(FI, MAXSIZE, FILE, UNIT, BUFFER)
  !  CLASS(FILE_INCREMENTER), INTENT(INOUT):: FI
  !  INTEGER,     INTENT(IN):: MAXSIZE
  !  CHARACTER(*),INTENT(IN):: FILE
  !  INTEGER,     INTENT(IN):: UNIT
  !  INTEGER,     INTENT(IN):: BUFFER
  !  !
  !  CALL INITIALIZE_FILE_INCREMENTER(FI, MAXSIZE, FILE=FILE, UNIT=UNIT, BUFFER=BUFFER)
  !END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_FILE_INCREMENTER(FI, MAXSIZE, FILE, UNIT, BUFFER, MAXCOUNT)
    CLASS(FILE_INCREMENTER), INTENT(INOUT):: FI
    INTEGER,     INTENT(IN):: MAXSIZE               !MAX FILE SIZE IN MB
    CHARACTER(*),INTENT(IN), OPTIONAL:: FILE
    INTEGER,     INTENT(IN), OPTIONAL:: UNIT
    INTEGER,     INTENT(IN):: BUFFER
    INTEGER,     INTENT(IN):: MAXCOUNT
    LOGICAL:: CHECK
    !
    INTEGER:: I, IU
    CHARACTER(:), ALLOCATABLE:: FNAME, FNAME_LONG
    CHARACTER(4):: NUM 
    !
    IF(PRESENT(FILE)) THEN
        CHECK = FILE.NE.BLNK
    ELSE
        CHECK=FALSE
    END IF
    !
    FI%BUF = BUFFER
    FI%COUNTER  = Z 
    FI%MAXCOUNT = MAXCOUNT
    !
    FI%OPENCLOSE=FALSE
    !
    IF(CHECK) THEN  !FILE PRESENT AND NON-EMPTY
        I=INDEX(FILE,'.',TRUE)
        IF(I>Z) THEN          
          ALLOCATE(FI%FILE, SOURCE=FILE(:I-1))
          ALLOCATE(FI%EXT, SOURCE=FILE(  I:))
        ELSE
          ALLOCATE(FI%FILE, SOURCE=FILE)
          ALLOCATE(FI%EXT, SOURCE='')
        END IF
        !
        !IF(PRESENT(UNIT)) THEN
        !    FI%IU=UNIT
        !    !
        !    INQUIRE(UNIT, OPENED=CHECK)
        !    IF(.NOT. CHECK) THEN
        !        OPEN(UNIT=FI%IU, FILE=FILE, ACTION='WRITE', STATUS='REPLACE', POSITION='REWIND', IOSTAT=I)
        !        IF(I.NE.0) CALL FILE_IO_ERROR(I, FNAME=FILE, UNIT=FI%IU)
        !    END IF
        !ELSE      
        !    OPEN(NEWUNIT=FI%IU,  FILE=FILE, ACTION='WRITE', STATUS='REPLACE', POSITION='REWIND', IOSTAT=I)
        !    IF(I.NE.0) CALL FILE_IO_ERROR(I, FNAME=FILE, UNIT=FI%IU)
        !END IF
        IF(PRESENT(UNIT)) THEN
            INQUIRE(UNIT, OPENED=CHECK)
            FI%IU=UNIT
        ELSE
            CHECK=FALSE
            FI%IU=Z
        END IF
        IF (.NOT. CHECK) THEN
            FI%OPENCLOSE=TRUE
            CALL GENERIC_OPEN(FILE, FI%IU, Z, ACTION='WRITE', FORM='FORMATTED', ACCESS='SEQUENTIAL', STATUS='REPLACE', BUFFER_BLOCKSIZE=FI%BUF, ASYNC='NO')   !, WARN=GET_WARN()
        END IF
        !
    ELSEIF(PRESENT(UNIT)) THEN
        FI%IU=UNIT
        ALLOCATE(CHARACTER(1000)::FNAME_LONG)
        !
        INQUIRE(UNIT, OPENED=CHECK, NAME=FNAME_LONG)
        IF(.NOT. CHECK)  WRITE(*,'(A)')'PROGRAMMING ERROR: A UNIT NUMBER WAS PASSED INTO SUBROUTINE INITIALIZE_FILE_INCREMENTER() BUT IT HAS NOT BEEN OPENED WITH A FILE NOR WAS A FILE NAME PASSED INTO THE SUBROUTINE TO ALLOW OPENING OF A FILE FOR THAT GIVEN UNIT NUMBER.'
        !CALL FILE_IO_ERROR(-1, UNIT=UNIT)
        !
        ALLOCATE(  FNAME, SOURCE=TRIM(FNAME_LONG))
        DEALLOCATE(FNAME_LONG)
        !
        I=INDEX(FNAME,'.',TRUE)
        IF(I>Z) THEN          
          ALLOCATE(FI%FILE, SOURCE=FNAME(:I-1))
          ALLOCATE(FI%EXT,  SOURCE=FNAME( I:))
        ELSE
          ALLOCATE(FI%FILE, SOURCE=FNAME)
          ALLOCATE(FI%EXT,  SOURCE='')
        END IF
        DEALLOCATE(FNAME)
    END IF
    !
    FI%NUM = Z
    IF(MAXSIZE>Z) THEN
        FI%MAXSIZE = MAXSIZE*1024
    ELSE
        FI%MAXSIZE = -1
    END IF
    !
    DO I=ONE, 5000
        IF     (I<100)  THEN
                             WRITE(NUM,'(I0.2)') I
        ELSEIF (I<1000) THEN
                             WRITE(NUM,'(I0.3)') I
        ELSE
                             WRITE(NUM,'(I4)'  ) I
        END IF
        !
        ALLOCATE(FNAME, SOURCE=FI%FILE//TRIM(NUM)//FI%EXT)
        !
        INQUIRE(FILE=FNAME, EXIST=CHECK)
        !
        IF (CHECK) THEN
            IU=Z
            INQUIRE(FILE=FNAME, OPENED=CHECK, NUMBER=IU)
            !
            IF (CHECK)  THEN
                CLOSE(IU, STATUS='DELETE')
            ELSE
                OPEN(NEWUNIT=IU, FILE=FNAME)
                CLOSE(IU, STATUS='DELETE')
            END IF
            DEALLOCATE(FNAME)
        ELSE
            EXIT
        END IF
        !
    END DO
    !
    INQUIRE(FI%IU, ACCESS=FI%ACCESS, FORM=FI%FORM)!, ASYNCHRONOUS=FI%ASYN)
    !
    !IF(FI%ASYN=='UNK'    ) FI%ASYN='NO'
    IF(FI%FORM=='UNKNOWN') FI%FORM='FORMATTED'
    !
    FI%BINARY = FI%FORM == 'UNFORMATTED' .OR.  FI%FORM == 'BINARY'
    !
  END SUBROUTINE
  !
  SUBROUTINE FILE_INCREMENTER_SET_HEADER(FI, HEADER, NOWRITE)
    CLASS(FILE_INCREMENTER), INTENT(INOUT):: FI
    CHARACTER(*),         INTENT(IN):: HEADER
    LOGICAL,     OPTIONAL,INTENT(IN):: NOWRITE
    LOGICAL:: WRITE_HED
    !
    IF(ALLOCATED(FI%HED)) DEALLOCATE(FI%HED)
                            ALLOCATE(FI%HED, SOURCE=TRIM(HEADER))
    !
    WRITE_HED = TRUE
    IF(PRESENT(NOWRITE)) WRITE_HED = .NOT. NOWRITE
    !
    IF(WRITE_HED .AND. FI%IU.NE.Z) THEN
                     IF(FI%BINARY) THEN
                          WRITE(FI%IU      ) FI%HED
                     ELSE
                          WRITE(FI%IU,'(A)') FI%HED
                     END IF
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE FILE_INCREMENTER_SIZE_CHECK(FI, LINE, NOWRITE)  !NOTE FI%IU CHANGES DUE TO COMPILER BUG -- PROBLEM IS WITH SINGLE FILE IPO
    CLASS(FILE_INCREMENTER), INTENT(INOUT):: FI
    CHARACTER(*), INTENT(IN),OPTIONAL:: LINE
    LOGICAL,     OPTIONAL,INTENT(IN):: NOWRITE
    !
    LOGICAL:: WRITE_HED
    INTEGER:: FSIZE
    CHARACTER(:), ALLOCATABLE:: FNAME
    CHARACTER(4):: NUM
    !
    FI%COUNTER = FI%COUNTER + ONE
    !
    IF( FI%MAXSIZE>Z .AND. FI%COUNTER.GE.FI%MAXCOUNT ) THEN
       !
       FI%COUNTER = Z
       !
       INQUIRE(FI%IU,SIZE=FSIZE)    
       FSIZE=FSIZE/1024  !SIZE in MB  1 MB = 1024*1024 B
       !
       IF (FSIZE>FI%MAXSIZE) THEN
                                 CALL FORCE_UNIT_CLOSE(FI%IU)  !SEPARTE IF TO GIVE TIME FOR BUFFER TO WRITE TO CLOSED FILE
       END IF
       !
       IF (FSIZE>FI%MAXSIZE) THEN
           !
           !FI%IU = Z  !--UNCOMENT IF THERE IS A PROBLEM WITH UNIT CLAIMING FILE ALREADY OPEN
           FI%NUM = FI%NUM + ONE
           !
           IF     (FI%NUM<100)  THEN
                                    WRITE(NUM,'(I0.2)') FI%NUM
           ELSEIF (FI%NUM<1000) THEN
                                    WRITE(NUM,'(I0.3)') FI%NUM
           ELSE
                                    WRITE(NUM,'(I4)'  ) FI%NUM
           END IF
           !
           ALLOCATE(FNAME, SOURCE=FI%FILE//TRIM(NUM)//FI%EXT)
           !
           CALL GENERIC_OPEN(FNAME, FI%IU, Z, ACTION='WRITE', FORM=FI%FORM, ACCESS=FI%ACCESS, STATUS='REPLACE', BUFFER_BLOCKSIZE=FI%BUF, ASYNC='NO')   !, WARN=GET_WARN()
           !OPEN(UNIT=FI%IU,  FILE=FNAME, ACTION='WRITE', STATUS='REPLACE', POSITION='REWIND', IOSTAT=I)
           !IF(I.NE.Z) CALL FILE_IO_ERROR(I, FNAME=FNAME, UNIT=FI%IU)
           !
           IF(PRESENT(LINE)) THEN
                     IF(FI%BINARY) THEN
                                            WRITE(FI%IU      ) LINE
                     ELSEIF(LINE.NE.BLNK) THEN
                                            WRITE(FI%IU,'(A)') TRIM(LINE)
                     END IF
           END IF
           !
           WRITE_HED = TRUE
           IF(PRESENT(NOWRITE)) WRITE_HED = .NOT. NOWRITE
           !
           IF( WRITE_HED .AND. ALLOCATED(FI%HED) ) THEN
                     IF(FI%BINARY) THEN
                          WRITE(FI%IU      ) FI%HED
                     ELSE
                          WRITE(FI%IU,'(A)') FI%HED
                     END IF
           END IF
           !
           DEALLOCATE(FNAME)
       END IF
       !
    END IF
    !
  END SUBROUTINE   
  !
  SUBROUTINE DEALLOCATE_FILE_INCREMENTER(FI)
    CLASS(FILE_INCREMENTER), INTENT(INOUT):: FI
    !
    IF (ALLOCATED(FI%HED))  DEALLOCATE(FI%HED)
    IF (ALLOCATED(FI%FILE)) DEALLOCATE(FI%FILE)
    IF (ALLOCATED(FI%EXT))  DEALLOCATE(FI%EXT)
    IF(FI%OPENCLOSE) CLOSE(FI%IU)
    !
  END SUBROUTINE 
  !
  SUBROUTINE FINAL_DEALLOCATE_FILE_INCREMENTER(FI)
    TYPE(FILE_INCREMENTER), INTENT(INOUT):: FI
    !
    IF (ALLOCATED(FI%HED))  DEALLOCATE(FI%HED)
    IF (ALLOCATED(FI%FILE)) DEALLOCATE(FI%FILE)
    IF (ALLOCATED(FI%EXT))  DEALLOCATE(FI%EXT)
    IF(FI%OPENCLOSE) CLOSE(FI%IU)
    !
  END SUBROUTINE       
  !
END MODULE
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!  
MODULE GENERIC_INPUT_OUTPUT_DATAFILES!, ONLY: CLOSE_GERNIC_INPUT_OUTPUT_DATAFILES, DATAFILE_UNIT_NUMBER
  !SHOULD CALL "CLOSE_GERNIC_INPUT_OUTPUT_DATAFILES" WHEN YOU WANT TO CLOSE ALL THE OPENED DATAFILES, OTHERWISE THEY WILL BE AUTOMATICALLY CLOSED WHEN SIMULATION ENDS
  USE CONSTANTS,        ONLY: Z, ONE, FALSE
  USE UTIL_INTERFACE,   ONLY: GET_FILE_NAME, FILENAME_TO_UNIT, FILENAME_TO_FULLNAME
  USE ARRAY_DATA_TYPES, ONLY: CHARACTER_ARRAY, INTEGER_VECTOR, LOGICAL_VECTOR
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: CLOSE_GERNIC_INPUT_OUTPUT_DATAFILES, DATAFILE_UNIT_NUMBER
  !
  TYPE UNIT_ARRAY_BUILDER
      TYPE(INTEGER_VECTOR ):: IU
      TYPE(LOGICAL_VECTOR ):: IS_BOM
      TYPE(CHARACTER_ARRAY):: FNAM
      CONTAINS
      PROCEDURE, PASS(DF):: ADD        => ADD_UNIT_ARRAY_ENTRY!(IU, [IS_BOM])
      PROCEDURE, PASS(DF):: CHECK_NAME => CHECK_NAME_UNIT_ARRAY!(FNAM,IU,ISOPEN)
      PROCEDURE, PASS(DF):: UNIT_IS_BOM => GET_IS_BOM_UNIT_ARRAY!(IU)
      PROCEDURE, PASS(DF):: DESTROY => DESTROY_UNIT_ARRAY_ENTRY
      FINAL:: FINAL_CLOSE_GERNIC_INPUT_OUTPUT_DATAFILES
  END TYPE
  !
  TYPE(UNIT_ARRAY_BUILDER), SAVE:: DATAFILE_UNIT_NUMBER
  !
  CONTAINS
  !
  SUBROUTINE ADD_UNIT_ARRAY_ENTRY(DF,IU,IS_BOM)
     CLASS(UNIT_ARRAY_BUILDER), INTENT(INOUT):: DF
     INTEGER,                   INTENT(IN   ):: IU
     LOGICAL, OPTIONAL,         INTENT(IN   ):: IS_BOM
     CHARACTER(:),ALLOCATABLE:: FNAM
     !
     CALL GET_FILE_NAME(IU,FNAM)
     !
     CALL DF%IU  %ADD(IU)
     CALL DF%FNAM%ADD(FNAM)
     !
     IF(PRESENT(IS_BOM)) THEN
                          CALL DF%IS_BOM%ADD(IS_BOM)
     ELSE
                          CALL DF%IS_BOM%ADD(FALSE)
     END IF
     !
  END SUBROUTINE
  !
  SUBROUTINE CHECK_NAME_UNIT_ARRAY(DF,FNAM,IU,ISOPEN,IS_BOM)
     CLASS(UNIT_ARRAY_BUILDER), INTENT(INOUT):: DF
     CHARACTER(*),              INTENT(IN   ):: FNAM
     INTEGER,                   INTENT(  OUT):: IU
     LOGICAL,         OPTIONAL, INTENT(  OUT):: ISOPEN, IS_BOM
     !
     CALL FILENAME_TO_UNIT(FNAM,IU)
     !
     IF(IU.NE.Z) THEN
                   IF(DF%IU%IS_UNIQUE(IU)) IU = Z  !FILE HAS YET TO BE OPEN
     END IF
     !
     IF(PRESENT(ISOPEN)) ISOPEN = IU.NE.Z
     !
     IF(PRESENT(IS_BOM)) THEN
                         IF(IU.NE.Z) THEN
                                     IS_BOM = DF%IS_BOM%VEC( DF%IU%FIND(IU) )
                         ELSE
                                     IS_BOM = FALSE
                         END IF
     END IF
     !
  END SUBROUTINE
  !
  PURE FUNCTION GET_IS_BOM_UNIT_ARRAY(DF, IU) RESULT(IS_BOM)
     CLASS(UNIT_ARRAY_BUILDER), INTENT(IN):: DF
     INTEGER,                   INTENT(IN):: IU
     INTEGER:: I
     LOGICAL:: IS_BOM
     !
     IS_BOM = FALSE
     !
     IF(IU .NE. Z) THEN
                   DO I=ONE, DF%IU%N
                             IF(IU == DF%IU%VEC(I)) THEN
                                                    IS_BOM = DF%IS_BOM%VEC(I)
                                                    EXIT
                             END IF
                   END DO
     END IF
     !
  END FUNCTION
  !
  SUBROUTINE DESTROY_UNIT_ARRAY_ENTRY(DF)
     CLASS(UNIT_ARRAY_BUILDER), INTENT(INOUT):: DF
     INTEGER:: I, IERR
     !
     IF(DF%IU%N > Z) THEN
         !
         DO I=1,   DF%IU%N
             CLOSE(DF%IU%VEC(I), IOSTAT=IERR)
         END DO
         !
         CALL DF%IU  %DESTROY()
         CALL DF%FNAM%DESTROY()
         !
     END IF
     !
  END SUBROUTINE
  !
  SUBROUTINE FINAL_CLOSE_GERNIC_INPUT_OUTPUT_DATAFILES(DF)
    TYPE(UNIT_ARRAY_BUILDER):: DF
    !
    CALL DESTROY_UNIT_ARRAY_ENTRY(DF)
    !
  END SUBROUTINE
  !
  SUBROUTINE CLOSE_GERNIC_INPUT_OUTPUT_DATAFILES()
    !
    CALL DESTROY_UNIT_ARRAY_ENTRY(DATAFILE_UNIT_NUMBER)
    !
  END SUBROUTINE
END MODULE
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!  
MODULE GENERIC_INPUT_FILE_INSTRUCTION!, ONLY: GENERIC_INPUT_FILE                        --side note, reposition STREAM with READ(IU,'()', ADVANCE='NO', POS=P)
  ! OPENS AN FILE FOR READING. FOR A GIVEN LINE SENT TO OPEN STATEMENT IT WILL:
  ! FIRST  CHECKS FOR UNIT NUMBER. IF THERE THEN IT WILL USE THAT.
  ! SECOND CHECKS FOR "EXTERNAL"   KEYWORD AND THEN OBTAIN UNIT NUMBER AFTER IT
  ! THIRD  CHECKS FOR "OPEN/CLOSE" KEYWORD AND THEN OPENS FILE AND SETS UNIT NUMBER
  ! FOURTH ATTEMPTS TO OPEN FILE SPECIFIED WITHIN LINE. RAISES AN ERROR IF IT CANNOT BE OPENED. ERROR CAN BE OVERRIDED WITH NOSTOP
  !
  USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: SNG => REAL32, DBL => REAL64
  !USE OPENSPEC,               ONLY: FORM, ACCESS
  USE GENERIC_OPEN_INTERFACE, ONLY: GENERIC_OPEN, UTF8_BOM_OFFSET_REWIND
  USE UTIL_INTERFACE,         ONLY: READ_TO_DATA, FILE_IO_ERROR, CHECK_FOR_POST_KEY, UPPER, MAX_LINE_LENGTH, PARSE_WORD, GET_NUMBER, GET_INTEGER, GET_FILE_NAME, COMMENT_INDEX, SPECIAL_BLANK_STRIP
  USE NUM2STR_INTERFACE,      ONLY: NUM2STR
  USE GENERIC_INPUT_OUTPUT_DATAFILES, ONLY:  DATAFILE_UNIT_NUMBER
  USE CONSTANTS, ONLY:BLNK,NL,BLN,TAB,COM,NEG,Z,ONE,TWO,THREE,TEN,DZ,UNO,DOS,DIEZ,TRUE,FALSE,inf_I
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: GENERIC_INPUT_FILE
  !
  TYPE GENERIC_INPUT_FILE
      INTEGER:: IU          = Z
      INTEGER:: IOUT        = Z
      LOGICAL:: OPENCLOSE   = FALSE
      LOGICAL:: ERROR       = FALSE   !IS TRUE IF NO FLAG IS FOUND AND FAILED TO OPEN FILE
      LOGICAL:: SKIP        = FALSE   !IS TRUE IF FILE WAS SET WITH SKIP OR NULL
      LOGICAL:: IS_CONSTANT = FALSE   !IS TRUE IF CONSTANT KEYWORD IS FOUND
      LOGICAL:: BINARY      = FALSE
      LOGICAL:: STREAM      = FALSE
      LOGICAL:: IS_BOM      = FALSE
      LOGICAL:: IS_EXTERNAL = FALSE
      CHARACTER(:),ALLOCATABLE:: FNAME
      !
      REAL(DBL):: SCALE = UNO
      !
      REAL(DBL), ALLOCATABLE:: CONST  !Only allocated if IS_CONSTANT is TRUE
      !
      CONTAINS
      !
      PROCEDURE, PASS(FL):: OPEN   => OPEN_GENERIC_INPUT_FILE !(LN,[LLOC,OUTPUT,INFILE,NOSTOP,REQKEY,NOSFAC,IU,BINARY,BUFFER,EOL,NO_INTERNAL,NO_CONSTANT,NEW_UNIT,SAVE_FNAME,KEY,DIM,PREPOST,STREAM_TEXT,NOPOSTKEY])
      GENERIC::             READ   => READ_GENERIC_INPUT_FILE_LINE, READ_GENERIC_INPUT_FILE_VECTOR,READ_GENERIC_INPUT_FILE_ARRAY
      PROCEDURE, PASS(FL):: REWIND => REWIND_GENERIC_INPUT_FILE
      PROCEDURE, PASS(FL):: BACK   => BACKSPACE_GENERIC_INPUT_FILE !([N])
      PROCEDURE, PASS(FL):: MOVE   => MOVE_GENERIC_INPUT_FILE
      PROCEDURE, PASS(FL):: CLOSE  => CLOSE_GENERIC_INPUT_FILE
      PROCEDURE, PASS(FL):: NOCLOSE=> NOCLOSE_GENERIC_INPUT_FILE
      PROCEDURE, PASS(FL):: SET_FNAME   => SET_FILE_NAME_GENERIC_INPUT_FILE
      PROCEDURE, PASS(FL):: COUNT_LINES => COUNT_UNCOMMENTED_LINES_GENERIC_INPUT_FILE
      PROCEDURE, PASS(FL):: BACKSPACE   => BACKSPACE_GENERIC_INPUT_FILE 
      PROCEDURE, PASS(FL):: GETPOS      => GET_FILE_POSITION !MUST BE OPENED WITH STREAM
      PROCEDURE, PASS(FL):: POS         => GOTO_FILE_POSITION
      !
      GENERIC            :: ASSIGNMENT(=) => COPY_GENERIC_INPUT_FILE
      !
      PROCEDURE, PASS(FL), PRIVATE:: READ_GENERIC_INPUT_FILE_LINE
      PROCEDURE, PASS(FL), PRIVATE:: READ_GENERIC_INPUT_FILE_VECTOR
      PROCEDURE, PASS(FL), PRIVATE:: READ_GENERIC_INPUT_FILE_ARRAY
      PROCEDURE, PASS(FL), PRIVATE:: BACKSPACE_GENERIC_INPUT_FILE
      PROCEDURE,           PRIVATE:: COPY_GENERIC_INPUT_FILE
      !
      FINAL::                       FINAL_CLOSE_GENERIC_INPUT_FILE
  END TYPE
  !
  CONTAINS
  !
  RECURSIVE SUBROUTINE OPEN_GENERIC_INPUT_FILE(FL,LN,LLOC,OUTPUT,INFILE,NOSTOP,REQKEY,NOSFAC,IU,BINARY,BUFFER,EOL,NO_INTERNAL,NO_CONSTANT,NEW_UNIT,SAVE_FNAME,KEY,DIM,PREPOST,STREAM_TEXT,NOPOSTKEY,FORCE_DATAFILE,MSG)
    ! ATTEMPTS TO READ KEYWORDS AND OPEN AN EXISTING INTPUT FILE
    ! SETS ERROR=TRUE IF FILE FAILED TO IDENTIFY OR OPEN A FILE/UNIT.
    !
    ! THE ORDER THAT THE FILE IS ATTEMPTED TO BE IDENTIFIED IS:
    ! 1) READ SINGLE UNIT NUMBER
    ! 2) CHECK FOR OPTIONAL KEYWORD "BINARY" --ADDED TO OPEN FILE
    ! 4) CHECK FOR KEYWORD INTERNAL IF FOUND THEN RETURNS IU=0
    ! 5) CHECK FOR KEYWORD EXTERNAL FOLLOWED BY UNIT NUMBER
    ! 6) CHECK FOR KEYWORD OPEN/CLOSE AND THEN OPENS FILE SPECIFIED
    ! 7) CHEKS IF THE LINE CONTAINS A FILE THAT CAN BE OPENED (SAME AS IF OPEN/CLOSE WAS NOT PRESENT)
    !
    ! LLOC   is the starting location of the line to look for KEYWORD/NAME
    ! LN     is the line to process the KEYWORDS/UNIT/NAME
    ! IOUT   is where to write error messages too
    ! IN     is the input file that LN originated from
    ! NOSTOP optional, when present and is true will prevent the program from stopping if the file fails to open. ERROR will be set to TRUE
    ! REQKEY optional, when present and is true indicates that a keyword is required to open file (viz. no reading a single number or just a file name)
    ! IU     optional, when present is the unit number used when a file is opened by OPEN/CLOSE or by NAME
    ! BINARY optional, when present is sets file to be opened as a binary file or formatted.
    ! BUFFER optional, when present is sets the buffer size in KB. --131072 = 128KB is the default and 1048576 = 1MB  --BUFFER USES TWO THREADS SO ACTUAL BUFFER IS TWICE THE VALUE (eg. 256KB)
    ! NOSFAC optional, when present and set to true indicates that file does not support scale factors
    ! 
    CLASS(GENERIC_INPUT_FILE),  INTENT(INOUT):: FL
    CHARACTER(*),               INTENT(IN   ):: LN
    INTEGER, OPTIONAL,          INTENT(INOUT):: LLOC
    INTEGER, OPTIONAL,          INTENT(IN   ):: OUTPUT, INFILE !Output file to write error msg too, infile to report error from.
    LOGICAL, OPTIONAL,          INTENT(IN   ):: NOSTOP
    LOGICAL, OPTIONAL,          INTENT(IN   ):: REQKEY
    INTEGER, OPTIONAL,          INTENT(IN   ):: IU
    LOGICAL, OPTIONAL,          INTENT(IN   ):: BINARY
    INTEGER, OPTIONAL,          INTENT(IN   ):: BUFFER
    INTEGER, OPTIONAL,          INTENT(  OUT):: EOL
    LOGICAL, OPTIONAL,          INTENT(  OUT):: NOSFAC
    LOGICAL, OPTIONAL,          INTENT(IN   ):: NO_INTERNAL, NO_CONSTANT, NEW_UNIT, SAVE_FNAME !NO_DATAFILE, NO_EXTERNAL
    CHARACTER(*),OPTIONAL,      INTENT(  OUT):: KEY  !SHOULD BE CHARACTER(>10)
    INTEGER, OPTIONAL,          INTENT(INOUT):: DIM
    INTEGER, OPTIONAL,          INTENT(  OUT):: PREPOST !Holds location before running post-keycheck
    LOGICAL,     OPTIONAL,      INTENT(IN   ):: STREAM_TEXT
    LOGICAL,     OPTIONAL,      INTENT(IN   ):: NOPOSTKEY
    LOGICAL,     OPTIONAL,      INTENT(IN   ):: FORCE_DATAFILE
    CHARACTER(*),OPTIONAL,      INTENT(IN   ):: MSG
    
    !
    LOGICAL:: ISOPEN, ALLOW_ERROR, NOREQKEY, FOUND_KEY, DATAFILE, GO_TO_TOP, EXIST, REQ_NEW_UNIT, CHECK_POST
    CHARACTER(12):: EXT, FORM_CHK, ACCESS_TXT
    CHARACTER(:),ALLOCATABLE:: FNAME, ERR_MSG
    INTEGER:: I, IIN, LL, ISTART, ISTOP, IERR, BUF, SPLIT, LLOC_BAK
    !
    SPLIT = Z
    IERR  = Z
    FL%SCALE      = UNO
    FL%BINARY     = FALSE
    FL%STREAM     = FALSE
    FL%ERROR      = FALSE
    FL%SKIP       = FALSE
    FL%IS_CONSTANT= FALSE
    FL%IS_BOM     = FALSE
    FL%IS_EXTERNAL= FALSE
    FOUND_KEY     = FALSE
    DATAFILE      = FALSE
    GO_TO_TOP     = FALSE
    !
    IF(PRESENT(LLOC)) THEN
        LL = LLOC
    ELSE
        LL = ONE
    END IF
    LLOC_BAK  = LL
    !
    REQ_NEW_UNIT = FALSE
    IF(PRESENT(NEW_UNIT)) REQ_NEW_UNIT = NEW_UNIT
    !
    IF(FL%OPENCLOSE) CLOSE(FL%IU)
    FL%OPENCLOSE = FALSE
    !
    IF(ALLOCATED(FL%FNAME)) DEALLOCATE(FL%FNAME)
    !
    IF(PRESENT(OUTPUT)) THEN
        FL%IOUT = OUTPUT
    ELSE
        FL%IOUT = Z
    END IF
    !
    IF(PRESENT(INFILE)) THEN
        IIN = INFILE
    ELSE
        IIN = Z
    END IF
    !
    IF(PRESENT(NOPOSTKEY)) THEN
        CHECK_POST = .NOT. NOPOSTKEY
    ELSE
        CHECK_POST = TRUE
    END IF
    !
    FL%IU = Z
    !
    IF(PRESENT(NOSTOP)) THEN
        ALLOW_ERROR = .NOT. NOSTOP
    ELSE
        ALLOW_ERROR = TRUE
    END IF
    !
    IF(PRESENT(REQKEY)) THEN
        NOREQKEY = .NOT. REQKEY
    ELSE
        NOREQKEY = TRUE
    END IF
    !
    IF(PRESENT(BINARY)) FL%BINARY = BINARY
    !
    BUF = 16384 ! 16KB x2 = 32KB  --1048576 = 1MB   --NOTE THAT TWO THREADS ARE USED PER BUFFER SO ACTUAL SPACE IS TWICE AS BIG
    IF(PRESENT(BUFFER)) BUF = BUFFER
    !
    ISOPEN = FALSE
    IF(PRESENT(STREAM_TEXT)) ISOPEN = STREAM_TEXT
    IF(ISOPEN) THEN
        ACCESS_TXT = 'STREAM'
    ELSE
        ACCESS_TXT = 'SEQUENTIAL'
    END IF
    !
    CALL PARSE_WORD(LN,LL,ISTART,ISTOP)
    !
    EXT = LN(ISTART:ISTOP)
    CALL UPPER(EXT)
    !
    IF (NOREQKEY .AND. LN(ISTART:ISTOP).NE.BLNK) THEN
                      READ(LN(ISTART:ISTOP),*,IOSTAT=IERR) FL%IU
    ELSE
        IERR=69
    END IF
    !
    IF (IERR .NE. Z) THEN
          !
          IERR = Z
          !
          IF(EXT == 'BINARY') THEN
                                  FL%BINARY = TRUE
                                  CALL PARSE_WORD(LN,LL,ISTART,ISTOP)
                                  EXT = LN(ISTART:ISTOP)
                                  CALL UPPER(EXT)
          END IF
          !
          IF(REQ_NEW_UNIT) THEN
              IF(EXT == 'EXTERNAL' .OR. EXT =='DATAUNIT') EXT = 'NO_EXTERN'
          END IF
          !
          IF(EXT == 'INTERNAL') THEN
                                           FOUND_KEY = TRUE
                                           FL%IU = Z
                                           IF(CHECK_POST) CALL CHECK_FOR_POST_KEY(LL,LN,IIN,FL%IOUT,BUF,SPLIT,FL%SCALE,GO_TO_TOP=GO_TO_TOP,DIM=DIM,OLDLOC=PREPOST, MSG=MSG)
          ELSEIF(EXT == 'EXTERNAL' .OR. EXT =='DATAUNIT') THEN
                                           FOUND_KEY      = TRUE
                                           FL%IS_EXTERNAL = TRUE
                                           CALL GET_INTEGER(LN,LL,ISTART,ISTOP,FL%IOUT,IIN,FL%IU,MSG='GENERIC_INPUT_FILE_INSTRUCTION ERROR: FROUND KEYWORD "'//TRIM(EXT)//'" WHICH SHOULD BE FOLLOWED BY AN INTEGER REPRESENTING THE UNIT NUMBER TO USE.')
                                           IF(CHECK_POST) CALL CHECK_FOR_POST_KEY(LL,LN,IIN,FL%IOUT,BUF,SPLIT,FL%SCALE,GO_TO_TOP=GO_TO_TOP,DIM=DIM,OLDLOC=PREPOST, MSG=MSG)
          ELSEIF(EXT == 'SKIP' .OR. EXT =='NAN' .OR. EXT =='NULL' .OR. EXT =='NUL') THEN
                                           FOUND_KEY = TRUE
                                           FL%IU = Z
                                           FL%ERROR  = TRUE
                                           FL%SKIP   = TRUE
                                           IF(CHECK_POST) CALL CHECK_FOR_POST_KEY(LL,LN,IIN,FL%IOUT,BUF,SPLIT,FL%SCALE,DIM=DIM,OLDLOC=PREPOST, MSG=MSG)
          ELSEIF(EXT == 'CONSTANT' ) THEN
                                           FOUND_KEY = TRUE
                                           FL%IU = Z
                                           FL%IS_CONSTANT = TRUE
                                           !
                                           IF(PRESENT(NO_CONSTANT)) THEN; IF(NO_CONSTANT) FL%ERROR = TRUE
                                           END IF
                                           !
                                           IF(.NOT. ALLOCATED(FL%CONST)) ALLOCATE(FL%CONST)
                                           !
                                           IF(.NOT.PRESENT(KEY)) KEY = EXT
                                           !
                                           CALL GET_NUMBER(LN,LL,ISTART,ISTOP,FL%IOUT,IIN,FL%CONST, MSG='GENERIC_INPUT_FILE_INSTRUCTION ERROR: FROUND KEYWORD "CONSTANT" WHICH SHOULD BE FOLLOWED BY AN NUMBER REPRESENTING THE CONSTANT VALUE.')
                                           !
                                           IF(CHECK_POST) CALL CHECK_FOR_POST_KEY(LL,LN,IIN,FL%IOUT,BUF,SPLIT,FL%SCALE,DIM=DIM,OLDLOC=PREPOST, MSG=MSG)
          ELSE
                IF (EXT == 'OPEN/CLOSE' .OR. EXT == 'DATAFILE') THEN  !OPEN/CLOSE FILE
                                           FOUND_KEY = TRUE
                                           !
                                           DATAFILE  = EXT == 'DATAFILE'
                                           IF(DATAFILE .AND. REQ_NEW_UNIT) DATAFILE = FALSE
                                           !
                                           !IF(DATAFILE .AND. PRESENT(NO_DATAFILE)) DATAFILE  = .NOT. NO_DATAFILE
                                           !
                                           CALL PARSE_WORD(LN,LL,ISTART,ISTOP)   !MOVE TO NEXT WORD WHICH IS THE FILE NAME
                                           FL%OPENCLOSE = TRUE
                ELSEIF(EXT == 'NO_EXTERN') THEN
                                           FOUND_KEY    = TRUE  !OPEN A CLONE OF FILE --EXT == 'NO_EXTERN' IF EXT == EXTERNAL AND REQ_NEW_UNIT = TRUE
                                           FL%OPENCLOSE = TRUE
                ELSEIF(NOREQKEY) THEN
                                           FL%OPENCLOSE = TRUE
                END IF
                !
                IF(PRESENT(FORCE_DATAFILE)) THEN
                  !
                  IF(FL%OPENCLOSE .AND. .NOT. DATAFILE .AND. .NOT. REQ_NEW_UNIT) DATAFILE = FORCE_DATAFILE
                END IF
                !
                IF(ISTART > ISTOP) THEN
                    ALLOCATE( FNAME, SOURCE = BLNK )
                    I      = Z
                    EXIST  = FALSE
                    ISOPEN = FALSE
                ELSEIF(EXT == 'NO_EXTERN') THEN
                    !
                    CALL GET_INTEGER(LN,LL,ISTART,ISTOP,FL%IOUT,IIN,I,MSG='GENERIC_INPUT_FILE_INSTRUCTION ERROR: FROUND KEYWORD "EXTERNAL" OR "DATAUNIT" WHICH SHOULD BE FOLLOWED BY AN INTEGER REPRESENTING THE UNIT NUMBER TO USE.')
                    !                 
                    CALL GET_FILE_NAME(I,FNAME,EXIST,FL%IOUT,IIN,MSG='GENERIC_INPUT_FILE_INSTRUCTION ERROR: FROUND KEYWORD "EXTERNAL" OR "DATAUNIT", BUT FAILED TO IDENTIFY THE FILE (IN PARTICULAR ITS NAME) THAT IS ASSOCAITED WITH IT.')
                    !                    
                    I = Z
                    ISOPEN = FALSE
                ELSE
                    ALLOCATE( FNAME, SOURCE = LN(ISTART:ISTOP) )
                    !
                    INQUIRE(FILE=FNAME, NUMBER=I, OPENED=ISOPEN, EXIST=EXIST)
                    !
                    ! OVERKILL CHECK
                    !IF(DATAFILE .AND. .NOT.ISOPEN .AND. EXIST)  CALL DATAFILE_UNIT_NUMBER%CHECK_NAME(FNAME,I,ISOPEN)
                    !
                END IF
                !
                IF(EXIST) THEN
                    !
                    IF(CHECK_POST) CALL CHECK_FOR_POST_KEY(LL,LN,IIN,FL%IOUT,BUF,SPLIT,FL%SCALE,BINARY=FL%BINARY,GO_TO_TOP=GO_TO_TOP,DIM=DIM,OLDLOC=PREPOST, MSG=MSG) !FL%BINARY ONLY SET TO TRUE IF BINARY FLAG FOUND, OTHERWISE IGNORED
                    !
                    IF(ISOPEN .AND. PRESENT(IU)) THEN; IF (I.NE.IU) ISOPEN = FALSE
                    END IF
                    !
                    IF( DATAFILE .AND. ISOPEN) THEN
                                               FL%IU = I
                                               FL%OPENCLOSE = FALSE
                                               FL%IS_BOM    = DATAFILE_UNIT_NUMBER%UNIT_IS_BOM(FL%IU)
                    ELSEIF(FL%OPENCLOSE) THEN
                                               FL%IU = Z
                                               IF(PRESENT(IU)) FL%IU = IU
                                               !
                                               IF(FL%BINARY) THEN
                                                    CALL GENERIC_OPEN(FNAME, FL%IU, FL%IOUT, ACTION='READ', FORM='UNFORMATTED', ACCESS='STREAM',   STATUS='OLD', ASYNC='NO', BUFFER_BLOCKSIZE=BUF, BUFFER_COUNT=2, LINE=LN, INFILE=IIN, ERROR=FL%ERROR, IS_BOM=FL%IS_BOM)
                                               ELSE
                                                    CALL GENERIC_OPEN(FNAME, FL%IU, FL%IOUT, ACTION='READ', FORM=  'FORMATTED', ACCESS=ACCESS_TXT, STATUS='OLD', ASYNC='NO', BUFFER_BLOCKSIZE=BUF, BUFFER_COUNT=2, LINE=LN, INFILE=IIN, ERROR=FL%ERROR, IS_BOM=FL%IS_BOM)
                                               END IF
                                               !
                                               IF     (FL%ERROR) THEN
                                                                     FL%OPENCLOSE = FALSE
                                               ELSEIF (DATAFILE) THEN
                                                                     FL%OPENCLOSE = FALSE
                                                                     CALL DATAFILE_UNIT_NUMBER%ADD(FL%IU, FL%IS_BOM)
                                               END IF
                    ELSE
                                               FL%ERROR = TRUE  !DID NOT FIND OPEN/CLOSE KEYWORD AND REQKEY=TRUE
                    END IF
                ELSE
                                               FL%IU    = Z
                                               FL%ERROR = TRUE  !FILE DOES NOT EXIST, MAYBE IMPLIED INTERNAL
                END IF
          END IF
    ELSE  !FOUND UNIT NUMBER--CHECK FOR POST KEYS
          FL%IS_EXTERNAL = TRUE
          IF(CHECK_POST) CALL CHECK_FOR_POST_KEY(LL,LN,IIN,FL%IOUT,BUF,SPLIT,FL%SCALE,GO_TO_TOP=GO_TO_TOP,DIM=DIM,OLDLOC=PREPOST, MSG=MSG)
    END IF
    !
    IF(.NOT. FL%ERROR) THEN
                           IF( FL%IU .NE. Z) THEN
                                                 INQUIRE(FL%IU,FORM=FORM_CHK, ACCESS=ACCESS_TXT, OPENED=ISOPEN)
                                                 FL%BINARY = FORM_CHK .NE. 'FORMATTED'
                                                 FL%STREAM = ACCESS_TXT == 'STREAM'
                           ELSE
                                                 FL%BINARY = FALSE
                                                 FL%STREAM = FALSE
                                                 ISOPEN    = TRUE !ASSUMED INTERNAL FILE SO IT IS ALREADY OPEN
                           END IF
                           !
                           IF(.NOT. ISOPEN) FL%ERROR =TRUE !FILE IS NOT INTERNAL, NOR UNIT WAS ASSOCIATED WITH A FILE, NOR WAS IT SUCCESFULLY OPENED.
    END IF
    !
    ! ERROR OCCURED AND EITHER STOPPING IS ALLOWED OR THAT A KEYWORD WAS FOUND SO IT CAN NOT BE AN IMPLIED INTERNAL
    IF (FL%ERROR .AND. (ALLOW_ERROR .OR. FOUND_KEY) .AND. .NOT. FL%SKIP) THEN
        IF(.NOT. NOREQKEY .AND.  .NOT. FOUND_KEY) THEN
                  ERR_MSG = ERR_MSG//NL//'THIS GENERIC INPUT REQUIRES YOU SPECIFY AN INPUT KEYWORD TO SPECIFY DIRECTLY HOW THE GENERIC INPUT FILE SHOULD BE PROCESSED.'//BLN//'ACCEPTIBLE GENERIC INPUT KEYWORDS ARE:'//NL//'   INTERNAL'//NL//'   EXTERNAL'//NL//'   OPEN/CLOSE'//NL//'   DATAUNIT'//NL//'   DATAFILE'//NL//'   NULL'//NL//'   AND SKIP '//NL//' (and for some special circumstances CONSTANT works too.)'//NL
        ELSEIF(ALLOCATED(FNAME)) THEN
            IF(EXT == 'OPEN/CLOSE') THEN
                  ERR_MSG = NL//'FOUND KEYWORD "OPEN/CLOSE",'
            ELSEIF( EXT == 'CONSTANT') THEN
                  ERR_MSG = NL//'FOUND KEYWORD "DATAFILE",'
            ELSEIF( EXT == 'DATAFILE') THEN
                  ERR_MSG = NL//'FOUND KEYWORD "DATAFILE",'
            ELSE
                  ERR_MSG = NL//'NO KEYWORD FOUND, ASSUMING FILE NAME IS JUST SPECIFIED ON CURRENT LINE,'
            END IF
                  IF(FNAME==BLNK) THEN
                      ERR_MSG = ERR_MSG//NL//'BUT FAILED TO FIND A FILE NAME, UNIT NUMBER, OR THAT WOULD IDENTIFY WHAT TO DO.'//BLN//'PLEASE CHECK TO SEE IF FILE OR UNIT NUMBER IS CORRECTLY SPECIFIED'//NL//'AND THE PATH AND FILE NAME CORRECT.'
                  ELSE
                      ERR_MSG = ERR_MSG//NL//'BUT FAILED TO OPEN THE FOLLOWING FILE:'//BLN//'"'//FNAME//'"'//BLN//'PLEASE CHECK TO SEE IF THE PATH AND FILE NAME CORRECT.'//BLN//' ***NOTE THAT THE "/" WORKS FOR BOTH WINDOWS AND LINUX,' //NL//'    BUT THE "\" ONLY WORKS ON WINDOWS.'
                  END IF
        ELSE
            IF(EXT == 'EXTERNAL') THEN
                  ERR_MSG = NL//'FOUND KEYWORD "EXTERNAL",'
            ELSEIF( EXT == 'DATAUNIT') THEN
                  ERR_MSG = NL//'FOUND KEYWORD "DATAUNIT",'
            ELSEIF( EXT == 'CONSTANT') THEN
                  ERR_MSG = NL//'FOUND KEYWORD "CONSTANT", BUT THIS IS NOT ALLOWED FOR THIS INPUT STRUCTURE'//NL//'OR AT LEAST GENERIC_INPUT CAME ACROSS "CONSTANT"'//NL//'AND IT WAS NOT PASSED THE FORTRAN ARGUMENTS TO HANDEL A CONSTANT KEYWORD,'//NL//'SO YOU MAY HAVE IT IN THE WRONG INPUT LOCATION'//NL//'OR IT IS NOT ALLOWED FOR THE CURRENT INPUT FEATURE.'
            ELSE
                  ERR_MSG = NL//'NO KEYWORD FOUND AND A UNIT NUMBER WAS SUCCESSFULLY READ,'//NL//'SO IT WAS ASSUMED TO BE A UNIT SPECIFIED IN THE NAME FILE OR ALREADY OPEN,'
            END IF
                  ERR_MSG = ERR_MSG//NL//'BUT UNIT NUMBER WAS NOT ASSOCIATED WITH ANY FILE (NOT OPEN).'//NL//'THIS PROBABLY IS BECAUSE IT WAS NOT SPECIFIED IN THE NAME FILE,'//NL//'FILE WAS CLOSED AT SOME POINT,'//NL//'OR EVEN NEVER SUCESSFULLY OPENED.'//BLN//'THE FOLLOWING IS THE UNIT NUMBER SEARCHED FOR: "'//NUM2STR(FL%IU)//'"'//BLN//'PLEASE CHECK TO SEE IF UNIT IS SPECIFIED IN THE NAME FILE WITH DATA OR DATA(BINARY) KEYWORDS.'
        END IF
        !
        ERR_MSG = 'FAILED TO OPEN FILE WITH GENERIC_INPUT_FILE_INSTRUCTION.'//BLN//ERR_MSG
        !
        IF(PRESENT(MSG))  ERR_MSG = ERR_MSG//BLN//'THE FOLLOWING MESSAGE WAS PASSED TO GENERIC_INPUT:'//BLN//MSG
        !
        CALL FILE_IO_ERROR(IERR,IIN,LINE=LN,OUTPUT=FL%IOUT,MSG=ERR_MSG)
    END IF
    !
    IF(PRESENT(NO_INTERNAL) .AND. FL%IU == Z .AND. .NOT. FL%ERROR) THEN
            !
            IF(NO_INTERNAL) FL%ERROR = TRUE
            !
            IF(NO_INTERNAL .AND. ALLOW_ERROR) THEN
                  !
                  IF( EXT=='INTERNAL') THEN
                      ERR_MSG = 'GENERIC_INPUT_FILE ERROR: FOUND KEYWORD "INTERNAL" BUT THIS INPUT DATA ITEM DOES NOT ALLOW FOR INTERNAL KEYWORD.'//BLN//'PLEASE MOVE INPUT TO SEPARATE FILE AND USE EITHER OPEN/CLOSE OR EXTERNAL.'
                      IF(PRESENT(MSG))  ERR_MSG = ERR_MSG//BLN//'THE FOLLOWING MESSAGE WAS PASSED TO GENERIC_INPUT:'//BLN//MSG
                      !
                      CALL FILE_IO_ERROR(Z,IIN,LINE=LN,OUTPUT=FL%IOUT,MSG=ERR_MSG)
                  END IF
                  !
                  IF( FL%IU == Z     ) THEN
                      ERR_MSG = 'GENERIC_INPUT_FILE ERROR: THIS INPUT DATA ITEM DOES NOT ALLOW IMPLIED INTERNAL LOADING (LOADING ON SAME LINE).'//NL//'EITHER THIS WAS WHAT WAS ATTEMPED AND NOT ALLOWED OR PROGRAM FAILED TO IDENTIFY KEYWORD USED (OPEN/CLOSE, EXTERNAL, CONSTANT, REPEAT, SKIP), OPEN THE SPECIFIED FILE, OR IDENTIFY UNIT NUMBER DECLARED.'//BLN//'PLEASE CHECK INPUT.'
                      IF(PRESENT(MSG))  ERR_MSG = ERR_MSG//BLN//'THE FOLLOWING MESSAGE WAS PASSED TO GENERIC_INPUT:'//BLN//MSG
                      !
                      CALL FILE_IO_ERROR(Z,IIN,LINE=LN,OUTPUT=FL%IOUT,MSG=ERR_MSG)
                  END IF
            END IF
    END IF
    !
    IF(PRESENT(NOSFAC) .AND. ALLOW_ERROR) THEN
            IF(NOSFAC  .AND. FL%SCALE.NE.UNO) CALL FILE_IO_ERROR(IERR,IIN,LINE=LN,OUTPUT=FL%IOUT,MSG='GENERIC_INPUT_FILE_INSTRUCTION FOUND KEYWORD "SF" OR "SCALE",'//NL//'BUT THIS MODEL FEATURE DOES NOT ALLOW SCALE FACTORS.'//NL//'PLEASE REMOVE KEYWORD SF OR SCALE'//NL//'("SCALE" IS A NUMBER LOCATED TO THE RIGHT OF THE FILE NAME THAT IS LOADED AS A SCALE FACTOR, PLEASE REMOVE OR PLACE A # TO COMMENT IT OUT).')
    END IF
    !
    IF(PRESENT(EOL)) THEN
         IF (.NOT. FL%ERROR .AND. .NOT. FL%BINARY .AND. FL%IU.NE.Z) THEN
             EOL = MAX_LINE_LENGTH(FL%IU)
         ELSE
             EOL = LEN(LN)
         END IF
    END IF
    !
    IF (FL%ERROR .AND. .NOT. FL%SKIP) THEN
                       FL%IU = Z
                       LL = LLOC_BAK
    END IF
    !
    IF(PRESENT(KEY)) THEN
          IF(FOUND_KEY) THEN
                             KEY = ADJUSTL(EXT)
          ELSE
                             KEY = 'NOKEY'
          END IF
    END IF
    !
    IF(GO_TO_TOP .AND. FL%IU.NE.Z) THEN
                       IF(FL%IS_EXTERNAL) THEN
                                       CALL UTF8_BOM_OFFSET_REWIND(FL%IU, FL%IS_BOM)  !EXTERNAL and DATAUNIT have no clue if file is UTF8 or UTF8_BOM - This rewinds appropiately
                       ELSE
                                       CALL REWIND_GENERIC_INPUT_FILE(FL)   !File includes flag for IS_BOM
                       END IF
    END IF
    !
    IF(PRESENT(LLOC)) LLOC = LL
    !
    IF(FL%IU.NE.Z .AND. PRESENT(SAVE_FNAME)) THEN
        IF(SAVE_FNAME) THEN
                   IF(ALLOCATED(FNAME)) THEN
                             IF(FNAME.NE.BLNK) THEN
                                               FL%FNAME = FNAME
                             ELSE
                                               CALL SET_FILE_NAME_GENERIC_INPUT_FILE(FL)
                             END IF
                   ELSE
                       CALL SET_FILE_NAME_GENERIC_INPUT_FILE(FL)
                   END IF
        END IF
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE READ_GENERIC_INPUT_FILE_LINE(FL, LINE, CNT, EOL, EOF, NOSHIFT, READ_COM)
    CLASS(GENERIC_INPUT_FILE), INTENT(INOUT):: FL
    CHARACTER(*),              INTENT(OUT  ):: LINE
    INTEGER,OPTIONAL,          INTENT(OUT  ):: CNT     !RETURNS A COUNT OF HOW MANY LINES WERE LOADED
    INTEGER,OPTIONAL,          INTENT(OUT  ):: EOL     !LOCATIONS OF WHERE THE END OF LINE IS OR ONE SPACE BEFORE #
    LOGICAL,OPTIONAL,          INTENT(OUT  ):: EOF     !SET TO TRUE IF END OF FILE IS REACHED
    LOGICAL,OPTIONAL,          INTENT(IN   ):: NOSHIFT !SET TO TRUE TO NOT TO USE ADJUSTL
    LOGICAL,OPTIONAL,          INTENT(IN   ):: READ_COM !IF TRUE, THEN COMMENTED LINES ARE NOT BYPASSED (default is True)
    INTEGER:: IERR
    LOGICAL:: EEOF
    !
    IERR = Z
    IF(PRESENT(READ_COM)) THEN; IF(READ_COM) IERR = ONE
    END IF
    !
    IF(FL%BINARY) THEN
        READ(FL%IU, IOSTAT=IERR) LINE
        FL%ERROR = IERR.NE.Z
        EEOF = IERR < Z
        IF(PRESENT(CNT)) CNT = ONE
        IF(PRESENT(EOL)) EOL = LEN(LINE)
    ELSEIF(IERR==Z) THEN
        CALL READ_TO_DATA(LINE,FL%IU,FL%IOUT,Z,CNT,EOL,EEOF,NOSHIFT)
        FL%ERROR = EEOF
    ELSE
          READ(FL%IU,'(A)',IOSTAT=IERR) LINE
          IF    (IERR > Z) THEN                                   !LINE FAILED TO READ, THIS IS MOST LIKELY DUE TO END OF FILE LINE,INFILE,OUTPUT,MSG
                               CALL FILE_IO_ERROR(IERR,FL%IU,LINE=LINE,INFILE=FL%IU,OUTPUT=FL%IOUT, MSG='ERROR WHILE READING A GENERIC_INPUT FILE')
          ELSEIF(IERR < Z) THEN !EOF
                               LINE=BLNK
                               EEOF=TRUE
                               BACKSPACE(FL%IU) !NOTE THAT EOF COUNTS OF 1 READ, BUT MULTIPLE READS TO EOF WILL NOT MOVE ANY FURTHER, SO REPOSITION TO THE END OF THE FILE, BUT NOT ONE BEYOND TO KEEP N (THE READ COUNT) CORRET 
          ELSE
                               CALL SPECIAL_BLANK_STRIP(LINE)   !FORTRAN TREATES TAB AS IF IT WAS CHARACTER--MAKE SPACES TO IMPROVE SEARCH
                               !
                               EEOF = TRUE
                               IF(PRESENT(NOSHIFT)) EEOF = .NOT. NOSHIFT
                               IF(LINE(1:1) == BLNK .AND. EEOF) LINE = ADJUSTL(LINE)
                               !
                               EEOF=FALSE
          END IF
          IF(PRESENT(CNT)) CNT = ONE
          IF(PRESENT(EOL)) EOL = COMMENT_INDEX(LINE)
          !
    END IF
    !
    IF(PRESENT(EOF)) EOF = EEOF
    !
  END SUBROUTINE
  !
  SUBROUTINE READ_GENERIC_INPUT_FILE_VECTOR(FL, VEC)
    CLASS(GENERIC_INPUT_FILE),      INTENT(INOUT):: FL
    REAL(DBL),DIMENSION(:),  INTENT(OUT  ):: VEC
    INTEGER:: IERR
    CHARACTER(10):: LN
    !
    IF(FL%BINARY) THEN
        READ(FL%IU, IOSTAT=IERR) VEC
    ELSE 
        CALL READ_TO_DATA(LN,FL%IU,FL%IOUT)
        BACKSPACE(FL%IU)
        READ(FL%IU, *, IOSTAT=IERR) VEC
    END IF
    FL%ERROR = IERR.NE.Z
    !
  END SUBROUTINE
  !
  SUBROUTINE READ_GENERIC_INPUT_FILE_ARRAY(FL, ARR)
    CLASS(GENERIC_INPUT_FILE),      INTENT(INOUT):: FL
    REAL(DBL),DIMENSION(:,:), INTENT(OUT  ):: ARR
    INTEGER:: IERR, I
    CHARACTER(10):: LN
    !
    IF(FL%BINARY) THEN
        READ(FL%IU, IOSTAT=IERR) ARR
    ELSE
        CALL READ_TO_DATA(LN,FL%IU,FL%IOUT)
        BACKSPACE(FL%IU)
        DO I=ONE, UBOUND(ARR,2)
            READ(FL%IU, *, IOSTAT=IERR) ARR(:,I)
            IF(IERR.NE.Z) EXIT
        END DO
        !
    END IF
    FL%ERROR = IERR.NE.Z
    !
  END SUBROUTINE
  !
  IMPURE ELEMENTAL SUBROUTINE REWIND_GENERIC_INPUT_FILE(FL)
    CLASS(GENERIC_INPUT_FILE), INTENT(IN):: FL
    !
    IF(FL%IU.NE.Z) THEN
        !
        IF(FL%BINARY) THEN
            !
            REWIND(FL%IU)
            !
        ELSEIF(FL%IS_EXTERNAL) THEN  !fix for -> Potential error is UTF8 BOM file that is opened in the Name File and calling REWIND_GENERIC_INPUT_FILE(FL) outside of the OPEN_GENERIC_INPUT_FILE routiune
            !
            CALL UTF8_BOM_OFFSET_REWIND(FL%IU)
            !
        ELSE
            REWIND(FL%IU)
            !
            IF(FL%IS_BOM) THEN
                          BLOCK
                              CHARACTER(THREE):: BOM
                              INTEGER:: IERR
                              READ(FL%IU, '(A)', ADVANCE='NO', IOSTAT=IERR) BOM
                          END BLOCK
            END IF
        END IF
    END IF
    !
  END SUBROUTINE
  !
  IMPURE ELEMENTAL SUBROUTINE BACKSPACE_GENERIC_INPUT_FILE(FL,N)
    CLASS(GENERIC_INPUT_FILE), INTENT(INOUT):: FL
    INTEGER, OPTIONAL,         INTENT(IN   ):: N
    INTEGER:: I
    !
    IF(FL%IU.NE.Z) THEN
        IF(PRESENT(N)) THEN
            DO I=1, N
                  BACKSPACE(FL%IU) !Potential error is UTF8 BOM file that is opened in the Name File and calling REWIND_GENERIC_INPUT_FILE(FL) outside of the OPEN_GENERIC_INPUT_FILE routiune
            END DO
        ELSE
                  BACKSPACE(FL%IU)
        END IF
    END IF
    !
  END SUBROUTINE
  !
  IMPURE ELEMENTAL SUBROUTINE SET_FILE_NAME_GENERIC_INPUT_FILE(FL)
    CLASS(GENERIC_INPUT_FILE), INTENT(INOUT):: FL
    LOGICAL:: EXIST
    !
    IF(FL%IU.NE.Z) THEN
        IF(.NOT. ALLOCATED(FL%FNAME)) THEN
              CALL GET_FILE_NAME(FL%IU,FL%FNAME,EXIST,FL%IOUT,Z,MSG='GENERIC_INPUT_FILE_INSTRUCTION ERROR: FROUND KEYWORD "EXTERNAL" OR "DATAUNIT", BUT FAILED TO IDENTIFY THE FILE (IN PARTICULAR ITS NAME) THAT IS ASSOCAITED WITH IT.')
        END IF
    ELSEIF(ALLOCATED(FL%FNAME)) THEN
        DEALLOCATE(FL%FNAME)
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE COUNT_UNCOMMENTED_LINES_GENERIC_INPUT_FILE(FL, CNT)
    CLASS(GENERIC_INPUT_FILE), INTENT(INOUT):: FL
    INTEGER,                   INTENT(OUT  ):: CNT
    LOGICAL:: EOF
    CHARACTER(120):: LN
    !
    CNT = Z
    IF    (FL%IS_CONSTANT         ) THEN; CONTINUE
    ELSEIF(FL%BINARY .OR. FL%IU==Z) THEN
        CNT = NEG
        FL%ERROR = TRUE
    ELSE
        CALL REWIND_GENERIC_INPUT_FILE(FL)
        DO
           CALL READ_TO_DATA(LN,FL%IU,EOF=EOF)
           IF (EOF) EXIT
           CNT = CNT + ONE
        END DO
        CALL REWIND_GENERIC_INPUT_FILE(FL)
    END IF
    !
  END SUBROUTINE
  !
  FUNCTION GET_FILE_POSITION(FL) RESULT(POS)
    CLASS(GENERIC_INPUT_FILE), INTENT(IN):: FL
    INTEGER:: POS
    !
    IF(FL%IU.NE.Z .AND. FL%STREAM) THEN
        INQUIRE(FL%IU, POS=POS)
    ELSE
        POS = ONE
    END IF
    !
  END FUNCTION
  !
  SUBROUTINE GOTO_FILE_POSITION(FL,POS)
    CLASS(GENERIC_INPUT_FILE), INTENT(INOUT):: FL
    INTEGER,                  INTENT(IN   ):: POS
    !
    IF(FL%IU.NE.Z .AND. FL%STREAM) THEN
        READ(FL%IU,'(A)', POS=POS, ADVANCE='NO')
    ELSEIF(FL%IU.NE.Z) THEN
        CALL REWIND_GENERIC_INPUT_FILE(FL)
    END IF
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MOVE_GENERIC_INPUT_FILE(FL,FL_NEW)
    CLASS(GENERIC_INPUT_FILE), INTENT(INOUT):: FL
    CLASS(GENERIC_INPUT_FILE), INTENT(INOUT):: FL_NEW
    !
    FL_NEW%IU        = FL%IU 
    FL_NEW%IOUT      = FL%IOUT
    FL_NEW%OPENCLOSE = FL%OPENCLOSE
    FL_NEW%ERROR     = FL%ERROR
    FL_NEW%BINARY    = FL%BINARY
    FL_NEW%SKIP      = FL%SKIP
    FL_NEW%SCALE     = FL%SCALE
    FL_NEW%IS_CONSTANT = FL%IS_CONSTANT
    FL_NEW%IS_BOM      = FL%IS_BOM      
    FL_NEW%IS_EXTERNAL = FL%IS_EXTERNAL 
    IF(ALLOCATED(FL%FNAME)) THEN
        CALL MOVE_ALLOC(FL%FNAME,FL_NEW%FNAME)
    END IF
    !
    FL%OPENCLOSE = FALSE
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_GENERIC_INPUT_FILE(FL_COPY,FL)
    CLASS(GENERIC_INPUT_FILE), INTENT(INOUT):: FL_COPY
    CLASS(GENERIC_INPUT_FILE), INTENT(IN):: FL
    !
    FL_COPY%IU        = FL%IU 
    FL_COPY%IOUT      = FL%IOUT
    FL_COPY%OPENCLOSE = FL%OPENCLOSE
    FL_COPY%ERROR     = FL%ERROR
    FL_COPY%BINARY    = FL%BINARY
    FL_COPY%SKIP      = FL%SKIP
    FL_COPY%SCALE     = FL%SCALE
    FL_COPY%IS_CONSTANT = FL%IS_CONSTANT
    FL_COPY%IS_BOM      = FL%IS_BOM      
    FL_COPY%IS_EXTERNAL = FL%IS_EXTERNAL 
    IF(ALLOCATED(FL%FNAME)) THEN
        ALLOCATE(FL_COPY%FNAME, SOURCE=FL%FNAME)
    END IF
    !
    FL_COPY%OPENCLOSE = FL%OPENCLOSE
    !
  END SUBROUTINE
  !
  IMPURE ELEMENTAL SUBROUTINE CLOSE_GENERIC_INPUT_FILE(FL)
    CLASS(GENERIC_INPUT_FILE), INTENT(INOUT):: FL
    INTEGER:: IERR
    !
    IF(FL%OPENCLOSE) CLOSE(FL%IU,IOSTAT=IERR)
    !
    IF(ALLOCATED(FL%FNAME)) DEALLOCATE(FL%FNAME)
    !
    FL%IU  = Z
    FL%OPENCLOSE  = FALSE
    FL%BINARY     = FALSE
    FL%SKIP       = FALSE
    FL%IS_CONSTANT= FALSE
    FL%IS_BOM     = FALSE 
    FL%IS_EXTERNAL= FALSE 
    FL%SCALE      = UNO
    !
  END SUBROUTINE
  !
  IMPURE ELEMENTAL SUBROUTINE NOCLOSE_GENERIC_INPUT_FILE(FL)
    CLASS(GENERIC_INPUT_FILE), INTENT(INOUT):: FL
    !
    FL%OPENCLOSE = FALSE
    !
  END SUBROUTINE
  !
  SUBROUTINE FINAL_CLOSE_GENERIC_INPUT_FILE(FL)
    TYPE(GENERIC_INPUT_FILE), INTENT(INOUT):: FL
    !
    CALL CLOSE_GENERIC_INPUT_FILE(FL)
    !
  END SUBROUTINE
  !
  !!!PURE SUBROUTINE GENERIC_INPUT_FILE_DEALLOCATE(FL)
  !!!  TYPE(GENERIC_INPUT_FILE),ALLOCATABLE,INTENT(INOUT):: FL
  !!!  INTEGER:: I
  !!!  !
  !!!  DEALLOCATE(FL, STAT=I)
  !!!  !
  !!!END SUBROUTINE
  !!!!
  !!!PURE SUBROUTINE GENERIC_INPUT_FILE_DEPOINT(FL)
  !!!  TYPE(GENERIC_INPUT_FILE),POINTER,INTENT(INOUT):: FL
  !!!  INTEGER:: I
  !!!  !
  !!!  DEALLOCATE(FL, STAT=I)
  !!!  !
  !!!END SUBROUTINE
  !
END MODULE
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
! 
MODULE GENERIC_OUTPUT_FILE_INSTRUCTION!, ONLY: GENERIC_OUTPUT_FILE
  !OPENS AN FILE FOR WRITING. PROVIDES GENERIC INTERFACING FOR WRITTING TO FILE. IF OPEN/CLOSE AUOTMATICALLY CLOSES FILES
  !
  USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: REAL32, REAL64, REAL128
  !
  !USE OPENSPEC,               ONLY: FORM, ACCESS  
  USE GENERIC_OPEN_INTERFACE, ONLY: GENERIC_OPEN, NULL_FILE
  USE UTIL_INTERFACE,         ONLY: FILE_IO_ERROR, WARNING_MESSAGE, CHECK_FOR_POST_KEY, UPPER, PARSE_WORD, GET_INTEGER, GET_FILE_NAME
  USE NUM2STR_INTERFACE,      ONLY: NUM2STR
  USE FILE_INCREMENTER_INTERFACE,     ONLY: FILE_INCREMENTER
  USE GENERIC_INPUT_OUTPUT_DATAFILES, ONLY: DATAFILE_UNIT_NUMBER
  USE CONSTANTS,                      ONLY: BLNK,NL,BLN,TAB,COM,Z,ONE,TWO,TEN,DZ,UNO,DOS,DIEZ,TRUE,FALSE
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: GENERIC_OUTPUT_FILE, GENERIC_OUTPUT_FILE_DEPOINT   ! XX_DEPOINT only necessary as workaround for gfortran compiler error
  !
  TYPE GENERIC_OUTPUT_FILE
      TYPE(FILE_INCREMENTER),ALLOCATABLE:: FI
      INTEGER:: IU = Z
      LOGICAL:: IS_OPEN   = FALSE
      LOGICAL:: OPENCLOSE = FALSE
      LOGICAL:: ERROR
      INTEGER:: IN, IOUT
      LOGICAL:: BINARY     = FALSE
      LOGICAL:: NULL_FILE  = FALSE
      CHARACTER(:),ALLOCATABLE:: FNAME
      !
      CONTAINS
      !
      PROCEDURE, PASS(FL):: OPEN        => OPEN_GENERIC_OUTPUT_FILE !(LN,[LLOC,OUTPUT,INFILE,NOSTOP,REQKEY,IU,BINARY,BUFFER,SPLIT_SIZE,NOBINARY, SPLITMAXCOUNT, NO_INTERNAL, SAVE_FNAME, KEY,DIM])
      PROCEDURE, PASS(FL):: SET_HEADER  => GENERIC_OUTPUT_SET_HEADER!(HEADER)
      PROCEDURE, PASS(FL):: SIZE_CHECK  => GENERIC_OUTPUT_SIZE_CHECK
      PROCEDURE, PASS(FL):: REWIND      => REWIND_GENERIC_OUTPUT_FILE
      PROCEDURE, PASS(FL):: MOVE        => MOVE_GENERIC_OUTPUT_FILE !(FL_NEW)
      PROCEDURE, PASS(FL):: CLOSE       => CLOSE_GENERIC_OUTPUT_FILE
      PROCEDURE, PASS(FL):: SET_FNAME   => SET_FILE_NAME_GENERIC_OUTPUT_FILE
      GENERIC            :: WRITE       => GENERIC_OUTPUT_FILE_WRITE_SINGLE, GENERIC_OUTPUT_FILE_WRITE_VECTOR, GENERIC_OUTPUT_FILE_WRITE_ARRAY
      !
      PROCEDURE, PASS(FL), PRIVATE:: GENERIC_OUTPUT_FILE_WRITE_SINGLE
      PROCEDURE, PASS(FL), PRIVATE:: GENERIC_OUTPUT_FILE_WRITE_VECTOR
      PROCEDURE, PASS(FL), PRIVATE:: GENERIC_OUTPUT_FILE_WRITE_ARRAY
      !
      FINAL::                       FINAL_CLOSE_GENERIC_OUTPUT_FILE
  END TYPE
  !
  INTERFACE GENERIC_OUTPUT_FILE_DEPOINT
        MODULE PROCEDURE GENERIC_OUTPUT_FILE_DEPOINT_DIM0
        MODULE PROCEDURE GENERIC_OUTPUT_FILE_DEPOINT_DIM1
  END INTERFACE
  !
  CONTAINS
  !
  PURE SUBROUTINE MOVE_GENERIC_OUTPUT_FILE(FL, FL_NEW)
    CLASS(GENERIC_OUTPUT_FILE),  INTENT(INOUT):: FL
    CLASS(GENERIC_OUTPUT_FILE),  INTENT(INOUT):: FL_NEW
    !
    IF( ALLOCATED(FL%FI)) CALL MOVE_ALLOC(FL%FI, FL_NEW%FI)
    FL_NEW%IU         =  FL%IU
    FL_NEW%OPENCLOSE  =  FL%OPENCLOSE
    FL_NEW%ERROR      =  FL%ERROR
    FL_NEW%IN         =  FL%IN
    FL_NEW%IOUT       =  FL%IOUT
    FL_NEW%BINARY     =  FL%BINARY
    FL_NEW%IS_OPEN    =  FL%IS_OPEN
    !
    FL%OPENCLOSE  =FALSE
    FL%IS_OPEN    =FALSE
    !
    IF(ALLOCATED(FL%FNAME)) THEN
        CALL MOVE_ALLOC(FL%FNAME,FL_NEW%FNAME)
    END IF
    !
  END SUBROUTINE
  !
  IMPURE ELEMENTAL SUBROUTINE REWIND_GENERIC_OUTPUT_FILE(FL)
    CLASS(GENERIC_OUTPUT_FILE), INTENT(INOUT):: FL
    !
    IF(FL%IU.NE.Z) REWIND(FL%IU)
    !
  END SUBROUTINE
  !
  SUBROUTINE OPEN_GENERIC_OUTPUT_FILE(FL, LN, LLOC, OUTPUT, INFILE, NOSTOP, REQKEY, IU, BINARY,BUFFER, SPLIT_SIZE, NOBINARY, SPLITMAXCOUNT, NO_INTERNAL, SAVE_FNAME, KEY, DIM)
    ! ATTEMPTS TO READ KEYWORDS AND CREATE A FILE FOR WRITTING TO. IF IT EXISTS IT IS REPLACED
    ! SETS ERROR=TRUE IF FILE FAILED TO IDENTIFY OR OPEN A FILE/UNIT.
    !
    ! THE ORDER THAT THE FILE IS ATTEMPTED TO BE IDENTIFIED IS:
    ! 1) READ SINGLE UNIT NUMBER
    ! 2) CHECK FOR OPTIONAL KEYWORD "BINARY" --ADDED TO OPEN FILE
    ! 4) CHECK FOR KEYWORD "INTERNAL", "LIST", OR THE REST OF HTE LINE IS BLANK TO INDICATE THAT OUTPUT IS WRITTEN TO LIST FILE
    ! 5) CHECK FOR KEYWORD EXTERNAL FOLLOWED BY UNIT NUMBER
    ! 6) CHECK FOR KEYWORD OPEN/CLOSE AND THEN OPENS FILE SPECIFIED
    ! 7) CHEKS IF THE LINE CONTAINS A FILE THAT CAN BE OPENED (SAME AS IF OPEN/CLOSE WAS NOT PRESENT)
    !
    ! LLOC   is the starting location of the line to look for KEYWORD/NAME
    ! LN     is the line to process the KEYWORDS/UNIT/NAME
    ! OUTPUT is where to write error messages too
    ! INFILE is the input file that LN originated from
    ! NOSTOP optional, when present and is true will prevent the program from stopping if the file fails to open. ERROR will be set to TRUE
    ! REQKEY optional, when present and is true indicates that a keyword is required to open file (viz. no reading a single number or just a file name)
    ! IU     optional, when present is the unit number used when a file is opened by OPEN/CLOSE or by NAME
    ! BINARY optional, when present sets file to be opened as a binary file or formatted.
    ! BUFFER optional, when present sets the buffer size in KB. --131072 = 128KB is the default and 1048576 = 1MB  --BUFFER USES TWO THREADS SO ACTUAL BUFFER IS TWICE THE VALUE (eg. 256KB)
    ! SPLIT_SIZE  optional, when present turns on the bility to split the file every SPLIT_SIZE megabytes into a new file
    ! NOBINARY    optional, when present and set to true idicates an error is raised when file is opened as a binary file.
    ! 
    CLASS(GENERIC_OUTPUT_FILE), INTENT(INOUT):: FL
    CHARACTER(*),               INTENT(IN   ):: LN
    INTEGER,      OPTIONAL,     INTENT(INOUT):: LLOC
    INTEGER,      OPTIONAL,     INTENT(IN   ):: OUTPUT, INFILE
    LOGICAL,      OPTIONAL,     INTENT(IN   ):: NOSTOP
    LOGICAL,      OPTIONAL,     INTENT(IN   ):: REQKEY
    INTEGER,      OPTIONAL,     INTENT(IN   ):: IU
    LOGICAL,      OPTIONAL,     INTENT(IN   ):: BINARY
    INTEGER,      OPTIONAL,     INTENT(IN   ):: BUFFER
    INTEGER,      OPTIONAL,     INTENT(IN   ):: SPLIT_SIZE
    LOGICAL,      OPTIONAL,     INTENT(IN   ):: NOBINARY
    INTEGER,      OPTIONAL,     INTENT(IN   ):: SPLITMAXCOUNT
    LOGICAL,      OPTIONAL,     INTENT(IN   ):: NO_INTERNAL
    LOGICAL,      OPTIONAL,     INTENT(IN   ):: SAVE_FNAME
    CHARACTER(*), OPTIONAL,     INTENT(  OUT):: KEY  !SHOULD BE CHARACTER(10)
    INTEGER,          INTENT(INOUT), OPTIONAL:: DIM
    LOGICAL:: ISOPEN, ALLOW_ERROR, NOREQKEY, DATAFILE, FOUND_KEY
    CHARACTER(12):: FORM_CHK, EXT
    CHARACTER(:), ALLOCATABLE:: FNAME, ERR_MSG
    INTEGER:: I, LL, IIN, ISTART, ISTOP, IERR, BUF, SPLIT, IU_READ, MXCNT
    !
    IERR = Z
    IU_READ = Z
    FL%BINARY    = FALSE
    FL%ERROR     = FALSE
    FL%NULL_FILE = FALSE
    FL%IS_OPEN   = FALSE
    DATAFILE     = FALSE
    FOUND_KEY    = FALSE
    !
    IF(ALLOCATED(FL%FNAME)) DEALLOCATE(FL%FNAME)
    !
    IF(FL%OPENCLOSE) CLOSE(FL%IU)
    FL%OPENCLOSE = FALSE
    !
    IF(PRESENT(LLOC)) THEN
        LL = LLOC
    ELSE
        LL = ONE
    END IF
    !
    IF(PRESENT(OUTPUT)) THEN
        FL%IOUT = OUTPUT
    ELSE
        FL%IOUT = Z
    END IF
    !
    IF(PRESENT(INFILE)) THEN
        IIN = INFILE
    ELSE
        IIN = Z
    END IF
    !
    FL%IU = Z
    !
    ISOPEN = FALSE
    IF(PRESENT(IU)) THEN
        IF(IU.NE.Z) THEN
                        INQUIRE(IU, OPENED=ISOPEN)
                        IF(ISOPEN) FL%IU = IU
        END IF
    END IF
    !
    IF(PRESENT(NOSTOP)) THEN
        ALLOW_ERROR = .NOT. NOSTOP
    ELSE
        ALLOW_ERROR = TRUE
    END IF
    !
    IF(PRESENT(REQKEY)) THEN
        NOREQKEY = .NOT. REQKEY
    ELSE
        NOREQKEY = TRUE
    END IF
    !
    SPLIT = Z
    IF(PRESENT(SPLIT_SIZE)) SPLIT = SPLIT_SIZE
    !
    MXCNT = 10
    IF(PRESENT(SPLITMAXCOUNT)) MXCNT = SPLITMAXCOUNT
    !
    IF(PRESENT(BINARY)) FL%BINARY = BINARY
    !
    BUF = 16384 != 16KB x2 = 32KB  --1048576 = 1MB   --NOTE THAT TWO THREADS ARE USED PER BUFFER SO ACTUAL SPACE IS TWICE AS BIG
    IF(PRESENT(BUFFER)) BUF = BUFFER
    !
    IF(.NOT. ISOPEN) THEN
            CALL PARSE_WORD(LN,LL,ISTART,ISTOP)
            IF (NOREQKEY .AND. LN(ISTART:ISTOP).NE.BLNK) THEN
                              READ(LN(ISTART:ISTOP),*,IOSTAT=IERR) IU_READ
            ELSE
                IERR=69
            END IF
            !
            IF (IERR .EQ. Z) THEN
                !
                FL%IU = IU_READ 
                CALL CHECK_FOR_POST_KEY(LL,LN,IIN,FL%IOUT,BUF,SPLIT,DIM=DIM)
                !
                IF (FL%IU == Z) THEN
                    CALL CLOSE_GENERIC_OUTPUT_FILE(FL)
                    CALL WARNING_MESSAGE(LN,IIN,FL%IOUT,MSG='GENERIC_OUTPUT_FILE_INSTRUCTION: SUCESSFULLY LOADED A UNIT NUMBER ON LINE,'//NL//'BUT THE UNIT NUMBER WAS ZERO, SO IT IS ASSUMED THAT NO OUTPUT IS MEANT TO BE WRITTEN.')
                    IF(PRESENT(KEY)) KEY = 'NOKEY'
                    RETURN
                END IF
            ELSE
                IERR= Z
                !
                EXT = LN(ISTART:ISTOP)
                CALL UPPER(EXT)
                !
                IF(EXT == 'BINARY') THEN
                                        FL%BINARY = TRUE
                                        CALL PARSE_WORD(LN,LL,ISTART,ISTOP)
                                        EXT = LN(ISTART:ISTOP)
                                        CALL UPPER(EXT)
                END IF
                !
                IF    (EXT == 'NOPRINT' .OR. EXT == 'SKIP' .OR. EXT == 'NUL' .OR. EXT == 'NULL') THEN
                                                 CALL CHECK_FOR_POST_KEY(LL,LN,IIN,FL%IOUT,BUF,SPLIT,DIM=DIM)
                                                 CALL CLOSE_GENERIC_OUTPUT_FILE(FL)
                                                 FL%IU = NULL_FILE%GET(LN,IIN,FL%IOUT)
                                                 FL%NULL_FILE = TRUE
                                                 IF(PRESENT(KEY)) KEY = ADJUSTL(EXT)
                                                 RETURN
                ELSEIF(EXT == 'INTERNAL'.OR. EXT == 'LIST' .OR. EXT==BLNK) THEN
                                                 FL%IU = FL%IOUT
                                                 IF(EXT.NE.BLNK) FOUND_KEY=TRUE
                ELSEIF(EXT == 'EXTERNAL' .OR. EXT=='DATAUNIT') THEN
                                                 CALL GET_INTEGER(LN,LL,ISTART,ISTOP,FL%IOUT,IIN,FL%IU,MSG='GENERIC_OUTPUT_FILE_INSTRUCTION ERROR: FROUND KEYWORD "'//TRIM(EXT)//'" WHICH SHOULD BE FOLLOWED BY AN INTEGER REPRESENTING THE UNIT NUMBER TO USE.')
                                                 CALL CHECK_FOR_POST_KEY(LL,LN,IIN,FL%IOUT,BUF,SPLIT,DIM=DIM)
                                                 FOUND_KEY=TRUE
                ELSE
                      !
                      IF (EXT == 'OPEN/CLOSE' .OR. EXT=='DATAFILE') THEN  ! OPEN/CLOSE KEYWORD
                                                 DATAFILE = EXT=='DATAFILE'
                                                 CALL PARSE_WORD(LN,LL,ISTART,ISTOP)   !MOVE TO NEXT WORD WHICH IS THE FILE NAME
                                                 FL%OPENCLOSE = TRUE
                                                 FOUND_KEY    = TRUE
                      ELSEIF(NOREQKEY) THEN
                                                 FL%OPENCLOSE = TRUE
                      END IF
                      !
                      ALLOCATE( FNAME, SOURCE = LN(ISTART:ISTOP) )
                      !
                      CALL CHECK_FOR_POST_KEY(LL,LN,IIN,FL%IOUT,BUF,SPLIT,BINARY=FL%BINARY,DIM=DIM)  !FL%BINARY IS ONLY SET TO TRUE IF BINARY FLAG FOUND, OTHERWISE IGNORED
                      !
                      INQUIRE(FILE=FNAME, NUMBER=I, OPENED=ISOPEN)
                      !
                      IF(ISOPEN .AND. PRESENT(IU)) THEN; IF (I.NE.IU) ISOPEN = FALSE
                      END IF
                      !
                      ! OVERKILL CHECK
                      !IF( DATAFILE .AND. .NOT.ISOPEN .AND. .NOT. PRESENT(IU)) CALL DATAFILE_UNIT_NUMBER%CHECK_NAME(FNAME,I,ISOPEN)
                      !
                      IF( DATAFILE .AND. ISOPEN) THEN
                                                 FL%IU = I
                                                 FL%OPENCLOSE = FALSE
                      ELSEIF(FL%OPENCLOSE) THEN
                                                 INQUIRE(FILE=FNAME,NUMBER=FL%IU,OPENED=ISOPEN)
                                                 IF(ISOPEN) THEN
                                                     CALL WARNING_MESSAGE(LN,IIN,FL%IOUT,MSG='GENERIC_OUTPUT FILE OPEN: OPEN/CLOSE FILE WITH FILENAME:'//NL//TRIM(FNAME)//NL//'HAS ALREADY BEEN OPENED/ASSOCIATED WITH A FORTRAN UNIT NUMBER.'//NL//'OUTPUT TO THIS FILE MAY CONTAIN INFORMATION FROM MULTIPLE SOURCES.'//NL//'(THIS IS JUST A WARNING AS YOU MAY BE INTENTIONALY DOING THIS.)')
                                                     FL%OPENCLOSE = FALSE
                                                 ELSE
                                                     FL%IU = Z
                                                     IF(PRESENT(IU)) FL%IU = IU
                                                     !
                                                     IF(FL%BINARY) THEN
                                                          CALL GENERIC_OPEN(FNAME, FL%IU, FL%IOUT, ACTION='WRITE', FORM='UNFORMATTED', ACCESS='STREAM',     STATUS='REPLACE', ASYNC='NO', BUFFER_BLOCKSIZE=BUF, BUFFER_COUNT=2, LINE=LN, INFILE=IIN, ERROR=FL%ERROR)
                                                     ELSE
                                                          CALL GENERIC_OPEN(FNAME, FL%IU, FL%IOUT, ACTION='WRITE', FORM=  'FORMATTED', ACCESS='SEQUENTIAL', STATUS='REPLACE', ASYNC='NO', BUFFER_BLOCKSIZE=BUF, BUFFER_COUNT=2, LINE=LN, INFILE=IIN, ERROR=FL%ERROR)
                                                     END IF
                                                     !
                                                     IF     (FL%ERROR) THEN
                                                                           FL%OPENCLOSE = FALSE
                                                     ELSEIF (DATAFILE) THEN
                                                                           FL%OPENCLOSE = FALSE
                                                                           CALL DATAFILE_UNIT_NUMBER%ADD(FL%IU)
                                                     END IF
                                                 END IF
                      ELSE
                                                 FL%ERROR = TRUE  !DID NOT FIND OPEN/CLOSE KEYWORD AND REQKEY=TRUE
                      END IF
                END IF
            END IF
    END IF
    !
    IF(.NOT. FL%ERROR) THEN
                           IF( FL%IU .NE. Z) THEN
                                                 INQUIRE(FL%IU,FORM=FORM_CHK, OPENED=ISOPEN) 
                                                 FL%BINARY = FORM_CHK .NE. 'FORMATTED'
                           ELSE
                                                 ISOPEN = FALSE
                           END IF
                           !
                           IF(.NOT. ISOPEN) FL%ERROR =TRUE !FILE IS NOT INTERNAL, NOR UNIT WAS ASSOCIATED WITH A FILE, NOR WAS IT SUCCESFULLY OPENED.
    END IF
    !
    IF(SPLIT>Z) THEN
                    ALLOCATE(FL%FI)
                    CALL FL%FI%INIT(SPLIT, FL%IU, BUF, MAXCOUNT=MXCNT)
    END IF
    !
    IF(PRESENT(NOBINARY)) THEN; IF(FL%BINARY .AND. NOBINARY) CALL FILE_IO_ERROR(Z,IIN,LINE=LN,OUTPUT=FL%IOUT,MSG='GENERIC_OUTPUT_FILE_INSTRUCTION ERROR: CONNECTED FILE IS SELECTED FOR BINARY OUTPUT, BUT ONLY FORMATTED OUTPUT IS ALLOWED. PLEASE REMOVE "BINARY" KEYWORD OR MAKE SURE TO USE IN THE NAME FILE THE KEYWORD "DATA" INSTEAD OF DATA(BINARY) FOR THIS FILE.')
    END IF
    !
    IF(PRESENT(NO_INTERNAL) .AND. (FL%IU == Z .OR. FL%IU == FL%IOUT).AND. .NOT. FL%ERROR) THEN
            !
            IF(NO_INTERNAL) FL%ERROR = TRUE
            !
            IF(NO_INTERNAL .AND. ALLOW_ERROR) THEN
                  !
                  IF( EXT=='INTERNAL') CALL FILE_IO_ERROR(Z,IIN,LINE=LN,OUTPUT=FL%IOUT,MSG='GENERIC_INPUT_FILE ERROR: FOUND KEYWORD "INTERNAL" BUT THIS OUTPUT DATA ITEM DOES NOT ALLOW FOR INTERNAL KEYWORD.'//BLN//'PLEASE WRITE OUTPUT TO SEPARATE FILE AND USE EITHER OPEN/CLOSE, DATAFILE, DATAUNIT, OR EXTERNAL.')
                  IF( EXT=='LIST')     CALL FILE_IO_ERROR(Z,IIN,LINE=LN,OUTPUT=FL%IOUT,MSG='GENERIC_INPUT_FILE ERROR: FOUND KEYWORD "LIST" BUT THIS OUTPUT DATA ITEM DOES NOT ALLOW FOR INTERNAL KEYWORD.'//BLN//'PLEASE WRITE OUTPUT TO SEPARATE FILE AND USE EITHER OPEN/CLOSE, DATAFILE, DATAUNIT, OR EXTERNAL.')
                  IF( FL%IU == Z .OR. EXT==BLNK) CALL FILE_IO_ERROR(Z,IIN,LINE=LN,OUTPUT=FL%IOUT,MSG='GENERIC_INPUT_FILE ERROR: THIS OUTPUT DATA ITEM DOES NOT ALLOW WRITING TO LIST FILE (NO KEYWORD FOUND, SO ASSUMING YOU MEANT THE LIST FILE).'//NL//'PLEASE WRITE OUTPUT TO SEPARATE FILE AND USE EITHER OPEN/CLOSE, DATAFILE, DATAUNIT, OR EXTERNAL.')
            END IF
    END IF
    !
    IF (FL%ERROR .AND. ALLOW_ERROR) THEN
        IF(EXT == 'INTERNAL'.OR. EXT == 'LIST' .OR. EXT==BLNK) THEN
            IF(EXT == 'INTERNAL') THEN
                ERR_MSG = NL//'FOUND KEYWORD "INTERNAL",'
            ELSEIF( EXT == 'LIST') THEN
                ERR_MSG = NL//'FOUND KEYWORD "LIST",'
            ELSE
                ERR_MSG = NL//'NO KEYWORD FOUND, ASSUMING THAT OUTPUT IS WRITTEN TO LIST.'
            END IF
            ERR_MSG = ERR_MSG//NL//'HOWEVER THE LIST FILE UNIT WAS NOT PASSED TO SUBROUTINE. THIS INDICATES THAT LIST WRITING IS NOT SUPPORTED FOR THIS OneWater OUTPUT OPTION.'//NL//'PLEASE CHOSE A DIFFERENT OUTPUT LOCATION (eg OPEN/CLOSE OR EXTERNAL).'
        ELSEIF(ALLOCATED(FNAME)) THEN
            IF(EXT == 'OPEN/CLOSE') THEN
                ERR_MSG = NL//'FOUND KEYWORD "OPEN/CLOSE",'
            ELSEIF( EXT == 'DATAFILE') THEN
                ERR_MSG = NL//'FOUND KEYWORD "DATAFILE",'
            ELSE
                ERR_MSG = NL//'NO KEYWORD FOUND, ASSUMING FILE NAME IS JUST SPECIFIED ON CURRENT LINE,'
            END IF
            ERR_MSG = ERR_MSG//NL//'BUT FAILED TO OPEN THE FOLLOWING FILE FOR WRITING:'//BLN//'"'//FNAME//'"'//BLN//'PLEASE CHECK TO SEE IF THE PATH AND FILE NAME CORRECT.'//BLN//' ***NOTE THAT THE "/" WORKS FOR BOTH WINDOWS AND LINUX,' //NL//'    BUT THE "\" ONLY WORKS ON WINDOWS.'
        ELSE
            IF(EXT == 'EXTERNAL') THEN
                ERR_MSG = NL//'FOUND KEYWORD "EXTERNAL",'
            ELSEIF( EXT == 'DATAUNIT') THEN
                ERR_MSG = NL//'FOUND KEYWORD "DATAUNIT",'
            ELSE
                ERR_MSG = NL//'NO KEYWORD FOUND AND A UNIT NUMBER WAS SUCCESSFULLY READ,'//NL//'SO IT WAS ASSUMED TO BE A UNIT SPECIFIED IN THE NAME FILE OR ALREADY OPEN,'
            END IF
            ERR_MSG = ERR_MSG//NL//'BUT UNIT NUMBER WAS NOT ASSOCIATED WITH ANY FILE (NOT OPEN) FOR WRITING.'//NL//'THIS PROBABLY IS BECAUSE IT WAS NOT SPECIFIED IN THE NAME FILE,'//NL//'FILE WAS CLOSED AT SOME POINT,'//NL//'OR EVEN NEVER SUCESSFULLY OPENED.'//BLN//'THE FOLLOWING IS THE UNIT NUMBER SEARCHED FOR: "'//NUM2STR(FL%IU)//'"'//BLN//'PLEASE CHECK TO SEE IF UNIT IS SPECIFIED IN THE NAME FILE WITH DATA OR DATA(BINARY) KEYWORDS.'
        END IF
        !
        ERR_MSG = 'FAILED TO OPEN FILE WITH GENERIC_OUTPUT_FILE_INSTRUCTION.'//BLN//ERR_MSG
        CALL FILE_IO_ERROR(IERR,IIN,LINE=LN,OUTPUT=FL%IOUT,MSG=ERR_MSG)
    END IF
    IF (FL%ERROR) FL%IU = Z
    !
    IF(PRESENT(KEY)) THEN
          IF(FOUND_KEY) THEN
                             KEY = ADJUSTL(EXT)
          ELSE
                             KEY = 'NOKEY'
          END IF
    END IF
    !
    IF(PRESENT(LLOC)) LLOC = LL
    !
    IF(FL%IU.NE.Z) FL%IS_OPEN = TRUE
    !
    IF(FL%IS_OPEN .AND. PRESENT(SAVE_FNAME)) THEN
        IF(SAVE_FNAME) THEN
                   IF(ALLOCATED(FNAME)) THEN
                             IF(FNAME.NE.BLNK) THEN
                                               FL%FNAME = FNAME
                             ELSE
                                               CALL SET_FILE_NAME_GENERIC_OUTPUT_FILE(FL)
                             END IF
                   ELSE
                       CALL SET_FILE_NAME_GENERIC_OUTPUT_FILE(FL)
                   END IF
        END IF
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE GENERIC_OUTPUT_SET_HEADER(FL, HEADER)
    CLASS(GENERIC_OUTPUT_FILE), INTENT(INOUT):: FL
    CHARACTER(*),               INTENT(IN   ):: HEADER
    !
    IF(FL%IS_OPEN) THEN
       IF(FL%BINARY) THEN
                         WRITE(FL%IU) HEADER
       ELSE
                         WRITE(FL%IU,'(A)') HEADER
       END IF
    END IF
    !
    IF(ALLOCATED(FL%FI)) CALL FL%FI%SET_HEADER(HEADER, TRUE)
    !
  END SUBROUTINE
  !
  SUBROUTINE GENERIC_OUTPUT_SIZE_CHECK(FL,HEADER)
    CLASS(GENERIC_OUTPUT_FILE), INTENT(INOUT):: FL
    CHARACTER(*), OPTIONAL,     INTENT(IN   ):: HEADER
    !
    IF(ALLOCATED(FL%FI)) THEN
                             IF(PRESENT(HEADER)) THEN
                                 CALL FL%FI%SIZE_CHECK(HEADER, TRUE)
                             ELSE
                                 CALL FL%FI%SIZE_CHECK()
                             END IF
                             IF(FL%IU.NE.FL%FI%IU) FL%IU=FL%FI%IU
    END IF
    !
  END SUBROUTINE
!
!    CLASS(GENERIC_OUTPUT_FILE), INTENT(INOUT):: FL
!    INTEGER,                    INTENT(INOUT):: LLOC
!    CHARACTER(*),               INTENT(IN   ):: LN
!    INTEGER,                    INTENT(IN   ):: IOUT, IN
!    INTEGER, OPTIONAL,          INTENT(IN   ):: IU
!    LOGICAL, OPTIONAL,          INTENT(IN   ):: BINARY
!    INTEGER, OPTIONAL,          INTENT(IN   ):: BUFFER
!    CHARACTER(8):: EXT
!    INTEGER:: I,Z,ISTART,ISTOP,IERR, BUF
!    REAL:: R
!    !
!    Z = 0
!    FL%IN  = IN
!    FL%IOUT= IOUT
!    FL%BINARY = FALSE
!    !
!    IF(FL%OPENCLOSE) CLOSE(FL%IU)
!    FL%OPENCLOSE = FALSE
!    !
!    FL%IU = Z
!    IF(PRESENT(IU)) FL%IU = IU
!    !
!    IF(PRESENT(BINARY)) FL%BINARY = BINARY
!    BUF = 131072 != 128KB  --1048576 = 1MB   --NOTE THAT TWO THREADS ARE USED PER BUFFER SO ACTUAL SPACE IS TWICE AS BIG
!    IF(PRESENT(BUFFER)) BUF = BUFFER
!    !
!    IF (FL%IU == Z) THEN
!       CALL URWORD(LN,LLOC,ISTART,ISTOP,Z,I,R,Z,Z)
!       READ(LN(ISTART:ISTOP),*,IOSTAT=IERR) FL%IU
!       !
!       IF (IERR .NE. Z) THEN
!             !
!             EXT = LN(ISTART:ISTOP)
!             CALL UPPER(EXT)
!             !
!             IF    (EXT == 'EXTERNAL') THEN
!                   CALL URWORD(LN,LLOC,ISTART,ISTOP,2,FL%IU,R,FL%IOUT,FL%IN)
!             ELSEIF(EXT == 'LIST' .OR. EXT=='') THEN
!                   FL%IU = IOUT
!             ELSE
!                   IF(EXT == 'OPEN/CLO' ) CALL URWORD(LN,LLOC,ISTART,ISTOP,Z,I,R,Z,Z)   !MOVE TO NEXT WORD WHICH IS THE FILE NAME
!                   !
!                   FL%OPENCLOSE = TRUE
!                   FL%IU = Z
!                   !
!                   IF(FL%BINARY) THEN
!                        CALL GENERIC_OPEN(LN(ISTART:ISTOP), FL%IU, FL%IOUT, ACTION='WRITE', FORM=FORM, ACCESS=ACCESS, STATUS='REPLACE', ASYNC='NO', BUFFER_BLOCKSIZE=BUF, BUFFER_COUNT=2, LINE=LN, INFILE=IN)
!                   ELSE
!                        CALL GENERIC_OPEN(LN(ISTART:ISTOP), FL%IU, FL%IOUT, ACTION='WRITE', FORM='FORMATTED', ACCESS='SEQUENTIAL', STATUS='REPLACE', ASYNC='NO', BUFFER_BLOCKSIZE=BUF, BUFFER_COUNT=2, LINE=LN, INFILE=IN)
!                   END IF
!             END IF
!       END IF
!       !
!    END IF
!    !
!    INQUIRE(FL%IU,FORM=FORM)
!    IF(FORM == 'FORMATTED') THEN
!        FL%BINARY = FALSE
!    ELSE
!        FL%BINARY = TRUE
!    END IF
!    !
!  END SUBROUTINE
  !
  SUBROUTINE GENERIC_OUTPUT_FILE_WRITE_LINE(FL,LINE)
    CLASS(GENERIC_OUTPUT_FILE), INTENT(INOUT):: FL
    CHARACTER(*), INTENT(IN):: LINE
    !
    IF(FL%IS_OPEN) THEN
       IF(FL%BINARY) THEN
                         WRITE(FL%IU) LINE
       ELSE
                         WRITE(FL%IU,'(A)') TRIM(LINE)
       END IF
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE GENERIC_OUTPUT_FILE_WRITE_SINGLE(FL,VAL,WIDTH,ADVANCE)
    CLASS(GENERIC_OUTPUT_FILE), INTENT(INOUT):: FL
    CLASS(*),          INTENT(IN):: VAL
    INTEGER, OPTIONAL, INTENT(IN):: WIDTH
    LOGICAL, OPTIONAL, INTENT(IN):: ADVANCE
    CHARACTER(3 ):: ADV
    CHARACTER(30):: FMT
    CHARACTER(4):: DEC
    !
    IF(FL%IS_OPEN) THEN
       !
       IF(FL%BINARY) THEN
           SELECT TYPE (VAL)
           TYPE IS (REAL(REAL64));    WRITE(FL%IU) VAL
           TYPE IS (INTEGER);         WRITE(FL%IU) VAL
           TYPE IS (REAL(REAL32));    WRITE(FL%IU) VAL
           TYPE IS (CHARACTER(*));    WRITE(FL%IU) VAL
           TYPE IS (REAL(REAL128));   WRITE(FL%IU) VAL
           END SELECT
           RETURN
       END IF
       !
       FMT=BLNK
       DEC=BLNK
       IF(PRESENT(WIDTH)) THEN
           WRITE(FMT,'(I30)') WIDTH - 1  !FORCE 1 blank between numbers
           FMT = ADJUSTL(FMT)
           WRITE(DEC,'(I4)') WIDTH - 8  !WIDTH  - 7 - 1
           DEC = ADJUSTL(DEC)
       END IF
       !
       ADV='YES'
       IF(PRESENT(ADVANCE)) THEN
           IF (.NOT. ADVANCE) ADV='NO'
       END IF
       !
       SELECT TYPE (VAL)
       TYPE IS (REAL(REAL64))
           IF(FMT==BLNK) THEN
                           FMT = '(1x ES19.11)'
           ELSE
                           FMT = '(1x ES'//TRIM(FMT)//'.'//DEC//')'
           END IF
           !
           WRITE(FL%IU,FMT, ADVANCE=ADV) VAL
       TYPE IS (REAL(REAL32))
           IF(FMT==BLNK) THEN
                           FMT = '(1x ES19.11)'
           ELSE
                           FMT = '(1x ES'//TRIM(FMT)//'.'//DEC//')'
           END IF
           !
           WRITE(FL%IU,FMT, ADVANCE=ADV) VAL
       TYPE IS (INTEGER)
           IF(FMT==BLNK) THEN
                           FMT = '(1x I19)'
           ELSE
                           FMT = '(1x I'//TRIM(FMT)//')'
           END IF
           !
           WRITE(FL%IU,FMT, ADVANCE=ADV) VAL
       TYPE IS (CHARACTER(*))
           IF(FMT==BLNK) THEN
                           FMT = '(A)'
           ELSE
                           FMT = '(1x A'//TRIM(FMT)//')'
           END IF
           !
           WRITE(FL%IU,FMT, ADVANCE=ADV) TRIM(VAL)
       TYPE IS (REAL(REAL128))
           IF(FMT==BLNK) THEN
                           FMT = '(1x ES19.11)'
           ELSE
                           FMT = '(1x ES'//TRIM(FMT)//'.'//DEC//')'
           END IF
           !
           WRITE(FL%IU,FMT, ADVANCE=ADV) VAL
       END SELECT
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE GENERIC_OUTPUT_FILE_WRITE_VECTOR(FL,VAL,WIDTH,ADVANCE)
    CLASS(GENERIC_OUTPUT_FILE), INTENT(INOUT):: FL
    CLASS(*),DIMENSION(:),INTENT(IN):: VAL
    INTEGER, OPTIONAL,    INTENT(IN):: WIDTH
    LOGICAL, OPTIONAL, INTENT(IN):: ADVANCE
    CHARACTER(3 ):: ADV
    CHARACTER(30):: FMT
    CHARACTER(4):: DEC
    INTEGER:: I
    IF(FL%IS_OPEN) THEN
       !
       IF(FL%BINARY) THEN
           SELECT TYPE (VAL)
           TYPE IS (REAL(REAL64));  WRITE(FL%IU) VAL
           TYPE IS (INTEGER);       WRITE(FL%IU) VAL
           TYPE IS (REAL(REAL32));  WRITE(FL%IU) VAL
           TYPE IS (CHARACTER(*));  WRITE(FL%IU) VAL
           TYPE IS (REAL(REAL128)); WRITE(FL%IU) VAL
           END SELECT
           RETURN
       END IF
       !
       FMT=BLNK
       DEC=BLNK
       IF(PRESENT(WIDTH)) THEN
           WRITE(FMT,'(I30)') WIDTH - 1  !FORCE 1 blank between numbers
           FMT = ADJUSTL(FMT)
           WRITE(DEC,'(I4)') WIDTH - 8  !WIDTH  - 7 - 1
           DEC = ADJUSTL(DEC)
       END IF
       !
       ADV='YES'
       IF(PRESENT(ADVANCE)) THEN
           IF (.NOT. ADVANCE) ADV='NO'
       END IF
       !
       SELECT TYPE (VAL)
       TYPE IS (REAL(REAL64))
           IF(FMT==BLNK) THEN
                           FMT = '(*(1x ES19.11))'
           ELSE
                           FMT = '(*(1x ES'//TRIM(FMT)//'.'//DEC//'))'
           END IF
           !
           WRITE(FL%IU,FMT, ADVANCE=ADV) VAL
       TYPE IS (REAL(REAL32))
           IF(FMT==BLNK) THEN
                           FMT = '(*(1x ES19.11))'
           ELSE
                           FMT = '(*(1x ES'//TRIM(FMT)//'.'//DEC//'))'
           END IF
           !
           WRITE(FL%IU,FMT, ADVANCE=ADV) VAL
       TYPE IS (INTEGER)
           IF(FMT==BLNK) THEN
                           FMT = '(*(1x I19))'
           ELSE
                           FMT = '(*(1x I'//TRIM(FMT)//'))'
           END IF
           !
           WRITE(FL%IU,FMT, ADVANCE=ADV) VAL
       TYPE IS (CHARACTER(*))
           IF(FMT==BLNK) THEN
                           FMT = '(*(A))'
           ELSE
                           FMT = '(*(1x A'//TRIM(FMT)//'))'
           END IF
           !
           DO I=ONE,SIZE(VAL)
                           WRITE(FL%IU,FMT) TRIM(VAL(I))
           END DO
       TYPE IS (REAL(REAL128))
           IF(FMT==BLNK) THEN
                           FMT = '(*(1x ES19.11))'
           ELSE
                           FMT = '(*(1x ES'//TRIM(FMT)//'.'//DEC//'))'
           END IF
           !
           WRITE(FL%IU,FMT, ADVANCE=ADV) VAL
       END SELECT
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE GENERIC_OUTPUT_FILE_WRITE_ARRAY(FL,VAL,WIDTH,ADVANCE)
    CLASS(GENERIC_OUTPUT_FILE), INTENT(INOUT):: FL
    CLASS(*),DIMENSION(:,:),INTENT(IN):: VAL
    INTEGER, OPTIONAL,    INTENT(IN):: WIDTH
    LOGICAL, OPTIONAL, INTENT(IN):: ADVANCE
    CHARACTER(3 ):: ADV
    CHARACTER(30):: FMT
    CHARACTER(4):: DEC
    INTEGER:: I
    IF(FL%IS_OPEN) THEN
        !
        IF(FL%BINARY) THEN
            SELECT TYPE (VAL)
            TYPE IS (REAL(REAL64));  WRITE(FL%IU) VAL
            TYPE IS (INTEGER);       WRITE(FL%IU) VAL
            TYPE IS (REAL(REAL32));  WRITE(FL%IU) VAL
            TYPE IS (CHARACTER(*));  WRITE(FL%IU) VAL
            TYPE IS (REAL(REAL128)); WRITE(FL%IU) VAL
            END SELECT
            RETURN
        END IF
        !
        FMT=BLNK
        DEC=BLNK
        IF(PRESENT(WIDTH)) THEN
            WRITE(FMT,'(I30)') WIDTH - 1  !FORCE 1 blank between numbers
            FMT = ADJUSTL(FMT)
            WRITE(DEC,'(I4)') WIDTH - 8  !WIDTH  - 7 - 1
            DEC = ADJUSTL(DEC)
        END IF
        !
        ADV='YES'
        IF(PRESENT(ADVANCE)) THEN
            IF (.NOT. ADVANCE) ADV='NO'
        END IF
        !
        SELECT TYPE (VAL)
        TYPE IS (REAL(REAL64))
            IF(FMT==BLNK) THEN
                            FMT = '(*(1x ES19.11))'
            ELSE
                            FMT = '(*(1x ES'//TRIM(FMT)//'.'//DEC//'))'
            END IF
            !
            DO I=ONE, UBOUND(VAL,2)
                                 WRITE(FL%IU,FMT, ADVANCE=ADV) VAL(:,I)
            END DO
        TYPE IS (REAL(REAL32))
            IF(FMT==BLNK) THEN
                            FMT = '(*(1x ES19.11))'
            ELSE
                            FMT = '(*(1x ES'//TRIM(FMT)//'.'//DEC//'))'
            END IF
            !
            DO I=ONE, UBOUND(VAL,2)
                                 WRITE(FL%IU,FMT, ADVANCE=ADV) VAL(:,I)
            END DO
        TYPE IS (INTEGER)
            IF(FMT==BLNK) THEN
                            FMT = '(*(1x I19))'
            ELSE
                            FMT = '(*(1x I'//TRIM(FMT)//'))'
            END IF
            !
            DO I=ONE, UBOUND(VAL,2)
                                 WRITE(FL%IU,FMT, ADVANCE=ADV) VAL(:,I)
            END DO
        TYPE IS (CHARACTER(*))
            IF(FMT==BLNK) THEN
                            FMT = '(*(A))'
            ELSE
                            FMT = '(*(1x A'//TRIM(FMT)//'))'
            END IF
            !
            DO I=ONE, UBOUND(VAL,2)
                                 WRITE(FL%IU,FMT, ADVANCE=ADV) VAL(:,I)
            END DO
        TYPE IS (REAL(REAL128))
            IF(FMT==BLNK) THEN
                            FMT = '(*(1x ES19.11))'
            ELSE
                            FMT = '(*(1x ES'//TRIM(FMT)//'.'//DEC//'))'
            END IF
            !
            DO I=ONE, UBOUND(VAL,2)
                                 WRITE(FL%IU,FMT, ADVANCE=ADV) VAL(:,I)
            END DO
        END SELECT
    END IF
    !
  END SUBROUTINE
  !
  IMPURE ELEMENTAL SUBROUTINE SET_FILE_NAME_GENERIC_OUTPUT_FILE(FL)
    CLASS(GENERIC_OUTPUT_FILE), INTENT(INOUT):: FL
    LOGICAL:: EXIST
    !
    IF(FL%IU.NE.Z) THEN
        IF(.NOT. ALLOCATED(FL%FNAME)) THEN
              CALL GET_FILE_NAME(FL%IU,FL%FNAME,EXIST,FL%IOUT,Z,MSG='GENERIC_INPUT_FILE_INSTRUCTION ERROR: FROUND KEYWORD "EXTERNAL" OR "DATAUNIT", BUT FAILED TO IDENTIFY THE FILE (IN PARTICULAR ITS NAME) THAT IS ASSOCAITED WITH IT.')
        END IF
    ELSEIF(ALLOCATED(FL%FNAME)) THEN
        DEALLOCATE(FL%FNAME)
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE CLOSE_GENERIC_OUTPUT_FILE(FL)
    CLASS(GENERIC_OUTPUT_FILE), INTENT(INOUT):: FL
    !
    IF(FL%OPENCLOSE) CLOSE(FL%IU)
    IF(ALLOCATED(FL%FI))    DEALLOCATE(FL%FI)
    IF(ALLOCATED(FL%FNAME)) DEALLOCATE(FL%FNAME)
    !
    FL%IU  = Z
    FL%OPENCLOSE = FALSE
    FL%BINARY    = FALSE
    FL%NULL_FILE = FALSE
    FL%IS_OPEN   = FALSE
    !
  END SUBROUTINE
  !
  SUBROUTINE FINAL_CLOSE_GENERIC_OUTPUT_FILE(FL)
    TYPE(GENERIC_OUTPUT_FILE), INTENT(INOUT):: FL
    !
    CALL CLOSE_GENERIC_OUTPUT_FILE(FL)
    !
  END SUBROUTINE
  !
  !!!PURE SUBROUTINE GENERIC_OUTPUT_FILE_DEALLOCATE(FL)
  !!!  TYPE(GENERIC_OUTPUT_FILE),ALLOCATABLE,INTENT(INOUT):: FL
  !!!  INTEGER:: I
  !!!  !
  !!!  DEALLOCATE(FL, STAT=I)
  !!!  !
  !!!END SUBROUTINE
  !!!!
  PURE SUBROUTINE GENERIC_OUTPUT_FILE_DEPOINT_DIM0(FL)
    TYPE(GENERIC_OUTPUT_FILE),POINTER,INTENT(INOUT):: FL
    INTEGER:: I
    !
    DEALLOCATE(FL, STAT=I)
    NULLIFY(FL)
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE GENERIC_OUTPUT_FILE_DEPOINT_DIM1(FL)
    TYPE(GENERIC_OUTPUT_FILE),POINTER,DIMENSION(:), INTENT(INOUT):: FL
    INTEGER:: I
    !
    DEALLOCATE(FL, STAT=I)
    NULLIFY(FL)
    !
  END SUBROUTINE
  !
END MODULE
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
! 
MODULE CYCLING_TEXT_FILE_INTERFACE!, ONLY: CYCLING_TEXT_FILE
  !OPENS AN FILE FOR WRITING. PROVIDES GENERIC INTERFACING FOR WRITTING TO FILE. IF OPEN/CLOSE AUOTMATICALLY CLOSES FILES
  !
  USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: REAL32, REAL64, REAL128
  !
  USE ARRAY_DATA_TYPES,       ONLY: CHARACTER_TYPE
  USE GENERIC_OPEN_INTERFACE, ONLY: GENERIC_OPEN, FORCE_UNIT_CLOSE
  USE UTIL_INTERFACE,         ONLY: FILE_IO_ERROR, WARNING_MESSAGE, CHECK_FOR_POST_KEY, UPPER, PARSE_WORD, GET_INTEGER, GET_FILE_NAME
  USE NUM2STR_INTERFACE,      ONLY: NUM2STR
  USE GENERIC_INPUT_OUTPUT_DATAFILES, ONLY: DATAFILE_UNIT_NUMBER
  USE CONSTANTS,                      ONLY: BLNK,NL,BLN,TAB,COM,Z,ONE,TWO,TEN,DZ,UNO,DOS,DIEZ,TRUE,FALSE
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: CYCLING_TEXT_FILE
  !
  TYPE CYCLING_TEXT_FILE
      INTEGER:: RECLEN = Z
      CHARACTER(:), ALLOCATABLE:: REC
      !
      INTEGER:: HEDLEN = Z
      CHARACTER(:),ALLOCATABLE:: HED
      !
      INTEGER:: IU = Z
      LOGICAL:: IS_OPEN   = FALSE
      LOGICAL:: OPENCLOSE = FALSE
      LOGICAL:: ERROR
      INTEGER:: IN, IOUT
      CHARACTER(:),ALLOCATABLE:: FNAME
      !
      INTEGER:: NVAL=Z, VPOS = ONE, RPOS = ONE
      INTEGER,              DIMENSION(:), ALLOCATABLE:: NSPACE
      TYPE(CHARACTER_TYPE), DIMENSION(:), ALLOCATABLE:: FMT
      !
      CONTAINS
      !
      PROCEDURE, PASS(FL):: OPEN        => OPEN_CYCLING_TEXT_FILE !(LLOC,LN,IOUT,IN,NOSTOP,REQKEY,IU,BUFFER, KEY, NVAL, HED)
      PROCEDURE, PASS(FL):: SET_HEADER  => CYCLING_TEXT_FILE_SET_HEADER!(HEADER, [NOWRITE]) --WILL REWIND FILE AND WRITE HEADER
      PROCEDURE, PASS(FL):: REWIND      => REWIND_CYCLING_TEXT_FILE
      PROCEDURE, PASS(FL):: WRITE       => WRITE_RECORD_CYCLING_TEXT_FILE
      PROCEDURE, PASS(FL):: SET_NVAL
      GENERIC::             SET_FMT     => SET_SINGLE_FMT, SET_MULTI_FMT !(FMT,NSPACE,[POS])
      GENERIC::             SET_REC     => SET_SINGLE_REC, SET_MULTI_REC !(VAL,[POS])
      PROCEDURE, PASS(FL):: BACK        => BACKSPACE_TEXT_FILE !(FL, NLINE)
      PROCEDURE, PASS(FL):: NEXT        => NEXTLINE_TEXT_FILE  !(FL, NLINE)
      PROCEDURE, PASS(FL):: MOVE        => MOVE_CYCLING_TEXT_FILE !(FL_NEW)
      PROCEDURE, PASS(FL):: CLOSE       => CLOSE_CYCLING_TEXT_FILE
      PROCEDURE, PASS(FL):: SET_FNAME   => SET_FILE_NAME_CYCLING_TEXT_FILE
      PROCEDURE, PASS(FL), PRIVATE:: SET_SINGLE_FMT
      PROCEDURE, PASS(FL), PRIVATE:: SET_MULTI_FMT
      PROCEDURE, PASS(FL), PRIVATE:: SET_SINGLE_REC
      PROCEDURE, PASS(FL), PRIVATE:: SET_MULTI_REC
      !
      FINAL::                            FINAL_CLOSE_CYCLING_TEXT_FILE
  END TYPE
  !
  CONTAINS
  !
  PURE SUBROUTINE ALLOCATE_REC(FL, RECLEN)
    CLASS(CYCLING_TEXT_FILE),  INTENT(INOUT):: FL
    INTEGER,                   INTENT(IN   ):: RECLEN
    !
    IF(FL%RECLEN .NE. RECLEN) THEN
        !
        FL%RECLEN = RECLEN
        IF(ALLOCATED(FL%REC)) DEALLOCATE(FL%REC)
        !
        ALLOCATE(CHARACTER(RECLEN):: FL%REC)
        !
    END IF
    !
    FL%REC(:) = BLNK
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE MOVE_CYCLING_TEXT_FILE(FL, FL_NEW)
    CLASS(CYCLING_TEXT_FILE),  INTENT(INOUT):: FL
    CLASS(CYCLING_TEXT_FILE),  INTENT(INOUT):: FL_NEW
    !
    FL_NEW%IU         =  FL%IU
    FL_NEW%OPENCLOSE  =  FL%OPENCLOSE
    FL_NEW%ERROR      =  FL%ERROR
    FL_NEW%IN         =  FL%IN
    FL_NEW%IOUT       =  FL%IOUT
    FL_NEW%IS_OPEN    =  FL%IS_OPEN
    FL_NEW%HEDLEN     =  FL%HEDLEN
    FL_NEW%NVAL       =  FL%NVAL
    FL_NEW%VPOS       =  FL%VPOS
    FL_NEW%RPOS       =  FL%RPOS
    !
    CALL ALLOCATE_REC(FL_NEW, FL%RECLEN)  !Set up FL%REC
    !
    FL%OPENCLOSE  =FALSE
    FL%IS_OPEN    =FALSE
    !
    IF(ALLOCATED(FL%FNAME)) THEN
        CALL MOVE_ALLOC(FL%FNAME,FL_NEW%FNAME)
    END IF
    !
    IF(ALLOCATED(FL%HED)) THEN
        CALL MOVE_ALLOC(FL%HED, FL_NEW%HED)
    END IF
    !
    IF(ALLOCATED(FL%FMT   )) THEN
        ALLOCATE(FL_NEW%FMT(FL%NVAL) )
        CALL FL%FMT%MOVE(FL_NEW%FMT)
        DEALLOCATE(FL%FMT)
    END IF
    IF(ALLOCATED(FL%NSPACE)) CALL MOVE_ALLOC(FL%NSPACE,FL_NEW%NSPACE)
    !
  END SUBROUTINE
  !
  IMPURE ELEMENTAL SUBROUTINE REWIND_CYCLING_TEXT_FILE(FL)
    CLASS(CYCLING_TEXT_FILE), INTENT(INOUT):: FL
    !
    IF(FL%IU.NE.Z) THEN
        REWIND(FL%IU)
        IF(ALLOCATED(FL%HED))  WRITE(FL%IU) FL%HED
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE WRITE_RECORD_CYCLING_TEXT_FILE(FL)
    CLASS(CYCLING_TEXT_FILE), INTENT(INOUT):: FL
    !
    IF(FL%IU.NE.Z) WRITE(FL%IU) FL%REC, NL
    !
    FL%RPOS = ONE
    FL%VPOS = ONE
    !
  END SUBROUTINE
  !
  SUBROUTINE SET_NVAL(FL,NVAL)
    CLASS(CYCLING_TEXT_FILE), INTENT(INOUT):: FL
    INTEGER,                     INTENT(IN   ):: NVAL
    !
    IF(FL%NVAL < NVAL) THEN
        !
        FL%NVAL = NVAL
        !
        IF(ALLOCATED(FL%FMT   )) DEALLOCATE(FL%FMT   )
        IF(ALLOCATED(FL%NSPACE)) DEALLOCATE(FL%NSPACE)
        !
        ALLOCATE(FL%FMT   (FL%NVAL))
        ALLOCATE(FL%NSPACE(FL%NVAL), SOURCE=Z)
        !
    ELSEIF(NVAL < ONE) THEN
        FL%NVAL = Z
        IF(ALLOCATED(FL%FMT   )) DEALLOCATE(FL%FMT   )
        IF(ALLOCATED(FL%NSPACE)) DEALLOCATE(FL%NSPACE)
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE SET_SINGLE_FMT(FL,FMT,NSPACE,POS)
    CLASS(CYCLING_TEXT_FILE), INTENT(INOUT):: FL
    CHARACTER(*),             INTENT(IN   ):: FMT
    INTEGER,                  INTENT(IN   ):: NSPACE
    INTEGER,                  INTENT(IN   ):: POS
    !
    IF(FL%NVAL > Z .AND. POS > Z .AND. POS <= FL%NVAL) THEN
        FL%FMT   (POS) = FMT
        FL%NSPACE(POS) = NSPACE
    ELSE
        WRITE(*,'(A)') 'CODE ERROR -- CYCLING_TEXT_FILE%SET_SINGLE_FMT NOT SET UP CORRECTLY'
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE SET_MULTI_FMT(FL,FMT,NSPACE,POS)
    CLASS(CYCLING_TEXT_FILE), INTENT(INOUT):: FL
    CHARACTER(*),DIMENSION(:),INTENT(IN   ):: FMT
    INTEGER,     DIMENSION(:),INTENT(IN   ):: NSPACE
    INTEGER,     OPTIONAL,    INTENT(IN   ):: POS
    INTEGER:: I, J, P, N
    !
    P = ONE
    IF(PRESENT(POS)) P = POS
    !
    N = P+SIZE(NSPACE)-ONE
    !
    IF(FL%NVAL > Z .AND.N <= FL%NVAL) THEN
        J = Z
        DO I = P, N
                     J = J + ONE
                     FL%FMT   (I) = FMT   (J)
                     FL%NSPACE(I) = NSPACE(J)
        END DO
    ELSE
        WRITE(*,'(A)') 'CODE ERROR -- CYCLING_TEXT_FILE%SET_SINGLE_FMT NOT SET UP CORRECTLY'
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE SET_SINGLE_REC(FL,VAL,POS)
    CLASS(CYCLING_TEXT_FILE), INTENT(INOUT):: FL
    CLASS(*),                 INTENT(IN   ):: VAL
    INTEGER,     OPTIONAL,    INTENT(IN   ):: POS
    !
    ASSOCIATE(P => FL%VPOS, LOC => FL%RPOS)
       !
       IF(PRESENT(POS)) THEN
                        P = POS
                        IF    (P==ONE) THEN
                                                 LOC = ONE
                        ELSEIF(P <= FL%NVAL) THEN
                                                 LOC = SUM(FL%NSPACE(1:POS-1)) + ONE
                        END IF
       END IF
       !
       IF(LOC <= FL%RECLEN .AND. P <= FL%NVAL) THEN
           SELECT TYPE (VAL)
           TYPE IS (INTEGER       ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL      
           TYPE IS (CHARACTER(*)  ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL 
           TYPE IS (REAL(REAL64)  ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL
           TYPE IS (REAL(REAL32)  ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL
           TYPE IS (REAL(REAL128) ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL
           TYPE IS (CHARACTER_TYPE); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL%STR
           END SELECT
           !
           LOC = LOC + FL%NSPACE(P)
           P = P + ONE
       ELSE
           WRITE(*,'(A)') 'CODE ERROR -- CYCLING_TEXT_FILE%SET_SINGLE_FMT NOT SET UP CORRECTLY'
       END IF
       !
    END ASSOCIATE
    !
  END SUBROUTINE
  !
  SUBROUTINE SET_MULTI_REC(FL,VAL,POS)
    CLASS(CYCLING_TEXT_FILE), INTENT(INOUT):: FL
    CLASS(*),    DIMENSION(:),INTENT(IN   ):: VAL
    INTEGER,     OPTIONAL,    INTENT(IN   ):: POS
    INTEGER:: I, J, N
    !
    ASSOCIATE(P => FL%VPOS, LOC => FL%RPOS)
       !
       IF(PRESENT(POS)) THEN
                        P = POS
                        IF    (P==ONE) THEN
                                                 LOC = ONE
                        ELSEIF(P <= FL%NVAL) THEN
                                                 LOC = SUM(FL%NSPACE(1:POS-1)) + ONE
                        END IF
       END IF
       !
       J = Z
       N = P + SIZE(VAL) - ONE
       !
       IF(N>FL%NVAL) N = FL%NVAL
       !
       DO I=P, N
           !
           IF(LOC <= FL%RECLEN .AND. P <= FL%NVAL) THEN
               J = J + ONE
               SELECT TYPE (VAL)
               TYPE IS (INTEGER       ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL(J)      
               TYPE IS (CHARACTER(*)  ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL(J) 
               TYPE IS (REAL(REAL64)  ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL(J)
               TYPE IS (REAL(REAL32)  ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL(J)
               TYPE IS (REAL(REAL128) ); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL(J)
               TYPE IS (CHARACTER_TYPE); WRITE( FL%REC(LOC:), FL%FMT(P)%STR ) VAL(J)%STR
               END SELECT
               !
               LOC = LOC + FL%NSPACE(I)
           ELSE
               WRITE(*,'(A)') 'CODE ERROR -- CYCLING_TEXT_FILE%SET_SINGLE_FMT NOT SET UP CORRECTLY'
           END IF
       END DO
       !
       P = P + SIZE(VAL)
       !
    END ASSOCIATE
    !
  END SUBROUTINE
  !
  SUBROUTINE OPEN_CYCLING_TEXT_FILE(FL,RECLEN,LLOC,LN,IOUT,IN,NOSTOP,REQKEY,IU,BUFFER, KEY, DIM, NVAL, HED)
    ! ATTEMPTS TO READ KEYWORDS AND CREATE A FILE FOR WRITTING TO. 
    ! FILE ASSUMES CONSTANT CHRACTER(RECLEN) RECORD LENGTH PER LINE
    ! SETS ERROR=TRUE IF FILE FAILED TO IDENTIFY OR OPEN A FILE/UNIT.
    !
    ! THE ORDER THAT THE FILE IS ATTEMPTED TO BE IDENTIFIED IS:
    ! 1) READ SINGLE UNIT NUMBER
    ! 2) CHECK FOR OPTIONAL KEYWORD "BINARY" --ADDED TO OPEN FILE
    ! 4) CHECK FOR KEYWORD "INTERNAL", "LIST", OR THE REST OF HTE LINE IS BLANK TO INDICATE THAT OUTPUT IS WRITTEN TO LIST FILE
    ! 5) CHECK FOR KEYWORD EXTERNAL FOLLOWED BY UNIT NUMBER
    ! 6) CHECK FOR KEYWORD OPEN/CLOSE AND THEN OPENS FILE SPECIFIED
    ! 7) CHEKS IF THE LINE CONTAINS A FILE THAT CAN BE OPENED (SAME AS IF OPEN/CLOSE WAS NOT PRESENT)
    !
    ! LLOC   is the starting location of the line to look for KEYWORD/NAME
    ! LN     is the line to process the KEYWORDS/UNIT/NAME
    ! IOUT   is where to write error messages too
    ! IN     is the input file that LN originated from
    ! NOSTOP optional, when present and is true will prevent the program from stopping if the file fails to open. ERROR will be set to TRUE
    ! REQKEY optional, when present and is true indicates that a keyword is required to open file (viz. no reading a single number or just a file name)
    ! IU     optional, when present is the unit number used when a file is opened by OPEN/CLOSE or by NAME
    ! BUFFER optional, when present sets the buffer size in KB. --131072 = 128KB is the default and 1048576 = 1MB  --BUFFER USES TWO THREADS SO ACTUAL BUFFER IS TWICE THE VALUE (eg. 256KB)
    ! 
    CLASS(CYCLING_TEXT_FILE),  INTENT(INOUT):: FL
    INTEGER,                   INTENT(IN   ):: RECLEN
    INTEGER,                   INTENT(INOUT):: LLOC
    CHARACTER(*),              INTENT(IN   ):: LN
    INTEGER,                   INTENT(IN   ):: IOUT, IN
    LOGICAL,      OPTIONAL,    INTENT(IN   ):: NOSTOP
    LOGICAL,      OPTIONAL,    INTENT(IN   ):: REQKEY
    INTEGER,      OPTIONAL,    INTENT(IN   ):: IU
    INTEGER,      OPTIONAL,    INTENT(IN   ):: BUFFER
    CHARACTER(*), OPTIONAL,    INTENT(  OUT):: KEY  !SHOULD BE CHARACTER(10)
    INTEGER,      OPTIONAL,    INTENT(INOUT):: DIM
    INTEGER,      OPTIONAL,    INTENT(IN   ):: NVAL
    CHARACTER(*), OPTIONAL,    INTENT(IN   ):: HED
    LOGICAL:: ISOPEN, ALLOW_ERROR, NOREQKEY, DATAFILE, FOUND_KEY
    CHARACTER(10):: EXT
    !CHARACTER(13):: FORM_CHK, ACC_CHCK
    CHARACTER(:), ALLOCATABLE:: FNAME, ERR_MSG
    INTEGER:: I, ISTART, ISTOP, IERR, BUF, IU_READ, SPLIT
    !
    IERR = Z
    IU_READ = Z
    FL%ERROR     = FALSE
    FL%IS_OPEN   = FALSE
    DATAFILE     = FALSE
    FOUND_KEY    = FALSE
    !
    CALL ALLOCATE_REC(FL, RECLEN)  !Set up FL%REC
    !
    FL%RPOS = ONE
    FL%VPOS = ONE
    FL%NVAL = Z
    IF(PRESENT(NVAL)) FL%NVAL = NVAL
    !
    IF(ALLOCATED(FL%FNAME )) DEALLOCATE(FL%FNAME )
    IF(ALLOCATED(FL%FMT   )) DEALLOCATE(FL%FMT   )
    IF(ALLOCATED(FL%NSPACE)) DEALLOCATE(FL%NSPACE)
    !
    IF(FL%NVAL > Z) THEN
        ALLOCATE(FL%FMT   (FL%NVAL))
        ALLOCATE(FL%NSPACE(FL%NVAL), SOURCE=Z)
    END IF
    !
    IF(FL%OPENCLOSE) CLOSE(FL%IU)
    FL%OPENCLOSE = FALSE
    !
    FL%IOUT = IOUT
    FL%IU = Z
    !
    ISOPEN = FALSE
    IF(PRESENT(IU)) THEN
        IF(IU.NE.Z) THEN
                        INQUIRE(IU, OPENED=ISOPEN)
                        IF(ISOPEN) FL%IU = IU
        END IF
    END IF
    !
    IF(PRESENT(NOSTOP)) THEN
        ALLOW_ERROR = .NOT. NOSTOP
    ELSE
        ALLOW_ERROR = TRUE
    END IF
    !
    IF(PRESENT(REQKEY)) THEN
        NOREQKEY = .NOT. REQKEY
    ELSE
        NOREQKEY = TRUE
    END IF
    !
    BUF = 16384 != 16KB x2 = 32KB  --1048576 = 1MB   --NOTE THAT TWO THREADS ARE USED PER BUFFER SO ACTUAL SPACE IS TWICE AS BIG
    IF(PRESENT(BUFFER)) BUF = BUFFER
    !
    IF(ISOPEN) THEN
        !
        CALL STREAM_FILE_CHECK(FL, BUF, LN)
        !
        IF(FL%ERROR) THEN
            FL%IU = Z
        ELSE
            REWIND(FL%IU)
        END IF
        !
    ELSE!IF(.NOT. ISOPEN) THEN
            CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
            IF (NOREQKEY .AND. LN(ISTART:ISTOP).NE.BLNK) THEN
                              READ(LN(ISTART:ISTOP),*,IOSTAT=IERR) IU_READ
            ELSE
                IERR=69
            END IF
            !
            IF (IERR .EQ. Z) THEN
                !
                FL%IU = IU_READ 
                CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,BUF,SPLIT,DIM=DIM)
                !
                IF (FL%IU == Z) THEN
                    CALL CLOSE_CYCLING_TEXT_FILE(FL)
                    CALL WARNING_MESSAGE(LN,IN,IOUT,MSG='GENERIC_OUTPUT_FILE_INSTRUCTION: SUCESSFULLY LOADED A UNIT NUMBER ON LINE,'//NL//'BUT THE UNIT NUMBER WAS ZERO, SO IT IS ASSUMED THAT NO OUTPUT IS MEANT TO BE WRITTEN.')
                    IF(PRESENT(KEY)) KEY = 'NOKEY'
                    RETURN
                END IF
                !
                CALL STREAM_FILE_CHECK(FL, BUF, LN)
            ELSE
                IERR= Z
                !
                EXT = LN(ISTART:ISTOP)
                CALL UPPER(EXT)
                !
                IF(EXT == 'BINARY') THEN
                                        CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
                                        EXT = LN(ISTART:ISTOP)
                                        CALL UPPER(EXT)
                END IF
                !
                IF    (EXT == 'NOPRINT' .OR. EXT == 'SKIP' .OR. EXT == 'NUL' .OR. EXT == 'NULL') THEN
                                                 CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,BUF,SPLIT,DIM=DIM)
                                                 CALL CLOSE_CYCLING_TEXT_FILE(FL)
                                                 FL%IU = Z
                                                 IF(PRESENT(KEY)) KEY = ADJUSTL(EXT)
                                                 IF(PRESENT(DIM)) DIM = Z
                                                 RETURN
                ELSEIF(EXT == 'INTERNAL'.OR. EXT == 'LIST' .OR. EXT==BLNK) THEN  !WILL RAISE ERROR LATER
                                                     FL%IU = IOUT
                ELSEIF(EXT == 'EXTERNAL' .OR. EXT=='DATAUNIT') THEN
                                                 CALL GET_INTEGER(LN,LLOC,ISTART,ISTOP,IOUT,IN,FL%IU,MSG='GENERIC_OUTPUT_FILE_INSTRUCTION ERROR: FROUND KEYWORD "'//TRIM(EXT)//'" WHICH SHOULD BE FOLLOWED BY AN INTEGER REPRESENTING THE UNIT NUMBER TO USE.')
                                                 CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,BUF,SPLIT,DIM=DIM)
                                                 FOUND_KEY=TRUE
                                                 CALL STREAM_FILE_CHECK(FL, BUF, LN)
                ELSE
                      !
                      IF (EXT == 'OPEN/CLOSE' .OR. EXT=='DATAFILE') THEN  ! OPEN/CLOSE KEYWORD
                                                 DATAFILE = EXT=='DATAFILE'
                                                 CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)   !MOVE TO NEXT WORD WHICH IS THE FILE NAME
                                                 FL%OPENCLOSE = TRUE
                                                 FOUND_KEY    = TRUE
                      ELSEIF(NOREQKEY) THEN
                                                 FL%OPENCLOSE = TRUE
                      END IF
                      !
                      ALLOCATE( FNAME, SOURCE = LN(ISTART:ISTOP) )
                      !
                      CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,BUF,SPLIT,DIM=DIM)  !FL%BINARY IS ONLY SET TO TRUE IF BINARY FLAG FOUND, OTHERWISE IGNORED
                      !
                      INQUIRE(FILE=FNAME, NUMBER=I, OPENED=ISOPEN)
                      !
                      IF(ISOPEN .AND. PRESENT(IU)) THEN; IF (I.NE.IU) ISOPEN = FALSE
                      END IF
                      !
                      IF( DATAFILE .AND. ISOPEN) THEN
                                                 FL%IU = I
                                                 CALL STREAM_FILE_CHECK(FL, BUF, LN)
                      ELSEIF(FL%OPENCLOSE) THEN
                                                 INQUIRE(FILE=FNAME,NUMBER=FL%IU,OPENED=ISOPEN)
                                                 IF(ISOPEN) THEN
                                                     CALL WARNING_MESSAGE(LN,IN,IOUT,MSG='GENERIC_OUTPUT FILE OPEN: OPEN/CLOSE FILE WITH FILENAME:'//NL//TRIM(FNAME)//NL//'HAS ALREADY BEEN OPENED/ASSOCIATED WITH A FORTRAN UNIT NUMBER.'//NL//'OUTPUT TO THIS FILE MAY CONTAIN INFORMATION FROM MULTIPLE SOURCES.'//NL//'(THIS IS JUST A WARNING AS YOU MAY BE INTENTIONALY DOING THIS.)')
                                                     CALL STREAM_FILE_CHECK(FL, BUF, LN)
                                                     FL%OPENCLOSE = FALSE
                                                 ELSE
                                                     FL%IU = Z
                                                     IF(PRESENT(IU)) FL%IU = IU
                                                     !
                                                     CALL GENERIC_OPEN(FNAME, FL%IU, IOUT, ACTION='WRITE', FORM='UNFORMATTED', ACCESS='STREAM', STATUS='REPLACE', ASYNC='NO', BUFFER_BLOCKSIZE=BUF, BUFFER_COUNT=2, LINE=LN, INFILE=IN, ERROR=FL%ERROR)
                                                     !
                                                     IF     (FL%ERROR) THEN
                                                                           FL%OPENCLOSE = FALSE
                                                     ELSEIF (DATAFILE) THEN
                                                                           FL%OPENCLOSE = FALSE
                                                                           CALL DATAFILE_UNIT_NUMBER%ADD(FL%IU)
                                                     END IF
                                                 END IF
                      ELSE
                                                 FL%ERROR = TRUE  !DID NOT FIND OPEN/CLOSE KEYWORD AND REQKEY=TRUE
                      END IF
                END IF
            END IF
    END IF
    !
    IF((FL%IU == Z .OR. FL%IU == IOUT) .AND. .NOT. FL%ERROR) THEN
            !
            FL%ERROR = TRUE
            !
            IF(ALLOW_ERROR) THEN
                  !
                  IF( EXT=='INTERNAL') CALL FILE_IO_ERROR(Z,IN,LINE=LN,OUTPUT=IOUT,MSG='CYCLING_TEXT_FILE ERROR: FOUND KEYWORD "INTERNAL" BUT THIS OUTPUT DATA ITEM DOES NOT ALLOW FOR INTERNAL KEYWORD.'//BLN//'PLEASE WRITE OUTPUT TO SEPARATE FILE AND USE EITHER OPEN/CLOSE, DATAFILE, DATAUNIT, OR EXTERNAL.')
                  IF( EXT=='LIST')     CALL FILE_IO_ERROR(Z,IN,LINE=LN,OUTPUT=IOUT,MSG='CYCLING_TEXT_FILE ERROR: FOUND KEYWORD "LIST" BUT THIS OUTPUT DATA ITEM DOES NOT ALLOW FOR INTERNAL KEYWORD.'//BLN//'PLEASE WRITE OUTPUT TO SEPARATE FILE AND USE EITHER OPEN/CLOSE, DATAFILE, DATAUNIT, OR EXTERNAL.')
                  IF( FL%IU == Z .OR. EXT==BLNK) CALL FILE_IO_ERROR(Z,IN,LINE=LN,OUTPUT=IOUT,MSG='CYCLING_TEXT_FILE ERROR: THIS OUTPUT DATA ITEM DOES NOT ALLOW WRITING TO LIST FILE (NO KEYWORD FOUND, SO ASSUMING YOU MEANT THE LIST FILE).'//NL//'PLEASE WRITE OUTPUT TO SEPARATE FILE AND USE EITHER OPEN/CLOSE, DATAFILE, DATAUNIT, OR EXTERNAL.')
            END IF
    END IF
    !
    IF(.NOT. FL%ERROR) THEN
                           IF( FL%IU .NE. Z) THEN
                                                 INQUIRE(FL%IU, OPENED=ISOPEN) 
                           ELSE
                                                 ISOPEN = FALSE
                           END IF
                           !
                           IF(.NOT. ISOPEN) FL%ERROR =TRUE !FILE IS NOT INTERNAL, NOR UNIT WAS ASSOCIATED WITH A FILE, NOR WAS IT SUCCESFULLY OPENED.
    END IF
    !
    IF (FL%ERROR .AND. ALLOW_ERROR) THEN
        IF(EXT == 'INTERNAL'.OR. EXT == 'LIST' .OR. EXT==BLNK) THEN
            IF(EXT == 'INTERNAL') THEN
                ERR_MSG = NL//'FOUND KEYWORD "INTERNAL",'
            ELSEIF( EXT == 'LIST') THEN
                ERR_MSG = NL//'FOUND KEYWORD "LIST",'
            ELSE
                ERR_MSG = NL//'NO KEYWORD FOUND, ASSUMING THAT OUTPUT IS WRITTEN TO LIST.'
            END IF
            ERR_MSG = ERR_MSG//NL//'HOWEVER THE LIST FILE UNIT WAS NOT PASSED TO SUBROUTINE. THIS INDICATES THAT LIST WRITING IS NOT SUPPORTED FOR THIS OneWater OUTPUT OPTION.'//NL//'PLEASE CHOSE A DIFFERENT OUTPUT LOCATION (eg OPEN/CLOSE OR EXTERNAL).'
        ELSEIF(ALLOCATED(FNAME)) THEN
            IF(EXT == 'OPEN/CLOSE') THEN
                ERR_MSG = NL//'FOUND KEYWORD "OPEN/CLOSE",'
            ELSEIF( EXT == 'DATAFILE') THEN
                ERR_MSG = NL//'FOUND KEYWORD "DATAFILE",'
            ELSE
                ERR_MSG = NL//'NO KEYWORD FOUND, ASSUMING FILE NAME IS JUST SPECIFIED ON CURRENT LINE,'
            END IF
            ERR_MSG = ERR_MSG//NL//'BUT FAILED TO OPEN THE FOLLOWING FILE FOR WRITING:'//BLN//'"'//FNAME//'"'//BLN//'PLEASE CHECK TO SEE IF THE PATH AND FILE NAME CORRECT.'//BLN//' ***NOTE THAT THE "/" WORKS FOR BOTH WINDOWS AND LINUX,' //NL//'    BUT THE "\" ONLY WORKS ON WINDOWS.'
        ELSE
            IF(EXT == 'EXTERNAL') THEN
                ERR_MSG = NL//'FOUND KEYWORD "EXTERNAL",'
            ELSEIF( EXT == 'DATAUNIT') THEN
                ERR_MSG = NL//'FOUND KEYWORD "DATAUNIT",'
            ELSE
                ERR_MSG = NL//'NO KEYWORD FOUND AND A UNIT NUMBER WAS SUCCESSFULLY READ,'//NL//'SO IT WAS ASSUMED TO BE A UNIT SPECIFIED IN THE NAME FILE OR ALREADY OPEN,'
            END IF
            ERR_MSG = ERR_MSG//NL//'BUT UNIT NUMBER WAS NOT ASSOCIATED WITH ANY FILE (NOT OPEN) FOR WRITING.'//NL//'THIS PROBABLY IS BECAUSE IT WAS NOT SPECIFIED IN THE NAME FILE,'//NL//'FILE WAS CLOSED AT SOME POINT,'//NL//'OR EVEN NEVER SUCESSFULLY OPENED.'//BLN//'THE FOLLOWING IS THE UNIT NUMBER SEARCHED FOR: "'//NUM2STR(FL%IU)//'"'//BLN//'PLEASE CHECK TO SEE IF UNIT IS SPECIFIED IN THE NAME FILE WITH DATA OR DATA(BINARY) KEYWORDS.'
        END IF
        !
        ERR_MSG = 'FAILED TO OPEN FILE WITH GENERIC_OUTPUT_FILE_INSTRUCTION.'//BLN//ERR_MSG
        CALL FILE_IO_ERROR(IERR,IN,LINE=LN,OUTPUT=IOUT,MSG=ERR_MSG)
    END IF
    IF (FL%ERROR) FL%IU = Z
    !
    IF(PRESENT(KEY)) THEN
          IF(FOUND_KEY) THEN
                             KEY = ADJUSTL(EXT)
          ELSE
                             KEY = 'NOKEY'
          END IF
    END IF
    !
    FL%IS_OPEN = FL%IU.NE.Z
    !
    IF(FL%IS_OPEN) REWIND(FL%IU)
    !
    IF(PRESENT(HED)) CALL CYCLING_TEXT_FILE_SET_HEADER(FL, HED)
    !
    END SUBROUTINE
    !
  SUBROUTINE STREAM_FILE_CHECK(FL, BUF, LINE)
    CLASS(CYCLING_TEXT_FILE),  INTENT(INOUT):: FL
    INTEGER:: BUF
    CHARACTER(*), INTENT(IN):: LINE
    CHARACTER(13):: FORM_CHK, ACC_CHCK
    !
    INQUIRE(FL%IU, FORM=FORM_CHK, ACCESS=ACC_CHCK)
    !
    IF( (FORM_CHK == 'UNFORMATTED' .OR. FORM_CHK == 'BINARY') .AND. ACC_CHCK == 'STREAM' ) THEN
        !
        IF(.NOT. ALLOCATED(FL%FNAME)) CALL GET_FILE_NAME(FL%IU,FL%FNAME,IOUT=FL%IOUT,IN=FL%IN, MSG='CYCLING_TEXT_FILE_INTERFACE ERROR: UNKNOWN ERROR WHILE TRYING TO INDENTIFY THE FILE NAME.', LINE=LINE)
        CALL FORCE_UNIT_CLOSE(FL%IU)
        CALL GENERIC_OPEN(FL%FNAME, FL%IU, FL%IOUT, ACTION='WRITE', FORM='UNFORMATTED', ACCESS='STREAM', STATUS='REPLACE', ASYNC='NO', BUFFER_BLOCKSIZE=BUF, BUFFER_COUNT=2, LINE=LINE, INFILE=FL%IN, ERROR=FL%ERROR)
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE CYCLING_TEXT_FILE_SET_HEADER(FL, HEADER, NOWRITE)
    CLASS(CYCLING_TEXT_FILE), INTENT(INOUT):: FL
    CHARACTER(*),             INTENT(IN   ):: HEADER
    LOGICAL,     OPTIONAL,    INTENT(IN   ):: NOWRITE
    LOGICAL:: WRITE_HED
    !
    IF(ALLOCATED(FL%HED)) DEALLOCATE(FL%HED)
                            ALLOCATE(FL%HED, SOURCE=HEADER//NL)
    !
    WRITE_HED = TRUE
    IF(PRESENT(NOWRITE)) WRITE_HED = .NOT. NOWRITE
    !
    IF(WRITE_HED .AND. FL%IU.NE.Z) THEN
        REWIND(FL%IU)
        WRITE(FL%IU) FL%HED
    END IF
    !
    FL%HEDLEN = LEN(FL%HED)
    !
    FL%VPOS = ONE
    FL%RPOS = ONE
    !
  END SUBROUTINE
  !
  SUBROUTINE BACKSPACE_TEXT_FILE(FL, NLINE)
    CLASS(CYCLING_TEXT_FILE), INTENT(INOUT):: FL
    INTEGER,     OPTIONAL,    INTENT(IN   ):: NLINE
    INTEGER:: N, P
    !
    P = Z
    !
    IF(FL%IU.NE.Z) THEN
       N = ONE
       IF(PRESENT(NLINE)) N = NLINE
       !
       N = N * (FL%RECLEN+ONE)
       !
       INQUIRE(FL%IU, POS=P)
       !
       IF(P - N > FL%HEDLEN ) THEN
           P = P - N
           WRITE(FL%IU,POS=P)
       ELSE
           CALL REWIND_CYCLING_TEXT_FILE(FL)
       END IF
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE NEXTLINE_TEXT_FILE(FL, NLINE)
    CLASS(CYCLING_TEXT_FILE), INTENT(INOUT):: FL
    INTEGER,     OPTIONAL,    INTENT(IN   ):: NLINE
    INTEGER:: N, P
    !
    P = Z
    !
    IF(FL%IU.NE.Z) THEN
       N = ONE
       IF(PRESENT(NLINE)) N = NLINE
       !
       N = N * (FL%RECLEN+ONE)
       !
       INQUIRE(FL%IU, POS=P)
       !
       P = P + N - 1
       WRITE(FL%IU,POS=P)
    END IF
    !
  END SUBROUTINE
  !
  IMPURE ELEMENTAL SUBROUTINE SET_FILE_NAME_CYCLING_TEXT_FILE(FL)
    CLASS(CYCLING_TEXT_FILE), INTENT(INOUT):: FL
    LOGICAL:: EXIST
    !
    IF(FL%IU.NE.Z) THEN
        IF(.NOT. ALLOCATED(FL%FNAME)) THEN
              CALL GET_FILE_NAME(FL%IU,FL%FNAME,EXIST,FL%IOUT,FL%IN,MSG='CYCLING_TEXT_FILE_INTERFACE ERROR: FROUND KEYWORD "EXTERNAL" OR "DATAUNIT", BUT FAILED TO IDENTIFY THE FILE (IN PARTICULAR ITS NAME) THAT IS ASSOCAITED WITH IT.')
        END IF
    ELSEIF(ALLOCATED(FL%FNAME)) THEN
        DEALLOCATE(FL%FNAME)
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE CLOSE_CYCLING_TEXT_FILE(FL)
    CLASS(CYCLING_TEXT_FILE), INTENT(INOUT):: FL
    !
    IF(FL%OPENCLOSE) CLOSE(FL%IU)
    IF(ALLOCATED(FL%FNAME)) DEALLOCATE(FL%FNAME)
    !
    FL%IU  = Z
    FL%RECLEN = Z
    FL%OPENCLOSE = FALSE
    FL%IS_OPEN   = FALSE
    !
    IF(ALLOCATED(FL%REC)) DEALLOCATE(FL%REC)
    !
    FL%NVAL = Z
    FL%VPOS = ONE
    FL%RPOS = ONE
    IF(ALLOCATED(FL%FMT)) DEALLOCATE(FL%FMT)
    !
    IF(ALLOCATED(FL%NSPACE)) DEALLOCATE(FL%NSPACE)
    !
  END SUBROUTINE
  !
  SUBROUTINE FINAL_CLOSE_CYCLING_TEXT_FILE(FL)
    TYPE(CYCLING_TEXT_FILE), INTENT(INOUT):: FL
    !
    CALL CLOSE_CYCLING_TEXT_FILE(FL)
    !
  END SUBROUTINE
  !
  !!!PURE SUBROUTINE CYCLING_TEXT_FILE_DEALLOCATE(FL)
  !!!  TYPE(CYCLING_TEXT_FILE),ALLOCATABLE,INTENT(INOUT):: FL
  !!!  INTEGER:: I
  !!!  !
  !!!  DEALLOCATE(FL, STAT=I)
  !!!  !
  !!!END SUBROUTINE
  !!!!
  !!!PURE SUBROUTINE CYCLING_TEXT_FILE_DEPOINT(FL)
  !!!  TYPE(CYCLING_TEXT_FILE),POINTER,INTENT(INOUT):: FL
  !!!  INTEGER:: I
  !!!  !
  !!!  DEALLOCATE(FL, STAT=I)
  !!!  !
  !!!END SUBROUTINE
  !
END MODULE
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!  
MODULE GENERIC_BLOCK_READER_INSTRUCTION!, ONLY: GENERIC_BLOCK_READER
  USE CONSTANTS,                      ONLY: BLNK,BLN,NL,TAB,COM,Z,ONE,TWO,TEN,DZ,UNO,DOS,DIEZ,TRUE,FALSE
  USE LINKED_LIST_INSTRUCTION,        ONLY: CHARACTER_LINKED_LIST
  USE UTIL_INTERFACE,                 ONLY: READ_TO_DATA, UPPER, PARSE_WORD, PARSE_WORD_UP, STOP_ERROR, COMMENT_INDEX
  USE NUM2STR_INTERFACE,              ONLY: NUM2STR
  USE GENERIC_OPEN_INTERFACE,         ONLY: GENERIC_SCRATCH_FILE
  USE GENERIC_INPUT_FILE_INSTRUCTION, ONLY: GENERIC_INPUT_FILE
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: GENERIC_BLOCK_READER
  ! 
  TYPE GENERIC_BLOCK_READER
      INTEGER:: LINE_LEN = 1250                      !SETS SIZE OF INTERNAL LINE
      INTEGER:: IU   = Z
      INTEGER:: IOUT = Z
      INTEGER:: NLINE= Z
      INTEGER:: SCRATCH = Z
      CHARACTER(:),             ALLOCATABLE:: NAME
      CHARACTER(:),             ALLOCATABLE:: EXTRA
      CHARACTER(:),             ALLOCATABLE:: END_KEY
      TYPE(CHARACTER_LINKED_LIST)          :: LIST
      CHARACTER(:),             ALLOCATABLE:: LN   !SCRATCH LINE FOR LOADING
      CHARACTER(:), POINTER:: LINE  => NULL()      !HOLDS LIST LN
      CONTAINS
      PROCEDURE, PASS(BL):: INIT        => INIT_GENERIC_BLOCK      !INIT (IU,[IOUT], [LEN_LEN]) --OPTIONAL, SHOULD USE LOAD
      PROCEDURE, PASS(BL):: LOAD        => LOAD_GENERIC_BLOCK      !LOAD (IU,[IOUT],[LINE], [END_KEY], [END_NOT_FOUND], [FOUND_BEGIN], [SKIP], [BEGIN_OPTIONAL])
      PROCEDURE, PASS(BL):: INNER       => LOAD_INNER_GENERIC_BLOCK!INNER([END_KEY], [IU], [IOUT], [END_NOT_FOUND], [SKIP_END_KEY])
      PROCEDURE, PASS(BL):: SET_LINE_LEN=> SET_BLOCK_LINE_LEN      !SET_LINE_LEN(LEN_LEN)
      PROCEDURE, PASS(BL):: START       => START_OF_BLOCK 
      PROCEDURE, PASS(BL):: NEXT        => NEXT_BLOCK_LINE
      PROCEDURE, PASS(BL):: BACK        => MOVE_BACK_BLOCK_LINE
      PROCEDURE, PASS(BL):: ADD_LINE    => INSERT_LINE_INTO_BLOCK!(LINE,[POS])
      PROCEDURE, PASS(BL):: DELETE_LINE => DELETE_CURRENT_LINE
      PROCEDURE, PASS(BL):: DEL_LINE    => DELETE_CURRENT_LINE
      PROCEDURE, PASS(BL):: POP_LINE    => REMOVE_LINE_AT !([POS])
      PROCEDURE, PASS(BL):: LINE_NUM    => GET_LINE_POS   !RESULT(POS) 
      PROCEDURE, PASS(BL):: GOTO_LINE   => GOTO_LINE_POS  !(POS)
      PROCEDURE, PASS(BL):: AT_END      => BLOCK_AT_END
      PROCEDURE, PASS(BL):: NOT_AT_END  => BLOCK_NOT_AT_END
      PROCEDURE, PASS(BL):: SET_LINE    => SET_BLOCK_LINE
      PROCEDURE, PASS(BL):: SET_END_KEY => SET_BLOCK_END_KEY!(END_KEY)
      PROCEDURE, PASS(BL):: READ_AND_SET_LINE!(IU, [EOL], [EOF]) --LOADS ONE LINE FROM IU TO BL%LN
      PROCEDURE, PASS(BL):: READ_SCRATCH=> READ_SCRATCH_LINE!([LINE], [ERROR])
      PROCEDURE, PASS(BL):: UPDATE_NLINE=> UPDATE_BLOCK_NLINE
      PROCEDURE, PASS(BL):: CLOSE_SCRATCH=>CLOSE_SCRATCH_GENERIC_BLOCK
      GENERIC            :: MAKE_SCRATCH => MAKE_SCRATCH_FILE, MAKE_SCRATCH_FILE_SUBFILE
      PROCEDURE, PASS(BL):: MAKE_SCRATCH_FILE        !(KEEPPOS)
      PROCEDURE, PASS(BL):: MAKE_SCRATCH_FILE_SUBFILE!(ISTART,[ISTOP]) --starting line and ending line
      PROCEDURE, PASS(BL):: ALLOC_LN
      PROCEDURE, PASS(BL):: DESTROY=> DEALLOCATE_GENERIC_BLOCK
      FINAL::                       FINAL_DEALLOCATE_GENERIC_BLOCK
  END TYPE
  !
  CONTAINS
  !
  SUBROUTINE LOAD_GENERIC_BLOCK(BL, IU, IOUT, LINE, END_KEY, END_NOT_FOUND, FOUND_BEGIN, BEGIN_OPTIONAL, NO_BACKSPACE, SKIP, NO_LOAD, ONLY_LOAD, SKIP_END_KEY )
    CLASS(GENERIC_BLOCK_READER),          INTENT(INOUT):: BL             ! DATA_TYPE THAT HOLDS BLOCK LINKED LIST
    INTEGER,                              INTENT(IN   ):: IU             ! UNIT NUMBER THAT BLOCK ORIGINATED FROM AND LOADED FROM. IF "LINE" IS NOT PROVDED OR "INTERNAL" KEYWORD IS FOUND, THEN BLOCK LOADS ON IU
    INTEGER,                    OPTIONAL, INTENT(IN   ):: IOUT           ! FILE TO WRITE ERROR INFORMATION TOO. SET TO ZERO TO NOT USE
    CHARACTER(*),               OPTIONAL, INTENT(INOUT):: LINE           ! LINE THAT HOLDS STARTING PART OF BLOCK, VIZ. "BEGIN BLOCKNAME". IF BEGIN IS FOUND, THEN BLOCK IS LOADED ON IU.
    CHARACTER(*),               OPTIONAL, INTENT(IN   ):: END_KEY        ! BLOCK TERMINATOR WORKD. IF NOT PROVIVED, THEN SET TO "END"
    LOGICAL,                    OPTIONAL, INTENT(  OUT):: END_NOT_FOUND  ! RETURNS TRUE ON ERROR WITH FINDING "END_KEY" (viz. reached end of file), IF NOT PRESENT THEN ERROR IS RAISED WHEN INPUT FINDS "BEGIN" BUT BLOCK FAILES TO FIND "END_KEY"
    LOGICAL,                    OPTIONAL, INTENT(  OUT):: FOUND_BEGIN    ! RETURNS TRUE IF THE KEYWORD BEGIN WAS FOUND. USED IN CASE THERE IS NO BL%NAME FOUND.
    LOGICAL,                    OPTIONAL, INTENT(IN   ):: BEGIN_OPTIONAL ! IF TRUE THEN BLOCK WILL LOAD IRRELEVANT OF BEGIN BEING FOUND
    LOGICAL,                    OPTIONAL, INTENT(IN   ):: NO_BACKSPACE   ! IF PRESENT AND SET TRUE, A FAILED LOAD OF BLOCK DOES NOT BACKSPACE FILE UNIT. DEFAULT IS FALSE, WHEN NOT SPECIFIED
    CHARACTER(*), DIMENSION(:), OPTIONAL, INTENT(IN   ):: SKIP           ! ARRAY OF BLOCK NAMES TO NOT LOAD...IF FOUND, WILL AUTOMATICALLY SKIP TO END STATEMENT WITHOUT LOADING
    CHARACTER(*), DIMENSION(:), OPTIONAL, INTENT(IN   ):: NO_LOAD        ! ARRAY OF BLOCK NAMES TO NOT LOAD...IF FOUND, INPUT LINE STOPS AND MOVES BACK ONE LINE
    CHARACTER(*), DIMENSION(:), OPTIONAL, INTENT(IN   ):: ONLY_LOAD      ! ARRAY OF BLOCK NAMES THAT CAN BE LOADED, OTEHRWISE STOP LOAD
    CHARACTER(*), DIMENSION(:), OPTIONAL, INTENT(IN   ):: SKIP_END_KEY   ! ARRAY OF NAMES THAT IF PRESENT AFTER "END" RESULT IN "END" BEING IGNORED
    !CHARACTER(256):: FLAG
    INTEGER:: N,LLOC,ISTART,ISTOP!,EOL
    LOGICAL:: LOAD,EOF, ALLOW_BACK
    !
    IF(ALLOCATED(BL%NAME))    DEALLOCATE(BL%NAME)
    IF(ALLOCATED(BL%EXTRA))   DEALLOCATE(BL%EXTRA)
    !IF(ALLOCATED(BL%END_KEY)) DEALLOCATE(BL%END_KEY)  --DEALLOCATED IN SET_BLOCK_END_KEY
    !
    IF(PRESENT(IOUT)) THEN
        BL%IOUT=IOUT
    ELSE
        BL%IOUT=Z
    END IF
    !
    BL%IU=IU
    !
    IF(PRESENT(NO_BACKSPACE)) THEN
        ALLOW_BACK= .NOT. NO_BACKSPACE
    ELSE
        ALLOW_BACK = TRUE
    END IF
    !
    IF(PRESENT(LINE)) THEN
        IF(.NOT. ALLOCATED(BL%LN)) ALLOCATE( CHARACTER(BL%LINE_LEN):: BL%LN )
        BL%LN = ADJUSTL(LINE)
        N = COMMENT_INDEX(BL%LN)
        EOF=FALSE
    ELSE
        CALL READ_AND_SET_LINE(BL, IU, EOL=N, EOF=EOF)
    END IF
    !
    IF(PRESENT(BEGIN_OPTIONAL)) THEN
        LOAD = BEGIN_OPTIONAL
    ELSE
        LOAD = FALSE
    END IF
    !
    CALL SET_BLOCK_END_KEY(BL, END_KEY)
    !
    LLOC=ONE
    CALL PARSE_WORD_UP(BL%LN,LLOC,ISTART,ISTOP)
    !
    IF(BL%LN(ISTART:ISTOP) == 'BEGIN') THEN
        CALL PARSE_WORD_UP(BL%LN,LLOC,ISTART,ISTOP)
        BL%NAME = BL%LN(ISTART:ISTOP)
        !
        LOAD=TRUE
        IF(PRESENT(SKIP)) THEN
            IF(ANY(BL%NAME == SKIP)) THEN
                DO WHILE (LOAD)
                      CALL READ_AND_SET_LINE(BL, BL%IU, EOF=EOF)
                      IF(EOF.AND. .NOT.PRESENT(END_NOT_FOUND)) CALL STOP_ERROR(INFILE=BL%IU,OUTPUT=BL%IOUT,MSG='GENERIC BLOCK LOADER ERROR: REACHED THE END OF THE FILE BEFORE LOCATING THE KEYWORD TO CLOSE THE BLOCK.'//BLN//'THE BLOCK THAT WAS BEING LOADED IS "'//BL%NAME//'" AND WAS EXPECTING THE FOLLOWING KEYWORD TO CLOSE/END THE BLOCK: "'//TRIM(BL%END_KEY)//'"'//BLN//'PLEASE CHECK INPUT TO ENSURE THAT THE BLOCK WAS PROPERLY CLOSED WITH THAT KEYWORD.')
                      LLOC=ONE
                      CALL PARSE_WORD_UP(BL%LN,LLOC,ISTART,ISTOP,TRUE)
                      IF( BL%LN(ISTART:ISTOP)==BL%END_KEY) THEN
                                                               LOAD = FALSE
                                                               EOF  = FALSE
                      ELSEIF(EOF) THEN
                                                               LOAD = FALSE
                      END IF
                END DO
            END IF
        END IF
        IF(PRESENT(NO_LOAD)) THEN
            IF(ANY(BL%NAME == NO_LOAD)) THEN
                  BL%NAME = BLNK
                  IF(EOF) THEN; BL%EXTRA = 'NO_LOAD'
                  ELSE;         BL%EXTRA = 'NO_LOAD' !TRIM(FLAG) --COULD DO THIS IF NECESSARY TO RETURN LINE LOADED
                  END IF
                  BL%NLINE = Z
                  IF(.NOT. PRESENT(LINE) .AND. ALLOW_BACK) BACKSPACE(IU)
                  IF(PRESENT(FOUND_BEGIN  )) FOUND_BEGIN   = FALSE
                  IF(PRESENT(END_NOT_FOUND)) END_NOT_FOUND = FALSE
                  RETURN
            END IF
        END IF
        IF(PRESENT(ONLY_LOAD)) THEN
            IF(.NOT. ANY(BL%NAME == ONLY_LOAD)) THEN
                  BL%NAME = BLNK
                  IF(EOF) THEN; BL%EXTRA = 'NO_LOAD'
                  ELSE;         BL%EXTRA = 'NO_LOAD' !TRIM(FLAG) --COULD DO THIS IF NECESSARY TO RETURN LINE LOADED
                  END IF
                  BL%NLINE = Z
                  IF(.NOT. PRESENT(LINE) .AND. ALLOW_BACK) BACKSPACE(IU)
                  IF(PRESENT(FOUND_BEGIN  )) FOUND_BEGIN   = FALSE
                  IF(PRESENT(END_NOT_FOUND)) END_NOT_FOUND = FALSE
                  RETURN
            END IF
        END IF
        !
        IF(LOAD) THEN  !ONLY FALSE IF SKIP IS TRUE
           !
           !N =  COMMENT_INDEX(FLAG)                           !N = LEN_TRIM or INDEX(#)-1
           CALL PARSE_WORD(BL%LN,LLOC,ISTART,ISTOP)
           !
           IF(N - ISTART >= Z) THEN
               BL%EXTRA=BL%LN(ISTART:N)
           ELSE
               BL%EXTRA=BLNK
           END IF
           !
           CALL LOAD_INNER_GENERIC_BLOCK(BL, END_NOT_FOUND=END_NOT_FOUND, SKIP_END_KEY=SKIP_END_KEY)
           !
        ELSE !BLOCK WAS SKIPPED
           IF(PRESENT(END_NOT_FOUND)) END_NOT_FOUND = BL%LN(ISTART:ISTOP).NE.BL%END_KEY
           IF(EOF) THEN;                   BL%EXTRA = 'EOF'
           ELSE;                           BL%EXTRA = BLNK !TRIM(FLAG) --COULD DO THIS IF NECESSARY TO RETURN LINE LOADED
           END IF
        END IF
        !
        IF(PRESENT(FOUND_BEGIN)) FOUND_BEGIN = TRUE
        IF(PRESENT(LINE)       ) CALL READ_TO_DATA(LINE,IU,BL%IOUT)
        !
    ELSEIF(LOAD.AND. .NOT. PRESENT(LINE) ) THEN
        !
        BL%NAME = 'NO_BEGIN'
        BL%EXTRA=BLNK
        !
        BACKSPACE(IU)
        !
        CALL LOAD_INNER_GENERIC_BLOCK(BL, END_NOT_FOUND=END_NOT_FOUND, SKIP_END_KEY=SKIP_END_KEY)
        !
        IF(PRESENT(FOUND_BEGIN)) FOUND_BEGIN = FALSE
        IF(PRESENT(LINE)       ) CALL READ_TO_DATA(LINE,IU,BL%IOUT)
    ELSE
        !BL%NAME = BLNK !' '
        BL%NAME = BL%LN(ISTART:ISTOP)
        IF(EOF) THEN; BL%EXTRA = 'EOF'
        ELSE;         BL%EXTRA = BLNK !TRIM(FLAG) --COULD DO THIS IF NECESSARY TO RETURN LINE LOADED
        END IF
        BL%NLINE = Z
        IF(.NOT. PRESENT(LINE) .AND. ALLOW_BACK) BACKSPACE(IU)
        IF(PRESENT(FOUND_BEGIN  )) FOUND_BEGIN   = FALSE
        IF(PRESENT(END_NOT_FOUND)) END_NOT_FOUND = FALSE
    END IF
    !
  END SUBROUTINE
  !
  RECURSIVE SUBROUTINE LOAD_INNER_GENERIC_BLOCK(BL, END_KEY, IU, IOUT, END_NOT_FOUND, SKIP_END_KEY)
    CLASS(GENERIC_BLOCK_READER),         INTENT(INOUT):: BL
    CHARACTER(*),              OPTIONAL, INTENT(IN   ):: END_KEY
    INTEGER,                   OPTIONAL, INTENT(IN   ):: IU
    INTEGER,                   OPTIONAL, INTENT(IN   ):: IOUT
    LOGICAL,                   OPTIONAL, INTENT(OUT  ):: END_NOT_FOUND
    CHARACTER(*), DIMENSION(:),OPTIONAL, INTENT(IN   ):: SKIP_END_KEY ! ARRAY OF NAMES THAT IF PRESENT AFTER "END" RESULT IN "END" BEING IGNORED
    INTEGER:: N, EOL, LLOC, ISTART, ISTOP
    LOGICAL:: EOF_CHK
    CHARACTER(:), ALLOCATABLE:: END_CHECK, END_WORD
    CHARACTER(14):: TXT
    !
    IF(PRESENT(IU))   BL%IU  = IU
    IF(PRESENT(IOUT)) BL%IOUT= IOUT
    IF(PRESENT(END_NOT_FOUND)) END_NOT_FOUND = FALSE
    !
    IF(PRESENT(END_KEY)) THEN
                                       N = LEN_TRIM( ADJUSTL(END_KEY) ) + ONE
                                       ALLOCATE(CHARACTER(N):: END_WORD)
                                       END_WORD(:) = ADJUSTL(END_KEY)
                                       CALL UPPER(END_WORD)
    ELSEIF(ALLOCATED(BL%END_KEY)) THEN
                                       ALLOCATE(END_WORD, SOURCE=BL%END_KEY)
    ELSE
                                       ALLOCATE(END_WORD, SOURCE='END ')
    END IF
    !
    ALLOCATE(END_CHECK, SOURCE=END_WORD)  !PREALLOCATE TO GET CORRECT SIZE
    !
    CALL BL%LIST%INIT()
    !
    DO 
        CALL READ_AND_SET_LINE(BL, BL%IU, EOL, EOF_CHK)
        !
        END_CHECK(:) = BL%LN(:EOL)  !WITHOUT EOL COULD CAUSE END_CHECK='END#', BECAUSE ALLOCATABLE, HAVE TO INCLUDE (:)
        CALL UPPER(END_CHECK)
        !
        IF ( EOF_CHK .OR. (END_CHECK == END_WORD .AND. .NOT. PRESENT(SKIP_END_KEY))) EXIT    !BL%LN IS SET TO '' AT END OF FILE => EOF=TRUE
        !
        IF ( END_CHECK == END_WORD ) THEN  !SKIP_END_KEY must be present for this to be true
            !
            LLOC = LEN_TRIM(END_WORD) + ONE
            !
            CALL PARSE_WORD_UP(BL%LN(:EOL),LLOC,ISTART,ISTOP)
            !
            IF    (ISTOP < ISTART) THEN;                               EXIT
            ELSEIF( ALL(BL%LN(ISTART:ISTOP) .NE. SKIP_END_KEY) ) THEN; EXIT   !IF NOT TRUE THEN SECOND KEY FAILED. eg SKIP_END_KEY=[DO, WHERE, IF] would not exit if END IF, END DO, and END WHERE is found
            END IF
            !
        ENDIF
        !
        IF(LEN_TRIM(BL%LN(:EOL)) > TEN) THEN  !CHECK IF INCLUDE STATEMENT IS FOUND TO LOAD EXTERNAL FILE
                       TXT = BL%LN(:EOL)
                       CALL UPPER(TXT)
                       IF (TXT == 'BLOCK_INCLUDE ') THEN !FOUND BLOCK FILE KEYWORD, ADD SEPARATE FILE TO BLOCK
                           CALL BLOCK_INCLUDE_STATEMENT(BL, TXT, LLOC, EOL, N)
                       ELSE
                           CALL ADD_BLOCK_LINE(BL,EOL,N)
                       END IF
        ELSE
            CALL ADD_BLOCK_LINE(BL,EOL,N)
        END IF
        !
    END DO
    !
    IF(END_CHECK .NE. END_WORD) THEN
        IF(PRESENT(END_NOT_FOUND)) THEN
            END_NOT_FOUND = TRUE
            IF(EOF_CHK) BL%EXTRA = 'EOF'
        ELSE
            CALL STOP_ERROR(INFILE=BL%IU,OUTPUT=BL%IOUT,MSG='GENERIC BLOCK LOADER ERROR: THIS ROUTINE ATTEMPTED TO LOAD A "BEGIN BLOCK_NAME FOLLOWED BY INPUT AND THEN THE BLOCK IS ENDED WITH THE KEYWORD"'//TRIM(END_WORD)//'".'//NL//'HOWEVER THE BLOCK INPUT FAILED TO FIND THE ENDING KEYWORD AFTER THE BEGIN KEYWORD AND REACHED THE END OF THE FILE INSTEAD.'//BLN//'THE BLOCK THAT WAS BEING LOADED IS "BEGIN '//BL%NAME//'" AND WAS EXPECTING THE FOLLOWING KEYWORD TO END THE BLOCK: "'//TRIM(END_WORD)//'"'//BLN//'PLEASE CHECK INPUT TO ENSURE THAT THE BLOCK WAS PROPERLY ENDED WITH THAT KEYWORD.')
        END IF
    END IF
    !
    BL%NLINE = BL%LIST%LEN()
    !
  END SUBROUTINE
  !
  RECURSIVE SUBROUTINE BLOCK_INCLUDE_STATEMENT(BL, TXT, LLOC, EOL, N)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    CHARACTER(14),               INTENT(INOUT):: TXT
    INTEGER,                     INTENT(INOUT):: LLOC, EOL, N  ! TEMP VARIABLES
    LOGICAL:: EOF_CHK
    TYPE(GENERIC_INPUT_FILE):: FL
    !
    LLOC = 15
    CALL FL%OPEN(BL%LN,LLOC,BL%IOUT,BL%IU,NO_INTERNAL=TRUE, NO_CONSTANT=TRUE)
    CALL READ_AND_SET_LINE(BL, FL%IU, EOL, EOF_CHK)
    !
    DO WHILE (.NOT. EOF_CHK)
        !
        IF(LEN_TRIM(BL%LN(:EOL)) > TEN) THEN  !CHECK IF INCLUDE STATEMENT IS FOUND TO LOAD EXTERNAL FILE
                       TXT = BL%LN(:EOL)
                       CALL UPPER(TXT)
                       IF (TXT == 'BLOCK_INCLUDE ') THEN
                           CALL BLOCK_INCLUDE_STATEMENT(BL, TXT, LLOC, EOL, N)
                       ELSE
                           CALL ADD_BLOCK_LINE(BL,EOL,N)
                       END IF
        ELSE
            CALL ADD_BLOCK_LINE(BL,EOL,N)
        END IF
        !
        CALL READ_AND_SET_LINE(BL, FL%IU, EOL, EOF_CHK)
    END DO
    !
    CALL FL%CLOSE()
    !
  END SUBROUTINE
  !
  SUBROUTINE ADD_BLOCK_LINE(BL,EOL,N)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    INTEGER,                     INTENT(IN   ):: EOL
    INTEGER,                     INTENT(OUT  ):: N
    !
    N = LEN_TRIM( BL%LN(1:EOL) ) + ONE      !ADD AN EXTRA SPACE FOR URWORD
    !
    IF(N <= BL%LINE_LEN) BL%LN(N:N) = ' '   !CLEAR OUT EXTRA SPACE FOR URWORD, OVER WRITES # IF LOCATED THERE
    !
    IF(N > BL%LINE_LEN) CALL STOP_ERROR(LINE=BL%LN,INFILE=BL%IU,OUTPUT=BL%IOUT,MSG='MODULE GENERIC_BLOCK_READER_INSTRUCTION ERROR: LINE SIZE OVERFLOW, MAX LINE SIZE IS SET TO '//NUM2STR(BL%LINE_LEN)//' CHARACTERS. PLEASE ENSURE THAT YOU COMMENT DATA THAT IS NOT LOADED INTO OneWater WITH A # SO IT IS NOT LOADED INTO MEMORY. OTHERWISE YOU MAY HAVE TO RECOMPILE CODE WITH A LARGER BLOCK INPUT "LINE_LEN" VALUE.')
    !
    CALL BL%LIST%ADD( BL%LN(1:N) )
    !
  END SUBROUTINE
  !
  SUBROUTINE SET_BLOCK_END_KEY(BL, END_KEY)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    CHARACTER(*),      OPTIONAL, INTENT(IN   ):: END_KEY
    INTEGER:: N
    !
    IF(ALLOCATED(BL%END_KEY)) DEALLOCATE(BL%END_KEY)
    !
    IF(PRESENT(END_KEY)) THEN
                             N = LEN_TRIM( ADJUSTL(END_KEY) ) + ONE
                             ALLOCATE(CHARACTER(N):: BL%END_KEY)
                             BL%END_KEY(:) = ADJUSTL(END_KEY)
                             CALL UPPER(BL%END_KEY)
    ELSE
                             ALLOCATE(BL%END_KEY, SOURCE='END ')
    END IF
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_BLOCK_LINE_LEN(BL,N)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    INTEGER,                     INTENT(IN   ):: N
    !
    IF(N > Z) THEN
        BL%LINE_LEN = N
    ELSE
        BL%LINE_LEN = 1250
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE UPDATE_BLOCK_NLINE(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    BL%NLINE = BL%LIST%LEN()
    !
  END SUBROUTINE
  !
  SUBROUTINE START_OF_BLOCK(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    CALL BL%LIST%START()
    CALL BL%LIST%SET_LN()
    BL%LINE => BL%LIST%LN
    !
  END SUBROUTINE
  !
  SUBROUTINE NEXT_BLOCK_LINE(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    CALL BL%LIST%NEXT()
    CALL BL%LIST%SET_LN()
    BL%LINE => BL%LIST%LN
    !
  END SUBROUTINE
  !
  SUBROUTINE MOVE_BACK_BLOCK_LINE(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    CALL BL%LIST%BACK()
    CALL BL%LIST%SET_LN()
    BL%LINE => BL%LIST%LN
    !
  END SUBROUTINE
  !
  SUBROUTINE SET_BLOCK_LINE(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    CALL BL%LIST%SET_LN()
    BL%LINE => BL%LIST%LN
    !
  END SUBROUTINE
  !
  FUNCTION BLOCK_AT_END(BL) RESULT(IS_ASSOCIATED)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    LOGICAL:: IS_ASSOCIATED
    !
    IS_ASSOCIATED = .NOT. BL%LIST%IS_ASSOCIATED()
    !
  END FUNCTION
  !
  FUNCTION BLOCK_NOT_AT_END(BL) RESULT(IS_ASSOCIATED)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    LOGICAL:: IS_ASSOCIATED
    !
    IS_ASSOCIATED = BL%LIST%IS_ASSOCIATED()
    !
  END FUNCTION
  !
  SUBROUTINE INSERT_LINE_INTO_BLOCK(BL,LINE,POS)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    CHARACTER(*),    INTENT(IN):: LINE
    INTEGER,OPTIONAL,INTENT(IN):: POS
    !
    IF(PRESENT(POS)) THEN
                         CALL BL%LIST%ADD(LINE, POS)
    ELSE
                         CALL BL%LIST%ADD(LINE)
    END IF
    !
    CALL BL%LIST%SET_LN()
    BL%LINE => BL%LIST%LN
    BL%NLINE = BL%LIST%LEN()
  END SUBROUTINE
  !
  SUBROUTINE DELETE_CURRENT_LINE(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    CALL BL%LIST%POP(Z)
    BL%NLINE = BL%NLINE - ONE
    !
    CALL BL%LIST%SET_LN()
    BL%LINE => BL%LIST%LN
    !
  END SUBROUTINE
  !
  SUBROUTINE REMOVE_LINE_AT(BL,POS)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    INTEGER, OPTIONAL, INTENT(IN):: POS
    INTEGER:: N
    !
    N=BL%LIST%GETPOS()
    IF(PRESENT(POS)) THEN ; IF(POS<N) N=N-1
    ENDIF
    CALL BL%LIST%POP(POS)
    BL%NLINE = BL%LIST%LEN()
    CALL BL%LIST%POS(N)
    CALL BL%LIST%SET_LN()
    BL%LINE => BL%LIST%LN
    !
  END SUBROUTINE
  !
  !
  FUNCTION GET_LINE_POS(BL) RESULT(POS)
    CLASS(GENERIC_BLOCK_READER), INTENT(IN):: BL
    INTEGER:: POS
    !
    POS=BL%LIST%GETPOS()
    !
  END FUNCTION
  !
  SUBROUTINE GOTO_LINE_POS(BL, POS)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    INTEGER, INTENT(IN):: POS
    !
    CALL BL%LIST%POS(POS)
    CALL BL%LIST%SET_LN()
    BL%LINE => BL%LIST%LN
    !
  END SUBROUTINE
  !
  SUBROUTINE MAKE_SCRATCH_FILE(BL, KEEPPOS)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    LOGICAL, OPTIONAL, INTENT(IN):: KEEPPOS
    INTEGER:: I
    LOGICAL:: START
    !
    IF(BL%SCRATCH.NE.Z) CLOSE(BL%SCRATCH, IOSTAT=I)
       BL%SCRATCH = Z
    !
    START = TRUE
    IF(PRESENT(KEEPPOS)) START = .NOT. KEEPPOS
    !
    IF(START) CALL BL%LIST%START()
    !
    CALL BL%LIST%SET_LN()
    CALL GENERIC_SCRATCH_FILE(BL%SCRATCH, BL%IOUT, BUFFER_BLOCKSIZE=1048576, LINE=BL%LIST%LN, INFILE=BL%IU)  !BUFF=1MB, block should not ever be bigger than this...so scartch file will remain in RAM for faster reading.
    DO I=BL%LIST%GETPOS(), BL%NLINE
          !
          WRITE(BL%SCRATCH, '(A)') BL%LIST%LN
          IF(  BL%LIST%LN=='ERROR' ) EXIT
          CALL BL%LIST%NEXT()
          CALL BL%LIST%SET_LN()
    END DO
    !
    REWIND(BL%SCRATCH)
    !
  END SUBROUTINE
  !
  SUBROUTINE MAKE_SCRATCH_FILE_SUBFILE(BL, ISTART, ISTOP)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    INTEGER,           INTENT(IN):: ISTART
    INTEGER, OPTIONAL, INTENT(IN):: ISTOP
    INTEGER:: I
    !
    IF(BL%SCRATCH.NE.Z) CLOSE(BL%SCRATCH, IOSTAT=I)
       BL%SCRATCH = Z
    !
    IF(ISTART.NE.Z) CALL GOTO_LINE_POS(BL, ISTART)
    !
    CALL GENERIC_SCRATCH_FILE(BL%SCRATCH, BL%IOUT, BUFFER_BLOCKSIZE=1048576, LINE=BL%LIST%LN, INFILE=BL%IU)  !BUFF=1MB, block should not ever be bigger than this...so scartch file will remain in RAM for faster reading.
    !
    IF(PRESENT(ISTOP)) THEN
       DO I=ISTART, ISTOP
             !
             WRITE(BL%SCRATCH, '(A)') BL%LIST%LN
             IF(  BL%LIST%LN=='ERROR' ) EXIT
             CALL BL%LIST%NEXT()
             CALL BL%LIST%SET_LN()
       END DO
    ELSE
       DO I=BL%LIST%GETPOS(), BL%NLINE
          !
          WRITE(BL%SCRATCH, '(A)') BL%LIST%LN
          IF(  BL%LIST%LN=='ERROR' ) EXIT
          CALL BL%LIST%NEXT()
          CALL BL%LIST%SET_LN()
       END DO
    END IF
    !
    REWIND(BL%SCRATCH)
    !
  END SUBROUTINE
  !
  SUBROUTINE READ_SCRATCH_LINE(BL, ERROR, LINE)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    LOGICAL,      OPTIONAL,      INTENT(OUT  ):: ERROR
    CHARACTER(*), OPTIONAL,      INTENT(OUT  ):: LINE
    INTEGER:: IERR
    !
    IERR = Z
    !
    IF(PRESENT(LINE)) THEN
                          IF(BL%SCRATCH.NE.Z) THEN
                              READ(BL%SCRATCH, '(A)' , IOSTAT=IERR) LINE
                              IF(IERR .NE. Z) LINE = BLNK
                          ELSE
                              LINE = BLNK
                          END IF
    ELSE
                          IF(.NOT. ALLOCATED(BL%LN)) ALLOCATE( CHARACTER(BL%LINE_LEN):: BL%LN )
                          !
                          IF(BL%SCRATCH.NE.Z) THEN
                              READ(BL%SCRATCH, '(A)' , IOSTAT=IERR) BL%LN
                          ELSE
                              BL%LN = BLNK
                          END IF
    END IF
    !
    IF(PRESENT(ERROR)) ERROR = IERR .NE. Z
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOC_LN(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    IF(.NOT. ALLOCATED(BL%LN)) ALLOCATE( CHARACTER(BL%LINE_LEN):: BL%LN )
  END SUBROUTINE
  !
  SUBROUTINE READ_AND_SET_LINE(BL, IU, EOL, EOF)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    INTEGER,           INTENT(IN ):: IU
    INTEGER, OPTIONAL, INTENT(OUT):: EOL
    LOGICAL, OPTIONAL, INTENT(OUT):: EOF
    !
    IF(.NOT. ALLOCATED(BL%LN)) ALLOCATE( CHARACTER(BL%LINE_LEN):: BL%LN )
    !
    CALL READ_TO_DATA(BL%LN,IU,BL%IOUT,EOL=EOL,EOF=EOF)
    !
  END SUBROUTINE
  !
  SUBROUTINE INIT_GENERIC_BLOCK(BL, IU, IOUT, LINE_LEN)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    INTEGER,           OPTIONAL, INTENT(IN   ):: IU, IOUT, LINE_LEN
    !
    CALL BL%LIST%INIT()
    BL%LINE_LEN = 1250
    BL%NLINE = Z
    BL%IOUT  = Z
    BL%IU    = Z
    BL%LINE => NULL()
    !
    IF(PRESENT(IU))       BL%IU       = IU 
    IF(PRESENT(IOUT))     BL%IOUT     = IOUT
    IF(PRESENT(LINE_LEN)) BL%LINE_LEN = LINE_LEN
    !
    IF(ALLOCATED(BL%NAME))    DEALLOCATE(BL%NAME)
    IF(ALLOCATED(BL%EXTRA))   DEALLOCATE(BL%EXTRA)
    IF(ALLOCATED(BL%END_KEY)) DEALLOCATE(BL%END_KEY)
    !
    IF(BL%SCRATCH.NE.Z) CLOSE(BL%SCRATCH)
       BL%SCRATCH = Z
    !
  END SUBROUTINE
  !
  SUBROUTINE CLOSE_SCRATCH_GENERIC_BLOCK(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    IF(BL%SCRATCH.NE.Z) CLOSE(BL%SCRATCH)
       BL%SCRATCH = Z
    !
  END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_GENERIC_BLOCK(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    CALL BL%LIST%DESTROY()
    BL%NLINE = Z
    BL%IOUT  = Z
    BL%IU    = Z
    BL%LINE => NULL()
    !
    IF(ALLOCATED(BL%LN))      DEALLOCATE(BL%LN)
    IF(ALLOCATED(BL%NAME))    DEALLOCATE(BL%NAME)
    IF(ALLOCATED(BL%EXTRA))   DEALLOCATE(BL%EXTRA)
    IF(ALLOCATED(BL%END_KEY)) DEALLOCATE(BL%END_KEY)
    !
    IF(BL%SCRATCH.NE.Z) CLOSE(BL%SCRATCH)
       BL%SCRATCH = Z
    !
  END SUBROUTINE
  !
  SUBROUTINE FINAL_DEALLOCATE_GENERIC_BLOCK(BL)
    TYPE(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    CALL DEALLOCATE_GENERIC_BLOCK(BL)
    !
    BL%LINE_LEN = 1250
    !
    IF(ALLOCATED(BL%LN))  DEALLOCATE(BL%LN)
    !
  END SUBROUTINE
  !
END MODULE
!
!!
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
!
MODULE ADJACENCY_LIST_INSTRUCTION!, ONLY: ADJ_LST, VERTEX_BACKPATH, VERTEX_VERTEX_PATH 
  !
  ! Construct an Adjacency list for vectex points and their connections. It may also include a weight (WT) for each connection.
  !  
  !  Can apply Dijkstra shortest path algorithm to a vertex V1 to all possible connecting points.
  !
  !     Shortest path is optimized for single starting location (V1), but many ending locations (V2)
  !     For many starting locations and advanced path options use MODULE MULTI_DIJKSTRA_SHORTEST_PATH
  !
  ! Usage:
  !   TYPE(ADJ_LST):: ADJ
  !
  !   CALL ADJ%INIT(DIM)                  DIM = Number of Vertex points that are identified from 1 to DIM (for example NSEG)
  !
  !   CALL ADJ%ADD(V1,V2,[WT],[ERR])      Add connection from Vertex V1 to V2 with optional weight WT -- WT could be Segment Length
  !
  !   CALL ADJ%SORT()                     Sorts Adjancy connections, may provide some improvement for being well ordered and clairity for output.
  !                                       For example Vertex 5 could be connected to ADJ%VER(5)%CON = [6, 2, 8]. The sort would ADJ%VER(5)%CON = [2, 6, 8]
  !
  !   CALL ADJ%GET_PATH(V1,V2,PATH,DIM)   Determines shortests path between V1 and V2. The number of Vertexs in path is DIM and hte actual vertexs is in PATH 
  !                                       INTEGER (IN ):: V1, V2
  !                                       INTEGER (OUT):: DIM                => Set to 0 if no backpath exists
  !                                       INTEGER, ALLOCATABLE:: PATH(DIM)
  !
  !   CALL ADJ%SHORTEST_PATH(V1)          Called by ADJ%GET_PATH if V1 does not equal ADJ%V1_BACK_PATH 
  !                                       Sets ADJ%V1_BACK_PATH to V1 and populates ADJ%BACKPATH(DIM) such that the index represents any vertex's next vertex backward towards V1
  USE CONSTANTS
  USE NUM2STR_INTERFACE,        ONLY: NUM2STR
  USE ALLOC_INTERFACE,          ONLY: ALLOC
  USE WARNING_TYPE_INSTRUCTION, ONLY: WARNING_TYPE
  USE SORT_INTERFACE,           ONLY: SORT           ! Calls SORT_INT_VECTOR_DBLE_VECTOR!(DIM1,IVEC,DVEC)
  USE BINARY_HEAP_INSTRUCTION,  ONLY: BINARY_HEAP
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: ADJ_LST, VERTEX_BACKPATH, VERTEX_VERTEX_PATH, BUILD_DIJKSTRA_PATH
  !
  TYPE VERTEX_BACKPATH
      LOGICAL:: GOT_BACK = FALSE
      INTEGER:: N  = Z
      INTEGER:: V1 = Z
      INTEGER, DIMENSION(:), ALLOCATABLE:: BACKPATH
      !
      CONTAINS
      !
      PROCEDURE, PASS(VTX):: INIT      => ALLOCATE_VERTEX_BACKPATH !(DIM, V1)
      PROCEDURE, PASS(VTX):: SET_V1    => ALLOCATE_VERTEX_BACKPATH !(DIM, V1)
      PROCEDURE, PASS(VTX):: IS_MATCH  => IS_VERTEX_MATCH !(V1)
      PROCEDURE, PASS(VTX):: MATCHED   => IS_VERTEX_AND_DIM_MATCH !(V1,DIM)
      PROCEDURE, PASS(VTX):: CLOSEST   => CLOSEST_COMMON_VERTEX_BACKPATH!(V2, V3, [JUNCT], [DN2], [DN3]))
      !PROCEDURE, PASS(VTX):: CLOSEST   => CLOSEST_COMMON_VERTEX_BACKPATH!(VTY,    JUNCT,  [DN2], [DN3]))
      PROCEDURE, PASS(VTX):: BACKSTEP  => BACKSTEP_VERTEX_BACKPATH      !(V2) RESULT(BACKSTEP)
      PROCEDURE, PASS(VTX):: NSTEP     => NSTEP_VERTEX_BACKPATH         !(V2)
      FINAL:: FINAL_DEALLOCATE_BINARY_HEAP
  END TYPE
  !
  ! ----------------------------------------------------------------------------------
  !
  TYPE VERTEX_VERTEX_PATH
      INTEGER:: N  = Z
      INTEGER:: V1 = Z
      INTEGER:: V2 = Z
      INTEGER, DIMENSION(:), ALLOCATABLE:: PATH
      !
      CONTAINS
      !
      PROCEDURE, PASS(VTX):: INIT   =>      SET_V_VERTEX_VERTEX_PATH  !(V1, V2)
      PROCEDURE, PASS(VTX):: BUILD  =>  MAKE_PATH_VERTEX_VERTEX_PATH  !(BACKPATH, [REBUILD])
      PROCEDURE, PASS(VTX):: SET_V1 =>     SET_V1_VERTEX_VERTEX_PATH  !(V1) If V1 does not match current V2, then PATH is deallcoated
      PROCEDURE, PASS(VTX):: SET_V2 =>     SET_V2_VERTEX_VERTEX_PATH  !(V2) If V2 does not match current V2, then PATH is deallcoated
      PROCEDURE, PASS(VTX):: ALLOC  =>      ALLOC_VERTEX_VERTEX_PATH
  END TYPE
  !
  ! ----------------------------------------------------------------------------------
  !
  TYPE ADJ_LST_ELM
      INTEGER:: N = Z
      INTEGER,          DIMENSION(:), ALLOCATABLE:: CON  !Connection Vertex
      DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE:: WT   !Weight of Connection
  END TYPE
  !
  TYPE ADJ_LST
      INTEGER:: N = Z
      TYPE(ADJ_LST_ELM), DIMENSION(:), ALLOCATABLE:: VER  !Vertex ID
      !
      INTEGER:: V1_BACK_PATH = Z
      INTEGER, DIMENSION(:), ALLOCATABLE:: BACKPATH  !Holdest best backstep for any vertex -- Used by DIJKSTRA to keep track of the vertices which are currently in min HEAP.
      !
      LOGICAL, PRIVATE, DIMENSION(:), ALLOCATABLE:: SPT !Shortest Path Tree -- Used by DIJKSTRA to keep track of the vertices which are currently in min HEAP.
      !
      TYPE(BINARY_HEAP), PRIVATE:: HEAP                 !Scratch Space if GET_PATH/SHORTEST_PATH is invoked
      !
      CONTAINS
      !
      GENERIC             :: INIT           => ALLOCATE_ADJ_LST,        &  !(DIM)  -- Always destroys %VER connections
                                               RESET_CONNECTIONS_ADJ_LST   !()
      PROCEDURE, PASS(ADJ):: DIM            => GET_VER_DIM_ADJ_LST         !()
      PROCEDURE, PASS(ADJ):: ADD            => ADD_CONNECTION_ADJ_LST      !(V1,V2,[WT])  -- Reallocate VER if V1 or V2 > ADJ%N
      PROCEDURE, PASS(ADJ):: SET_CONNECTION => SET_CONNECTION_ADJ_LST      !(V1,V2,[WT])  -- Same as ADD but if V1 or V2 exceeds ADJ%N then raises an errror
      PROCEDURE, PASS(ADJ):: SET_WT         => SET_WT_ADJ_LST              !(V1,V2, WT )
      PROCEDURE, PASS(ADJ):: SCALE_WT       => SCALE_WT_ADJ_LST            !(V1,V2, SCALE )
      PROCEDURE, PASS(ADJ):: GET_WT         => GET_WT_ADJ_LST              !(V1,V2)
      GENERIC             :: SUM_WT         =>          SUM_WT_ADJ_LST, &  !(V1)
                                               SUM_WT_BACKPATH_ADJ_LST     !(V1, BACKPATH)
      PROCEDURE, PASS(ADJ):: SORT           => SORT_CONNECTIONS_ADJ_LST    !()
      GENERIC             :: CLOSEST_COMMON => CLOSEST_COMMON_V1_V2_ADJ_LST,               & ! (V1,   V2,          JUNCT, [UP1], [UP2])
                                               CLOSEST_COMMON_V1_V2_IMAP_ADJ_LST,          & ! (V1,   V2, I, IMAP, JUNCT, [UP1], [UP2]) 
                                               CLOSEST_COMMON_VERTEX_BACKPATH_ADJ_LST,     & ! (VTX, VTY,          JUNCT, [UP1], [UP2])  
                                               CLOSEST_COMMON_IMAP_VERTEX_BACKPATH_ADJ_LST   ! (VTX, VTY, I, IMAP, JUNCT, [UP1], [UP2])
      PROCEDURE, PASS(ADJ):: GET_PATH       => GET_PATH_DIJKSTRA_SHORTEST_PATH!(V1,V2,PATH,DIM)  -- Uses internal array
      GENERIC::              BUILD_BACKPATH => DIJKSTRA_SHORTEST_PATH_VERTEX,          &     ! (V1,                            [REBUILD])
                                               DIJKSTRA_SHORTEST_PATH_BACKPATH,        &     ! (V1, BACKPATH, [INTERNAL_COPY]           )
                                               DIJKSTRA_SHORTEST_PATH_VERTEX_BACKPATH, &     ! (    VTX,      [INTERNAL_COPY]           ) -- Assumes VTX%V1 is set to vertix
                                               DIJKSTRA_SHORTEST_PATH_VERTEX_VERTEX_BACKPATH ! (V1, VTX,      [INTERNAL_COPY], [REBUILD])
      !
      PROCEDURE, PASS(ADJ), PRIVATE:: ALLOCATE_ADJ_LST         !(DIM)
      PROCEDURE, PASS(ADJ), PRIVATE:: RESET_CONNECTIONS_ADJ_LST!()
      PROCEDURE, PASS(ADJ), PRIVATE:: DIJKSTRA_SHORTEST_PATH_VERTEX                 ! (V1,                            [REBUILD])
      PROCEDURE, PASS(ADJ), PRIVATE:: DIJKSTRA_SHORTEST_PATH_BACKPATH               ! (V1, BACKPATH, [INTERNAL_COPY]           )
      PROCEDURE, PASS(ADJ), PRIVATE:: DIJKSTRA_SHORTEST_PATH_VERTEX_BACKPATH        ! (    VTX,      [INTERNAL_COPY]           ) -- Assumes VTX%V1 is set to vertix
      PROCEDURE, PASS(ADJ), PRIVATE:: DIJKSTRA_SHORTEST_PATH_VERTEX_VERTEX_BACKPATH ! (V1, VTX,      [INTERNAL_COPY], [REBUILD])
      PROCEDURE, PASS(ADJ), PRIVATE:: CLOSEST_COMMON_V1_V2_ADJ_LST                  ! (V1,   V2,          JUNCT, [UP1], [UP2])
      PROCEDURE, PASS(ADJ), PRIVATE:: CLOSEST_COMMON_V1_V2_IMAP_ADJ_LST             ! (V1,   V2, I, IMAP, JUNCT, [UP1], [UP2])
      PROCEDURE, PASS(ADJ), PRIVATE:: CLOSEST_COMMON_VERTEX_BACKPATH_ADJ_LST        ! (VTX, VTY,          JUNCT, [UP1], [UP2])
      PROCEDURE, PASS(ADJ), PRIVATE:: CLOSEST_COMMON_IMAP_VERTEX_BACKPATH_ADJ_LST   ! (VTX, VTY, I, IMAP, JUNCT, [UP1], [UP2])
      PROCEDURE, PASS(ADJ), PRIVATE:: SUM_WT_ADJ_LST           !(V1)
      PROCEDURE, PASS(ADJ), PRIVATE:: SUM_WT_BACKPATH_ADJ_LST  !(V1, BACKPATH)
  END TYPE
  !
  ! ----------------------------------------------------------------------------------
  !
  INTERFACE BUILD_DIJKSTRA_PATH
      MODULE PROCEDURE BUILD_DIJKSTRA_PATH_VERTEX_VERTEX_PATH     !(VTX, VPATH)
      MODULE PROCEDURE BUILD_DIJKSTRA_PATH_V2_VERTEX_VERTEX_PATH  !(V2, VTX, VPATH)  
      MODULE PROCEDURE BUILD_DIJKSTRA_PATH_BACKPATH               !(V2, BACKPATH, PATH, DIM) 
  END INTERFACE
  !
  ! ----------------------------------------------------------------------------------
  !
  INTERFACE   ! VERTEX_VERTEX_PATH_SUBS
          !
      MODULE PURE SUBROUTINE MAKE_PATH_VERTEX_VERTEX_PATH(VTX, BACKPATH, REBUILD)
        CLASS(VERTEX_VERTEX_PATH), INTENT(INOUT):: VTX
        TYPE(VERTEX_BACKPATH),     INTENT(IN   ):: BACKPATH
        LOGICAL,         OPTIONAL, INTENT(IN   ):: REBUILD
      END SUBROUTINE
      !
      MODULE PURE SUBROUTINE EXTEND_VERTEX_VERTEX_PATH(VTX, V1, V2)
        TYPE(VERTEX_VERTEX_PATH), DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: VTX
        INTEGER,                                             INTENT(IN   ):: V1, V2
      END SUBROUTINE
      !
      MODULE ELEMENTAL PURE SUBROUTINE COPY_VERTEX_VERTEX_PATH(VTX_OUT,VTX_IN)
        CLASS(VERTEX_VERTEX_PATH), INTENT(IN   ):: VTX_IN
        CLASS(VERTEX_VERTEX_PATH), INTENT(INOUT):: VTX_OUT
      END SUBROUTINE
      !
      MODULE ELEMENTAL PURE SUBROUTINE MOVE_VERTEX_VERTEX_PATH(VTX_IN, VTX_OUT)
        CLASS(VERTEX_VERTEX_PATH), INTENT(INOUT):: VTX_IN
        CLASS(VERTEX_VERTEX_PATH), INTENT(INOUT):: VTX_OUT
      END SUBROUTINE
      !
      MODULE PURE SUBROUTINE ALLOC_VERTEX_VERTEX_PATH(VTX, N)
        CLASS(VERTEX_VERTEX_PATH), INTENT(INOUT):: VTX
        INTEGER,                   INTENT(IN   ):: N
      END SUBROUTINE
      !
      MODULE ELEMENTAL PURE SUBROUTINE SET_V_VERTEX_VERTEX_PATH(VTX, V1, V2, NEW_ALLOC)
        CLASS(VERTEX_VERTEX_PATH),                     INTENT(INOUT):: VTX
        INTEGER,                                       INTENT(IN   ):: V1, V2
        LOGICAL,                             OPTIONAL, INTENT(  OUT):: NEW_ALLOC
      END SUBROUTINE
      !
      MODULE PURE SUBROUTINE SET_V1_VERTEX_VERTEX_PATH(VTX, V1, NEW_ALLOC)
        CLASS(VERTEX_VERTEX_PATH),                     INTENT(INOUT):: VTX
        INTEGER,                                       INTENT(IN   ):: V1
        LOGICAL,                             OPTIONAL, INTENT(  OUT):: NEW_ALLOC
      END SUBROUTINE
      !
      MODULE PURE SUBROUTINE SET_V2_VERTEX_VERTEX_PATH(VTX, V2, NEW_ALLOC)
        CLASS(VERTEX_VERTEX_PATH),                     INTENT(INOUT):: VTX
        INTEGER,                                       INTENT(IN   ):: V2
        LOGICAL,                             OPTIONAL, INTENT(  OUT):: NEW_ALLOC
      END SUBROUTINE
  END INTERFACE
  !
  ! ----------------------------------------------------------------------------------
  !
  INTERFACE  !VERTEX_BACKPATH_SUBS
      !
      MODULE PURE FUNCTION IS_VERTEX_MATCH(VTX, V1) RESULT(IS_MATCH)
        CLASS(VERTEX_BACKPATH), INTENT(IN):: VTX
        INTEGER,                INTENT(IN):: V1
        LOGICAL:: IS_MATCH
      END FUNCTION
      !
      MODULE PURE FUNCTION IS_VERTEX_AND_DIM_MATCH(VTX, V1, DIM) RESULT(IS_MATCH)
        CLASS(VERTEX_BACKPATH), INTENT(IN):: VTX
        INTEGER,                INTENT(IN):: V1, DIM
        LOGICAL:: IS_MATCH
      END FUNCTION
      !
      MODULE PURE SUBROUTINE ALLOCATE_VERTEX_BACKPATH(VTX, DIM, V1)
        CLASS(VERTEX_BACKPATH), INTENT(INOUT):: VTX
        INTEGER,                INTENT(IN   ):: DIM
        INTEGER,  OPTIONAL,     INTENT(IN   ):: V1
      END SUBROUTINE
      !
      MODULE PURE SUBROUTINE SET_V1_VERTEX_BACKPATH(VTX, V1)
        CLASS(VERTEX_BACKPATH), INTENT(INOUT):: VTX
        INTEGER,                INTENT(IN   ):: V1
      END SUBROUTINE
      !
      MODULE PURE SUBROUTINE CLOSEST_COMMON_VERTEX_BACKPATH(VTX, V2, V3, JUNCT, DN2, DN3)
        CLASS(VERTEX_BACKPATH), INTENT(IN   ):: VTX
        INTEGER,                INTENT(IN   ):: V2, V3
        INTEGER,     OPTIONAL,  INTENT(INOUT):: JUNCT, DN2, DN3
      END SUBROUTINE
      !
      MODULE PURE FUNCTION BACKSTEP_VERTEX_BACKPATH(VTX, V2) RESULT(BACKSTEP)
        CLASS(VERTEX_BACKPATH), INTENT(IN):: VTX
        INTEGER,                INTENT(IN):: V2
        INTEGER:: BACKSTEP
      END FUNCTION
      !
      MODULE PURE FUNCTION NSTEP_VERTEX_BACKPATH(VTX, V2) RESULT(DIM)
        CLASS(VERTEX_BACKPATH), INTENT(IN):: VTX
        INTEGER,                INTENT(IN):: V2
        INTEGER:: DIM
      END FUNCTION
      !
      MODULE PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_BINARY_HEAP(VTX)
        TYPE(VERTEX_BACKPATH), INTENT(INOUT):: VTX
      END SUBROUTINE
  END INTERFACE
  !
  CONTAINS
  !
  ! ----------------------------------------------------------------------------------
  !
  PURE SUBROUTINE DIJKSTRA_SHORTEST_PATH_VERTEX(ADJ, V1, REBUILD)
    CLASS(ADJ_LST),                                INTENT(INOUT):: ADJ
    INTEGER,                                       INTENT(IN   ):: V1
    LOGICAL,                             OPTIONAL, INTENT(IN   ):: REBUILD
    LOGICAL:: FORCE_REBUILD, NEW_ALLOC
    !
    IF(ADJ%N > Z .AND. V1 > Z .AND. V1 <= ADJ%N) THEN
                  !
                  IF(PRESENT(REBUILD)) THEN; FORCE_REBUILD = REBUILD
                  ELSE;                      FORCE_REBUILD = FALSE
                  END IF
                  !
                  CALL ALLOC(ADJ%SPT,      ADJ%N, NEW_ALLOC=NEW_ALLOC)
                  CALL ALLOC(ADJ%BACKPATH, ADJ%N, NEW_ALLOC=NEW_ALLOC)
                  !
                  IF(ADJ%V1_BACK_PATH .NE. V1 .OR. NEW_ALLOC .OR. FORCE_REBUILD)  CALL DIJKSTRA_SHORTEST_PATH(ADJ, V1, ADJ%BACKPATH, ADJ%SPT)
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE DIJKSTRA_SHORTEST_PATH_BACKPATH(ADJ, V1, BACKPATH, INTERNAL_COPY)
    CLASS(ADJ_LST),                     INTENT(INOUT):: ADJ
    INTEGER,                            INTENT(IN   ):: V1
    INTEGER, DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: BACKPATH
    LOGICAL,                  OPTIONAL, INTENT(IN   ):: INTERNAL_COPY
    INTEGER:: V1_BAK
    !
    IF(ADJ%N > Z .AND. V1 > Z .AND. V1 <= ADJ%N) THEN
                  !
                  V1_BAK = ADJ%V1_BACK_PATH
                  !
                  CALL ALLOC(ADJ%SPT, ADJ%N)
                  !
                  CALL ALLOC(BACKPATH, ADJ%N)
                  !
                  CALL DIJKSTRA_SHORTEST_PATH(ADJ,V1,BACKPATH, ADJ%SPT)
                  !
                  ADJ%V1_BACK_PATH = V1_BAK !No local storage of path
                  !
                  IF(PRESENT(INTERNAL_COPY)) THEN
                          IF(INTERNAL_COPY) THEN
                              ADJ%V1_BACK_PATH = V1
                              CALL ALLOC(ADJ%BACKPATH, ADJ%N, SRC=BACKPATH)
                          END IF
                  END IF
    ELSE
        IF(ALLOCATED(BACKPATH)) THEN
                                 BACKPATH = Z
        ELSE
            ALLOCATE(BACKPATH(ONE), SOURCE=Z)
        END IF
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE DIJKSTRA_SHORTEST_PATH_VERTEX_VERTEX_BACKPATH(ADJ, V1, VTX, INTERNAL_COPY, REBUILD)
    CLASS(ADJ_LST),        INTENT(INOUT):: ADJ
    INTEGER,               INTENT(IN   ):: V1
    TYPE(VERTEX_BACKPATH), INTENT(INOUT):: VTX
    LOGICAL,     OPTIONAL, INTENT(IN   ):: INTERNAL_COPY, REBUILD
    INTEGER:: V1_BAK
    LOGICAL:: FORCE_REBUILD
    !
    IF(ADJ%N > Z .AND. V1 > Z .AND. V1 <= ADJ%N) THEN
                  !
                  IF(PRESENT(REBUILD)) THEN; FORCE_REBUILD = REBUILD
                  ELSE;                      FORCE_REBUILD = FALSE
                  END IF
                  !
                  IF(.NOT. IS_VERTEX_AND_DIM_MATCH(VTX, V1, ADJ%N) .OR. FORCE_REBUILD .OR. .NOT. VTX%GOT_BACK) THEN
                       !
                       V1_BAK = ADJ%V1_BACK_PATH
                       !
                       CALL VTX%INIT(ADJ%N, V1)
                       !
                       CALL ALLOC(ADJ%SPT, ADJ%N)
                       CALL DIJKSTRA_SHORTEST_PATH(ADJ, VTX%V1, VTX%BACKPATH, ADJ%SPT)
                       VTX%GOT_BACK = TRUE
                       !
                       ADJ%V1_BACK_PATH = V1_BAK
                       !
                       IF(PRESENT(INTERNAL_COPY)) THEN
                               IF(INTERNAL_COPY) THEN
                                                 ADJ%V1_BACK_PATH = VTX%V1
                                                 CALL ALLOC(ADJ%BACKPATH, ADJ%N, SRC=VTX%BACKPATH)
                               END IF
                       END IF
                  END IF
    ELSE
        CALL ALLOCATE_VERTEX_BACKPATH(VTX, Z)
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE DIJKSTRA_SHORTEST_PATH_VERTEX_BACKPATH(ADJ, VTX, INTERNAL_COPY) !assumes V1 is set
    CLASS(ADJ_LST),        INTENT(INOUT):: ADJ
    TYPE(VERTEX_BACKPATH), INTENT(INOUT):: VTX
    LOGICAL,     OPTIONAL, INTENT(IN   ):: INTERNAL_COPY
    INTEGER:: V1_BAK
    !
    IF(ADJ%N > Z .AND. VTX%V1 > Z .AND. VTX%V1 <= ADJ%N) THEN
                  !
                  V1_BAK = ADJ%V1_BACK_PATH
                  VTX%N = ADJ%N
                  !
                  CALL ALLOC(VTX%BACKPATH, ADJ%N)  !Ensure that it has been allocated
                  !
                  CALL ALLOC(ADJ%SPT, ADJ%N)
                  CALL DIJKSTRA_SHORTEST_PATH(ADJ, VTX%V1, VTX%BACKPATH, ADJ%SPT)
                  VTX%GOT_BACK = TRUE
                  !
                  ADJ%V1_BACK_PATH = V1_BAK !No local storage of path
                  !
                  IF(PRESENT(INTERNAL_COPY)) THEN
                          IF(INTERNAL_COPY) THEN
                                            ADJ%V1_BACK_PATH = VTX%V1
                                            CALL ALLOC(ADJ%BACKPATH, ADJ%N, SRC=VTX%BACKPATH)
                          END IF
                  END IF
    ELSE
        V1_BAK = VTX%V1
        CALL ALLOCATE_VERTEX_BACKPATH(VTX, Z, V1_BAK)
    END IF
    !
  END SUBROUTINE
  !
  !PURE SUBROUTINE GET_PATH_DIJKSTRA_SHORTEST_PATH_MAIN(ADJ,V1,V2,PATH,DIM,BACKPATH)
  !  CLASS(ADJ_LST),                                INTENT(INOUT):: ADJ
  !  INTEGER,                                       INTENT(IN   ):: V1,V2
  !  INTEGER,                                       INTENT(  OUT):: DIM
  !  INTEGER, DIMENSION(:), ALLOCATABLE,            INTENT(INOUT):: PATH
  !  INTEGER, DIMENSION(:), ALLOCATABLE,  OPTIONAL, INTENT(INOUT):: BACKPATH
  !  !
  !  IF(ADJ%N > Z) THEN
  !                CALL ALLOC(ADJ%SPT, ADJ%N)
  !                !
  !                IF(PRESENT(BACKPATH)) THEN
  !                                      CALL ALLOC(BACKPATH, ADJ%N)
  !                                      CALL DIJKSTRA_SHORTEST_PATH(ADJ,V1,BACKPATH, ADJ%SPT)
  !                                      !
  !                                      ADJ%V1_BACK_PATH = Z !No local storage of path
  !                ELSE
  !                                      CALL ALLOC(ADJ%BACKPATH, ADJ%N)
  !                                      CALL DIJKSTRA_SHORTEST_PATH(ADJ,V1,ADJ%BACKPATH, ADJ%SPT)
  !                END IF
  !  ELSEIF(PRESENT(BACKPATH)) THEN
  !                            IF(ALLOCATED(BACKPATH)) THEN
  !                                                     BACKPATH = Z
  !                            ELSE
  !                                ALLOCATE(BACKPATH(ONE), SOURCE=Z)
  !                            END IF
  !  END IF
  !  !
  !END SUBROUTINE
  !
  ! ----------------------------------------------------------------------------------
  !
  PURE SUBROUTINE DIJKSTRA_SHORTEST_PATH(ADJ,V1,BACKPATH, SPT)
    CLASS(ADJ_LST),            INTENT(INOUT):: ADJ
    INTEGER,                   INTENT(IN   ):: V1
    INTEGER, DIMENSION(ADJ%N), INTENT(INOUT):: BACKPATH
    LOGICAL, DIMENSION(ADJ%N), INTENT(INOUT):: SPT
    INTEGER:: I,U,V,P
    DOUBLE PRECISION:: DIST_U, DIST_V, DIST 
    !
    ADJ%V1_BACK_PATH = V1  !Keep track of where BACKPATH CURRENTLY POINTS TOO.
    !
    SPT      = TRUE   !If FALSE then point is in the tree
    BACKPATH = Z      !Non-Zero when point exists
    !
    IF( V1 > Z ) THEN
        CALL ADJ%HEAP%DIJKSTRA_INIT(V1, ADJ%N)  !Set up HEAP For DIJKSTRA Algorithm 
        !
        DO WHILE (ADJ%HEAP%SIZE() > Z)
            !
            CALL ADJ%HEAP%POP(U, DIST_U)  !GET MIN FROM HEAP
            !
            IF(U > Z .AND. DIST_U < near_inf) THEN !dist is < inf
                !
                SPT(U) = FALSE  !Point is being explored so add it to the shortest path
                !
                DO I=ONE, ADJ%VER(U)%N
                    !
                    V = ADJ%VER(U)%CON(I)
                    !
                    IF(V > Z) THEN
                       !
                       IF(SPT(V)) THEN  !Have not visited point before
                            !
                            DIST = DIST_U + ADJ%VER(U)%WT(I)
                            !
                            CALL ADJ%HEAP%GET(V,DIST_V,P)
                            !
                            IF( DIST < DIST_V) THEN
                                BACKPATH(V) = U
                                !ADJ%HEAP%CHILD(P)%PNT%X = DIST  !Update with new lower distance
                                CALL ADJ%HEAP%SET_X(P,DIST)      !Update with new lower distance
                            END IF
                       END IF
                    END IF
                END DO
            ELSE
                EXIT
            END IF
            !
        END DO
    END IF
  END SUBROUTINE
  !
  ! ----------------------------------------------------------------------------------
  !
  PURE SUBROUTINE GET_PATH_DIJKSTRA_SHORTEST_PATH(ADJ,V1,V2,PATH,DIM)
    CLASS(ADJ_LST),                      INTENT(INOUT):: ADJ
    INTEGER,                             INTENT(IN   ):: V1,V2
    INTEGER,                             INTENT(  OUT):: DIM
    INTEGER, DIMENSION(:), ALLOCATABLE,  INTENT(INOUT):: PATH
    INTEGER:: I,J
    !
    IF(ADJ%V1_BACK_PATH .NE. V1) CALL DIJKSTRA_SHORTEST_PATH_VERTEX(ADJ, V1)
    !
    IF(ADJ%BACKPATH(V2) == Z) THEN
        DIM = Z
        RETURN
    END IF
    !
    DIM = ONE
    I   = V2
    DO WHILE ( ADJ%BACKPATH(I) > Z )
            DIM = DIM + ONE
            !
            I = ADJ%BACKPATH(I)
    END DO
    !
    CALL ALLOC(PATH,DIM)
    !
    I       = V2
    J       = DIM
    DO J=DIM, ONE, NEG
            !
            PATH(J) = I
            !
            I = ADJ%BACKPATH(I)
    END DO
    !
  END SUBROUTINE
  !
  ! ----------------------------------------------------------------------------------
  !
  PURE SUBROUTINE CLOSEST_COMMON_VERTEX_BACKPATH_ADJ_LST(ADJ, VTX, VTY, JUNCT, UP1, UP2)
    CLASS(ADJ_LST),         INTENT(INOUT):: ADJ
    TYPE(VERTEX_BACKPATH),  INTENT(IN   ):: VTX, VTY
    INTEGER,                INTENT(  OUT):: JUNCT
    INTEGER,      OPTIONAL, INTENT(  OUT):: UP1, UP2
    !
    IF(VTX%N .NE. ADJ%N) CALL ADJ%BUILD_BACKPATH(VTX)
    IF(VTY%N .NE. ADJ%N) CALL ADJ%BUILD_BACKPATH(VTY)
    !
    ASSOCIATE(V1 => VTX%V1, DIM1 => VTX%N, BACK1 => VTX%BACKPATH, &
              V2 => VTY%V1, DIM2 => VTY%N, BACK2 => VTY%BACKPATH   )
             !
       IF    (V1 == V2) THEN
                                JUNCT = V1
       ELSEIF(ADJ%N <  TWO) THEN
                                JUNCT = Z
       ELSE
           JUNCT = Z
           CALL ALLOC(ADJ%SPT, ADJ%N)
           !
           IF(BACK2(V1) > Z) THEN !V1 is downstream of V2
               !
               CALL CLOSEST_COMMON_ADJ_LST(ADJ, V2, V1, BACK2, ADJ%SPT, JUNCT)
               !
           ELSE! V1 is upstream of V2 or common is somewhere downstream
               !
               CALL CLOSEST_COMMON_ADJ_LST(ADJ, V1, V2, BACK1, ADJ%SPT, JUNCT)
           END IF
           !
       END IF
       !
       IF(JUNCT > Z) THEN
                     IF(PRESENT(UP1)) UP1 = BACK1(JUNCT)
                     IF(PRESENT(UP2)) UP2 = BACK2(JUNCT)
       ELSE
                     IF(PRESENT(UP1)) UP1 = Z
                     IF(PRESENT(UP2)) UP2 = Z
       END IF
       !
    END ASSOCIATE
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CLOSEST_COMMON_IMAP_VERTEX_BACKPATH_ADJ_LST(ADJ, VTX, VTY, I, IMAP, JUNCT, UP1, UP2)
    CLASS(ADJ_LST),            INTENT(INOUT):: ADJ
    TYPE(VERTEX_BACKPATH),     INTENT(IN   ):: VTX, VTY
    INTEGER,                   INTENT(IN   ):: I
    INTEGER, DIMENSION(ADJ%N), INTENT(IN   ):: IMAP
    INTEGER,                   INTENT(  OUT):: JUNCT
    INTEGER,         OPTIONAL, INTENT(  OUT):: UP1, UP2
    !
    IF(VTX%N .NE. ADJ%N) CALL ADJ%BUILD_BACKPATH(VTX)
    IF(VTY%N .NE. ADJ%N) CALL ADJ%BUILD_BACKPATH(VTY)
    !                         
    ASSOCIATE(V1 => VTX%V1, DIM1 => VTX%N, BACK1 => VTX%BACKPATH, &
              V2 => VTY%V1, DIM2 => VTY%N, BACK2 => VTY%BACKPATH   )
             !
       IF    (V1 == V2) THEN
                                JUNCT = V1
       ELSEIF(ADJ%N <  TWO) THEN
                                JUNCT = Z
       ELSE
           JUNCT = Z
           CALL ALLOC(ADJ%SPT, ADJ%N)
           !
           IF(BACK2(V1) > Z) THEN !V1 is downstream of V2
               !
               CALL CLOSEST_COMMON_IMAP_ADJ_LST(ADJ, V2, V1, I, IMAP, BACK2, ADJ%SPT, JUNCT)
               !
           ELSE! V1 is upstream of V2 or common is somewhere downstream
               !
               CALL CLOSEST_COMMON_IMAP_ADJ_LST(ADJ, V1, V2, I, IMAP, BACK1, ADJ%SPT, JUNCT)
           END IF
           !
       END IF
       !
       IF(JUNCT > Z) THEN
                     IF(PRESENT(UP1)) UP1 = BACK1(JUNCT)
                     IF(PRESENT(UP2)) UP2 = BACK2(JUNCT)
       ELSE
                     IF(PRESENT(UP1)) UP1 = Z
                     IF(PRESENT(UP2)) UP2 = Z
       END IF
       !
    END ASSOCIATE
    !
  END SUBROUTINE
  !
  ! ----------------------------------------------------------------------------------
  !
  PURE SUBROUTINE CLOSEST_COMMON_V1_V2_ADJ_LST(ADJ, V1, V2, JUNCT, UP1, UP2)
    CLASS(ADJ_LST),         INTENT(INOUT):: ADJ
    INTEGER,                INTENT(IN   ):: V1, V2
    INTEGER,                INTENT(INOUT):: JUNCT
    INTEGER,      OPTIONAL, INTENT(INOUT):: UP1, UP2
    INTEGER:: P1, P2
    INTEGER, DIMENSION(:), ALLOCATABLE:: BACKPATH
    !
    IF    (V1 == V2) THEN
                             JUNCT = V1
    ELSEIF(ADJ%N <  TWO) THEN
                             JUNCT = Z
    ELSE
        IF(V2 == ADJ%V1_BACK_PATH) THEN
            P1 = V2
            P2 = V1
        ELSE
            P1 = V1
            P2 = V2
        END IF
        JUNCT = Z
        !
        CALL DIJKSTRA_SHORTEST_PATH_VERTEX  (ADJ, P1)
        CALL DIJKSTRA_SHORTEST_PATH_BACKPATH(ADJ, P2, BACKPATH)
        !
        IF(BACKPATH(P1) > Z) THEN !P1 is downstream of P2
                                  !
                                  CALL CLOSEST_COMMON_ADJ_LST(ADJ, P2, P1,     BACKPATH, ADJ%SPT, JUNCT)
                                  !
        ELSE! P1 is upstream of P2 or common is somewhere downstream
                                  !
                                  CALL CLOSEST_COMMON_ADJ_LST(ADJ, P1, P2, ADJ%BACKPATH, ADJ%SPT, JUNCT)
        END IF
        !
    END IF
    !
    IF(PRESENT(UP1) .OR. PRESENT(UP2)) THEN
       IF(JUNCT > Z) THEN
           IF(V2 == ADJ%V1_BACK_PATH) THEN
               P1 =     BACKPATH(JUNCT)
               P2 = ADJ%BACKPATH(JUNCT)
           ELSE
               P1 = ADJ%BACKPATH(JUNCT)
               P2 =     BACKPATH(JUNCT)
           END IF
       ELSE
           P1 = Z
           P2 = Z
       END IF
       !
       IF(PRESENT(UP1)) UP1 = P1
       IF(PRESENT(UP2)) UP2 = P2
       !
    END IF
    !
  END SUBROUTINE
  !
  !V2 cannot be upstream of V1, BACKPATH is for V1
  !Assumes that V1 /= V2 and ADJ%N > 1
  !This will return V2 if it is the closest path to V1
  PURE SUBROUTINE CLOSEST_COMMON_ADJ_LST(ADJ, V1, V2, BACKPATH, SPT, JUNCT) 
    CLASS(ADJ_LST),            INTENT(INOUT):: ADJ
    INTEGER,                   INTENT(IN   ):: V1, V2
    INTEGER, DIMENSION(ADJ%N), INTENT(IN   ):: BACKPATH
    LOGICAL, DIMENSION(ADJ%N), INTENT(INOUT):: SPT
    INTEGER,                   INTENT(INOUT):: JUNCT
    INTEGER:: I,U,V,P
    DOUBLE PRECISION:: COM_DIST
    DOUBLE PRECISION:: DIST_U, DIST_V, DIST 
    !
    JUNCT = Z
    COM_DIST = inf
    !
    SPT = TRUE
    !
    CALL ADJ%HEAP%DIJKSTRA_INIT(V2, ADJ%N)  !Set up HEAP 
    !
    DO WHILE (ADJ%HEAP%SIZE() > Z)
        !
        CALL ADJ%HEAP%POP(U, DIST_U)  !GET MIN FROM HEAP  (FIRST POP IS V2)
        !
        IF(U > Z .AND. DIST_U < near_inf) THEN !dist is < inf
            !
            IF(BACKPATH(U) > Z .AND. DIST_U < COM_DIST) THEN  !TRUE if direct path to V1
                  !
                  DIST = DIST_U + ADJ%SUM_WT(U, BACKPATH)
                  !
                  IF(DIST < COM_DIST) THEN
                      !
                      COM_DIST = DIST
                      JUNCT      = U
                  END IF
            END IF
            !
            SPT(U) = FALSE  !Point is being explored so add it to the shortest path
            !
            DO I=ONE, ADJ%VER(U)%N
                !
                V = ADJ%VER(U)%CON(I)
                !
                IF(V > Z) THEN
                   !
                   IF(SPT(V)) THEN  !Have not visited point before
                        !
                        DIST = DIST_U + ADJ%VER(U)%WT(I)
                        !
                        CALL ADJ%HEAP%GET(V,DIST_V,P)
                        !
                        IF( DIST < DIST_V)  CALL ADJ%HEAP%SET_X(P,DIST)      !Update with new lower distance
                   END IF
                END IF
            END DO
        ELSE
            EXIT
        END IF
        !
    END DO
    !
  END SUBROUTINE
  !
  PURE FUNCTION SUM_WT_ADJ_LST(ADJ, V1)  RESULT(DIST)
    CLASS(ADJ_LST),            INTENT(IN):: ADJ
    INTEGER,                   INTENT(IN):: V1
    DOUBLE PRECISION:: DIST
    !
    DIST = DZ
    !
    IF(ADJ%V1_BACK_PATH > Z) DIST = SUM_WT_BACKPATH_ADJ_LST(ADJ, V1, ADJ%BACKPATH) 
    !
  END FUNCTION
  !
  PURE FUNCTION SUM_WT_BACKPATH_ADJ_LST(ADJ, V1, BACKPATH)  RESULT(DIST)
    CLASS(ADJ_LST),            INTENT(IN):: ADJ
    INTEGER,                   INTENT(IN):: V1
    INTEGER, DIMENSION(ADJ%N), INTENT(IN):: BACKPATH
    DOUBLE PRECISION:: DIST
    INTEGER:: I, J, K
    !
    DIST = DZ
    !
    IF(Z < V1 .AND. V1 <= ADJ%N) THEN
        !
        J = V1
        I = BACKPATH(J)
        !
        DO WHILE(I > Z)
            !
            DIST = DIST + ADJ%GET_WT(I, J, DZ)
            !
            J = I
            I = BACKPATH(J)
            !
        END DO
    END IF
    !
  END FUNCTION
  !
  PURE FUNCTION GET_WT_ADJ_LST(ADJ, V1, V2, ERROR_VAL)  RESULT(WT)
    CLASS(ADJ_LST),             INTENT(IN):: ADJ
    INTEGER,                    INTENT(IN):: V1, V2
    DOUBLE PRECISION, OPTIONAL, INTENT(IN):: ERROR_VAL
    DOUBLE PRECISION:: WT
    INTEGER:: J
    !
    IF(PRESENT(ERROR_VAL)) THEN
          WT = ERROR_VAL
    ELSE
          WT = DNEG        ! = -1 is an error condition
    END IF
    !
    IF(  Z < V1 .AND. V1 <= ADJ%N .AND.  &
       NEG < V2 .AND. V2 <= ADJ%N .AND. ADJ%VER(V1)%N > Z ) THEN
                      !
                      DO J = ONE, ADJ%VER(V1)%N
                               IF(ADJ%VER(V1)%CON(J) == V2) WT = ADJ%VER(V1)%WT(J)
                      END DO
                      !
    END IF
    !
  END FUNCTION
  !
  ! ----------------------------------------------------------------------------------
  !
  PURE SUBROUTINE CLOSEST_COMMON_V1_V2_IMAP_ADJ_LST(ADJ, V1, V2, I, IMAP, JUNCT, UP1, UP2)
    CLASS(ADJ_LST),            INTENT(INOUT):: ADJ
    INTEGER,                   INTENT(IN   ):: V1, V2, I
    INTEGER, DIMENSION(ADJ%N), INTENT(IN   ):: IMAP
    INTEGER,                   INTENT(INOUT):: JUNCT
    INTEGER,         OPTIONAL, INTENT(INOUT):: UP1, UP2
    INTEGER:: P1, P2 
    INTEGER, DIMENSION(:), ALLOCATABLE:: BACKPATH
    !
    IF    (V1 == V2) THEN
                             JUNCT = V1
    ELSEIF(ADJ%N <  TWO) THEN
                             JUNCT = Z
    ELSE
        IF(V2 == ADJ%V1_BACK_PATH) THEN
            P1 = V2
            P2 = V1
        ELSE
            P1 = V1
            P2 = V2
        END IF
        JUNCT = Z
        !
        CALL DIJKSTRA_SHORTEST_PATH_VERTEX  (ADJ, P1)
        CALL DIJKSTRA_SHORTEST_PATH_BACKPATH(ADJ, P2, BACKPATH)
        !
        IF(BACKPATH(P1) > Z) THEN !P1 is downstream of P2
                                  !
                                  CALL CLOSEST_COMMON_IMAP_ADJ_LST(ADJ, P2, P1, I, IMAP,     BACKPATH, ADJ%SPT, JUNCT)
                                  !
        ELSE! P1 is upstream of P2 or common is somewhere downstream
                                  !
                                  CALL CLOSEST_COMMON_IMAP_ADJ_LST(ADJ, P1, P2, I, IMAP, ADJ%BACKPATH, ADJ%SPT, JUNCT)
        END IF
        !
    END IF
    !
    IF(PRESENT(UP1) .OR. PRESENT(UP2)) THEN
       IF(JUNCT > Z) THEN
           IF(V2 == ADJ%V1_BACK_PATH) THEN
               P1 =     BACKPATH(JUNCT)
               P2 = ADJ%BACKPATH(JUNCT)
           ELSE
               P1 = ADJ%BACKPATH(JUNCT)
               P2 =     BACKPATH(JUNCT)
           END IF
       ELSE
           P1 = Z
           P2 = Z
       END IF
       !
       IF(PRESENT(UP1)) UP1 = P1
       IF(PRESENT(UP2)) UP2 = P2
       !
    END IF
    !
  END SUBROUTINE
  !
  !V2 cannot be upstream of V1, BACKPATH is for V1
  !Assumes that V1 /= V2 and ADJ%N > 1
  !This will return V2 if it is the closest path to V1
  PURE SUBROUTINE CLOSEST_COMMON_IMAP_ADJ_LST(ADJ, V1, V2, ID, IMAP, BACKPATH, SPT, JUNCT) 
    CLASS(ADJ_LST),            INTENT(INOUT):: ADJ
    INTEGER,                   INTENT(IN   ):: V1, V2, ID
    INTEGER, DIMENSION(ADJ%N), INTENT(IN   ):: BACKPATH, IMAP
    LOGICAL, DIMENSION(ADJ%N), INTENT(INOUT):: SPT
    INTEGER,                   INTENT(INOUT):: JUNCT
    INTEGER:: I,U,V,P
    DOUBLE PRECISION:: COM_DIST
    DOUBLE PRECISION:: DIST_U, DIST_V, DIST 
    !
    JUNCT = Z
    COM_DIST = inf
    !
    SPT = TRUE
    !
    CALL ADJ%HEAP%DIJKSTRA_INIT(V2, ADJ%N)  !Set up HEAP 
    !
    DO WHILE (ADJ%HEAP%SIZE() > Z)
        !
        CALL ADJ%HEAP%POP(U, DIST_U)  !GET MIN FROM HEAP  (FIRST POP IS V2)
        !
        IF(U > Z .AND. DIST_U < near_inf) THEN !dist is < inf
            !
            IF(BACKPATH(U) > Z .AND. DIST_U < COM_DIST) THEN  !TRUE if direct path to V1
                  !
                  IF(ID == IMAP(U)) THEN
                                    DIST = DIST_U + ADJ%SUM_WT(U, BACKPATH)
                                    !
                                    IF(DIST < COM_DIST) THEN
                                        !
                                        COM_DIST = DIST
                                        JUNCT      = U
                                    END IF
                  END IF
            END IF
            !
            SPT(U) = FALSE  !Point is being explored so add it to the shortest path
            !
            DO I=ONE, ADJ%VER(U)%N
                !
                V = ADJ%VER(U)%CON(I)
                !
                IF(V > Z) THEN
                   !
                   IF(SPT(V)) THEN  !Have not visited point before
                        !
                        DIST = DIST_U + ADJ%VER(U)%WT(I)
                        !
                        CALL ADJ%HEAP%GET(V,DIST_V,P)
                        !
                        IF( DIST < DIST_V)  CALL ADJ%HEAP%SET_X(P,DIST)      !Update with new lower distance
                   END IF
                END IF
            END DO
        ELSE
            EXIT
        END IF
        !
    END DO
    !
  END SUBROUTINE
  !
  !!!PURE SUBROUTINE CLOSEST_COMMON_ADJ_LST(ADJ,V1,V2,JUNCT) !V1 must be upstream of V2
  !!!  CLASS(ADJ_LST),         INTENT(INOUT):: ADJ
  !!!  INTEGER,                INTENT(IN   ):: V1, V2
  !!!  INTEGER,                INTENT(INOUT):: JUNCT
  !!!  INTEGER:: I,U,V, P1, P2, P
  !!!  DOUBLE PRECISION:: COM_DIST
  !!!  DOUBLE PRECISION:: DIST_U, DIST_V, DIST 
  !!!  !
  !!!  IF    (V1 == V2) THEN
  !!!                           JUNCT = V1
  !!!  ELSEIF(ADJ%N <  TWO) THEN
  !!!                           JUNCT = Z
  !!!  ELSE
  !!!      JUNCT = Z
  !!!      COM_DIST = inf
  !!!      !
  !!!      IF(V2 == ADJ%V1_BACK_PATH) THEN
  !!!          P1 = V2
  !!!          P2 = V1
  !!!      ELSE
  !!!          P1 = V1
  !!!          P2 = V2
  !!!      END IF
  !!!      !
  !!!      CALL DIJKSTRA_SHORTEST_PATH_VERTEX(ADJ, P1)
  !!!      !
  !!!      CALL ADJ%HEAP%DIJKSTRA_INIT(P2, ADJ%N)  !Set up HEAP 
  !!!      !
  !!!      ADJ%SPT = TRUE !SET TO FALSE IF VISITED
  !!!      !
  !!!      DO WHILE (ADJ%HEAP%SIZE() > Z)
  !!!          !
  !!!          CALL ADJ%HEAP%POP(U, DIST_U)  !GET MIN FROM HEAP  (FIRST POP IS P2)
  !!!          !
  !!!          IF(U > Z .AND. DIST_U < D200) THEN !dist is < inf
  !!!              !
  !!!              IF(ADJ%BACKPATH(U) > Z .AND. DIST_U < COM_DIST) THEN  !TRUE if direct path to P1
  !!!                    COM_DIST = DIST_U
  !!!                    JUNCT      = U
  !!!              END IF
  !!!              !
  !!!              ADJ%SPT(U) = FALSE  !Point is being explored so add it to the shortest path
  !!!              !
  !!!              DO I=ONE, ADJ%VER(U)%N
  !!!                  !
  !!!                  V = ADJ%VER(U)%CON(I)
  !!!                  !
  !!!                  IF(V > Z) THEN
  !!!                     !
  !!!                     IF(ADJ%SPT(V)) THEN  !Have not visited point before
  !!!                          !
  !!!                          DIST = DIST_U + ADJ%VER(U)%WT(I)
  !!!                          !
  !!!                          CALL ADJ%HEAP%GET(V,DIST_V,P)
  !!!                          !
  !!!                          IF( DIST < DIST_V)  CALL ADJ%HEAP%SET_X(P,DIST)      !Update with new lower distance
  !!!                     END IF
  !!!                  END IF
  !!!              END DO
  !!!          ELSE
  !!!              EXIT
  !!!          END IF
  !!!          !
  !!!      END DO
  !!!  END IF
  !!!  !
  !!!END SUBROUTINE
  !
  ! ----------------------------------------------------------------------------------
  !
  PURE SUBROUTINE BUILD_DIJKSTRA_PATH_VERTEX_VERTEX_PATH(VTX, VPATH)
    TYPE(VERTEX_BACKPATH),               INTENT(IN   ):: VTX
    TYPE(VERTEX_VERTEX_PATH),            INTENT(INOUT):: VPATH
    !
    IF(VPATH%V1 == VTX%V1) THEN
                            CALL BUILD_DIJKSTRA_PATH_BACKPATH(VPATH%V2, VTX%BACKPATH, VPATH%PATH, VPATH%N)
    ELSE
                            VPATH%N = Z
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE BUILD_DIJKSTRA_PATH_V2_VERTEX_VERTEX_PATH(V2, VTX, VPATH)
    INTEGER,                             INTENT(IN   ):: V2
    TYPE(VERTEX_BACKPATH),               INTENT(IN   ):: VTX
    TYPE(VERTEX_VERTEX_PATH),            INTENT(INOUT):: VPATH
    INTEGER:: DIM
    !
    VPATH%V1 = VTX%V1
    VPATH%V2 = V2
    CALL BUILD_DIJKSTRA_PATH_BACKPATH(V2, VTX%BACKPATH, VPATH%PATH, DIM)
    VPATH%N = DIM
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE BUILD_DIJKSTRA_PATH_BACKPATH(V2, BACKPATH, PATH, DIM)
    INTEGER,                             INTENT(IN   ):: V2
    INTEGER, DIMENSION(:), ALLOCATABLE,  INTENT(IN   ):: BACKPATH
    INTEGER,                             INTENT(  OUT):: DIM
    INTEGER, DIMENSION(:), ALLOCATABLE,  INTENT(INOUT):: PATH
    INTEGER:: I,J
    !
    DIM = ONE
    !
    IF(.NOT. ALLOCATED(BACKPATH)) THEN; DIM = Z
    ELSEIF(BACKPATH(V2) == Z    ) THEN; DIM = Z
    END IF
    !
    IF(DIM == ONE) THEN
                      I   = V2
                      DO WHILE ( BACKPATH(I) > Z )
                              DIM = DIM + ONE
                              !
                              I = BACKPATH(I)
                      END DO
                      !
                      CALL ALLOC(PATH,DIM)
                      !
                      I       = V2
                      J       = DIM
                      DO J=DIM, ONE, NEG
                              !
                              PATH(J) = I
                              !
                              I = BACKPATH(I)
                      END DO
    END IF
    !
  END SUBROUTINE
  !
  !!!PURE SUBROUTINE DIJKSTRA_SHORTEST_PATH(ADJ,V1)
  !!!  CLASS(ADJ_LST),                      INTENT(INOUT):: ADJ
  !!!  INTEGER,                             INTENT(IN   ):: V1
  !!!  INTEGER:: I,U,V,P
  !!!  DOUBLE PRECISION:: DIST_U, DIST_V, DIST 
  !!!  !
  !!!  IF(.NOT. ALLOCATED(ADJ%SPT      )) ALLOCATE(ADJ%SPT(ADJ%N))
  !!!  IF(.NOT. ALLOCATED(ADJ%BACKPATH)) ALLOCATE(ADJ%BACKPATH(ADJ%N))
  !!!  !
  !!!  ADJ%V1_BACK_PATH = V1
  !!!  !
  !!!  ADJ%SPT       = TRUE  !If FALSE then point is in the tree
  !!!  ADJ%BACKPATH = Z     !Non-Zero when point exists
  !!!  !
  !!!  !!!CALL ADJ%HEAP%INIT(ADJ%N)
  !!!  !
  !!!  CALL ADJ%HEAP%DIJKSTRA_INIT(V1, ADJ%N)  !Set up HEAP For DIJKSTRA Algorithm 
  !!!  !
  !!!  DO WHILE (ADJ%HEAP%SIZE() > Z)
  !!!      !
  !!!      CALL ADJ%HEAP%POP(U, DIST_U)  !GET MIN FROM HEAP
  !!!      !
  !!!      IF(U > Z .AND. DIST_U < D200) THEN !dist is < inf
  !!!          !
  !!!          ADJ%SPT(U) = FALSE  !Point is being explored so add it to the shortest path
  !!!          !
  !!!          DO I=ONE, ADJ%VER(U)%N
  !!!              !
  !!!              V = ADJ%VER(U)%CON(I)
  !!!              !
  !!!              IF(V > Z) THEN
  !!!                 !
  !!!                 IF(ADJ%SPT(V)) THEN  !Have not visited point before
  !!!                      !
  !!!                      DIST = DIST_U + ADJ%VER(U)%WT(I)
  !!!                      !
  !!!                      CALL ADJ%HEAP%GET(V,DIST_V,P)
  !!!                      !
  !!!                      IF( DIST < DIST_V) THEN
  !!!                          ADJ%BACKPATH(V) = U
  !!!                          !ADJ%HEAP%CHILD(P)%PNT%X = DIST  !Update with new lower distance
  !!!                          CALL ADJ%HEAP%SET_X(P,DIST)      !Update with new lower distance
  !!!                      END IF
  !!!                 END IF
  !!!              END IF
  !!!          END DO
  !!!      ELSE
  !!!          EXIT
  !!!      END IF
  !!!      !
  !!!  END DO
  !!!END SUBROUTINE
  !!!!
  !!!PURE SUBROUTINE GET_PATH_DIJKSTRA_SHORTEST_PATH(ADJ,V1,V2,PATH,DIM)
  !!!  CLASS(ADJ_LST),                      INTENT(INOUT):: ADJ
  !!!  INTEGER,                             INTENT(IN   ):: V1,V2
  !!!  INTEGER,                             INTENT(  OUT):: DIM
  !!!  INTEGER, DIMENSION(:), ALLOCATABLE,  INTENT(INOUT):: PATH
  !!!  INTEGER:: I,J
  !!!  !
  !!!  IF(ADJ%V1_BACK_PATH .NE. V1) CALL DIJKSTRA_SHORTEST_PATH(ADJ,V1)
  !!!  !
  !!!  IF(ADJ%BACKPATH(V2) == Z) THEN
  !!!      DIM = Z
  !!!      RETURN
  !!!  END IF
  !!!  !
  !!!  DIM = ONE
  !!!  I   = V2
  !!!  DO WHILE ( ADJ%BACKPATH(I) > Z )
  !!!          DIM = DIM + ONE
  !!!          !
  !!!          I = ADJ%BACKPATH(I)
  !!!  END DO
  !!!  !
  !!!  CALL ALLOC(PATH,DIM)
  !!!  !
  !!!  I       = V2
  !!!  J       = DIM
  !!!  DO J=DIM, ONE, NEG
  !!!          !
  !!!          PATH(J) = I
  !!!          !
  !!!          I = ADJ%BACKPATH(I)
  !!!  END DO
  !!!  !
  !!!END SUBROUTINE
  !
  PURE ELEMENTAL FUNCTION GET_VER_DIM_ADJ_LST(ADJ) RESULT(DIM)
     CLASS(ADJ_LST), INTENT(IN):: ADJ
     INTEGER:: DIM
     !
     DIM = ADJ%N
     !
  END FUNCTION
  !
  PURE ELEMENTAL SUBROUTINE ALLOCATE_ADJ_LST(ADJ,DIM)
     CLASS(ADJ_LST),INTENT(INOUT):: ADJ
     INTEGER,       INTENT(IN   ):: DIM
     !
     IF(DIM < ONE) THEN
         IF(ALLOCATED(ADJ%VER)) DEALLOCATE(ADJ%VER)
         ADJ%N=Z
     ELSEIF(ADJ%N .NE. DIM) THEN
         IF(ALLOCATED(ADJ%VER)) DEALLOCATE(ADJ%VER)
         ALLOCATE(ADJ%VER(DIM))
         ADJ%N=DIM
     ELSE
         CALL RESET_CONNECTIONS_ADJ_LST(ADJ)
     END IF
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE RESET_CONNECTIONS_ADJ_LST(ADJ)
     CLASS(ADJ_LST),INTENT(INOUT):: ADJ
     INTEGER:: I
     !
    DO CONCURRENT (I=ONE:ADJ%N, ADJ%VER(I)%N > Z)
                                ADJ%VER(I)%N = Z
                                DEALLOCATE(ADJ%VER(I)%CON)
                                DEALLOCATE(ADJ%VER(I)%WT)
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ADD_CONNECTION_ADJ_LST(ADJ,V1,V2,WT,ERR)
    CLASS(ADJ_LST),                      INTENT(INOUT):: ADJ
    INTEGER,                             INTENT(IN   ):: V1,V2
    DOUBLE PRECISION,          OPTIONAL, INTENT(IN   ):: WT
    CHARACTER(:), ALLOCATABLE, OPTIONAL, INTENT(INOUT):: ERR
    INTEGER:: DIM
    !
    IF(V1 < ONE .OR. V2 < Z) THEN
                       CALL SET_ERR_MSG('ADJACENCY_LIST_INSTRUCTION RECIEVED VERTEX-CONNECTION PAIR THAT IS INVALID. MAX SIZE OF VERTEX IS '//NUM2STR(ADJ%N)//' BUT THE VERTEX AND CONNECTION RECIEVED WERE: '//NUM2STR(V1)//' AND '//NUM2STR(V2),ERR)
    ELSE
        IF(V1>V2) THEN; DIM = V1
        ELSE;           DIM = V2
        END IF
        !
        IF(DIM > ADJ%N) CALL REALLOCATE_ADJ_LST(ADJ, DIM)
        !
        CALL SET_CONNECTION_ADJ_LST(ADJ,V1,V2,WT,ERR)
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE REALLOCATE_ADJ_LST(ADJ, DIM)
    CLASS(ADJ_LST), INTENT(INOUT):: ADJ
    INTEGER,        INTENT(IN   ):: DIM
    TYPE(ADJ_LST):: TMP
    INTEGER:: I
    !
    IF(ADJ%N < ONE) THEN
                       CALL ALLOCATE_ADJ_LST( ADJ, DIM )
    ELSE
        CALL ALLOCATE_ADJ_LST( TMP, DIM )
        !
        DO CONCURRENT (I=ONE:ADJ%N, ADJ%VER(I)%N > Z)
                                                 TMP%VER(I)%N = ADJ%VER(I)%N
                                                 !
                                                 CALL MOVE_ALLOC(ADJ%VER(I)%CON, TMP%VER(I)%CON)
                                                 CALL MOVE_ALLOC(ADJ%VER(I)%WT , TMP%VER(I)%WT )
        END DO
        !
        DEALLOCATE(ADJ%VER);  ALLOCATE(ADJ%VER(DIM))
        !
        DO CONCURRENT (I=ONE:ADJ%N, TMP%VER(I)%N > Z)
                                                 ADJ%VER(I)%N = TMP%VER(I)%N
                                                 !
                                                 CALL MOVE_ALLOC(TMP%VER(I)%CON, ADJ%VER(I)%CON)
                                                 CALL MOVE_ALLOC(TMP%VER(I)%WT , ADJ%VER(I)%WT )
        END DO
        ADJ%N=DIM
        ADJ%V1_BACK_PATH=Z
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_CONNECTION_ADJ_LST(ADJ,V1,V2,WT,ERR)
    CLASS(ADJ_LST),                      INTENT(INOUT):: ADJ
    INTEGER,                             INTENT(IN   ):: V1,V2
    DOUBLE PRECISION,          OPTIONAL, INTENT(IN   ):: WT
    CHARACTER(:), ALLOCATABLE, OPTIONAL, INTENT(INOUT):: ERR
    INTEGER,          DIMENSION(:),ALLOCATABLE:: ITMP
    DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE:: DTMP
    INTEGER:: I
    DOUBLE PRECISION:: WEIGHT
    !
    IF(PRESENT(WT)) THEN;  WEIGHT = WT
    ELSE;                  WEIGHT = DZ
    END IF
    !
    IF(ADJ%N < ONE) THEN
                       CALL SET_ERR_MSG('ADJACENCY_LIST_INSTRUCTION RECIEVED VERTEX-CONNECTION PAIR WHEN IT WAS NOT ALLOCATED',ERR)
                       !
    ELSEIF(V1 < ONE .OR. V2 < Z .OR. V1 > ADJ%N .OR. V2 > ADJ%N) THEN
                       CALL SET_ERR_MSG('ADJACENCY_LIST_INSTRUCTION RECIEVED VERTEX-CONNECTION PAIR THAT IS INVALID. MAX SIZE OF VERTEX IS '//NUM2STR(ADJ%N)//' BUT THE VERTEX AND CONNECTION RECIEVED WERE: '//NUM2STR(V1)//' AND '//NUM2STR(V2),ERR)
    ELSE
        ASSOCIATE (DIM => ADJ%VER(V1)%N, VER => ADJ%VER(V1))
           !
           IF(DIM == Z) THEN
               ALLOCATE(VER%CON(ONE), SOURCE=V2)
               !
               ALLOCATE(VER%WT(ONE), SOURCE=WEIGHT)
               !
               DIM = ONE
           ELSE
               IF(ALL(VER%CON .NE. V2)) THEN
                   !
                   ALLOCATE(ITMP(DIM+ONE))
                   !
                   ITMP(ONE:DIM) = VER%CON
                   ITMP(DIM+ONE) = V2
                   CALL MOVE_ALLOC(ITMP,VER%CON)
                   !
                   ALLOCATE(DTMP(DIM+ONE))
                   !
                   DTMP(ONE:DIM) = VER%WT
                   !
                   DTMP(DIM+ONE) = WEIGHT
                   !
                   CALL MOVE_ALLOC(DTMP, VER%WT)
                   !
                   DIM = DIM + ONE
                   !
               ELSEIF(PRESENT(WT)) THEN  !Update WT if passed in
                   !
                   DO I=ONE, DIM
                             IF(VER%CON(I)==V2) THEN
                                                VER%WT(I) = WT
                                                EXIT
                             END IF
                   END DO
               END IF
           END IF
        END ASSOCIATE
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_WT_ADJ_LST(ADJ,V1,V2,WT,ERR)
    CLASS(ADJ_LST),                      INTENT(INOUT):: ADJ
    INTEGER,                             INTENT(IN   ):: V1,V2
    DOUBLE PRECISION,                    INTENT(IN   ):: WT
    CHARACTER(:), ALLOCATABLE, OPTIONAL, INTENT(INOUT):: ERR
    INTEGER:: I
    !
    IF(ADJ%N < ONE) THEN
                       CALL SET_ERR_MSG('ADJACENCY_LIST_INSTRUCTION RECIEVED VERTEX-CONNECTION PAIR WHEN IT WAS NOT ALLOCATED',ERR)
                       !
    ELSEIF(V1 < ONE .OR. V2 < Z .OR. V1 > ADJ%N .OR. V2 > ADJ%N) THEN
                       CALL SET_ERR_MSG('ADJACENCY_LIST_INSTRUCTION RECIEVED VERTEX-CONNECTION PAIR THAT IS INVALID. MAX SIZE OF VERTEX IS '//NUM2STR(ADJ%N)//' BUT THE VERTEX AND CONNECTION RECIEVED WERE: '//NUM2STR(V1)//' AND '//NUM2STR(V2),ERR)
    ELSE
        ASSOCIATE (DIM => ADJ%VER(V1)%N, VER => ADJ%VER(V1))
           !
           IF(DIM == Z) THEN
               CALL SET_ERR_MSG('ADJACENCY_LIST_INSTRUCTION RECIEVED VERTEX-CONNECTION-WEIGHT, BUT THE CONNECTION DOES NOT EXIST. THE VERTEX AND CONNECTION RECIEVED WERE: '//NUM2STR(V1)//' AND '//NUM2STR(V2),ERR)
           ELSE
               DO I=ONE, DIM
                   IF(VER%CON(I)==V2) THEN
                      VER%WT(I) = WT
                      EXIT
                   ELSEIF(I==DIM) THEN
                          CALL SET_ERR_MSG('ADJACENCY_LIST_INSTRUCTION RECIEVED VERTEX-CONNECTION-WEIGHT, BUT THE CONNECTION DOES NOT EXIST. THE VERTEX AND CONNECTION RECIEVED WERE: '//NUM2STR(V1)//' AND '//NUM2STR(V2),ERR)
                   END IF
               END DO
             END IF
        END ASSOCIATE
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SCALE_WT_ADJ_LST(ADJ,V1,V2,SCALE,ERR)
    CLASS(ADJ_LST),                      INTENT(INOUT):: ADJ
    INTEGER,                             INTENT(IN   ):: V1,V2
    DOUBLE PRECISION,                    INTENT(IN   ):: SCALE
    CHARACTER(:), ALLOCATABLE, OPTIONAL, INTENT(INOUT):: ERR
    INTEGER:: I
    !
    IF(ADJ%N < ONE) THEN
                       CALL SET_ERR_MSG('ADJACENCY_LIST_INSTRUCTION RECIEVED VERTEX-CONNECTION PAIR WHEN IT WAS NOT ALLOCATED',ERR)
                       !
    ELSEIF(V1 < ONE .OR. V2 < Z .OR. V1 > ADJ%N .OR. V2 > ADJ%N) THEN
                       CALL SET_ERR_MSG('ADJACENCY_LIST_INSTRUCTION RECIEVED VERTEX-CONNECTION PAIR THAT IS INVALID. MAX SIZE OF VERTEX IS '//NUM2STR(ADJ%N)//' BUT THE VERTEX AND CONNECTION RECIEVED WERE: '//NUM2STR(V1)//' AND '//NUM2STR(V2),ERR)
    ELSE
        ASSOCIATE (DIM => ADJ%VER(V1)%N, VER => ADJ%VER(V1))
           !
           IF(DIM == Z) THEN
               CALL SET_ERR_MSG('ADJACENCY_LIST_INSTRUCTION RECIEVED VERTEX-CONNECTION-WEIGHT, BUT THE CONNECTION DOES NOT EXIST. THE VERTEX AND CONNECTION RECIEVED WERE: '//NUM2STR(V1)//' AND '//NUM2STR(V2),ERR)
           ELSE
               DO I=ONE, DIM
                   IF(VER%CON(I)==V2) THEN
                      !
                      IF(VER%WT(I) < D100) VER%WT(I) = VER%WT(I) * SCALE 
                      EXIT
                   ELSEIF(I==DIM) THEN
                          CALL SET_ERR_MSG('ADJACENCY_LIST_INSTRUCTION RECIEVED VERTEX-CONNECTION-WEIGHT, BUT THE CONNECTION DOES NOT EXIST. THE VERTEX AND CONNECTION RECIEVED WERE: '//NUM2STR(V1)//' AND '//NUM2STR(V2),ERR)
                   END IF
               END DO
             END IF
        END ASSOCIATE
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SORT_CONNECTIONS_ADJ_LST(ADJ)
    CLASS(ADJ_LST),                      INTENT(INOUT):: ADJ
    INTEGER:: I
    !
    DO CONCURRENT (I=ONE:ADJ%N, ADJ%VER(I)%N > ONE)
          !
          CALL SORT(ADJ%VER(I)%N, ADJ%VER(I)%CON, ADJ%VER(I)%WT)
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_ERR_MSG(MSG,ERR)
    CHARACTER(*),                        INTENT(IN   ):: MSG
    CHARACTER(:), ALLOCATABLE, OPTIONAL, INTENT(INOUT):: ERR
    !
    IF(PRESENT(ERR)) THEN
         IF(ALLOCATED(ERR)) THEN
             ERR = ERR//MSG//NL
         ELSE
             ERR = MSG//NL
         END IF
    END IF
    !
  END SUBROUTINE
END MODULE
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
SUBMODULE (ADJACENCY_LIST_INSTRUCTION) VERTEX_VERTEX_PATH_SUBS
  !
  IMPLICIT NONE
  !
  CONTAINS  ! ------------------------------------------------------------------------------------------------------------------------------------------------------
  !
  MODULE PURE SUBROUTINE MAKE_PATH_VERTEX_VERTEX_PATH(VTX, BACKPATH, REBUILD)
    CLASS(VERTEX_VERTEX_PATH), INTENT(INOUT):: VTX
    TYPE(VERTEX_BACKPATH),     INTENT(IN   ):: BACKPATH
    LOGICAL,         OPTIONAL, INTENT(IN   ):: REBUILD
    LOGICAL:: FORCE_REBUILD
    !
    IF(PRESENT(REBUILD)) THEN
                        FORCE_REBUILD = REBUILD
    ELSE
                        FORCE_REBUILD = FALSE
    END IF
    !
    IF(VTX%V1 == BACKPATH%V1 .AND. BACKPATH%N > Z) THEN
        !
        IF(VTX%N == Z .OR. FORCE_REBUILD) CALL BUILD_DIJKSTRA_PATH_VERTEX_VERTEX_PATH( BACKPATH, VTX)
        !
    END IF
    !
  END SUBROUTINE
  !
  MODULE PURE SUBROUTINE EXTEND_VERTEX_VERTEX_PATH(VTX, V1, V2)
    TYPE(VERTEX_VERTEX_PATH), DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: VTX
    INTEGER,                                             INTENT(IN   ):: V1, V2
    TYPE(VERTEX_VERTEX_PATH), DIMENSION(:), ALLOCATABLE:: TMP
    INTEGER:: DIM
    !
    IF(ALLOCATED(VTX)) THEN
        DIM = SIZE(VTX)
        ALLOCATE(TMP(DIM+ONE))
        !
        CALL MOVE_VERTEX_VERTEX_PATH(VTX, TMP(:DIM))
        !
        DEALLOCATE(VTX)
        CALL MOVE_ALLOC(TMP, VTX)
    ELSE
        ALLOCATE(VTX(ONE))
        CALL SET_V_VERTEX_VERTEX_PATH(VTX(ONE), V1, V2)
        VTX%N = Z
    END IF
    !
  END SUBROUTINE
  !
  MODULE ELEMENTAL PURE SUBROUTINE COPY_VERTEX_VERTEX_PATH(VTX_OUT,VTX_IN)
    CLASS(VERTEX_VERTEX_PATH), INTENT(IN   ):: VTX_IN
    CLASS(VERTEX_VERTEX_PATH), INTENT(INOUT):: VTX_OUT
    !
    VTX_OUT%V1  = VTX_IN%V1
    VTX_OUT%V2  = VTX_IN%V2
    VTX_OUT%N   = VTX_IN%N
    CALL ALLOC(VTX_OUT%PATH, VTX_OUT%N, SRC=VTX_IN%PATH)
    !
  END SUBROUTINE
  !
  MODULE ELEMENTAL PURE SUBROUTINE MOVE_VERTEX_VERTEX_PATH(VTX_IN, VTX_OUT)
    CLASS(VERTEX_VERTEX_PATH), INTENT(INOUT):: VTX_IN
    CLASS(VERTEX_VERTEX_PATH), INTENT(INOUT):: VTX_OUT
    !
    VTX_OUT%V1  = VTX_IN%V1
    VTX_OUT%V2  = VTX_IN%V2
    VTX_OUT%N   = VTX_IN%N
    !
    IF(VTX_IN%N > Z) CALL MOVE_ALLOC(VTX_IN%PATH, VTX_OUT%PATH)
    !
    VTX_IN%V1 = Z
    VTX_IN%V2 = Z
    VTX_IN%N  = Z
    !
  END SUBROUTINE
  !
  MODULE PURE SUBROUTINE ALLOC_VERTEX_VERTEX_PATH(VTX, N)
    CLASS(VERTEX_VERTEX_PATH), INTENT(INOUT):: VTX
    INTEGER,                   INTENT(IN   ):: N
    !
    IF( N > Z) THEN
        VTX%N = N
    ELSE
        VTX%N = Z
    END IF
    !
    CALL ALLOC(VTX%PATH, N)
    !
  END SUBROUTINE
  !
  MODULE ELEMENTAL PURE SUBROUTINE SET_V_VERTEX_VERTEX_PATH(VTX, V1, V2, NEW_ALLOC)
    CLASS(VERTEX_VERTEX_PATH),                     INTENT(INOUT):: VTX
    INTEGER,                                       INTENT(IN   ):: V1, V2
    LOGICAL,                             OPTIONAL, INTENT(  OUT):: NEW_ALLOC
    !
    IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=FALSE
    !
    IF(VTX%V1.NE.V1 .OR. VTX%V2.NE.V2 .OR. V1 < ONE .OR. V2 < ONE) THEN
                                                                   VTX%N = Z
                                                                   CALL ALLOC(VTX%PATH, Z, NEW_ALLOC=NEW_ALLOC)
    END IF
    !
    IF(V1 > Z) THEN
               VTX%V1 = V1
    ELSE
               VTX%V1 = Z
    END IF
    !
    IF(V2 > Z) THEN
               VTX%V2 = V2
    ELSE
               VTX%V2 = Z
    END IF
    !
  END SUBROUTINE
  !
  MODULE PURE SUBROUTINE SET_V1_VERTEX_VERTEX_PATH(VTX, V1, NEW_ALLOC)
    CLASS(VERTEX_VERTEX_PATH),                     INTENT(INOUT):: VTX
    INTEGER,                                       INTENT(IN   ):: V1
    LOGICAL,                             OPTIONAL, INTENT(  OUT):: NEW_ALLOC
    !
    IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=FALSE
    !
    IF(VTX%V1.NE.V1 .OR. V1 < ONE) THEN
                                   VTX%N = Z
                                   CALL ALLOC(VTX%PATH, Z, NEW_ALLOC=NEW_ALLOC)
    END IF
    !
    IF(V1 > Z) THEN
               VTX%V1 = V1
    ELSE
               VTX%V1 = Z
    END IF
    !
  END SUBROUTINE
  !
  MODULE PURE SUBROUTINE SET_V2_VERTEX_VERTEX_PATH(VTX, V2, NEW_ALLOC)
    CLASS(VERTEX_VERTEX_PATH),                     INTENT(INOUT):: VTX
    INTEGER,                                       INTENT(IN   ):: V2
    LOGICAL,                             OPTIONAL, INTENT(  OUT):: NEW_ALLOC
    !
    IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=FALSE
    !
    IF(VTX%V2.NE.V2 .OR. V2 < ONE) THEN
                                   VTX%N = Z
                                   CALL ALLOC(VTX%PATH, Z, NEW_ALLOC=NEW_ALLOC)
    END IF
    !
    IF(V2 > Z) THEN
               VTX%V2 = V2
    ELSE
               VTX%V2 = Z
    END IF
    !
  END SUBROUTINE
  !
END SUBMODULE 
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
SUBMODULE (ADJACENCY_LIST_INSTRUCTION) VERTEX_BACKPATH_SUBS
  !
  IMPLICIT NONE
  !
  CONTAINS  ! ------------------------------------------------------------------------------------------------------------------------------------------------------
  !
  MODULE PURE FUNCTION IS_VERTEX_MATCH(VTX, V1) RESULT(IS_MATCH)
    CLASS(VERTEX_BACKPATH), INTENT(IN):: VTX
    INTEGER,                INTENT(IN):: V1
    LOGICAL:: IS_MATCH
    !
    IS_MATCH = VTX%V1 == V1
    !
  END FUNCTION
  !
  MODULE PURE FUNCTION IS_VERTEX_AND_DIM_MATCH(VTX, V1, DIM) RESULT(IS_MATCH)
    CLASS(VERTEX_BACKPATH), INTENT(IN):: VTX
    INTEGER,                INTENT(IN):: V1, DIM
    LOGICAL:: IS_MATCH
    !
    IS_MATCH = VTX%V1 == V1 .AND. VTX%N == DIM
    !
  END FUNCTION
  !
  MODULE PURE SUBROUTINE ALLOCATE_VERTEX_BACKPATH(VTX, DIM, V1)
    CLASS(VERTEX_BACKPATH), INTENT(INOUT):: VTX
    INTEGER,                INTENT(IN   ):: DIM
    INTEGER,  OPTIONAL,     INTENT(IN   ):: V1
    !
    IF(PRESENT(V1)) THEN
        VTX%V1 = V1
    ELSE
        VTX%V1 = Z
    END IF
    !
    VTX%GOT_BACK = FALSE
    VTX%N  = DIM
    CALL ALLOC(VTX%BACKPATH, DIM)
    !
  END SUBROUTINE
  !
  MODULE PURE SUBROUTINE SET_V1_VERTEX_BACKPATH(VTX, V1)
    CLASS(VERTEX_BACKPATH), INTENT(INOUT):: VTX
    INTEGER,                INTENT(IN   ):: V1
    !
    IF(V1 .NE. VTX%V1) THEN
               VTX%V1 = V1
               VTX%GOT_BACK = FALSE
    END IF
    !
  END SUBROUTINE
  !
  MODULE PURE SUBROUTINE CLOSEST_COMMON_VERTEX_BACKPATH(VTX, V2, V3, JUNCT, DN2, DN3)
    CLASS(VERTEX_BACKPATH), INTENT(IN   ):: VTX
    INTEGER,                INTENT(IN   ):: V2, V3
    INTEGER,     OPTIONAL,  INTENT(INOUT):: JUNCT, DN2, DN3
    INTEGER:: CON
    INTEGER:: I, J, D2, D3
    !
    D2 = V2
    D3 = V3
    CON = Z
    IF(V2 == V3) THEN
       CON = V3
    ELSEIF(V2 <= VTX%N .AND. V3 <= VTX%N) THEN
          !
          I = V2
          J = V3
V2_LOOP:  DO WHILE ( VTX%BACKPATH(I) > Z )
                !
                D2 = I
                I  = VTX%BACKPATH(I)
                !
                J = V3
                !
                DO WHILE ( VTX%BACKPATH(J) > Z )
                      !
                      D3 = J
                      J  = VTX%BACKPATH(J)
                      !
                      IF(I == J) THEN
                                 CON = I
                                 EXIT V2_LOOP
                      END IF
                END DO
          END DO V2_LOOP
    END IF
    !
    IF(PRESENT(DN2)) DN2 = D2 
    IF(PRESENT(DN3)) DN3 = D3
    IF(PRESENT(JUNCT)) JUNCT = CON 
    !
  END SUBROUTINE
  !
!!!  MODULE PURE SUBROUTINE CLOSEST_COMMON_VERTEX_BACKPATH_VERTEX_BACKPATH(VTX, VTY, JUNCT, UP1, UP2)
!!!    CLASS(VERTEX_BACKPATH), INTENT(IN   ):: VTX
!!!    CLASS(VERTEX_BACKPATH), INTENT(IN   ):: VTY
!!!    INTEGER,                INTENT(INOUT):: JUNCT
!!!    INTEGER,     OPTIONAL,  INTENT(INOUT):: UP1, UP2
!!!    INTEGER:: I, BS
!!!    LOGICAL, DIMENSION(:), ALLOCATABLE:: CHK1, CHK2
!!!    !
!!!    ASSOCIATE(V1 => VTX%V1, DIM1 => VTX%N, B1 => VTX%BACKPATH &
!!!              V2 => VTY%V1, DIM2 => VTY%N, B2 => VTY%BACKPATH  )
!!!    !
!!!    IF(V1 < ONE .OR. V2 < ONE .OR. V1 > DIM1 .OR. V1 > DIM2 .OR. V2 > DIM1 .OR. V2 > DIM2 .OR. DIM1 < ONE .OR. DIM2 < Z) THEN
!!!           JUNCT = Z
!!!    ELSEIF(V1 == V2) THEN
!!!           JUNCT = V1
!!!    ELSE
!!!          ALLOCATE(CHK1(DIM1), SOURCE=TRUE)
!!!          ALLOCATE(CHK2(DIM2), SOURCE=TRUE)
!!!          !
!!!LOOP:     DO I = ONE, DIM1
!!!                V = B1
!!!                !
!!!                D2 = I
!!!                I  = VTX%BACKPATH(I)
!!!                !
!!!                J = V3
!!!                !
!!!                DO WHILE ( VTX%BACKPATH(J) > Z )
!!!                      !
!!!                      D3 = J
!!!                      J  = VTX%BACKPATH(J)
!!!                      !
!!!                      IF(I == J) THEN
!!!                                 CON = I
!!!                                 EXIT V2_LOOP
!!!                      END IF
!!!                END DO
!!!          END DO V2_LOOP
!!!    END IF
!!!    !
!!!    IF(PRESENT(DN2)) DN2 = D2 
!!!    IF(PRESENT(DN3)) DN3 = D3
!!!    IF(PRESENT(JUNCT)) JUNCT = CON 
!!!    !
!!!  END SUBROUTINE
  !
  MODULE PURE FUNCTION BACKSTEP_VERTEX_BACKPATH(VTX, V2) RESULT(BACKSTEP)
    CLASS(VERTEX_BACKPATH), INTENT(IN):: VTX
    INTEGER,                INTENT(IN):: V2
    INTEGER:: BACKSTEP
    !
    IF(V2 < ONE .OR. VTX%N < V2) THEN
        BACKSTEP = Z
    ELSE
        BACKSTEP = VTX%BACKPATH(V2)
    END IF
    !
  END FUNCTION
  !
  MODULE PURE FUNCTION NSTEP_VERTEX_BACKPATH(VTX, V2) RESULT(DIM)
    CLASS(VERTEX_BACKPATH), INTENT(IN):: VTX
    INTEGER,                INTENT(IN):: V2
    INTEGER:: DIM
    INTEGER:: I
    !
    DIM = Z
    IF(V2 > Z .AND. V2 <= VTX%N) THEN
                                 DIM = ONE
                                 I   = V2
                                 DO WHILE ( VTX%BACKPATH(I) > Z )
                                         DIM = DIM + ONE
                                         !
                                         I = VTX%BACKPATH(I)
                                 END DO
    END IF
    !
  END FUNCTION
  !
  MODULE PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_BINARY_HEAP(VTX)
    TYPE(VERTEX_BACKPATH), INTENT(INOUT):: VTX
    !
    VTX%N  = Z
    VTX%V1 = Z
    VTX%GOT_BACK = FALSE
    IF(ALLOCATED(VTX%BACKPATH)) DEALLOCATE(VTX%BACKPATH)
  END SUBROUTINE
  !
END SUBMODULE 
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!
!
!  Module superceded by features that can be performed by ADJACENCY_LIST_INSTRUCTION with ADJ_LST and VERTEX_BACKPATH
!
!
!!!MODULE MULTI_DIJKSTRA_SHORTEST_PATH!, ONLY: DIJKSTRA_PATHS
!!!  USE CONSTANTS
!!!  USE ALLOC_INTERFACE,        ONLY: ALLOC
!!!  USE BINARY_HEAP_INSTRUCTION,    ONLY: BINARY_HEAP
!!!  USE ADJACENCY_LIST_INSTRUCTION, ONLY: ADJ_LST
!!!  IMPLICIT NONE
!!!  PRIVATE
!!!  PUBLIC:: DIJKSTRA_PATHS
!!!  !
!!!  TYPE DIJKSTRA_PATHS
!!!      INTEGER:: DIM = Z
!!!      INTEGER:: N   = Z !Size of BACKPATH(N,DIM)
!!!      !
!!!      TYPE(BINARY_HEAP):: HEAP
!!!      INTEGER, DIMENSION(:),   ALLOCATABLE:: V1
!!!      LOGICAL, DIMENSION(:),   ALLOCATABLE:: SPT        !Shortest Path Tree -- Used by DIJKSTRA to keep track of the vertices which are currently in min HEAP.
!!!      INTEGER, DIMENSION(:,:), ALLOCATABLE:: BACKPATH  !Holdest best backstep for any vertex -- Used by DIJKSTRA to keep track of the vertices which are currently in min HEAP.
!!!      !
!!!      CONTAINS
!!!      !
!!!      PROCEDURE, PASS(PTH):: INIT      => ALLOCATE_DIJKSTRA_PATHS               !INIT(ADJ,VERT)
!!!      PROCEDURE, PASS(PTH):: GET_PATH  => GET_PATH_DIJKSTRA_SHORTEST_PATH       !GET_PATH(V1,V2,PATH,DIM)
!!!      PROCEDURE, PASS(PTH):: GET_COMMON=> CLOSEST_COMMON_DIJKSTRA_SHORTEST_PATH !GET_COMMON(V1,V2,V3,JUNCT)
!!!  END TYPE
!!!  !
!!!  CONTAINS
!!!  !
!!!  PURE SUBROUTINE ALLOCATE_DIJKSTRA_PATHS(PTH,ADJ,VERT)
!!!    CLASS(DIJKSTRA_PATHS), INTENT(INOUT):: PTH
!!!    CLASS(ADJ_LST),        INTENT(IN   ):: ADJ
!!!    INTEGER, DIMENSION(:), INTENT(IN   ):: VERT
!!!    INTEGER:: I, J, V1,U,V,P
!!!    DOUBLE PRECISION:: DIST_U, DIST_V, DIST 
!!!    !
!!!    PTH%DIM = SIZE(VERT)
!!!    PTH%N = ADJ%N
!!!    !
!!!    CALL ALLOC(PTH%V1, PTH%N, SRC=VERT)
!!!    !
!!!    CALL ALLOC(PTH%SPT, PTH%N)
!!!    !
!!!    CALL ALLOC(PTH%BACKPATH, PTH%N, PTH%DIM)
!!!    !
!!!    PTH%BACKPATH = Z
!!!    !
!!!    CALL PTH%HEAP%INIT(PTH%N)  !Set up Heap to sort PTH%N vertices
!!!    !
!!!    DO J=ONE, PTH%DIM
!!!            V1 = VERT(J)
!!!            !
!!!            PTH%SPT = TRUE
!!!            !
!!!            CALL PTH%HEAP%DIJKSTRA_INIT(V1)  !Set up HEAP For DIJKSTRA Algorithm 
!!!            !
!!!            DO WHILE (PTH%HEAP%SIZE() > Z)
!!!                !
!!!                CALL PTH%HEAP%POP(U, DIST_U)  !GET MIN FROM HEAP
!!!                !
!!!                IF(U > Z .AND. DIST_U < near_inf) THEN !dist is < inf
!!!                    !
!!!                    PTH%SPT(U) = FALSE  !Point is being explored so add it to the shortest path
!!!                    !
!!!                    DO I=ONE, ADJ%VER(U)%N
!!!                        !
!!!                        V = ADJ%VER(U)%CON(I)
!!!                        !
!!!                        IF(V > Z) THEN
!!!                           !
!!!                           IF(PTH%SPT(V)) THEN  !Have not visited point before
!!!                                !
!!!                                DIST = DIST_U + ADJ%VER(U)%WT(I)
!!!                                !
!!!                                CALL PTH%HEAP%GET(V,DIST_V,P)
!!!                                !
!!!                                IF( DIST < DIST_V) THEN
!!!                                    PTH%BACKPATH(V,J) = U
!!!                                    !
!!!                                    CALL PTH%HEAP%SET_X(P,DIST)      !Update with new lower distance
!!!                                END IF
!!!                           END IF
!!!                        END IF
!!!                    END DO
!!!                ELSE
!!!                    EXIT
!!!                END IF
!!!                !
!!!            END DO
!!!    END DO
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  PURE SUBROUTINE GET_PATH_DIJKSTRA_SHORTEST_PATH(PTH,V1,V2,PATH,DIM)
!!!    CLASS(DIJKSTRA_PATHS),               INTENT(INOUT):: PTH
!!!    INTEGER,                             INTENT(IN   ):: V1,V2
!!!    INTEGER,                             INTENT(  OUT):: DIM
!!!    INTEGER, DIMENSION(:), ALLOCATABLE,  INTENT(INOUT):: PATH
!!!    INTEGER:: I,J,K
!!!    !
!!!    K = Z
!!!    DO J=ONE, PTH%DIM
!!!        IF(V1 == PTH%V1(J)) THEN
!!!            K = J
!!!            EXIT
!!!        END IF
!!!    END DO
!!!    !
!!!    IF(K == Z) THEN                              !-----------------------
!!!                                      DIM = NEG                          !Vertex V1 was not part of the DIJKSTRA_PATHS initialization
!!!    ELSEIF(PTH%BACKPATH(V2,K) == Z) THEN        !-----------------------
!!!                                      DIM = Z                            !No connection between V1 and V2
!!!    ELSE !---------------------------------------------------------------
!!!                                      DIM = ONE
!!!                                      I   = V2
!!!                                      DO WHILE ( PTH%BACKPATH(I,K) > Z )
!!!                                              DIM = DIM + ONE
!!!                                              !
!!!                                              I = PTH%BACKPATH(I,K)
!!!                                      END DO
!!!                                      !
!!!                                      CALL ALLOC(PATH,DIM)
!!!                                      !
!!!                                      I       = V2
!!!                                      J       = DIM
!!!                                      DO J=DIM, ONE, NEG
!!!                                              !
!!!                                              PATH(J) = I
!!!                                              !
!!!                                              I = PTH%BACKPATH(I,K)
!!!                                      END DO
!!!    END IF  !------------------------------------------------------------
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  PURE SUBROUTINE CLOSEST_COMMON_DIJKSTRA_SHORTEST_PATH(PTH,V1,V2,V3,JUNCT)   !V1 and V2 common point to V3
!!!    CLASS(DIJKSTRA_PATHS),               INTENT(INOUT):: PTH
!!!    INTEGER,                             INTENT(IN   ):: V1,V2,V3
!!!    INTEGER,                             INTENT(  OUT):: JUNCT
!!!    INTEGER:: I,J, DIM1, DIM2
!!!    INTEGER, DIMENSION(:),ALLOCATABLE:: PATH1, PATH2
!!!    !
!!!    IF(V1 == V2) THEN
!!!        JUNCT = V1
!!!        RETURN
!!!    END IF
!!!    !
!!!    CALL GET_PATH_DIJKSTRA_SHORTEST_PATH(PTH,V1,V3,PATH1,DIM1)
!!!    !
!!!    IF    (DIM1 < Z ) THEN
!!!                       JUNCT = NEG
!!!    ELSEIF(DIM1 == Z) THEN
!!!                       JUNCT = Z
!!!    END IF
!!!    !
!!!    IF(DIM1 < ONE) RETURN
!!!    !
!!!    CALL GET_PATH_DIJKSTRA_SHORTEST_PATH(PTH,V2,V3,PATH2,DIM2)
!!!    !
!!!    IF    (DIM2 < Z ) THEN
!!!                       JUNCT = NEG
!!!    ELSEIF(DIM2 == Z) THEN
!!!                       JUNCT = Z
!!!    END IF
!!!    !
!!!    IF(DIM2 < ONE) RETURN
!!!    !
!!!    LP: DO I=ONE, DIM1
!!!        DO J=ONE, DIM2
!!!                     IF( PATH1(I) == PATH2(J) ) THEN
!!!                         JUNCT = PATH1(I)
!!!                         EXIT LP
!!!                     END IF
!!!        END DO
!!!    END DO LP
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!END MODULE
!!
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
! 
MODULE IXJ_INSTRUCTION!, ONLY: IXJ_STRUCTURE, IXJ_SINGLE_ENTRY
  !OPENS AN FILE FOR WRITING. PROVIDES GENERIC INTERFACING FOR WRITTING TO FILE. IF OPEN/CLOSE AUOTMATICALLY CLOSES FILES
  !
  USE, INTRINSIC:: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN
  USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: SNG => REAL32, DBL => REAL64
  USE CONSTANTS,                        ONLY: DZ, Z, ONE, TWO, FOUR, SIX, EIGHT, TEN, TRUE, FALSE, BLNK, NL, BLN
  USE UTIL_INTERFACE,                   ONLY: GET, STOP_ERROR
  USE NUM2STR_INTERFACE,                ONLY: NUM2STR
  USE ARRAY_DATA_TYPES,                 ONLY: COMPRESSED_VALUE_STORAGE, COMPRESSED_LOCATION_STORAGE
  USE ALLOC_INTERFACE,                  ONLY: ALLOC
  USE GENERIC_BLOCK_READER_INSTRUCTION, ONLY: GENERIC_BLOCK_READER
  USe GENERIC_INPUT_FILE_INSTRUCTION,     ONLY: GENERIC_INPUT_FILE
  !
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: IXJ_STRUCTURE, IXJ_SINGLE_ENTRY
  !
  TYPE IXJ_SINGLE_ENTRY
      INTEGER,   DIMENSION(:), ALLOCATABLE:: I
      REAL(DBL), DIMENSION(:), ALLOCATABLE:: X
      INTEGER,   DIMENSION(:), ALLOCATABLE:: J
      !
  CONTAINS
      !
      GENERIC             :: ALLOC         => ALLOCATE_IXJ_SINGLE_ENTRY, ALLOCATE_IXJ_SINGLE_ENTRY_ELM
      GENERIC             :: GET_DIM       => GET_IXJ_SINGLE_ENTRY_DIM,      &  !(DIM)
                                              GET_IXJ_SINGLE_ENTRY_DIM_I_X_J    !([I],[X],[J])
      PROCEDURE, PASS(DAT):: MOVE          => MOVE_IXJ_SINGLE_ENTRY! (DAT_TO)
      PROCEDURE, PASS(DAT):: DESTROY       => DESTROY_IXJ_SINGLE_ENTRY
      GENERIC             :: ASSIGNMENT(=) => COPY_IXJ_SINGLE_ENTRY
      GENERIC             :: OPERATOR(==)  => EQUALITY_IXJ_SINGLE_ENTRY
      !
      PROCEDURE, PASS(DAT),PRIVATE:: ALLOCATE_IXJ_SINGLE_ENTRY
      PROCEDURE, PASS(DAT),PRIVATE:: ALLOCATE_IXJ_SINGLE_ENTRY_ELM
      PROCEDURE,           PRIVATE:: COPY_IXJ_SINGLE_ENTRY
      PROCEDURE,           PRIVATE:: EQUALITY_IXJ_SINGLE_ENTRY
      PROCEDURE, PASS(DAT),PRIVATE:: GET_IXJ_SINGLE_ENTRY_DIM
      PROCEDURE, PASS(DAT),PRIVATE:: GET_IXJ_SINGLE_ENTRY_DIM_I_X_J
      !
      FINAL:: FINAL_IXJ_SINGLE_ENTRY  !-- Causes compile error in GFORTRAN
      !
  END TYPE
  !
  TYPE IXJ_STRUCTURE
      !
      INTEGER:: N    = Z   !Count that is currently loaded
      INTEGER:: SIZ  = Z   !Size of DAT that is currently allocated
      !
      LOGICAL:: IS_CONSTANT = FALSE  !IF TRUE, THEN N = 1 and all intries equal CONSTANT VALUE
      !
      INTEGER:: P = ONE !SCRATCH VAR FOR POSITION
      INTEGER:: IOUT = Z
      !
      INTEGER, DIMENSION(3):: DIM = Z !HOLDS DIM of I, X, J
      !
      TYPE(IXJ_SINGLE_ENTRY), DIMENSION(:), ALLOCATABLE:: DAT
      !
      CHARACTER(:), ALLOCATABLE:: ERRMSG
      !
      CONTAINS
      !
      GENERIC             :: INIT     => INIT_IXJ_STRUCTURE,  &      !INIT(DIM1, DIM2, DIM3, OUTPUT, [SIZ], [EXACT])
                                         INIT_IXJ_STRUCTURE_DIMVEC   !INIT(DIM,              OUTPUT, [SIZ], [EXACT])
      GENERIC             :: LOAD     => LOAD_IXJ_STRUCTURE_LINE,  & !LOAD(LINE, LLOC, [INFILE  ], [OUTPUT], [SCALE], [NOSTOP], [MSG])
                                         LOAD_IXJ_STRUCTURE_IU       !LOAD(IU,         [ERROR_IU], [OUTPUT], [NOSTOP], [CONST], [FIRST_LINE], [MSG])
      !
      PROCEDURE, PASS(IXJ):: STR      => PRINT_IXJ_STRUCTURE         !STR([P], [PAD_INT], [PAD_DBL]) 
      !
      PROCEDURE, PASS(IXJ):: COUNT_ID => COUNT_INT_IXJ_STRUCTURE     !COUNT_ID(ID, ICOL, CNT)
      PROCEDURE, PASS(IXJ):: GET_VAL  => GET_POS_P_VAL_PART          !GET_VAL(ICOL) RESULT(VAL)
      PROCEDURE, PASS(IXJ):: GET_VALUE_IXJ                           !GET_VALUE_IXJ(VAL, IVAL, ID, ID_COL, ROW, IROW, COL, ICOL, FOUND, FROM_START)
      !
      PROCEDURE, PASS(IXJ):: MOVE_POS_P_TO_RECORD          !(FOUND, FROM_START, ID, ID_COLNUM, ROW, IROW, COL, ICOL)
      !
      PROCEDURE, PASS(IXJ):: START    => SET_POS_P_TO_START    !([EOF])
      PROCEDURE, PASS(IXJ):: NEXT     => MOVE_POS_P_TO_NEXT    !([EOF])
      !
      PROCEDURE, PASS(IXJ):: START_ID => SET_POS_P_TO_START_ID !START_ID(ID, ICOL, [EOF]) 
      PROCEDURE, PASS(IXJ):: NEXT_ID  => MOVE_POS_P_TO_NEXT_ID !NEXT_ID (ID, ICOL, [EOF])
      ! 
      PROCEDURE, PASS(IXJ):: MATCH_INT=> MATCH_POS_P_INT_PART     !(ID1, C1, [ID2, C2], [ID3, C3], [ID4, C4])
      !
      GENERIC             :: SORT_BY_I=> SORT_BY_INT_COLVEC,   &  ! SORT_BY_I(IXJ, ICOL)   ICOL is DIM(:)
                                         SORT_BY_INT_COL,      &  ! SORT_BY_I(IXJ, ICOL) 
                                         SORT_BY_INT_COL1_COL2    ! SORT_BY_I(IXJ, ICOL1, ICOL2)
      !
      GENERIC             :: TO_ARRAY     => COPY_TO_2D_ARRAY_DBL, & !TO_ARRAY(IROW, ICOL, VPOS, DIM1, DIM2, ARR, ERROR)
                                             COPY_TO_2D_ARRAY_INT    !TO_ARRAY(IROW, ICOL, IPOS, DIM1, DIM2, ARR, ERROR)
      !
      GENERIC             :: TO_CVS      => BUILD_COMPRESSED_VALUE_STORAGE_TYPE_DIM2, & !TO_CVS(IDIM1, IDIM2, VPOS, CVS)
                                            BUILD_COMPRESSED_VALUE_STORAGE_TYPE_DIM3    !TO_CVS(IDIM1, IDIM2, IDIM3, VPOS, CVS)
      !
      PROCEDURE, PASS(IXJ):: TO_LAC      => BUILD_COMPRESSED_LOCATION_STORAGE_TYPE      !(IDIM1, IDIM2, IDIM_ID, ID, LAC) 
      PROCEDURE, PASS(IXJ):: TO_LAC_BYDIM=> BUILD_COMPRESSED_LOCATION_STORAGE_TYPE_BYDIM!(IDIM1, IDIM2, IDIM_ID,     LAC)
      !
      PROCEDURE, PASS(IXJ):: DESTROY  => DESTROY_IXJ_STRUCTURE !(IU)
      !
      PROCEDURE, PASS(IXJ), PRIVATE:: LOAD_IXJ_STRUCTURE_IU  !(IU, [ERROR_IU], [OUTPUT], [NOSTOP], [CONST], [FIRST_LINE], [MSG])
      PROCEDURE, PASS(IXJ), PRIVATE:: LOAD_IXJ_STRUCTURE_LINE!(LINE, LLOC, [INFILE], [OUTPUT], [SCALE], [NOSTOP], [MSG])
      !
      PROCEDURE, PASS(IXJ), PRIVATE:: INIT_IXJ_STRUCTURE
      PROCEDURE, PASS(IXJ), PRIVATE:: INIT_IXJ_STRUCTURE_DIMVEC
      !
      PROCEDURE, PASS(IXJ), PRIVATE:: SORT_BY_INT_COLVEC   !(IXJ, ICOL)
      PROCEDURE, PASS(IXJ), PRIVATE:: SORT_BY_INT_COL      !(IXJ, ICOL) 
      PROCEDURE, PASS(IXJ), PRIVATE:: SORT_BY_INT_COL1_COL2!(IXJ, ICOL1, ICOL2)
      !
      PROCEDURE, PASS(IXJ), PRIVATE:: COPY_TO_2D_ARRAY_DBL !(IROW, ICOL, VPOS, DIM1, DIM2, ARR, ERROR)
      PROCEDURE, PASS(IXJ), PRIVATE:: COPY_TO_2D_ARRAY_INT !(IROW, ICOL, IPOS, DIM1, DIM2, ARR, ERROR)
      !
      PROCEDURE, PASS(IXJ), PRIVATE:: BUILD_COMPRESSED_VALUE_STORAGE_TYPE_DIM2 !(IDIM1, IDIM2, VPOS, CVS)
      PROCEDURE, PASS(IXJ), PRIVATE:: BUILD_COMPRESSED_VALUE_STORAGE_TYPE_DIM3 !(IDIM1, IDIM2, IDIM3, VPOS, CVS)
      !
      !!!PROCEDURE, PASS(IXJ):: GET_J_IXJ                   !(J,   IVAL, ID, ID_COL, ROW, IROW, COL, ICOL, FOUND, FROM_START)
      !
      FINAL::                           FINAL_DESTROY_IXJ_STRUCTURE
  END TYPE
  !
  CONTAINS
  !
  ! #############################################################################################################################
  ! #############################################################################################################################
  ! #############################################################################################################################
  !
  PURE FUNCTION PRINT_IXJ_STRUCTURE(IXJ, P, PAD_INT, PAD_DBL) RESULT(STR)
    CLASS(IXJ_STRUCTURE), INTENT(IN):: IXJ
    INTEGER,    OPTIONAL, INTENT(IN):: P, PAD_INT, PAD_DBL
    CHARACTER(:),        ALLOCATABLE:: STR
    INTEGER:: I
    !
    IF(PRESENT(P)) THEN
                    STR = PRINT_IXJ_STRUCTURE_BY_P(IXJ, P, PAD_INT, PAD_DBL)
    ELSE
        STR = PRINT_IXJ_STRUCTURE_BY_P(IXJ, ONE, PAD_INT, PAD_DBL)
        !
        DO I=TWO, IXJ%N
                  STR = STR//NL//PRINT_IXJ_STRUCTURE_BY_P(IXJ, I, PAD_INT, PAD_DBL)
        END DO
    END IF
    !
  END FUNCTION
  !
  PURE FUNCTION PRINT_IXJ_STRUCTURE_BY_P(IXJ, P, PAD_INT, PAD_DBL) RESULT(STR)
    CLASS(IXJ_STRUCTURE), INTENT(IN):: IXJ
    INTEGER,              INTENT(IN):: P
    INTEGER,    OPTIONAL, INTENT(IN):: PAD_INT, PAD_DBL
    CHARACTER(:),        ALLOCATABLE:: STR
    INTEGER:: I, PD1, PD2
    !
    STR = ' '
    !
    IF(SUM(IXJ%DIM) > Z) THEN
        !
        PD1 = SIX
        PD2 = TEN
        IF(PRESENT(PAD_INT)) PD1 = PAD_INT
        IF(PRESENT(PAD_DBL)) PD2 = PAD_DBL
        !
        DO I=ONE, IXJ%DIM(1); STR = STR//NUM2STR(IXJ%DAT(P)%I(I),PD1)//', '
        END DO
        !
        DO I=ONE, IXJ%DIM(2); STR = STR//NUM2STR(IXJ%DAT(P)%X(I),PD2)//', '
        END DO
        !
        DO I=ONE, IXJ%DIM(3); STR = STR//NUM2STR(IXJ%DAT(P)%J(I),PD1)//', '
        END DO
        !
        I = LEN(STR) - TWO
        !
        STR = STR(TWO:I)
    END IF
    !
  END FUNCTION
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE INIT_IXJ_STRUCTURE_DIMVEC(IXJ, DIM, OUTPUT, SIZ, EXACT)
    CLASS(IXJ_STRUCTURE),      INTENT(INOUT):: IXJ
    INTEGER,    DIMENSION(3),  INTENT(IN   ):: DIM
    INTEGER,         OPTIONAL, INTENT(IN   ):: OUTPUT
    INTEGER,         OPTIONAL, INTENT(IN   ):: SIZ
    LOGICAL,         OPTIONAL, INTENT(IN   ):: EXACT
    !
    CALL INIT_IXJ_STRUCTURE(IXJ, DIM(1), DIM(2), DIM(3), OUTPUT, SIZ, EXACT)
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE INIT_IXJ_STRUCTURE(IXJ, DIM1, DIM2, DIM3, OUTPUT, SIZ, EXACT)
    CLASS(IXJ_STRUCTURE), INTENT(INOUT):: IXJ
    INTEGER,              INTENT(IN   ):: DIM1, DIM2, DIM3
    INTEGER,    OPTIONAL, INTENT(IN   ):: OUTPUT
    INTEGER,    OPTIONAL, INTENT(IN   ):: SIZ
    LOGICAL,    OPTIONAL, INTENT(IN   ):: EXACT
    !
    IF(PRESENT(OUTPUT)) THEN;  IF(OUTPUT.NE.Z) IXJ%IOUT = OUTPUT
    END IF
    !
    IXJ%N = Z
    IXJ%P = ONE
    !
    IXJ%ERRMSG = BLNK
    !
    IXJ%IS_CONSTANT = FALSE
    !
    IF(IXJ%DIM(1).NE.DIM1  .OR. IXJ%DIM(2).NE.DIM2  .OR. IXJ%DIM(3).NE.DIM3) THEN
        !
        CALL DESTROY_IXJ_STRUCTURE_DAT(IXJ)
        !
        IXJ%DIM(1) = DIM1
        IXJ%DIM(2) = DIM2
        IXJ%DIM(3) = DIM3
        !
        IF( IXJ%SIZ > Z ) CALL ALLOCATE_IXJ_SINGLE_ENTRY_ELM(IXJ%DAT, IXJ%DIM(1), IXJ%DIM(2), IXJ%DIM(3))
    END IF
    !
    IF(PRESENT(SIZ)) CALL ALLOCATE_IXJ_DAT(IXJ, SIZ, EXACT)
    ! 
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE ALLOCATE_IXJ_DAT(IXJ, SIZ, EXACT, NEW_ALLOC)
    CLASS(IXJ_STRUCTURE),               INTENT(INOUT):: IXJ
    INTEGER,                            INTENT(IN   ):: SIZ
    LOGICAL,                  OPTIONAL, INTENT(IN   ):: EXACT
    LOGICAL,                  OPTIONAL, INTENT(OUT  ):: NEW_ALLOC
    LOGICAL:: EXACT_DIM, NEW_ALLOCATION
    !
    NEW_ALLOCATION = FALSE
    EXACT_DIM      = FALSE
    IF(PRESENT(EXACT)) EXACT_DIM = EXACT
    !
    IF(SIZ > Z) THEN
                  IF( IXJ%SIZ > Z ) THEN
                      IF( IXJ%SIZ < SIZ .OR. (EXACT_DIM .AND. IXJ%SIZ.NE.SIZ) ) THEN
                                                                                 NEW_ALLOCATION = TRUE
                                                                                 IXJ%SIZ        = SIZ
                                                                                 DEALLOCATE(IXJ%DAT)
                                                                                   ALLOCATE(IXJ%DAT(SIZ))
                      END IF
                  ELSE
                      NEW_ALLOCATION = TRUE
                      IXJ%SIZ        = SIZ
                      ALLOCATE(IXJ%DAT(SIZ))
                  END IF
    ELSEIF(EXACT_DIM) THEN
                  IF(ALLOCATED(IXJ%DAT)) THEN
                                         NEW_ALLOCATION = TRUE
                                         IXJ%SIZ        = Z
                                         DEALLOCATE(IXJ%DAT)
                  END IF
    END IF
    !
    IF(NEW_ALLOCATION) THEN
                       IXJ%N = Z
                       CALL ALLOCATE_IXJ_SINGLE_ENTRY_ELM(IXJ%DAT, IXJ%DIM(1), IXJ%DIM(2), IXJ%DIM(3))
    END IF
    !
    IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=NEW_ALLOCATION
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE MOVE_ALLOCATE_IXJ_DAT(DAT_FROM, DAT_TO)                           !Internal utility routine
    TYPE(IXJ_SINGLE_ENTRY), DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: DAT_FROM
    TYPE(IXJ_SINGLE_ENTRY), DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: DAT_TO
    !
    INTEGER:: SIZ
    !
    SIZ = SIZE(DAT_FROM)
    IF    (.NOT. ALLOCATED(DAT_FROM)) THEN
                                      SIZ = Z
                                      IF(ALLOCATED(DAT_TO)) DEALLOCATE(DAT_TO)
    ELSEIF(ALLOCATED(DAT_TO)) THEN
        IF(SIZ.NE.SIZE(DAT_TO)) THEN
                                           DEALLOCATE(DAT_TO)
                                             ALLOCATE(DAT_TO(SIZ))
        END IF
    ELSE
        ALLOCATE(DAT_TO(SIZ))
    END IF
    !
    IF(SIZ > Z) CALL MOVE_IXJ_SINGLE_ENTRY(DAT_FROM, DAT_TO)
    !
    IF(ALLOCATED(DAT_FROM)) DEALLOCATE(DAT_FROM)
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE CHECK_SIZE_AND_REALLOCATE_IXJ_DAT(IXJ, SIZ, EXACT, NEW_ALLOC)     !Internal utility routine
    CLASS(IXJ_STRUCTURE),               INTENT(INOUT):: IXJ
    INTEGER,                            INTENT(IN   ):: SIZ
    LOGICAL,                  OPTIONAL, INTENT(IN   ):: EXACT
    LOGICAL,                  OPTIONAL, INTENT(OUT  ):: NEW_ALLOC
    TYPE(IXJ_SINGLE_ENTRY), DIMENSION(:), ALLOCATABLE:: TMP
    LOGICAL:: EXACT_DIM, NEW_ALLOCATION
    !
    NEW_ALLOCATION = FALSE
    EXACT_DIM      = FALSE
    IF(PRESENT(EXACT)) EXACT_DIM = EXACT
    !
    IF(SIZ > Z) THEN
                  IF( IXJ%SIZ > Z ) THEN
                      IF( IXJ%SIZ < SIZ .OR. (EXACT_DIM .AND. IXJ%SIZ.NE.SIZ) ) THEN
                                                                                 NEW_ALLOCATION = TRUE
                                                                                 CALL MOVE_ALLOCATE_IXJ_DAT(IXJ%DAT, TMP)
                                                                                 !
                                                                                 ALLOCATE(IXJ%DAT(SIZ))
                                                                                 !
                                                                                 CALL MOVE_IXJ_SINGLE_ENTRY(TMP, IXJ%DAT(:IXJ%SIZ))
                                                                                 !
                                                                                 CALL ALLOCATE_IXJ_SINGLE_ENTRY_ELM(IXJ%DAT(IXJ%SIZ+1:), IXJ%DIM(1), IXJ%DIM(2), IXJ%DIM(3))
                                                                                 IXJ%SIZ = SIZ
                      END IF
                  ELSE
                      NEW_ALLOCATION = TRUE
                      IXJ%SIZ        = SIZ
                      ALLOCATE(IXJ%DAT(SIZ))
                      CALL ALLOCATE_IXJ_SINGLE_ENTRY_ELM(IXJ%DAT, IXJ%DIM(1), IXJ%DIM(2), IXJ%DIM(3))
                  END IF
    ELSEIF(EXACT_DIM) THEN
                  IF(ALLOCATED(IXJ%DAT)) THEN
                                         NEW_ALLOCATION = TRUE
                                         IXJ%SIZ        = Z
                                         DEALLOCATE(IXJ%DAT)
                  END IF
    END IF
    !
    IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=NEW_ALLOCATION
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  SUBROUTINE LOAD_IXJ_STRUCTURE_LINE(IXJ, LINE, LLOC, INFILE, OUTPUT, SCALE, NOSTOP, MSG, DIM)
    CLASS(IXJ_STRUCTURE),    INTENT(INOUT):: IXJ
    CHARACTER(*),            INTENT(IN   ):: LINE
    INTEGER,                 INTENT(INOUT):: LLOC
    INTEGER,      OPTIONAL,  INTENT(IN   ):: INFILE
    REAL(DBL),    OPTIONAL,  INTENT(INOUT):: SCALE
    INTEGER,      OPTIONAL,  INTENT(IN   ):: OUTPUT
    LOGICAL,      OPTIONAL,  INTENT(IN   ):: NOSTOP
    CHARACTER(*), OPTIONAL,  INTENT(IN   ):: MSG
    INTEGER,      OPTIONAL,  DIMENSION(3), INTENT(IN):: DIM
    TYPE(GENERIC_INPUT_FILE):: FL
    !
    IF(PRESENT(DIM)) THEN;  IF( ANY(DIM.NE.IXJ%DIM) ) CALL IXJ%INIT(DIM)
    END IF
    !
    CALL FL%OPEN(LINE, LLOC, OUTPUT, INFILE)
    !
    IF    (FL%SKIP) THEN
                    IXJ%N = Z
    ELSEIF(FL%IS_CONSTANT) THEN
                           CALL LOAD_IXJ_STRUCTURE_IU(IXJ, FL%IU, INFILE, OUTPUT, NOSTOP, FL%CONST, MSG=MSG)
    ELSE
        CALL LOAD_IXJ_STRUCTURE_IU(IXJ, FL%IU, INFILE, OUTPUT, NOSTOP, MSG=MSG)
    END IF    
    !
    IF(PRESENT(SCALE)) SCALE = SCALE*FL%SCALE
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  SUBROUTINE LOAD_IXJ_STRUCTURE_IU(IXJ, IU, ERROR_IU, OUTPUT, NOSTOP, CONST, FIRST_LINE, MSG, DIM)
    CLASS(IXJ_STRUCTURE),    INTENT(INOUT):: IXJ
    INTEGER,                 INTENT(IN   ):: IU
    INTEGER,      OPTIONAL,  INTENT(IN   ):: ERROR_IU, OUTPUT
    LOGICAL,      OPTIONAL,  INTENT(IN   ):: NOSTOP
    REAL(DBL),    OPTIONAL,  INTENT(IN   ):: CONST
    CHARACTER(*), OPTIONAL,  INTENT(IN   ):: FIRST_LINE, MSG
    INTEGER,      OPTIONAL,  DIMENSION(3), INTENT(IN   ):: DIM  !Resets IXJ%DIM if necessary
    TYPE(GENERIC_BLOCK_READER):: BL
    INTEGER:: LINE_LEN, ERR_IU
    INTEGER:: LLOC, ISTART, ISTOP, I
    LOGICAL:: END_NOT_FOUND, ALLOW_ERROR, HAS_ERROR
    CHARACTER(FOUR):: WORD
    !
    IF(PRESENT(DIM)) THEN;  IF( ANY(DIM.NE.IXJ%DIM) ) CALL IXJ%INIT(DIM)
    END IF
    !
    IF(PRESENT(OUTPUT)) THEN;  IF(OUTPUT.NE.Z) IXJ%IOUT = OUTPUT
    END IF
    !
    IF(PRESENT(FIRST_LINE)) THEN
                            LLOC = ONE
                            CALL GET(FIRST_LINE,LLOC,ISTART,ISTOP,WORD)
    ELSE;                                                         WORD = BLNK
    END IF
    !
    IXJ%IS_CONSTANT = FALSE
    !
    IF(PRESENT(CONST)) THEN
             !
             IXJ%IS_CONSTANT = TRUE
             !
             CALL CHECK_SIZE_AND_REALLOCATE_IXJ_DAT(IXJ, ONE)
             !
             IXJ%N = ONE
             I = INT(CONST)
             !
             IF(IXJ%DIM(1) > Z) IXJ%DAT(1)%I = I        ! I = INT(CONST)
             IF(IXJ%DIM(2) > Z) IXJ%DAT(1)%X = CONST
             IF(IXJ%DIM(3) > Z) IXJ%DAT(1)%J = I        ! I = INT(CONST)
             !
    ELSEIF(WORD.NE.'STOP' .AND. IU .NE. Z) THEN
             IF(PRESENT(ERROR_IU)) THEN
                                   ERR_IU = ERROR_IU
             ELSE
                                   ERR_IU = IU
             END IF
             !
             IF(PRESENT(NOSTOP)) THEN
                 ALLOW_ERROR = .NOT. NOSTOP
                 !
                 IF(NOSTOP) IXJ%ERRMSG = BLNK
             ELSE
                 ALLOW_ERROR = TRUE
             END IF
             !
             LINE_LEN = IXJ%DIM(1)*EIGHT + IXJ%DIM(1)*21 + IXJ%DIM(3)*EIGHT + SUM(IXJ%DIM)*TWO
             !
             IF( LINE_LEN < 96 ) LINE_LEN = 96
             !
             CALL BL%INIT(IU, IXJ%IOUT, LINE_LEN)
             !
             CALL BL%INNER('STOP', END_NOT_FOUND=END_NOT_FOUND)
             !
             IF(PRESENT(FIRST_LINE)) CALL BL%ADD_LINE(FIRST_LINE, ONE)
             !
             CALL CHECK_SIZE_AND_REALLOCATE_IXJ_DAT(IXJ, BL%NLINE)
             !
             IXJ%N = BL%NLINE
             !
             CALL BL%START()
             !
             HAS_ERROR = FALSE
             DO I=ONE, BL%NLINE
                       LLOC = ONE
                       !
                       IF(IXJ%DIM(1) > Z                      ) CALL GET(BL%LINE,LLOC,ISTART,ISTOP,IXJ%IOUT,ERR_IU,IXJ%DAT(I)%I,HAS_ERROR=HAS_ERROR)
                       IF(IXJ%DIM(2) > Z .AND. .NOT. HAS_ERROR) CALL GET(BL%LINE,LLOC,ISTART,ISTOP,IXJ%IOUT,ERR_IU,IXJ%DAT(I)%X,HAS_ERROR=HAS_ERROR)
                       IF(IXJ%DIM(3) > Z .AND. .NOT. HAS_ERROR) CALL GET(BL%LINE,LLOC,ISTART,ISTOP,IXJ%IOUT,ERR_IU,IXJ%DAT(I)%J,HAS_ERROR=HAS_ERROR)
                       !
                       IF(HAS_ERROR) EXIT
                       !
                       CALL BL%NEXT() !MOVE TO NEXT LINE
             END DO
             ! 
             IF(HAS_ERROR) THEN
                 IXJ%ERRMSG = 'IXJ STYLE INPUT FAILED TO LOAD AN INPUT'
                 !
                 IF(.NOT. ALLOW_ERROR) IXJ%ERRMSG = IXJ%ERRMSG//' ON THE FOLLOWING LINE:'//BLN//'"'//BL%LINE//'"'
                 !
                 IXJ%ERRMSG = IXJ%ERRMSG//BLN//'Input expects to read '//NUM2STR(IXJ%DIM(1))//' I integers, '//NUM2STR(IXJ%DIM(2))//' X numbers, and '//NUM2STR(IXJ%DIM(3))//' J integers' 
                 !
                 IF(END_NOT_FOUND) IXJ%ERRMSG = IXJ%ERRMSG//BLN//'NOTE THAT THE KEYWORD "STOP IXJ" WAS NOT FOUND, SO THIS ERROR MAYBE BECAUSE IXJ LOADED TO THE END OF THE FILE RATHER THAN THE END OF THE ACTUAL IXJ INPUT.'
                 !
                 IF(ALLOW_ERROR) CALL STOP_ERROR(BL%LINE, INFILE=ERR_IU, OUTPUT=IXJ%IOUT, MSG=IXJ%ERRMSG, MSG2=MSG)
                 !
             END IF
    ELSE
        CALL ALLOCATE_IXJ_DAT(IXJ, Z)
        IXJ%ERRMSG = BLNK
    END IF
    ! 
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE COUNT_INT_IXJ_STRUCTURE(IXJ, ID, ICOL, CNT)
    CLASS(IXJ_STRUCTURE),  INTENT(IN   ):: IXJ
    INTEGER,               INTENT(IN   ):: ID, ICOL
    INTEGER,               INTENT(INOUT):: CNT
    INTEGER:: I
    !
    CNT   = Z
    !
    DO I=ONE, IXJ%N;  IF(IXJ%DAT(I)%I(ICOL) == ID) CNT = CNT + ONE
    END DO
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE SET_POS_P_TO_START(IXJ, EOF)
    CLASS(IXJ_STRUCTURE), INTENT(INOUT):: IXJ
    LOGICAL,    OPTIONAL, INTENT(  OUT):: EOF
    !
    IXJ%P = ONE
    !
    IF(PRESENT(EOF)) EOF = IXJ%P > IXJ%N
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE MOVE_POS_P_TO_NEXT(IXJ, EOF)
    CLASS(IXJ_STRUCTURE), INTENT(INOUT):: IXJ
    LOGICAL,    OPTIONAL, INTENT(  OUT):: EOF
    !
    IXJ%P = IXJ%P + ONE
    !
    IF(PRESENT(EOF)) EOF = IXJ%P > IXJ%N
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE SET_POS_P_TO_START_ID(IXJ, ID, ICOL, EOF)
    CLASS(IXJ_STRUCTURE), INTENT(INOUT):: IXJ
    INTEGER,              INTENT(IN   ):: ID, ICOL
    LOGICAL,    OPTIONAL, INTENT(  OUT):: EOF
    INTEGER:: I
    !
    IXJ%P = IXJ%N + ONE
    !
    DO I=ONE, IXJ%N
           IF(IXJ%DAT(I)%I(ICOL) == ID) THEN
                                        IXJ%P = I
                                        EXIT
           END IF
    END DO
    !
    IF(PRESENT(EOF)) EOF = IXJ%P > IXJ%N
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE MOVE_POS_P_TO_NEXT_ID(IXJ, ID, ICOL, EOF)
    CLASS(IXJ_STRUCTURE), INTENT(INOUT):: IXJ
    INTEGER,              INTENT(IN   ):: ID, ICOL
    LOGICAL,    OPTIONAL, INTENT(  OUT):: EOF
    INTEGER:: I, P
    !
    P = IXJ%P + ONE
    !
    IXJ%P = IXJ%N + ONE
    !
    DO I=P, IXJ%N
           IF(IXJ%DAT(I)%I(ICOL) == ID) THEN
                                        IXJ%P = I
                                        EXIT
           END IF
    END DO
    !
    IF(PRESENT(EOF)) EOF = IXJ%P > IXJ%N
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE FUNCTION MATCH_POS_P_INT_PART(IXJ, ID1, C1, ID2, C2, ID3, C3, ID4, C4) RESULT(MATCH)
    CLASS(IXJ_STRUCTURE), INTENT(IN):: IXJ
    INTEGER,              INTENT(IN):: ID1, C1
    INTEGER,    OPTIONAL, INTENT(IN):: ID2, C2, ID3, C3, ID4, C4
    LOGICAL:: MATCH
    !
    IF(IXJ%N == Z) THEN
                   MATCH = FALSE
    ELSE
        ASSOCIATE( IVEC => IXJ%DAT(IXJ%P)%I )
                   !
                   MATCH = ID1 == IVEC(C1)
                   !
                   IF(MATCH .AND. PRESENT(ID2)) THEN
                       !
                       MATCH = ID2 == IVEC(C2)
                       !
                       IF(MATCH .AND. PRESENT(ID3)) THEN
                           !
                           MATCH = ID3 == IVEC(C3)
                           !
                           IF(MATCH .AND. PRESENT(ID4)) THEN
                               !
                               MATCH = ID4 == IVEC(C4)
                               !
                           END IF
                       END IF
                   END IF
        END ASSOCIATE
    END IF
    !
  END FUNCTION
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE ELEMENTAL FUNCTION GET_POS_P_VAL_PART(IXJ, ICOL) RESULT(VAL)
    CLASS(IXJ_STRUCTURE), INTENT(IN):: IXJ
    INTEGER,    OPTIONAL, INTENT(IN):: ICOL
    REAL(DBL):: VAL
    !
    IF(Z < IXJ%P .AND. IXJ%P <= IXJ%N .AND. IXJ%DIM(2)>Z) THEN
       IF(PRESENT(ICOL)) THEN
           VAL = IXJ%DAT(IXJ%P)%X(ICOL)
       ELSE
           VAL = IXJ%DAT(IXJ%P)%X(ONE)
       END IF
    ELSE
        VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)
    END IF
    !
  END FUNCTION
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE MOVE_POS_P_TO_RECORD(IXJ, FOUND, FROM_START, ID, ID_COLNUM, ROW, IROW, COL, ICOL)
    CLASS(IXJ_STRUCTURE),      INTENT(INOUT):: IXJ
    LOGICAL,                   INTENT(OUT  ):: FOUND
    LOGICAL,                   INTENT(IN   ):: FROM_START
    INTEGER,       OPTIONAL,   INTENT(IN   ):: ID, ID_COLNUM, ROW, IROW, COL, ICOL
    INTEGER:: ID_COL, IRR, ICC
    LOGICAL:: EOF
    !
    IF(IXJ%IS_CONSTANT) THEN
        FOUND = TRUE
        IXJ%P = ONE
    ELSE
       IF(PRESENT(ID) .AND. PRESENT(ID_COLNUM)) THEN
           ID_COL = ID_COLNUM
       ELSE
           ID_COL = Z
       END IF
       !
       IF(PRESENT(ROW) .AND. PRESENT(COL)) THEN
           IRR = ROW
           ICC = COL
       ELSE
           IRR = Z
           ICC = Z
       END IF
       !
       IF(ID_COL > Z) THEN
           !
           IF(FROM_START) THEN
                              CALL SET_POS_P_TO_START_ID(IXJ, ID, ID_COL, EOF)
           ELSE
                              CALL MOVE_POS_P_TO_NEXT_ID(IXJ, ID, ID_COL, EOF)
           END IF
           !
           IF(.NOT. EOF .AND. IRR > Z) THEN
               DO WHILE ( .NOT. EOF .AND. .NOT. ( ROW == IXJ%DAT(IXJ%P)%I(IRR) .AND. &
                                                  COL == IXJ%DAT(IXJ%P)%I(ICC))       )
                   !
                   CALL MOVE_POS_P_TO_NEXT_ID(IXJ, ID, ID_COL, EOF)
               END DO
           END IF
           !
       ELSEIF(IRR > Z) THEN
           !
           IF(FROM_START) THEN
                              CALL SET_POS_P_TO_START_ID(IXJ, ROW, IRR, EOF)
           ELSE
                              CALL MOVE_POS_P_TO_NEXT_ID(IXJ, ROW, IRR, EOF)
           END IF
           !
           DO WHILE (.NOT. EOF .AND. COL .NE. IXJ%DAT(IXJ%P)%I(ICC))
                 !
                 CALL MOVE_POS_P_TO_NEXT_ID(IXJ, ROW, IRR, EOF)
           END DO
       END IF
       !
       FOUND = .NOT. EOF
    END IF
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE GET_VALUE_IXJ(IXJ, VAL, IVAL, ID, ID_COL, ROW, IROW, COL, ICOL, FOUND, FROM_START)
    CLASS(IXJ_STRUCTURE), INTENT(INOUT):: IXJ
    REAL(DBL),            INTENT(OUT):: VAL
    INTEGER,              INTENT(IN ):: IVAL
    INTEGER,  OPTIONAL,   INTENT(IN ):: ID, ID_COL, ROW, IROW, COL, ICOL
    LOGICAL,  OPTIONAL,   INTENT(OUT):: FOUND
    LOGICAL,  OPTIONAL,   INTENT(IN ):: FROM_START
    LOGICAL:: FND, FRM_STRT
    !
    IF(IXJ%IS_CONSTANT) THEN
                         FND = TRUE
                         VAL = IXJ%DAT(ONE)%X(IVAL)
    ELSE
        IF(PRESENT(FROM_START)) THEN
            FRM_STRT = FROM_START
        ELSE
            FRM_STRT = TRUE
        END IF
        !
        CALL MOVE_POS_P_TO_RECORD(IXJ, FND, FRM_STRT, ID, ID_COL, ROW, IROW, COL, ICOL)
        !
        IF(FND) THEN
            VAL = IXJ%DAT(IXJ%P)%X(IVAL)
        ELSE
            VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)
        END IF
    END IF
    !
    IF(PRESENT(FOUND)) FOUND = FND
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  !!!PURE SUBROUTINE GET_J_IXJ(IXJ, J, IVAL, ID, ID_COL, ROW, IROW, COL, ICOL, FOUND, FROM_START)
  !!!  CLASS(IXJ_STRUCTURE), INTENT(INOUT):: IXJ
  !!!  INTEGER,                   INTENT(OUT  ):: J
  !!!  INTEGER,                   INTENT(IN   ):: IVAL
  !!!  INTEGER,       OPTIONAL,   INTENT(IN   ):: ID, ID_COL, ROW, IROW, COL, ICOL
  !!!  LOGICAL,       OPTIONAL,   INTENT(OUT  ):: FOUND
  !!!  LOGICAL,       OPTIONAL,   INTENT(IN   ):: FROM_START
  !!!  LOGICAL:: FND, FRM_STRT
  !!!  !
  !!!  IF(PRESENT(FROM_START)) THEN
  !!!      FRM_STRT = FROM_START
  !!!  ELSE
  !!!      FRM_STRT = TRUE
  !!!  END IF
  !!!  !
  !!!  CALL MOVE_POS_P_TO_RECORD(IXJ, FND, FRM_STRT, ID, ID_COL, ROW, IROW, COL, ICOL)
  !!!  !
  !!!  IF(FND) THEN
  !!!      J = IXJ%CUR%J(IVAL)
  !!!  ELSE
  !!!      J = Z
  !!!  END IF
  !!!  !
  !!!  IF(PRESENT(FOUND)) FOUND = FND
  !!!  !
  !!!END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  ! 
  PURE SUBROUTINE COPY_TO_2D_ARRAY_DBL(IXJ, IROW, ICOL, VPOS, DIM1, DIM2, ARR, ERROR, NULL_VAL)
    CLASS(IXJ_STRUCTURE),             INTENT(IN   ):: IXJ
    INTEGER,                          INTENT(IN   ):: IROW, ICOL, VPOS, DIM1, DIM2
    REAL(DBL), DIMENSION(DIM1, DIM2), INTENT(INOUT):: ARR
    LOGICAL,                          INTENT(  OUT):: ERROR
    REAL(DBL),              OPTIONAL, INTENT(IN   ):: NULL_VAL
    REAL(DBL):: INIT
    INTEGER  :: N, I, J
    !
    IF(PRESENT(NULL_VAL)) THEN
        INIT = NULL_VAL
    ELSE
        INIT = DZ
    END IF
    !
    ERROR = FALSE
    !
    IF(IXJ%IS_CONSTANT) THEN
                   BLOCK
                        REAL(DBL):: DTMP
                        DTMP = IXJ%DAT(ONE)%X( VPOS )
                        DO CONCURRENT(I=1:DIM1, J=1:DIM2); ARR(I,J) = DTMP
                        END DO
                   END BLOCK
    ELSE
        DO CONCURRENT(I=1:DIM1, J=1:DIM2); ARR(I,J) = INIT
        END DO
        !
        DO N = ONE, IXJ%N
            !
            I = IXJ%DAT(I)%I(IROW)
            J = IXJ%DAT(I)%I(ICOL)
            !
            IF(I < ONE .OR. DIM1 < I .OR. J < ONE .OR. DIM2 < J) THEN
                ERROR = TRUE
            ELSE
                ARR(I,J) = IXJ%DAT(I)%X( VPOS )
            END IF
            !
        END DO
    END IF
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE COPY_TO_2D_ARRAY_INT(IXJ, IROW, ICOL, IPOS, DIM1, DIM2, ARR, ERROR, NULL_VAL)
    CLASS(IXJ_STRUCTURE),           INTENT(IN   ):: IXJ
    INTEGER,                        INTENT(IN   ):: IROW, ICOL, IPOS, DIM1, DIM2
    INTEGER, DIMENSION(DIM1, DIM2), INTENT(INOUT):: ARR
    LOGICAL,                        INTENT(  OUT):: ERROR
    INTEGER,              OPTIONAL, INTENT(IN   ):: NULL_VAL
    INTEGER:: N, I, J, INIT
    !
    IF(PRESENT(NULL_VAL)) THEN
        INIT = NULL_VAL
    ELSE
        INIT = Z
    END IF
    !
    ERROR = FALSE
    !
    IF(IXJ%IS_CONSTANT) THEN
                        N = IXJ%DAT(I)%I( IPOS )
                        DO CONCURRENT(I=1:DIM1, J=1:DIM2); ARR(I,J) = N
                        END DO
    ELSE
        DO CONCURRENT(I=1:DIM1, J=1:DIM2); ARR(I,J) = INIT
        END DO
        !
        DO N = ONE, IXJ%N
            !
            I = IXJ%DAT(I)%I(IROW)
            J = IXJ%DAT(I)%I(ICOL)
            !
            IF(I < ONE .OR. DIM1 < I .OR. J < ONE .OR. DIM2 < J) THEN
                ERROR = TRUE
            ELSE
                ARR(I,J) = IXJ%DAT(I)%I( IPOS )
            END IF
            !
        END DO
    END IF
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE BUILD_COMPRESSED_VALUE_STORAGE_TYPE_DIM2(IXJ, IDIM1, IDIM2, VPOS, CVS)
    CLASS(IXJ_STRUCTURE),           INTENT(IN   ):: IXJ
    INTEGER,                        INTENT(IN   ):: IDIM1, IDIM2, VPOS
    TYPE(COMPRESSED_VALUE_STORAGE), INTENT(INOUT):: CVS
    INTEGER:: K
    !
    CVS%IS_CONSTANT = FALSE
    !
    IF(IXJ%IS_CONSTANT) THEN
                       CALL CVS%ALLOC(ONE,TWO)
                       CVS%IS_CONSTANT = TRUE
                       !
                       K=1
                       CVS%DIM(ONE,K) = IXJ%DAT(ONE)%I(IDIM1)
                       CVS%DIM(TWO,K) = IXJ%DAT(ONE)%I(IDIM2)
                       CVS%VAL(K)     = IXJ%DAT(ONE)%X(VPOS )
    ELSEIF (IXJ%N > Z) THEN
                       CALL CVS%ALLOC(IXJ%N,TWO)
                       !
                       DO K =1, IXJ%N
                                CVS%DIM(ONE,K) = IXJ%DAT(K)%I(IDIM1)
                                CVS%DIM(TWO,K) = IXJ%DAT(K)%I(IDIM2)
                                CVS%VAL(K)     = IXJ%DAT(K)%X(VPOS )
                       END DO
    ELSE
                       CALL CVS%DESTROY()
    END IF
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE BUILD_COMPRESSED_VALUE_STORAGE_TYPE_DIM3(IXJ, IDIM1, IDIM2, IDIM3, VPOS, CVS)
    CLASS(IXJ_STRUCTURE),           INTENT(IN   ):: IXJ
    INTEGER,                        INTENT(IN   ):: IDIM1, IDIM2, IDIM3, VPOS
    TYPE(COMPRESSED_VALUE_STORAGE), INTENT(INOUT):: CVS
    INTEGER:: K
    !
    CVS%IS_CONSTANT = FALSE
    !
    IF(IXJ%IS_CONSTANT) THEN
                       CALL CVS%ALLOC(ONE,3)
                       CVS%IS_CONSTANT = TRUE
                       !
                       K=1
                       CVS%DIM(ONE, K) = IXJ%DAT(K)%I(IDIM1)
                       CVS%DIM(TWO, K) = IXJ%DAT(K)%I(IDIM2)
                       CVS%DIM(  3, K) = IXJ%DAT(K)%I(IDIM3)
                       CVS%VAL(K)      = IXJ%DAT(K)%X(VPOS )
    ELSEIF (IXJ%N > Z) THEN
                       CALL CVS%ALLOC(IXJ%N, 3)
                       !
                       DO K =1, IXJ%N
                                CVS%DIM(ONE, K) = IXJ%DAT(K)%I(IDIM1)
                                CVS%DIM(TWO, K) = IXJ%DAT(K)%I(IDIM2)
                                CVS%DIM(  3, K) = IXJ%DAT(K)%I(IDIM3)
                                CVS%VAL(K)      = IXJ%DAT(K)%X(VPOS )
                       END DO
                       !
    ELSE
                       CALL CVS%DESTROY()
    END IF
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE BUILD_COMPRESSED_LOCATION_STORAGE_TYPE(IXJ, IDIM1, IDIM2, IDIM_ID, ID, LAC) 
    CLASS(IXJ_STRUCTURE),              INTENT(IN   ):: IXJ
    INTEGER,                           INTENT(IN   ):: IDIM1, IDIM2, IDIM_ID, ID
    TYPE(COMPRESSED_LOCATION_STORAGE), INTENT(INOUT):: LAC
    INTEGER:: K, I
    !
    LAC%IS_CONSTANT = FALSE
    !
    LAC%ID = ID
    !
    IF(IXJ%IS_CONSTANT) THEN
                       CALL LAC%ALLOC(ONE, TWO)
                       LAC%IS_CONSTANT = TRUE
    ELSEIF (IXJ%N > Z) THEN
                       CALL COUNT_INT_IXJ_STRUCTURE(IXJ, ID, IDIM_ID, K)  !K is number of IDs found
                       !
                       CALL LAC%ALLOC(K, TWO)
                       LAC%N = K
                       !
                       I = Z
                       DO K =1, IXJ%N
                           !
                           IF(IXJ%DAT(K)%I(IDIM_ID) == ID) THEN
                               I = I + ONE
                               LAC%DIM(ONE,I) = IXJ%DAT(K)%I(IDIM1)
                               LAC%DIM(TWO,I) = IXJ%DAT(K)%I(IDIM2)
                           END IF
                       END DO
    ELSE
                       LAC%N = Z
    END IF
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  SUBROUTINE BUILD_COMPRESSED_LOCATION_STORAGE_TYPE_BYDIM(IXJ, IDIM1, IDIM2, IDIM_ID, NID, LAC)
    CLASS(IXJ_STRUCTURE),                              INTENT(IN   ):: IXJ
    INTEGER,                                           INTENT(IN   ):: IDIM1, IDIM2, IDIM_ID
    TYPE(COMPRESSED_LOCATION_STORAGE), DIMENSION(NID), INTENT(INOUT):: LAC
    INTEGER:: K, I, NID
    !
    IF (IXJ%N > Z) THEN
                       DO CONCURRENT(I=ONE:NID); LAC(I)%N = Z  !Use %N as a counter
                       END DO
                       !
                       DO K=1, IXJ%N
                           !
                           I = IXJ%DAT(K)%I(IDIM_ID)
                           !
                           IF(I > Z .AND. I <= NID) LAC(I)%N = LAC(I)%N + ONE
                           !
                       END DO
                       !
                       DO I=ONE, NID
                                 K  = LAC(I)%N
                                 CALL LAC(I)%ALLOC(K, TWO)
                                 !
                                 LAC(I)%N = K
                                 !
                                 LAC(I)%IS_CONSTANT = FALSE
                       END DO
                       !
                       DO CONCURRENT(I=ONE:NID); LAC(I)%N = Z
                       END DO
                       !
                       DO CONCURRENT(I=ONE:NID); LAC(I)%ID = I
                       END DO
                       !
                       DO K =1, IXJ%N
                                     I = IXJ%DAT(K)%I(IDIM_ID)
                                     !
                                     IF(I > Z .AND. I <= NID) THEN
                                                              LAC(I)%N  = LAC(I)%N + ONE
                                                              LAC(I)%DIM(ONE,LAC(I)%N) = IXJ%DAT(K)%I(IDIM1)
                                                              LAC(I)%DIM(TWO,LAC(I)%N) = IXJ%DAT(K)%I(IDIM2)
                                     END IF
                       END DO
                       !
                       IF(IXJ%IS_CONSTANT) THEN
                                  DO I=ONE, NID
                                            IF(LAC(I)%N > Z) LAC(I)%IS_CONSTANT = TRUE
                                  END DO
                       END IF
    ELSE
                       LAC%N = Z
                       DO I=ONE, NID
                                 LAC(I)%IS_CONSTANT = FALSE
                       END DO
    END IF
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE DESTROY_IXJ_STRUCTURE_DAT(IXJ)
    CLASS(IXJ_STRUCTURE), INTENT(INOUT):: IXJ
    INTEGER:: I
    !
    DO I=ONE, IXJ%SIZ
        IF(ALLOCATED(IXJ%DAT(I)%I)) DEALLOCATE(IXJ%DAT(I)%I)
        IF(ALLOCATED(IXJ%DAT(I)%X)) DEALLOCATE(IXJ%DAT(I)%X)
        IF(ALLOCATED(IXJ%DAT(I)%J)) DEALLOCATE(IXJ%DAT(I)%J)
    END DO
    !
    IXJ%N    = Z
    IXJ%P    = ONE
    ! 
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE DESTROY_IXJ_STRUCTURE(IXJ)
    CLASS(IXJ_STRUCTURE), INTENT(INOUT):: IXJ
    INTEGER:: I
    !
    DO I=ONE, IXJ%SIZ
        IF(ALLOCATED(IXJ%DAT(I)%I)) DEALLOCATE(IXJ%DAT(I)%I)
        IF(ALLOCATED(IXJ%DAT(I)%X)) DEALLOCATE(IXJ%DAT(I)%X)
        IF(ALLOCATED(IXJ%DAT(I)%J)) DEALLOCATE(IXJ%DAT(I)%J)
    END DO
    !
    IF(ALLOCATED(IXJ%DAT)) DEALLOCATE(IXJ%DAT)
    IF(ALLOCATED(IXJ%ERRMSG)) DEALLOCATE(IXJ%ERRMSG)
    !
    IXJ%SIZ  = Z
    IXJ%N    = Z
    IXJ%P    = ONE
    IXJ%IOUT = Z
    IXJ%DIM  = Z
    !
    IXJ%IS_CONSTANT = FALSE
    ! 
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE FINAL_DESTROY_IXJ_STRUCTURE(IXJ)
    TYPE(IXJ_STRUCTURE), INTENT(INOUT):: IXJ
    !
    CALL DESTROY_IXJ_STRUCTURE(IXJ)
    ! 
  END SUBROUTINE
  !
  ! #############################################################################################################################
  ! #############################################################################################################################
  ! #############################################################################################################################
  !
  PURE SUBROUTINE ALLOCATE_IXJ_SINGLE_ENTRY(DAT,DIM)
    CLASS(IXJ_SINGLE_ENTRY), INTENT(INOUT):: DAT
    INTEGER,   DIMENSION(3), INTENT(IN   ):: DIM
    !
    CALL ALLOC(DAT%I, DIM(1))
    CALL ALLOC(DAT%X, DIM(2))
    CALL ALLOC(DAT%J, DIM(3))
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  ELEMENTAL PURE SUBROUTINE ALLOCATE_IXJ_SINGLE_ENTRY_ELM(DAT,D1,D2,D3)
    CLASS(IXJ_SINGLE_ENTRY), INTENT(INOUT):: DAT
    INTEGER,                 INTENT(IN   ):: D1,D2,D3
    !
    CALL ALLOC(DAT%I, D1)
    CALL ALLOC(DAT%X, D2)
    CALL ALLOC(DAT%J, D3)
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE GET_IXJ_SINGLE_ENTRY_DIM(DAT,DIM)
    CLASS(IXJ_SINGLE_ENTRY), INTENT(IN ):: DAT
    INTEGER,   DIMENSION(3), INTENT(OUT):: DIM
    !
    DIM(1) = SIZE(DAT%I)
    DIM(2) = SIZE(DAT%X)
    DIM(3) = SIZE(DAT%J)
    !
    IF(.NOT. ALLOCATED(DAT%I)) DIM(1) = Z
    IF(.NOT. ALLOCATED(DAT%X)) DIM(2) = Z
    IF(.NOT. ALLOCATED(DAT%J)) DIM(3) = Z
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE GET_IXJ_SINGLE_ENTRY_DIM_I_X_J(DAT,I,X,J)
    CLASS(IXJ_SINGLE_ENTRY), INTENT(IN   ):: DAT
    INTEGER,       OPTIONAL, INTENT(INOUT):: I,X,J
    !
    IF(PRESENT(I)) THEN
        IF(ALLOCATED(DAT%I)) THEN; I = SIZE(DAT%I)
        ELSE;                      I = Z
        END IF
    END IF
    !
    IF(PRESENT(X)) THEN
        IF(ALLOCATED(DAT%X)) THEN; X = SIZE(DAT%X)
        ELSE;                      X = Z
        END IF
    END IF
    !
    IF(PRESENT(J)) THEN
        IF(ALLOCATED(DAT%J)) THEN; J = SIZE(DAT%J)
        ELSE;                      J = Z
        END IF
    END IF
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  ELEMENTAL PURE SUBROUTINE MOVE_IXJ_SINGLE_ENTRY(DAT, DAT_TO)
    CLASS(IXJ_SINGLE_ENTRY), INTENT(INOUT):: DAT, DAT_TO
    !
    IF    (ALLOCATED(DAT   %I)) THEN; CALL MOVE_ALLOC(DAT%I, DAT_TO%I)
    ELSEIF(ALLOCATED(DAT_TO%I)) THEN;             DEALLOCATE(DAT_TO%I)
    END IF
    !
    IF    (ALLOCATED(DAT   %X)) THEN; CALL MOVE_ALLOC(DAT%X, DAT_TO%X)
    ELSEIF(ALLOCATED(DAT_TO%X)) THEN;             DEALLOCATE(DAT_TO%X)
    END IF
    !
    IF    (ALLOCATED(DAT   %J)) THEN; CALL MOVE_ALLOC(DAT%J, DAT_TO%J)
    ELSEIF(ALLOCATED(DAT_TO%J)) THEN;             DEALLOCATE(DAT_TO%J)
    END IF
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE COPY_IXJ_SINGLE_ENTRY(DAT_OUT,DAT_IN)
    CLASS(IXJ_SINGLE_ENTRY), INTENT(IN   ):: DAT_IN
    CLASS(IXJ_SINGLE_ENTRY), INTENT(INOUT):: DAT_OUT
    INTEGER, DIMENSION(3):: DIM1, DIM2 
    !
    CALL  DAT_IN%GET_DIM(DIM1)
    CALL DAT_OUT%GET_DIM(DIM2)
    !
    IF(ANY(DIM1.NE.DIM2)) THEN
        IF(ALLOCATED(DAT_OUT%I)) DEALLOCATE(DAT_OUT%I)
        IF(ALLOCATED(DAT_OUT%X)) DEALLOCATE(DAT_OUT%X)
        IF(ALLOCATED(DAT_OUT%J)) DEALLOCATE(DAT_OUT%J)
        !
        IF(DIM1(1) > Z) ALLOCATE( DAT_OUT%I, SOURCE = DAT_IN%I )
        IF(DIM1(2) > Z) ALLOCATE( DAT_OUT%X, SOURCE = DAT_IN%X )
        IF(DIM1(3) > Z) ALLOCATE( DAT_OUT%J, SOURCE = DAT_IN%J )
    ELSE
        IF(DIM1(1) > Z) DAT_OUT%I = DAT_IN%I
        IF(DIM1(2) > Z) DAT_OUT%X = DAT_IN%X
        IF(DIM1(3) > Z) DAT_OUT%J = DAT_IN%J
    END IF
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE FAST_COPY_IXJ_SINGLE_ENTRY(DIM, FROM, TOO)  !assumes I, X, and J are already allcocated
    INTEGER, DIMENSION(3),  INTENT(IN   ):: DIM
    TYPE(IXJ_SINGLE_ENTRY), INTENT(IN   ):: FROM
    TYPE(IXJ_SINGLE_ENTRY), INTENT(INOUT):: TOO
    !
    IF(DIM(1) > Z) TOO%I = FROM%I
    IF(DIM(2) > Z) TOO%X = FROM%X
    IF(DIM(3) > Z) TOO%J = FROM%J
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !                                 
  ELEMENTAL PURE FUNCTION EQUALITY_IXJ_SINGLE_ENTRY(DAT1, DAT2) RESULT(EQ)
    CLASS(IXJ_SINGLE_ENTRY), INTENT(IN):: DAT1, DAT2
    LOGICAL:: EQ
    INTEGER, DIMENSION(3):: DIM1, DIM2 
    REAL(DBL):: TOL
    !
    TOL = 1D-12
    !
    CALL DAT1%GET_DIM(DIM1)
    CALL DAT2%GET_DIM(DIM2)
    !
    EQ = ALL(DIM1==DIM2)
    !
    IF(EQ .AND. DIM1(1) > Z) EQ = ALL( DAT1%I == DAT2%I )
    IF(EQ .AND. DIM1(2) > Z) EQ = ALL( ABS(DAT1%X - DAT2%X) <  DAT1%X*TOL)
    IF(EQ .AND. DIM1(3) > Z) EQ = ALL( DAT1%J == DAT2%J )
    !
  END FUNCTION
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  ELEMENTAL PURE SUBROUTINE DESTROY_IXJ_SINGLE_ENTRY(DAT)
    CLASS(IXJ_SINGLE_ENTRY),         INTENT(INOUT):: DAT
    !
    IF(ALLOCATED(DAT%I)) DEALLOCATE(DAT%I)
    IF(ALLOCATED(DAT%X)) DEALLOCATE(DAT%X)
    IF(ALLOCATED(DAT%J)) DEALLOCATE(DAT%J)
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE RECURSIVE SUBROUTINE FINAL_IXJ_SINGLE_ENTRY(DAT)
    TYPE(IXJ_SINGLE_ENTRY),        INTENT(INOUT):: DAT
    !
    IF(ALLOCATED(DAT%I)) DEALLOCATE(DAT%I)
    IF(ALLOCATED(DAT%X)) DEALLOCATE(DAT%X)
    IF(ALLOCATED(DAT%J)) DEALLOCATE(DAT%J)
    !
  END SUBROUTINE
  !
  ! #############################################################################################################################
  ! #############################################################################################################################
  ! #############################################################################################################################
  !
  PURE SUBROUTINE SORT_BY_INT_COLVEC(IXJ, ICOL)
    CLASS(IXJ_STRUCTURE),              INTENT(INOUT):: IXJ
    INTEGER, DIMENSION(:), CONTIGUOUS, INTENT(IN   ):: ICOL
    !
    INTEGER:: N
    !
    N = SIZE(ICOL)
    !
    IF(IXJ%N > ONE) THEN                                                      !Silly to sort when size is 1
        IF    (N == ONE) THEN
                         CALL SORT_BY_INT_COL(IXJ, ICOL(1))                   !Optimized routine for sorting by 1 column reference
        ELSEIF(N == TWO) THEN
                         CALL SORT_BY_INT_COL1_COL2(IXJ, ICOL(1), ICOL(2))    !Optimized routine for sorting by 2 column reference
        ELSEIF(N ==   3) THEN
                         CALL SORT_BY_INT_COL1_COL2_COL3(IXJ, ICOL(1), ICOL(2), ICOL(3))   !Optimized routine for sorting by 3 column reference
        ELSE
                         CALL SORT_BY_INT_COLVEC_UNLIMITED(IXJ, N, ICOL)
        END IF
    END IF
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE SORT_BY_INT_COL(IXJ, ICOL)
    CLASS(IXJ_STRUCTURE), INTENT(INOUT):: IXJ
    INTEGER,              INTENT(IN   ):: ICOL
    INTEGER:: I, J, P, ICHK
    TYPE(IXJ_SINGLE_ENTRY):: TMP
    !
    CALL TMP%ALLOC(IXJ%DIM)
    IXJ%P = ONE
    !
    DO I=ONE, IXJ%N
       !
       ICHK = IXJ%DAT(I)%I(ICOL)
       P    = Z
       !
       DO J=I+ONE, IXJ%N
           IF(IXJ%DAT(J)%I(ICOL) < ICHK) THEN
                                             ICHK = IXJ%DAT(J)%I(ICOL)
                                             P    = J
           END IF
       END DO
       !
       IF(P > Z) THEN                                          ! FROM  TOO
                 CALL FAST_COPY_IXJ_SINGLE_ENTRY( IXJ%DIM, IXJ%DAT(I),        TMP )
                 CALL FAST_COPY_IXJ_SINGLE_ENTRY( IXJ%DIM, IXJ%DAT(P), IXJ%DAT(I) )
                 CALL FAST_COPY_IXJ_SINGLE_ENTRY( IXJ%DIM,        TMP, IXJ%DAT(P) )
                 !                       
                 !TMP        = IXJ%DAT(I)
                 !IXJ%DAT(I) = IXJ%DAT(P)
                 !IXJ%DAT(P) = TMP    
       END IF
       !
    END DO
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE SORT_BY_INT_COL1_COL2(IXJ, ICOL1, ICOL2)
    CLASS(IXJ_STRUCTURE), INTENT(INOUT):: IXJ
    INTEGER,              INTENT(IN   ):: ICOL1, ICOL2
    INTEGER:: I, J, P, ICHK1, ICHK2
    TYPE(IXJ_SINGLE_ENTRY):: TMP
    !
    CALL TMP%ALLOC(IXJ%DIM)
    IXJ%P = ONE
    !
    DO I=ONE, IXJ%N
       !
       ICHK1 = IXJ%DAT(I)%I(ICOL1)
       ICHK2 = IXJ%DAT(I)%I(ICOL2)
       !
       P    = Z
       !
       DO J=I+ONE, IXJ%N
           IF(IXJ%DAT(J)%I(ICOL1) == ICHK1 .AND. IXJ%DAT(J)%I(ICOL2) < ICHK2) THEN
                                                    !
                                                    ICHK1 = IXJ%DAT(J)%I(ICOL1)
                                                    ICHK2 = IXJ%DAT(J)%I(ICOL2)
                                                    P     = J
           ELSEIF(IXJ%DAT(J)%I(ICOL1) < ICHK1) THEN
                                                    ICHK1 = IXJ%DAT(J)%I(ICOL1)
                                                    ICHK2 = IXJ%DAT(J)%I(ICOL2)
                                                    P     = J
           END IF
       END DO
       !
       IF(P > Z) THEN                                          ! FROM  TOO
                 CALL FAST_COPY_IXJ_SINGLE_ENTRY( IXJ%DIM, IXJ%DAT(I),        TMP )
                 CALL FAST_COPY_IXJ_SINGLE_ENTRY( IXJ%DIM, IXJ%DAT(P), IXJ%DAT(I) )
                 CALL FAST_COPY_IXJ_SINGLE_ENTRY( IXJ%DIM,        TMP, IXJ%DAT(P) )
       END IF
       !
    END DO
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE SORT_BY_INT_COL1_COL2_COL3(IXJ, ICOL1, ICOL2, ICOL3)
    CLASS(IXJ_STRUCTURE), INTENT(INOUT):: IXJ
    INTEGER,              INTENT(IN   ):: ICOL1, ICOL2, ICOL3
    INTEGER:: I, J, P, ICHK1, ICHK2, ICHK3
    TYPE(IXJ_SINGLE_ENTRY):: TMP
    !
    CALL TMP%ALLOC(IXJ%DIM)
    IXJ%P = ONE
    !
    DO I=ONE, IXJ%N
       !
       ICHK1 = IXJ%DAT(I)%I(ICOL1)
       ICHK2 = IXJ%DAT(I)%I(ICOL2)
       ICHK3 = IXJ%DAT(I)%I(ICOL3)
       !
       P    = Z
       !
       DO J=I+ONE, IXJ%N
           IF    (IXJ%DAT(J)%I(ICOL1) == ICHK1 .AND. IXJ%DAT(J)%I(ICOL2) == ICHK2 .AND. IXJ%DAT(J)%I(ICOL3) < ICHK3) THEN
                                                    !
                                                    ICHK1 = IXJ%DAT(J)%I(ICOL1)
                                                    ICHK2 = IXJ%DAT(J)%I(ICOL2)
                                                    ICHK3 = IXJ%DAT(I)%I(ICOL3)
                                                    P     = J
                                                    !
           ELSEIF(IXJ%DAT(J)%I(ICOL1) == ICHK1 .AND. IXJ%DAT(J)%I(ICOL2) < ICHK2) THEN
                                                    !
                                                    ICHK1 = IXJ%DAT(J)%I(ICOL1)
                                                    ICHK2 = IXJ%DAT(J)%I(ICOL2)
                                                    ICHK3 = IXJ%DAT(I)%I(ICOL3)
                                                    P     = J
           ELSEIF(IXJ%DAT(J)%I(ICOL1) < ICHK1) THEN
                                                    ICHK1 = IXJ%DAT(J)%I(ICOL1)
                                                    ICHK2 = IXJ%DAT(J)%I(ICOL2)
                                                    ICHK3 = IXJ%DAT(I)%I(ICOL3)
                                                    P     = J
           END IF
       END DO
       !
       IF(P > Z) THEN                                          ! FROM  TOO
                 CALL FAST_COPY_IXJ_SINGLE_ENTRY( IXJ%DIM, IXJ%DAT(I),        TMP )
                 CALL FAST_COPY_IXJ_SINGLE_ENTRY( IXJ%DIM, IXJ%DAT(P), IXJ%DAT(I) )
                 CALL FAST_COPY_IXJ_SINGLE_ENTRY( IXJ%DIM,        TMP, IXJ%DAT(P) )
       END IF
       !
    END DO
    !
  END SUBROUTINE
  !
  ! -----------------------------------------------------------------------------------------------------------------------------
  !
  PURE SUBROUTINE SORT_BY_INT_COLVEC_UNLIMITED(IXJ, N, ICOL)
    CLASS(IXJ_STRUCTURE),  INTENT(INOUT):: IXJ
    INTEGER,               INTENT(IN   ):: N
    INTEGER, DIMENSION(N), INTENT(IN   ):: ICOL
    !
    INTEGER, DIMENSION(N):: ICHK
    TYPE(IXJ_SINGLE_ENTRY):: TMP
    INTEGER:: I, J, K, P
    LOGICAL:: REPOINT, SPIN
    !
    CALL TMP%ALLOC(IXJ%DIM)
    IXJ%P = ONE
    !
    DO I=ONE, IXJ%N
       !
       DO K=ONE, N;   ICHK(K) = IXJ%DAT(I)%I( ICOL(K) )
       END DO
       !
       P = Z
       !
       DO J=I+ONE, IXJ%N
           !
           REPOINT = IXJ%DAT(J)%I( ICOL(1) ) <= ICHK(1)  !Flag to indicate P must be updated
           SPIN    = IXJ%DAT(J)%I( ICOL(1) ) == ICHK(1)  !Flag to indicate that ICOL(2:) must be checked
           !
           K=TWO
           DO WHILE (K <= N .AND. SPIN)                         !Note that alogrithm will REPOINT a full matching %I, but this is a negligable speed hit compared to include an addition check for this within the while loop.
                     !
                     REPOINT = IXJ%DAT(J)%I( ICOL(K) ) <= ICHK(K)
                     SPIN    = IXJ%DAT(J)%I( ICOL(K) ) == ICHK(K)
                     !
                     K = K + ONE
           END DO
           !
           IF(REPOINT) THEN
                           P = J
                           DO K=ONE, N;   ICHK(K) = IXJ%DAT(P)%I( ICOL(K) )
                           END DO
           END IF
       END DO
       !
       IF(P > Z) THEN                                          ! FROM  TOO
                 CALL FAST_COPY_IXJ_SINGLE_ENTRY( IXJ%DIM, IXJ%DAT(I),        TMP )
                 CALL FAST_COPY_IXJ_SINGLE_ENTRY( IXJ%DIM, IXJ%DAT(P), IXJ%DAT(I) )
                 CALL FAST_COPY_IXJ_SINGLE_ENTRY( IXJ%DIM,        TMP, IXJ%DAT(P) )
                 !                       
                 !TMP        = IXJ%DAT(I)
                 !IXJ%DAT(I) = IXJ%DAT(P)
                 !IXJ%DAT(P) = TMP    
       END IF
       !
    END DO
    
  END SUBROUTINE
  !
  ! #############################################################################################################################
  ! #############################################################################################################################
  ! #############################################################################################################################
  !
END MODULE
!
!!   
!   LOOKUP_TABLE_INSTRUCTION
!                           DATA TYPE
!                                    LOOKUP_TABLE_TYPE
!                           SUBROUTINES
!                                    LOOKUP_BY_NAME      
!                                    TB%LOAD
!                                    TB%LOOKUP
! 
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
! MODULE LOOKUP_TABLE_INSTRUCTION   ==>  USE LOOKUP_TABLE_INSTRUCTION, ONLY: LOOKUP_TABLE_TYPE, LOOKUP_BY_NAME
!
!  LOOKUP_TABLE_TYPE IS DATA TYPE THAT HOLDS LOOKUP TABLE AND LOOKUP FUNCTIONS
!  LOOKUP_BY_NAME IS A FUNCTION PROVIDED TO ASSIST IN MULTIPLE TABLE LOOKUPS.
!      DESIGNED FOR TYPE(LOOKUP_TABLE_TYPE), DIMENSION(:):: TABLES 
!      AND EACH TABLE HAS A UNIQUE NAME, TABLENAM, SO FOR A GIVEN X:
!                 Y = LOOKUP_BY_NAME(TABLES, TABLENAM, X) 
!
!  LOOKUP_TABLE_TYPE PROVIDES BASE DATA TYPE FOR TWO COLUMN LOOK UP TABLES.
!  COLUMN 1 CALLED X
!  COLUMN 2 CALLED Y
!
!  TABLE INPUT IS LOADED WITH LOAD SUBROUTINE
!  TYPE(LOOKUP_TABLE_TYPE):: TAB
!  CALL TAB%LOAD(LLOC,ISTART,ISTOP,LINE,IU,IOUT)
!  WHERE LINE WOULD CONTAIN:  
!       TABNAM  [INTERPOLATE|STEP_FUNCTION|NEAREST] COUNT  GENERIC_INPUT
! OR    TABNAM  [INTERP     |STEP         |NEAR   ] COUNT  GENERIC_INPUT
!
!  LOOKUP IS BASED ON REQUESTED X VALUE AND RETURNS Y. 
!  Y IS SET TO NaN IF THERE IS ANY PROBLEM WITH LOOKUP.
!
!  VALUE OF Y CAN BE EITHER AN INTERPOLATED VALUE, NEAREST VALUE, OR STEP FUNCTION (BASED ON INPUT KEYWORD IN [])
!
!  VERSION 1.0 [6/23/2017] ORIGINAL VERSION 
!
!  MODULE DEPENDENCIES:
!                      CONSTANTS
!                      UTIL_INTERFACE 
!                      GENERIC_INPUT_FILE_INSTRUCTION
!                      GENERIC_BLOCK_READER_INSTRUCTION   ==> ONLY REQUIRED IF USING BLOCKS TO LOAD TABLEFILE...CAN COMMENT OUT
!
MODULE LOOKUP_TABLE_INSTRUCTION
  USE, INTRINSIC:: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN
  USE CONSTANTS
  USE UTIL_INTERFACE,                    ONLY: STOP_ERROR, PARSE_WORD_UP, READ_TO_DATA, GET_INTEGER, GET_NUMBER, GET_DOUBLE_DATE, CHECK_FOR_POST_KEY
  USE NUM2STR_INTERFACE,                 ONLY: NUM2STR
  USE GENERIC_INPUT_FILE_INSTRUCTION,    ONLY: GENERIC_INPUT_FILE
  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
  USE DATE_OPERATOR_INSTRUCTION,         ONLY: DATE_OPERATOR
  USE SORT_INTERFACE ! SORT(DIM1,ARR) or SORT(DIM1,DIM2,ARR,COL)
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: LOOKUP_TABLE_TYPE, LOOKUP_BY_NAME
  !
  INTERFACE LOOKUP_BY_NAME ! (TAB,TABNAM,X,[OPTION]) RESULT(Y)
     !
     MODULE PROCEDURE GET_LOOKUP_TABLE_BY_NAME       
     MODULE PROCEDURE GET_LOOKUP_TABLE_BY_NAME_SINGLE
     !
  END INTERFACE
  !
  TYPE MID_CHECK
      DOUBLE PRECISION:: XMID
      INTEGER::          IMID
  END TYPE
  !
  TYPE LOOKUP_TABLE_TYPE
      INTEGER:: N  = Z    ! SIZE OF X, Y
      INTEGER:: OPT= Z    ! OPT => 0=INTERP; 1=STEP, 2=NEAR
      CHARACTER(:), ALLOCATABLE:: NAM
      DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE:: X,Y
      !
      TYPE(MID_CHECK),ALLOCATABLE:: MD
      !
      CONTAINS
      !
      GENERIC::                       LOAD   => LOAD_LOOKUP_TABLE_BLOCK, LOAD_LOOKUP_TABLE_FILE, LOAD_LOOKUP_TABLE_VALUE
      !
      PROCEDURE, PASS(TAB)::          LOOKUP => GET_LOOKUP_TABLE_VALUE_SUB        ! (X,Y,[OPTION])
      GENERIC::                       GET    => GET_LOOKUP_TABLE_VALUE,         & ! (X,[OPTION]) RESULT(Y)
                                                GET_LOOKUP_TABLE_BY_NAME_SINGLE   ! (TABNAM,X,[OPTION]) RESULT(Y)
      PROCEDURE, PASS(TAB)::          MOVE   => MOVE_LOOKUP_TABLE!(TAB,TAB2)
      PROCEDURE, PASS(TAB)::          COPY   => COPY_LOOKUP_TABLE!(TAB,TAB2)
      PROCEDURE, PASS(TAB), PRIVATE:: LOAD_LOOKUP_TABLE_BLOCK ! (LLOC,ISTART,ISTOP,BL,LOAD_NAME,[NO_INTERNAL])  
      PROCEDURE, PASS(TAB), PRIVATE:: LOAD_LOOKUP_TABLE_FILE  ! (LLOC,ISTART,ISTOP,LINE,IU,IOUT,LOAD_NAME,[NO_INTERNAL],[SKIP_VAL])
      PROCEDURE, PASS(TAB), PRIVATE:: LOAD_LOOKUP_TABLE_VALUE ! (VAL, [NAM])
      PROCEDURE, PASS(TAB), PRIVATE:: GET_LOOKUP_TABLE_VALUE
      PROCEDURE, PASS(TAB), PRIVATE:: GET_LOOKUP_TABLE_VALUE_SUB
      PROCEDURE, PASS(TAB), PRIVATE:: GET_LOOKUP_TABLE_BY_NAME_SINGLE ! (TAB,TABNAM,X,[OPTION]) RESULT(Y)
      PROCEDURE, PASS(TAB)::          DESTROY => DEALLOCATE_LOOKUP_TABLE
      FINAL:: FINAL_DEALLOCATE_LOOKUP_TABLE
  END TYPE
  !
  CONTAINS
  !
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_LOOKUP_TABLE(TAB)
    CLASS(LOOKUP_TABLE_TYPE), INTENT(INOUT):: TAB
    IF(ALLOCATED(TAB%NAM)) DEALLOCATE(TAB%NAM)
    IF(ALLOCATED(TAB%X  )) DEALLOCATE(TAB%X  )
    IF(ALLOCATED(TAB%Y  )) DEALLOCATE(TAB%Y  )
    IF(ALLOCATED(TAB%MD )) DEALLOCATE(TAB%MD )
    TAB%N   = Z
    TAB%OPT = Z
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MOVE_LOOKUP_TABLE(TAB,TAB2)  !COULD ADD SPEED OPTIMIZERS for TAB2%N==TAB%N
    CLASS(LOOKUP_TABLE_TYPE), INTENT(INOUT):: TAB,TAB2
    !
    CALL DEALLOCATE_LOOKUP_TABLE(TAB2)
    !
    TAB2%N   = TAB%N
    TAB2%OPT = TAB%OPT
    IF(ALLOCATED(TAB%NAM)) ALLOCATE(TAB2%NAM, SOURCE = TAB%NAM)
    IF(ALLOCATED(TAB%X  )) CALL MOVE_ALLOC(TAB%X,  TAB2%X )
    IF(ALLOCATED(TAB%Y  )) CALL MOVE_ALLOC(TAB%Y,  TAB2%Y )
    IF(ALLOCATED(TAB%MD )) CALL MOVE_ALLOC(TAB%MD, TAB2%MD)
    !
    CALL DEALLOCATE_LOOKUP_TABLE(TAB)
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_LOOKUP_TABLE(TAB,TAB2)
    CLASS(LOOKUP_TABLE_TYPE), INTENT(IN   ):: TAB
    CLASS(LOOKUP_TABLE_TYPE), INTENT(INOUT):: TAB2
    !
    CALL DEALLOCATE_LOOKUP_TABLE(TAB2)
    !
    TAB2%N   = TAB%N
    TAB2%OPT = TAB%OPT
    IF(ALLOCATED(TAB%NAM)) ALLOCATE(TAB2%NAM, SOURCE = TAB%NAM)
    IF(ALLOCATED(TAB%X  )) ALLOCATE( TAB2%X , SOURCE = TAB%X  )
    IF(ALLOCATED(TAB%Y  )) ALLOCATE( TAB2%Y , SOURCE = TAB%Y  )
    IF(ALLOCATED(TAB%MD )) ALLOCATE( TAB2%MD, SOURCE = TAB%MD )
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_LOOKUP_TABLE(TAB)
    TYPE(LOOKUP_TABLE_TYPE), INTENT(INOUT):: TAB
    CALL DEALLOCATE_LOOKUP_TABLE(TAB)
  END SUBROUTINE
  !
  FUNCTION GET_LOOKUP_TABLE_VALUE(TAB,X,OPTION) RESULT(Y)
    CLASS(LOOKUP_TABLE_TYPE), INTENT(IN):: TAB
    DOUBLE PRECISION,         INTENT(IN):: X
    INTEGER, OPTIONAL,        INTENT(IN):: OPTION
    DOUBLE PRECISION:: Y
    !
    ! OPTION = 0 INTERPOLATE
    ! OPTION = 1 STEP_FUNCTION
    ! OPTION = 2 NEAREST VALUE
    !
    CALL GET_LOOKUP_TABLE_VALUE_SUB(TAB,X,Y,OPTION)
    !
    !!!SELECT CASE (OPT)
    !!!CASE(Z);     Y = TAB%Y(N) + (X - TAB%X(N)) * (TAB%Y(N+1)-TAB%Y(N)) / (TAB%X(N+1)-TAB%X(N))
    !!!CASE(ONE);   Y = TAB%Y(N)
    !!!CASE(TWO)
    !!!         IF( X - TAB%X(N) > TAB%X(N+1) - X) THEN
    !!!             Y = TAB%Y(N+1)
    !!!         ELSE
    !!!             Y = TAB%Y(N)
    !!!         END IF
    !!!END SELECT
  END FUNCTION
  !
  PURE SUBROUTINE GET_LOOKUP_TABLE_VALUE_SUB(TAB,X,Y,OPTION)
    CLASS(LOOKUP_TABLE_TYPE), INTENT(IN   ):: TAB
    DOUBLE PRECISION,         INTENT(IN   ):: X
    DOUBLE PRECISION,         INTENT(  OUT):: Y
    INTEGER, OPTIONAL,        INTENT(IN   ):: OPTION
    INTEGER:: N, OPT, P
    !
    ! OPTION = 0 INTERPOLATE
    ! OPTION = 1 STEP_FUNCTION
    ! OPTION = 2 NEAREST VALUE
    !
    OPT = TAB%OPT
    IF(PRESENT(OPTION)) OPT = OPTION
    !
    IF(TAB%N == Z) THEN
            !
            Y = IEEE_VALUE(Y, IEEE_QUIET_NAN)  ! NO VALUES IN LOOKUP TABLE!!!
            !
    ELSEIF(X <= TAB%X(ONE) .OR. TAB%N == ONE) THEN
        !
        IF(TAB%N > ONE .AND. OPT==Z) THEN
            Y = TAB%Y(ONE) + (X - TAB%X(ONE)) * (TAB%Y(TWO)-TAB%Y(ONE)) / (TAB%X(TWO)-TAB%X(ONE))
        ELSE
            Y = TAB%Y(ONE)
        END IF
    ELSEIF( X >= TAB%X(TAB%N) ) THEN
        !
        N = TAB%N
        IF(OPT==Z) THEN
            Y = TAB%Y(N-1) + (X - TAB%X(N-1)) * (TAB%Y(N)-TAB%Y(N-1)) / (TAB%X(N)-TAB%X(N-1))
        ELSE
            Y = TAB%Y(N)
        END IF
    ELSE
        !
        P = TWO
        !
        IF(TAB%N > 39) THEN;  IF (X > TAB%MD%XMID) P = TAB%MD%IMID  !HALF CHECK SPEED UP
        END IF
        !
        DO N=P, TAB%N
            IF(X < TAB%X(N)) THEN
                                 P = N - ONE
                                 EXIT
            END IF
        END DO
        !
        IF    (OPT == Z  ) THEN;  Y = TAB%Y(P) + (X - TAB%X(P)) * (TAB%Y(P+1)-TAB%Y(P)) / (TAB%X(P+1)-TAB%X(P))
        ELSEIF(OPT == ONE) THEN;  Y = TAB%Y(P)
        ELSEIF(OPT == TWO) THEN 
                              IF( X - TAB%X(P) >= TAB%X(P+1) - X) THEN !True if closer to next point
                                  Y = TAB%Y(P+1)
                              ELSE
                                  Y = TAB%Y(P)
                              END IF
        END IF
    END IF
    !
  END SUBROUTINE
  !
  !!!PURE SUBROUTINE GET_LOOKUP_TABLE_VALUE_SUB(TAB,X,Y,OPTION)
  !!!  CLASS(LOOKUP_TABLE_TYPE), INTENT(INOUT):: TAB
  !!!  DOUBLE PRECISION,         INTENT(IN   ):: X
  !!!  DOUBLE PRECISION,         INTENT(  OUT):: Y
  !!!  INTEGER, OPTIONAL,        INTENT(IN   ):: OPTION
  !!!  INTEGER:: N, OPT, P
  !!!  !
  !!!  ! OPTION = 0 INTERPOLATE
  !!!  ! OPTION = 1 STEP_FUNCTION
  !!!  ! OPTION = 2 NEAREST VALUE
  !!!  !
  !!!  OPT = TAB%OPT
  !!!  IF(PRESENT(OPTION)) OPT = OPTION
  !!!  !
  !!!  IF(TAB%N == Z) THEN
  !!!          !
  !!!          Y = IEEE_VALUE(Y, IEEE_QUIET_NAN)  ! NO VALUES IN LOOKUP TABLE!!!
  !!!          !
  !!!  ELSEIF(X <= TAB%X(ONE) .OR. TAB%N == ONE) THEN
  !!!      !
  !!!      IF(TAB%N > ONE .AND. OPT==Z) THEN
  !!!          Y = TAB%Y(ONE) + (X - TAB%X(ONE)) * (TAB%Y(TWO)-TAB%Y(ONE)) / (TAB%X(TWO)-TAB%X(ONE))
  !!!      ELSE
  !!!          Y = TAB%Y(ONE)
  !!!      END IF
  !!!  ELSEIF( X >= TAB%X(TAB%N) ) THEN
  !!!      !
  !!!      N = TAB%N
  !!!      IF(OPT==Z) THEN
  !!!          Y = TAB%Y(N-1) + (X - TAB%X(N-1)) * (TAB%Y(N)-TAB%Y(N-1)) / (TAB%X(N)-TAB%X(N-1))
  !!!      ELSE
  !!!          Y = TAB%Y(N)
  !!!      END IF
  !!!  ELSE
  !!!      !
  !!!      IF(TAB%P >= 50) THEN   ! SPEED UP IF PREVIOUS SEARCH IS >50 INDEX AND NEW SEARCH WITHIN 10 LEVELS OF IT
  !!!          P = TAB%P - TEN
  !!!          IF (X < TAB%X(P)) P = TWO
  !!!      ELSE
  !!!          P = TWO
  !!!      END IF
  !!!      !
  !!!      DO N=P, TAB%N
  !!!          IF(X < TAB%X(N)) THEN
  !!!                               TAB%P = N - ONE
  !!!                               EXIT
  !!!          END IF
  !!!      END DO
  !!!      !
  !!!      N = TAB%P
  !!!      !
  !!!      IF    (OPT == Z  ) THEN;  Y = TAB%Y(N) + (X - TAB%X(N)) * (TAB%Y(N+1)-TAB%Y(N)) / (TAB%X(N+1)-TAB%X(N))
  !!!      ELSEIF(OPT == ONE) THEN;  Y = TAB%Y(N)
  !!!      ELSEIF(OPT == TWO) THEN 
  !!!                            IF( X - TAB%X(N) >= TAB%X(N+1) - X) THEN !True if closer to next point
  !!!                                Y = TAB%Y(N+1)
  !!!                            ELSE
  !!!                                Y = TAB%Y(N)
  !!!                            END IF
  !!!      END IF
  !!!  END IF
  !!!  !
  !!!END SUBROUTINE
  !
  SUBROUTINE LOAD_LOOKUP_TABLE_BLOCK(TAB,LLOC,ISTART,ISTOP,BL,LOAD_NAME,NO_INTERNAL,SKIP_VAL)  !ASSUMES THAT LLOC IS SET AND RAN "CALL BL%LIST%SET_LN()"  -- THAT IS BL IS LOCATED AT CORRECT LINE
    CLASS(LOOKUP_TABLE_TYPE),    INTENT(INOUT):: TAB
    INTEGER,                     INTENT(INOUT):: LLOC,ISTART,ISTOP
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    LOGICAL,                     INTENT(IN   ):: LOAD_NAME
    LOGICAL, OPTIONAL,           INTENT(IN   ):: NO_INTERNAL
    DOUBLE PRECISION, OPTIONAL,  INTENT(IN   ):: SKIP_VAL
    TYPE(GENERIC_INPUT_FILE):: FL
    TYPE(DATE_OPERATOR):: DATE
    DOUBLE PRECISION:: X, Y, SFAC
    INTEGER:: I, N, OPT
    LOGICAL:: EOF
    !
    SFAC    = UNO
    !
    IF(LOAD_NAME) THEN
       CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP)
       !
       ALLOCATE(TAB%NAM, SOURCE = BL%LINE(ISTART:ISTOP))
    ELSE
       ALLOCATE(TAB%NAM, SOURCE = 'Null')
    END IF
    !
    CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP)
    !
    SELECT CASE(BL%LINE(ISTART:ISTOP))
    CASE('CONSTANT');                OPT = NEG
    CASE('INTERP','INTERPOLATE'   ); OPT = Z
    CASE('STEP','STEP_FUNCTION'   ); OPT = ONE
    CASE('NEAR','NEAREST'         ); OPT = TWO
    CASE('SKIP','NULL','NUL','NAN'); OPT = NEG2
    CASE DEFAULT;                    CALL STOP_ERROR( LINE=BL%LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: YOU MUST SPECIFY KEYWORD "INTERPOLATE", OR "STEP_FUNCTION", "NEAREST", "CONSTANT", OR "SKIP" AFTER THE TABLE NAME.') 
    END SELECT 
    !
    IF(OPT==NEG2) THEN
        !
        IF(.NOT. PRESENT(SKIP_VAL))  CALL STOP_ERROR( LINE=BL%LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: FOUND KEYWORD "'//BL%LINE(ISTART:ISTOP)//'" BUT THIS LOOKUP TABLE DOES NOT SUPPORT THAT OPTION. PLEASE CHANGE TO "INTERPOLATE", OR "STEP_FUNCTION", "NEAREST", OR "CONSTANT".') 
        !
        CALL LOAD_LOOKUP_TABLE_VALUE(TAB, SKIP_VAL, TAB%NAM)
        !
        RETURN
        !
    ELSEIF(OPT==NEG) THEN
        !
        CALL GET_DOUBLE_DATE(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,X,DATE,MSG='LOOKUP TABLE LOAD ERROR: FOUND KEYWORD "CONSTANT", BUT FAILED TO LOAD THE CONSTANT VALUE', ONLY_DYEAR=TRUE)
        !
        CALL CHECK_FOR_POST_KEY(LLOC, BL%LINE, BL%IU, BL%IOUT, I, N, SCALE=Y)
        X = X*Y
        !
        CALL LOAD_LOOKUP_TABLE_VALUE(TAB, X, TAB%NAM)
        !
        RETURN
    END IF
    !
    TAB%OPT = OPT
    !
    CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,N,MSG='LOOKUP TABLE LOAD BLOCK ERROR: FAILED TO LOAD COUNT OF LOOK UP TABLE (NUMBER OF ROWS). A VALUE LESS THAN ONE, WILL TRIGGER AN AUTO-COUNT, BUT YOU STILL MUST SPECIFIY AN INTEGER AS A PLACE HOLDER.')
    IF (N<Z) N=Z
    !
    CALL FL%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU)
    !
    IF(FL%SKIP) THEN
        !
        IF(.NOT. PRESENT(SKIP_VAL))  CALL STOP_ERROR( LINE=BL%LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: FOUND KEYWORD "'//BL%LINE(ISTART:ISTOP)//'" BUT THIS LOOKUP TABLE DOES NOT SUPPORT THAT OPTION. PLEASE CHANGE TO "INTERPOLATE", OR "STEP_FUNCTION", "NEAREST", OR "CONSTANT".') 
        !
        CALL LOAD_LOOKUP_TABLE_VALUE(TAB, SKIP_VAL, TAB%NAM)
        !
        RETURN
        !
    ELSEIF(FL%IS_CONSTANT) THEN
        !
        FL%CONST = FL%CONST*FL%SCALE
        CALL LOAD_LOOKUP_TABLE_VALUE(TAB, FL%CONST, TAB%NAM)
        !
        RETURN
    END IF
    !
    IF(FL%BINARY .AND. N < ONE)  CALL STOP_ERROR( LINE=BL%LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG= 'LOOKUP TABLE ERROR: IF YOU USE READ FROM A BINARY FILE, YOU MUST PROVIDE THE NUMBER OF ENTRIES IN TABLE (COUNT). SETTING THE NUMBER TO LESS THAN ONE WILL AUTO-COUNT, BUT THIS ONLY WORKS WITH ASCII/UNICODE/TEXT (viz. human readible) FILES.')
    !
    IF(PRESENT(NO_INTERNAL)) THEN
            IF(NO_INTERNAL .AND. FL%IU==Z)  CALL STOP_ERROR( LINE=BL%LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG= 'LOOKUP TABLE ERROR: THIS INPUT LOCATION FOR A LOOK UP TABLE DOES NOT ALLOW FOR THE "INTERNAL" KEYWORD. PLEASE INSTEAD USE "OPEN/CLOSE" OR "EXTERNAL".')
    END IF
    !
    IF(FL%IU==Z) THEN
         !
         IF(N < ONE)  CALL STOP_ERROR( LINE=BL%LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG= 'LOOKUP TABLE ERROR: IF YOU USE KEYWORD INTERNAL, YOU MUST PROVIDE THE NUMBER OF ENTRIES IN TABLE (COUNT). SETTING THE NUMBER TO LESS THAN ONE WILL AUTO-COUNT, BUT THIS ONLY WORKS WITH "OPEN/CLOSE" OR "EXTERNAL", NOT "INTERNAL".')
         !
         DO I=ONE, N
             CALL BL%NEXT()
             LLOC = ONE
             CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP)
             IF( BL%LINE(ISTART:ISTOP) == 'SFAC' ) THEN
                 !
                 CALL GET_NUMBER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,X,MSG='FAILED TO SCALE FACTOR AFTER READING "SFAC" KEYWORD.')
                 !
                 IF(X.NE.UNO) SFAC = SFAC*X
             ELSE
                 EXIT
             END IF
         END DO
         !
         TAB%N = N
         ALLOCATE(TAB%X(N), TAB%Y(N))
         DO I=ONE, N
                    LLOC=ONE
                    CALL GET_DOUBLE_DATE(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,TAB%X(I),DATE,MSG='LOOKUP TABLE LOAD BLOCK ERROR: FAILED TO LOAD FIRST  VALUE ON LINE IN TABLE', ONLY_DYEAR=TRUE)
                    CALL GET_DOUBLE_DATE(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,TAB%Y(I),DATE,MSG='LOOKUP TABLE LOAD BLOCK ERROR: FAILED TO LOAD SECOND VALUE ON LINE IN TABLE', ONLY_DYEAR=TRUE)
                    !
                    IF(I>ONE) THEN
                         IF(TAB%X(I-ONE) > TAB%X(I)) CALL STOP_ERROR( LINE=BL%LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: THE LOOKUP COLUMN MUST BE IN ASCENDING ORDER.') 
                    END IF
                    !
                    IF(I < N) CALL BL%NEXT()
         END DO
    ELSE
         IF(N==Z .AND. .NOT. FL%BINARY) THEN
             CALL FL%REWIND()
             DO
                   CALL READ_TO_DATA(BL%LN, FL%IU, BL%IOUT, EOF=EOF)
                   IF(EOF) EXIT
                   LLOC=ONE
                   CALL PARSE_WORD_UP(BL%LN,LLOC,ISTART,ISTOP)
                   !
                   IF( BL%LN(ISTART:ISTOP) .NE. 'SFAC' ) THEN
                       LLOC = ISTART
                       CALL GET_DOUBLE_DATE(BL%LN,LLOC,ISTART,ISTOP,BL%IOUT,FL%IU,X,DATE,MSG='NOSTOP', ONLY_DYEAR=TRUE)
                       CALL GET_DOUBLE_DATE(BL%LN,LLOC,ISTART,ISTOP,BL%IOUT,FL%IU,Y,DATE,MSG='NOSTOP', ONLY_DYEAR=TRUE)
                       IF(X.NE.X .OR. Y.NE.Y) THEN
                           EXIT
                       ELSE
                           N=N+ONE
                       END IF
                   END IF
             END DO
             CALL FL%REWIND()
         END IF
         !
         IF(N==Z)  CALL STOP_ERROR(INFILE=FL%IU, OUTPUT=BL%IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: FILE THAT CONTAINED LOOKUP TABLE TTHAT WAS EMPTY OR THERE WAS A FAILURE TO LOAD ANY OF THE INFORMATION WITHIN THE LOOKUP TABLE (eg BAD DATA).')
         !
         IF(.NOT. FL%BINARY) THEN
           DO I=ONE, N
               CALL READ_TO_DATA(BL%LN, FL%IU, BL%IOUT)
               LLOC = ONE
               CALL PARSE_WORD_UP(BL%LN,LLOC,ISTART,ISTOP)
               IF( BL%LN(ISTART:ISTOP) == 'SFAC' ) THEN
                   !
                   CALL GET_NUMBER(BL%LN,LLOC,ISTART,ISTOP,BL%IOUT,FL%IU,X,MSG='FAILED TO SCALE FACTOR AFTER READING "SFAC" KEYWORD.')
                   !
                   IF(X.NE.UNO) SFAC = SFAC*X
               ELSE
                   EXIT
               END IF
           END DO
         END IF
         !
         TAB%N = N
         ALLOCATE(TAB%X(N), TAB%Y(N))
         !
         IF(FL%BINARY) THEN
             DO N=ONE, TAB%N
                 READ(FL%IU) TAB%X(N), TAB%Y(N)
             END DO
         ELSE
             DO I=ONE, N
                    LLOC=ONE
                    CALL GET_DOUBLE_DATE(BL%LN,LLOC,ISTART,ISTOP,BL%IOUT,FL%IU,TAB%X(I),DATE,MSG='LOOKUP TABLE LOAD BLOCK ERROR: FAILED TO LOAD FIRST  VALUE ON LINE IN TABLE', ONLY_DYEAR=TRUE)
                    CALL GET_DOUBLE_DATE(BL%LN,LLOC,ISTART,ISTOP,BL%IOUT,FL%IU,TAB%Y(I),DATE,MSG='LOOKUP TABLE LOAD BLOCK ERROR: FAILED TO LOAD SECOND VALUE ON LINE IN TABLE', ONLY_DYEAR=TRUE)
                    !
                    IF(I>ONE) THEN
                         IF(TAB%X(I-ONE) > TAB%X(I)) CALL STOP_ERROR( LINE=BL%LN, INFILE=FL%IU, OUTPUT=BL%IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: THE LOOKUP COLUMN MUST BE IN ASCENDING ORDER.') 
                    END IF
                    !
                    IF(I < N) CALL READ_TO_DATA(BL%LN, FL%IU, BL%IOUT)
             END DO
         END IF
    END IF
    !
    IF(FL%SCALE.NE.UNO) TAB%Y = TAB%Y * FL%SCALE
    IF(SFAC    .NE.UNO) TAB%Y = TAB%Y * SFAC
    !
    CALL CHECK_ASCENDING_ORDER(TAB)
    !
    IF(TAB%N > 39) THEN
        ALLOCATE(TAB%MD)
        TAB%MD%IMID = TAB%N/2
        TAB%MD%XMID = TAB%X(TAB%MD%IMID-ONE)
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_LOOKUP_TABLE_FILE(TAB,LLOC,ISTART,ISTOP,LINE,IU,IOUT,LOAD_NAME,NO_INTERNAL,SKIP_VAL)
    CLASS(LOOKUP_TABLE_TYPE),    INTENT(INOUT):: TAB
    INTEGER,                     INTENT(INOUT):: LLOC,ISTART,ISTOP
    CHARACTER(*),                INTENT(INOUT):: LINE
    INTEGER,                     INTENT(IN   ):: IU, IOUT
    LOGICAL,                     INTENT(IN   ):: LOAD_NAME
    LOGICAL,          OPTIONAL,  INTENT(IN   ):: NO_INTERNAL
    DOUBLE PRECISION, OPTIONAL,  INTENT(IN   ):: SKIP_VAL
    TYPE(GENERIC_INPUT_FILE):: FL
    TYPE(DATE_OPERATOR):: DATE
    DOUBLE PRECISION:: X, Y, SFAC
    INTEGER:: I, N, OPT
    LOGICAL:: EOF
    !
    SFAC    = UNO
    !
    IF(LOAD_NAME) THEN
       CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
       !
       ALLOCATE(TAB%NAM, SOURCE = LINE(ISTART:ISTOP))
    ELSE
       ALLOCATE(TAB%NAM, SOURCE = 'Null')
    END IF
    !
    CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
    !
    SELECT CASE(LINE(ISTART:ISTOP))
    CASE('CONSTANT');                OPT = NEG
    CASE('INTERP','INTERPOLATE'   ); OPT = Z
    CASE('STEP','STEP_FUNCTION'   ); OPT = ONE
    CASE('NEAR','NEAREST'         ); OPT = TWO
    CASE('SKIP','NULL','NUL','NAN'); OPT = NEG2
    CASE DEFAULT;                    CALL STOP_ERROR( LINE=LINE, INFILE=IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: YOU MUST SPECIFY KEYWORD "INTERPOLATE", OR "STEP_FUNCTION", "NEAREST", "CONSTANT", OR "SKIP" AFTER THE TABLE NAME.') 
    END SELECT
    !
    IF(OPT==NEG2) THEN
        !
        IF(.NOT. PRESENT(SKIP_VAL))  CALL STOP_ERROR( LINE=LINE, INFILE=IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: FOUND KEYWORD "'//LINE(ISTART:ISTOP)//'" BUT THIS LOOKUP TABLE DOES NOT SUPPORT THAT OPTION. PLEASE CHANGE TO "INTERPOLATE", OR "STEP_FUNCTION", "NEAREST", OR "CONSTANT".') 
        !
        CALL LOAD_LOOKUP_TABLE_VALUE(TAB, SKIP_VAL, TAB%NAM)
        !
        RETURN
        !
    ELSEIF(OPT==NEG) THEN
        !
        CALL GET_DOUBLE_DATE(LINE,LLOC,ISTART,ISTOP,IOUT,IU,X,DATE,MSG='LOOKUP TABLE LOAD ERROR: FOUND KEYWORD "CONSTANT", BUT FAILED TO LOAD THE CONSTANT VALUE', ONLY_DYEAR=TRUE)
        !
        CALL LOAD_LOOKUP_TABLE_VALUE(TAB, X, TAB%NAM)
        !
        RETURN
    END IF
    !
    TAB%OPT = OPT
    !
    CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IU,N,MSG='LOOKUP TABLE LOAD ERROR: FAILED TO LOAD COUNT OF LOOK UP TABLE (NUMBER OF ROWS). A VALUE LESS THAN ONE, WILL TRIGGER AN AUTO-COUNT, BUT YOU STILL MUST SPECIFIY AN INTEGER AS A PLACE HOLDER.')
    IF (N<Z) N=Z
    !
    CALL FL%OPEN(LINE,LLOC,IOUT,IU)
    !
    IF(FL%BINARY .AND. N < ONE)  CALL STOP_ERROR( LINE=LINE, INFILE=IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE ERROR: IF YOU USE READ FROM A BINARY FILE, YOU MUST PROVIDE THE NUMBER OF ENTRIES IN TABLE (COUNT). SETTING THE NUMBER TO LESS THAN ONE WILL AUTO-COUNT, BUT THIS ONLY WORKS WITH ASCII/UNICODE/TEXT (viz. human readible) FILES.')
    !
    IF(PRESENT(NO_INTERNAL)) THEN
            IF(NO_INTERNAL .AND. FL%IU==Z)  CALL STOP_ERROR( LINE=LINE, INFILE=IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE ERROR: THIS INPUT LOCATION FOR A LOOK UP TABLE DOES NOT ALLOW FOR THE "INTERNAL" KEYWORD. PLEASE INSTEAD USE "OPEN/CLOSE" OR "EXTERNAL".')
    END IF
    !
    IF(FL%IU==Z) THEN
         !
         IF(N < ONE)  CALL STOP_ERROR( LINE=LINE, INFILE=IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE ERROR: IF YOU USE KEYWORD INTERNAL, YOU MUST PROVIDE THE NUMBER OF ENTRIES IN TABLE (COUNT). SETTING THE NUMBER TO LESS THAN ONE WILL AUTO-COUNT, BUT THIS ONLY WORKS WITH "OPEN/CLOSE" OR "EXTERNAL", NOT "INTERNAL".')
         !
         DO I=ONE, N
             CALL READ_TO_DATA(LINE, IU, IOUT)
             LLOC = ONE
             CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
             IF( LINE(ISTART:ISTOP) == 'SFAC' ) THEN
                 !
                 CALL GET_NUMBER(LINE,LLOC,ISTART,ISTOP,IOUT,IU,X,MSG='FAILED TO SCALE FACTOR AFTER READING "SFAC" KEYWORD.')
                 !
                 IF(X.NE.UNO) SFAC = SFAC*X
             ELSE
                 EXIT
             END IF
         END DO
         !
         TAB%N = N
         ALLOCATE(TAB%X(N), TAB%Y(N))
         DO I=ONE, N
                    LLOC=ONE
                    CALL GET_DOUBLE_DATE(LINE,LLOC,ISTART,ISTOP,IOUT,IU,TAB%X(I),DATE,MSG='LOOKUP TABLE LOAD ERROR: FAILED TO LOAD FIRST  VALUE ON LINE IN TABLE', ONLY_DYEAR=TRUE)
                    CALL GET_DOUBLE_DATE(LINE,LLOC,ISTART,ISTOP,IOUT,IU,TAB%Y(I),DATE,MSG='LOOKUP TABLE LOAD ERROR: FAILED TO LOAD SECOND VALUE ON LINE IN TABLE', ONLY_DYEAR=TRUE)
                    !
                    IF(I>ONE) THEN
                         IF(TAB%X(I-ONE) > TAB%X(I)) CALL STOP_ERROR( LINE=LINE, INFILE=IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: THE LOOKUP COLUMN MUST BE IN ASCENDING ORDER.') 
                    END IF
                    !
                    IF(I < N) CALL READ_TO_DATA(LINE, IU, IOUT)
         END DO
    ELSE
         IF(N==Z .AND. .NOT. FL%BINARY) THEN
             CALL FL%REWIND()
             DO
                   CALL READ_TO_DATA(LINE, FL%IU, IOUT, EOF=EOF)
                   IF(EOF) EXIT
                   LLOC=ONE
                   CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                   !
                   IF( LINE(ISTART:ISTOP) .NE. 'SFAC' ) THEN
                         LLOC = ISTART
                         CALL GET_DOUBLE_DATE(LINE,LLOC,ISTART,ISTOP,IOUT,FL%IU,X,DATE,MSG='NOSTOP', ONLY_DYEAR=TRUE)
                         CALL GET_DOUBLE_DATE(LINE,LLOC,ISTART,ISTOP,IOUT,FL%IU,Y,DATE,MSG='NOSTOP', ONLY_DYEAR=TRUE)
                         IF(X.NE.X .OR. Y.NE.Y) THEN
                             EXIT
                         ELSE
                             N=N+ONE
                         END IF
                   END IF
             END DO
             CALL FL%REWIND()
         END IF
         !
         IF(N==Z)  CALL STOP_ERROR(INFILE=FL%IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: FILE THAT CONTAINED LOOKUP TABLE TTHAT WAS EMPTY OR THERE WAS A FAILURE TO LOAD ANY OF THE INFORMATION WITHIN THE LOOKUP TABLE (eg BAD DATA).')
         !
         IF(.NOT. FL%BINARY) THEN
           DO I=ONE, N
               CALL READ_TO_DATA(LINE, FL%IU, IOUT)
               LLOC = ONE
               CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
               IF( LINE(ISTART:ISTOP) == 'SFAC' ) THEN
                   !
                   CALL GET_NUMBER(LINE,LLOC,ISTART,ISTOP,IOUT,FL%IU,X,MSG='FAILED TO SCALE FACTOR AFTER READING "SFAC" KEYWORD.')
                   !
                   IF(X.NE.UNO) SFAC = SFAC*X
               ELSE
                   EXIT
               END IF
           END DO
         END IF
         !
         TAB%N = N
         ALLOCATE(TAB%X(N), TAB%Y(N))
         !
         IF(FL%BINARY) THEN
             DO I=ONE, TAB%N
                 READ(FL%IU) TAB%X(I), TAB%Y(I)
             END DO
             !
             DO I=TWO, TAB%N
                   IF(TAB%X(I-ONE) > TAB%X(I)) THEN
                                               CALL STOP_ERROR( INFILE=FL%IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: THE LOOKUP COLUMN MUST BE IN ASCENDING ORDER.') 
                   END IF
             END DO
         ELSE
             DO I=ONE, N
                    LLOC=ONE
                    CALL GET_DOUBLE_DATE(LINE,LLOC,ISTART,ISTOP,IOUT,FL%IU,TAB%X(I),DATE,MSG='LOOKUP TABLE LOAD ERROR: FAILED TO LOAD FIRST  VALUE ON LINE IN TABLE', ONLY_DYEAR=TRUE)
                    CALL GET_DOUBLE_DATE(LINE,LLOC,ISTART,ISTOP,IOUT,FL%IU,TAB%Y(I),DATE,MSG='LOOKUP TABLE LOAD ERROR: FAILED TO LOAD SECOND VALUE ON LINE IN TABLE', ONLY_DYEAR=TRUE)
                    !
                    IF(I>ONE) THEN
                         IF(TAB%X(I-ONE) > TAB%X(I)) CALL STOP_ERROR( LINE=LINE, INFILE=FL%IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: THE LOOKUP COLUMN MUST BE IN ASCENDING ORDER.') 
                    END IF
                    !
                    IF(I < N) CALL READ_TO_DATA(LINE, FL%IU, IOUT)
             END DO
         END IF
    END IF
    !
    IF(FL%SCALE.NE.UNO) TAB%Y = TAB%Y * FL%SCALE
    IF(SFAC    .NE.UNO) TAB%Y = TAB%Y * SFAC
    !
    !CALL CHECK_ASCENDING_ORDER(TAB)
    !
    IF(TAB%N > 39) THEN
        ALLOCATE(TAB%MD)
        TAB%MD%IMID = TAB%N/2
        TAB%MD%XMID = TAB%X(TAB%MD%IMID-ONE)
    END IF
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE LOAD_LOOKUP_TABLE_VALUE(TAB, VAL, NAM)  !SET TO SINGLE VALUE
    CLASS(LOOKUP_TABLE_TYPE),    INTENT(INOUT):: TAB
    DOUBLE PRECISION,            INTENT(IN   ):: VAL
    CHARACTER(*),    OPTIONAL,   INTENT(IN   ):: NAM
    !
    IF(PRESENT(NAM)) THEN
        IF(ALLOCATED(TAB%NAM)) THEN
                               IF(TAB%NAM.NE.NAM) TAB%NAM=NAM
        ELSE
            TAB%NAM = NAM  
        END IF
    ELSE
            TAB%NAM = NUM2STR(VAL)
    END IF
    !
    TAB%N   = ONE
    TAB%OPT = ONE
    ALLOCATE(TAB%X(ONE), TAB%Y(ONE), SOURCE=VAL)
    !
  END SUBROUTINE
  !
  SUBROUTINE CHECK_ASCENDING_ORDER(TAB)
     CLASS(LOOKUP_TABLE_TYPE),      INTENT(INOUT):: TAB
     INTEGER:: I
     !
     IF(TAB%N>ONE) THEN
           DO I=ONE, TAB%N-ONE
                 IF(TAB%X(I) > TAB%X(I+ONE)) THEN
                                             CALL SORT(TAB%N,TAB%X,TAB%Y)
                                             EXIT
                 END IF
           END DO
     END IF
     !
  END SUBROUTINE
  !
  FUNCTION GET_LOOKUP_TABLE_BY_NAME(TAB,TABNAM,X,OPTION) RESULT(Y)
    CLASS(LOOKUP_TABLE_TYPE), DIMENSION(:), CONTIGUOUS, INTENT(INOUT):: TAB
    CHARACTER(*),                                       INTENT(IN   ):: TABNAM
    DOUBLE PRECISION,                                   INTENT(IN   ):: X
    INTEGER, OPTIONAL,                                  INTENT(IN   ):: OPTION
    DOUBLE PRECISION:: Y
    INTEGER:: I, NTAB
    !
    NTAB = SIZE(TAB)
    DO I=ONE, NTAB
        IF(TABNAM == TAB(I)%NAM) EXIT
        IF(I==NTAB)  NTAB = Z
    END DO
    !
    IF (NTAB > Z ) THEN
                       Y = GET_LOOKUP_TABLE_VALUE(TAB(I),X,OPTION)
    ELSE
                       Y = IEEE_VALUE(Y, IEEE_QUIET_NAN)
    END IF
    !
  END FUNCTION
  !
  FUNCTION GET_LOOKUP_TABLE_BY_NAME_SINGLE(TAB,TABNAM,X,OPTION) RESULT(Y)
    CLASS(LOOKUP_TABLE_TYPE), INTENT(INOUT):: TAB
    CHARACTER(*),             INTENT(IN   ):: TABNAM
    DOUBLE PRECISION,         INTENT(IN   ):: X
    INTEGER, OPTIONAL,        INTENT(IN   ):: OPTION
    DOUBLE PRECISION:: Y
    !
    IF ( TABNAM == TAB%NAM ) THEN
                       Y = GET_LOOKUP_TABLE_VALUE(TAB,X,OPTION)
    ELSE
                       Y = IEEE_VALUE(Y, IEEE_QUIET_NAN)
    END IF
    !
  END FUNCTION
  !
END MODULE
!
!! 
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
! MODULE TIME_SERIES_INSTRUCTION   ==>  USE TIME_SERIES_FILE
!
MODULE TIME_SERIES_INSTRUCTION!, ONLY: TIME_SERIES_FILE
  USE CONSTANTS
  USE DATE_OPERATOR_INSTRUCTION,        ONLY: DATE_OPERATOR
  USE UTIL_INTERFACE,                   ONLY: READ_TO_DATA, PARSE_WORD, GET_WORD, GET_DATE, GET_NUMBER, GET_INTEGER, STOP_ERROR, CHECK_FOR_POST_KEY
  USE WARNING_TYPE_INSTRUCTION,         ONLY: WARNING_TYPE
  USE GENERIC_INPUT_FILE_INSTRUCTION,   ONLY: GENERIC_INPUT_FILE
  USE GENERIC_BLOCK_READER_INSTRUCTION, ONLY: GENERIC_BLOCK_READER
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: TIME_SERIES_FILE, TIME_SERIES_FILE_GROUP, LOAD_TIME_SERIES_BLOCK, LOAD_TIME_SERIES_BLOCK_POINTER
  !
  TYPE TSF_DATA
    DOUBLE PRECISION   :: TIM=DZ, DAT=DZ
    TYPE(DATE_OPERATOR):: DATE
  END TYPE
  !
  TYPE TIME_SERIES_FILE
      INTEGER:: P         = Z     !CURRENT LINE, IS SET TO ZERO IF WHEN NOT INITIALIZED
      LOGICAL:: BINARY    = FALSE
      LOGICAL:: AT_NEXT   = FALSE
      LOGICAL:: MONTHDAY  = FALSE
      INTEGER:: MD_FLAG   = Z        ! =0 Within File, 1 PREV-CUR stradles EOF, 2 CUR-NEXT stradles EOF
      INTEGER:: OPT= Z    ! OPT => 0=INTERP; 1=STEP, 2=NEAR
      INTEGER:: N  = Z    ! SIZE OF FILE
      INTEGER:: IOUT = Z
      CHARACTER(:), ALLOCATABLE:: NAM
      CHARACTER(75):: LINE
      !
      DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE:: T500
      INTEGER:: N500 = Z
      !
      !INTEGER::          CHK     = inf_I ! INDEX TO CHECK IF FASTER TO MOVE TO START OF FILE
      !DOUBLE PRECISION:: CHK_TIM = ninf  !TIME TO CHECK AGAINST IF FASTER TO MOVE TO FRONT OF FILE
      !
      TYPE(GENERIC_INPUT_FILE):: FL
      !TYPE(DATE_OPERATOR):: DATE  !SCRATCH SPACE FOR LOADING TIME VALUE --Made availible to each location
      !
      !DOUBLE PRECISION:: SFAC = UNO
      TYPE(TSF_DATA), POINTER:: PREV => NULL()
      TYPE(TSF_DATA), POINTER:: CUR  => NULL()
      TYPE(TSF_DATA), POINTER:: NEXT => NULL()
      !
      TYPE(TSF_DATA), POINTER:: TMP => NULL()
      !
      CONTAINS
      !
      GENERIC::              INIT     => INITIALIZE_TIME_SERIES_FILE, INITIALIZE_TIME_SERIES_FILE_LINE, INITIALIZE_TIME_SERIES_FILE_VALUE!(LINE,LLOC,IOUT,IN,READ_NAME,[DEFAULT_OPT]) or (LINE,[READ_NAME],[DEFAULT_OPT]) or (VALUE)
      PROCEDURE, PASS(TSF):: OPENED   => TIME_SERIES_FILE_IN_USE
      PROCEDURE, PASS(TSF):: MOVE     => MOVE_TIME_SERIES_TOO
      GENERIC::              GET      => LOOKUP_TIME_SERIES_VALUE_DATE, LOOKUP_TIME_SERIES_VALUE_DYEAR, LOOKUP_TIME_SERIES_VALUE_DATE_DATE
      PROCEDURE, PASS(TSF):: IS_INIT
      PROCEDURE, PASS(TSF):: TIME_MEAN   !(TIME0, TIME, VALUE)
      PROCEDURE, PASS(TSF):: TIME_SUM    !(TIME0, TIME, VAL, DELT)
      PROCEDURE, PASS(TSF):: TIME_MAX    !(TIME0, TIME, VALUE)
      PROCEDURE, PASS(TSF):: TIME_MIN    !(TIME0, TIME, VALUE)
      PROCEDURE, PASS(TSF):: INTERVAL_SUM!(TIME0, TIME, VALUE)
      PROCEDURE, PASS(TSF):: SET_OPTION  !(OPT)
      PROCEDURE, PASS(TSF):: GET_N_SET_OPTION !(LINE, LLOC, ISTART, ISTOP, [CONST], [DEFAULT_OPT])
      PROCEDURE, PASS(TSF):: GET_OPTION       !(LINE, LLOC, ISTART, ISTOP, [CONST])
      PROCEDURE, PASS(TSF):: PRINT_OPTION !([OPT])
      !
      PROCEDURE, PASS(TSF),PRIVATE::     LOOKUP_TIME_SERIES_VALUE_DATE_DATE !(DATE, VALUE, DATE0)
      PROCEDURE, PASS(TSF),PRIVATE::     LOOKUP_TIME_SERIES_VALUE_DATE      !(DATE, VALUE)
      PROCEDURE, PASS(TSF),PRIVATE::     LOOKUP_TIME_SERIES_VALUE_DYEAR     !(TIME, VALUE)
      PROCEDURE, PASS(TSF),PRIVATE::     INITIALIZE_TIME_SERIES_FILE        !(LINE,LLOC,IOUT,IN,READ_NAME,[VALUE],[DEFAULT_OPT],[NAME])
      PROCEDURE, PASS(TSF),PRIVATE::     INITIALIZE_TIME_SERIES_FILE_LINE   !(LINE,[READ_NAME],[DEFAULT_OPT],[NAME])
      PROCEDURE, PASS(TSF),PRIVATE::     INITIALIZE_TIME_SERIES_FILE_VALUE  !(VALUE)
      !
      PROCEDURE, PASS(TSF):: DESTROY  => DEALLOCATE_TIME_SERIES_FILE
      FINAL:: FINAL_DEALLOCATE_TIME_SERIES_FILE
      !
  END TYPE
  !
  TYPE TIME_SERIES_FILE_GROUP
      INTEGER:: NFIL = Z
      TYPE(TIME_SERIES_FILE),DIMENSION(:),ALLOCATABLE:: TSF
      INTEGER,               DIMENSION(:),ALLOCATABLE:: ID
      !
      CONTAINS
      !
      PROCEDURE, PASS(TSG):: INIT    => INITIALIZE_TIME_SERIES_GROUP
      PROCEDURE, PASS(TSG):: DESTROY => DEALLOCATE_TIME_SERIES_GROUP
      FINAL::                FINAL_DEALLOCATE_TIME_SERIES_GROUP
  END TYPE
  !  
  CONTAINS 
  !
  PURE FUNCTION IS_INIT(TSF)
    CLASS(TIME_SERIES_FILE),  INTENT(IN):: TSF
    LOGICAL:: IS_INIT
    !
    IS_INIT = TSF%P > Z
    !
  END FUNCTION
  !
  SUBROUTINE INITIALIZE_TIME_SERIES_GROUP(TSG, BL, READ_ID, READ_NAME)
    CLASS(TIME_SERIES_FILE_GROUP), INTENT(INOUT):: TSG
    CLASS(GENERIC_BLOCK_READER),   INTENT(INOUT):: BL
    LOGICAL, OPTIONAL,             INTENT(IN   ):: READ_ID, READ_NAME
    !
    INTEGER:: I, LLOC,ISTART,ISTOP
    LOGICAL:: GET_ID
    !
    GET_ID = FALSE
    IF(PRESENT(READ_ID)) GET_ID = READ_ID
    !
    CALL DEALLOCATE_TIME_SERIES_GROUP(TSG)
    !
    TSG%NFIL = BL%NLINE
    !
    IF(TSG%NFIL > Z) THEN
       !
       ALLOCATE(TSG%TSF(TSG%NFIL))
       !
       IF(GET_ID) ALLOCATE(TSG%ID(TSG%NFIL))
       !
       CALL BL%START()
       !
       DO I = ONE, TSG%NFIL
                       !
                       LLOC=ONE
                       IF(GET_ID) CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,TSG%ID(I),MSG='TIME SERIES FILE FAILED TO LOAD INTEGER ID BEFORE TIME SERIES FILE ITSELF. THIS INPUT REQUIRES YOU SPECIFY AN INTEGER FIRST, THEN THE ACTUAL TIME SERIES FILE.')
                       !
                       CALL TSG%TSF(I)%INIT(BL%LINE,LLOC,BL%IOUT,BL%IU,READ_NAME=READ_NAME)
                       !
                       CALL BL%NEXT()    !NOVE TO NEXT TIME SERIES FILE
       END DO
    END IF
    !
  END SUBROUTINE
  !
  IMPURE ELEMENTAL SUBROUTINE DEALLOCATE_TIME_SERIES_GROUP(TSG)
    CLASS(TIME_SERIES_FILE_GROUP), INTENT(INOUT):: TSG
    TSG%NFIL = Z
    IF(ALLOCATED(TSG%TSF)) DEALLOCATE(TSG%TSF)
    IF(ALLOCATED(TSG%ID )) DEALLOCATE(TSG%ID)
  END SUBROUTINE
  !
  IMPURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_TIME_SERIES_GROUP(TSG)
    TYPE(TIME_SERIES_FILE_GROUP), INTENT(INOUT):: TSG
    CALL DEALLOCATE_TIME_SERIES_GROUP(TSG)
  END SUBROUTINE
  !
  SUBROUTINE LOAD_TIME_SERIES_BLOCK(BL,TSF, NFIL, ID, READ_NAME)
    CLASS(GENERIC_BLOCK_READER),                     INTENT(INOUT):: BL
    TYPE(TIME_SERIES_FILE),DIMENSION(:),ALLOCATABLE, INTENT(INOUT):: TSF
    INTEGER,                                         INTENT(  OUT):: NFIL
    INTEGER, OPTIONAL,     DIMENSION(:),ALLOCATABLE, INTENT(  OUT):: ID
    LOGICAL, OPTIONAL,                               INTENT(IN   ):: READ_NAME
    !
    INTEGER:: I, LLOC,ISTART,ISTOP
    !
    NFIL = BL%NLINE
    !
    IF(NFIL > Z) THEN
       IF(ALLOCATED(TSF)) DEALLOCATE(TSF)
       !
       ALLOCATE(TSF(NFIL))
       IF(PRESENT(ID)) THEN
           IF(ALLOCATED(ID)) DEALLOCATE(ID)
           ALLOCATE(ID(NFIL))
       END IF
       !
       CALL BL%START()
       !
       DO I = ONE, NFIL
                       !
                       LLOC=ONE
                       IF(PRESENT(ID)) CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,ID(I),MSG='TIME SERIES FILE FAILED TO LOAD INTEGER ID BEFORE TIME SERIES FILE ITSELF. THIS INPUT REQUIRES YOU SPECIFY AN INTEGER FIRST, THEN THE ACTUAL TIME SERIES FILE.')
                       !
                       CALL TSF(I)%INIT(BL%LINE,LLOC,BL%IOUT,BL%IU,READ_NAME=READ_NAME)
                       !
                       CALL BL%NEXT()    !NOVE TO NEXT TIME SERIES FILE
       END DO
    ELSE
       NFIL = Z
       IF(ALLOCATED(TSF)) DEALLOCATE(TSF)
       IF(PRESENT(ID)) THEN; IF(ALLOCATED(ID)) DEALLOCATE(ID)
       END IF
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_TIME_SERIES_BLOCK_POINTER(BL,TSF, NFIL, ID, READ_NAME)
    CLASS(GENERIC_BLOCK_READER),                             INTENT(INOUT):: BL
    TYPE(TIME_SERIES_FILE),DIMENSION(:),POINTER, CONTIGUOUS, INTENT(INOUT):: TSF
    INTEGER,                                                 INTENT(  OUT):: NFIL
    INTEGER, OPTIONAL,     DIMENSION(:),POINTER, CONTIGUOUS, INTENT(  OUT):: ID
    LOGICAL, OPTIONAL,                                       INTENT(IN   ):: READ_NAME
    !
    INTEGER:: I, LLOC,ISTART,ISTOP
    !
    NFIL = BL%NLINE
    !
    IF(NFIL > Z) THEN
       IF(ASSOCIATED(TSF)) DEALLOCATE(TSF,STAT=I)
       !
       ALLOCATE(TSF(NFIL))
       IF(PRESENT(ID)) THEN
           IF(ASSOCIATED(ID)) DEALLOCATE(ID,STAT=I)
           ALLOCATE(ID(NFIL))
       END IF
       !
       CALL BL%START()
       !
       DO I = ONE, NFIL
                       !
                       LLOC=ONE
                       IF(PRESENT(ID)) CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,ID(I),MSG='TIME SERIES FILE FAILED TO LOAD INTEGER ID BEFORE TIME SERIES FILE ITSELF. THIS INPUT REQUIRES YOU SPECIFY AN INTEGER FIRST, THEN THE ACTUAL TIME SERIES FILE.')
                       !
                       CALL TSF(I)%INIT(BL%LINE,LLOC,BL%IOUT,BL%IU,READ_NAME=READ_NAME)
                       !
                       CALL BL%NEXT()    !NOVE TO NEXT TIME SERIES FILE
       END DO
    ELSE
       NFIL = Z
       IF(ASSOCIATED(TSF)) DEALLOCATE(TSF,STAT=I)
       IF(PRESENT(ID)) THEN; IF(ASSOCIATED(ID)) DEALLOCATE(ID,STAT=I)
       END IF
    END IF
    !
  END SUBROUTINE
  !  
  IMPURE ELEMENTAL SUBROUTINE INITIALIZE_TIME_SERIES_FILE_VALUE(TSF,VALUE)
    CLASS(TIME_SERIES_FILE),  INTENT(INOUT):: TSF
    DOUBLE PRECISION,OPTIONAL,INTENT(IN   ):: VALUE
    INTEGER:: LLOC
    !
    LLOC = ONE
    CALL INITIALIZE_TIME_SERIES_FILE(TSF,'SKIP',LLOC,Z,Z,FALSE,VALUE)
    !
  END SUBROUTINE
  !  
  IMPURE ELEMENTAL SUBROUTINE INITIALIZE_TIME_SERIES_FILE_LINE(TSF,LINE,READ_NAME,DEFAULT_OPT,NAME)
    CLASS(TIME_SERIES_FILE),  INTENT(INOUT):: TSF
    CHARACTER(*),             INTENT(IN   ):: LINE
    LOGICAL     ,    OPTIONAL,INTENT(IN   ):: READ_NAME
    CHARACTER(*),    OPTIONAL,INTENT(IN   ):: DEFAULT_OPT !IF NO KEYWORD OPTION IS FOUND THIS STRING WILL BE PARSED
    CHARACTER(*),    OPTIONAL,INTENT(IN   ):: NAME        !IF PRESENT SETS NAME TO THIS STRING
    LOGICAL:: REED_NAME
    INTEGER:: LLOC
    !
    IF(PRESENT(READ_NAME)) THEN
        REED_NAME = READ_NAME
    ELSE
        REED_NAME = FALSE
    END IF
    !
    LLOC = ONE
    CALL INITIALIZE_TIME_SERIES_FILE(TSF,LINE,LLOC,Z,Z,REED_NAME, DEFAULT_OPT=DEFAULT_OPT, NAME=NAME)
    !
  END SUBROUTINE
  !  
  IMPURE ELEMENTAL SUBROUTINE INITIALIZE_TIME_SERIES_FILE(TSF,LINE,LLOC,IOUT,IN,READ_NAME,VALUE,DEFAULT_OPT,NAME)
    CLASS(TIME_SERIES_FILE),  INTENT(INOUT):: TSF
    CHARACTER(*),             INTENT(IN   ):: LINE
    INTEGER,                  INTENT(INOUT):: LLOC
    INTEGER,                  INTENT(IN   ):: IOUT,IN  !Output file to write error msg too, infile to report error from. IN not used other then error msg
    !
    LOGICAL,         OPTIONAL,INTENT(IN   ):: READ_NAME
    DOUBLE PRECISION,OPTIONAL,INTENT(IN   ):: VALUE      !IF PRESENT THEN TIME SERIES ONLY SEES THIS VALUE
    CHARACTER(*),    OPTIONAL,INTENT(IN   ):: DEFAULT_OPT!IF NO KEYWORD OPTION IS FOUND THIS STRING WILL BE PARSED
    CHARACTER(*),    OPTIONAL,INTENT(IN   ):: NAME       !IF PRESENT SETS NAME TO THIS STRING
    !
    INTEGER:: I, K, ISTART,ISTOP
    DOUBLE PRECISION:: CONST
    LOGICAL:: EOF
    !
    CALL DEALLOCATE_TIME_SERIES_FILE(TSF)
    !
    ALLOCATE(TSF%PREV, TSF%CUR, TSF%NEXT)
    TSF%IOUT = IOUT
    !
    IF(PRESENT(VALUE)) THEN
        !
        CALL SET_CONSTANT_VALUE(TSF, VALUE)
        !
        IF(PRESENT(NAME)) THEN
                       ALLOCATE(TSF%NAM, SOURCE = NAME)
        ELSE
                       ALLOCATE(TSF%NAM, SOURCE = 'n')
        END IF
        RETURN
    END IF!-----------------------------------------------------------------------------------
    !
    EOF = FALSE
    IF(PRESENT(READ_NAME)) EOF = READ_NAME
    IF(EOF) THEN
                      CALL GET_WORD(LINE,LLOC,ISTART,ISTOP,TSF%NAM,IS_ALLOC=TRUE,COM_STOP=TRUE)
    ELSE
                      ALLOCATE(TSF%NAM, SOURCE = 'n')
    END IF
    !
    IF(PRESENT(NAME)) THEN
                   DEALLOCATE(TSF%NAM)
                   ALLOCATE(TSF%NAM, SOURCE = NAME)
    END IF
    !
    CALL GET_N_SET_OPTION(TSF, LINE, LLOC, ISTART, ISTOP, IN, CONST, DEFAULT_OPT)
    !
    IF(TSF%OPT > NEG) THEN
        !
        CALL TSF%FL%OPEN(LINE, LLOC, IOUT, IN, NO_INTERNAL=TRUE, NEW_UNIT=TRUE, MSG='ATTEMPED TO OPEN AND LOAD A TIME_SERIES_FILE') !IF DATAFILE OR EXTERNAL REOPEN FILE TO CREATE NEW UNIT NUMBER
        CALL TSF%FL%COUNT_LINES(TSF%N)
        !
        IF(TSF%FL%IS_CONSTANT) THEN               !Should never be true cause it is caught by call GET_N_SET_OPTION
                               TSF%OPT = NINER
                               CONST = TSF%FL%CONST
        END IF
        !
    ELSEIF(TSF%OPT == NINER) THEN
        !
        TSF%FL%SKIP = FALSE
        CALL CHECK_FOR_POST_KEY(LLOC,LINE,IN,IOUT,I,K,TSF%FL%SCALE) !CHECK FOR SCALE FACTORS AFTER CONSTANT
    ELSE
        TSF%FL%SKIP = TRUE !TSF%OPT = NEG SO ITS A SKIPPED FILE
    END IF
    !
    IF(TSF%FL%SKIP) THEN
        !
        CALL SET_CONSTANT_VALUE(TSF, DZ)
        TSF%OPT = NEG
        !
    ELSEIF(TSF%OPT == NINER) THEN
        !
        CALL SET_CONSTANT_VALUE(TSF, CONST)
        TSF%FL%SKIP = TRUE
        !
    ELSEIF(TSF%N == ONE) THEN !ONLY ONE LINE SO TREAT AS CONSTANT
        !
        CALL TSF%FL%READ(TSF%LINE) !MOVE TO FIRST LOCATION
        LLOC = ONE
        CALL GET_DATE  (TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%PREV%DATE, ONLY_DYEAR=TRUE ,MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
        CALL GET_NUMBER(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,        CONST,                  MSG='FAILED TO LOAD DATA/VALUE PART (SECOND NUMBER) OF THE TIME SERIES INPUT FILE.')
        CALL SET_CONSTANT_VALUE(TSF, CONST)
        CALL TSF%FL%CLOSE()
        !
    ELSEIF(TSF%N < ONE) THEN
                            CALL STOP_ERROR( LINE=LINE, INFILE=IN, OUTPUT=IOUT, MSG= 'TIME SERIES INPUT ERROR: THE TIME SERIES FILE APPEARS TO BE EMPTY? OR THE FILE WAS OPENED WITH BINARY FORMAT.') 
    ELSE
        TSF%N500 = TSF%N / QUIN
        !
        IF(TSF%N500 > Z)  ALLOCATE(TSF%T500(TSF%N500+ONE), SOURCE=inf)
        !
        !ALLOCATE(CHARACTER(75)::TSF%LINE)
        !
        CALL TSF%FL%READ(TSF%LINE) !MOVE TO FIRST LOCATION
        !
        !CHECK IF MONTH/DAY TIME INPUT
        !
        LLOC = ONE
        CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%PREV%DATE, ONLY_DYEAR=TRUE, MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
        TSF%MONTHDAY = TSF%PREV%DATE%MONTH_DAY
        !
        ! CHECK FOR CONTIGUOUS INPUT
        !
        DO ISTART=TWO, TSF%N !ALREADY LOADED FIRST LINE
            CALL TSF%FL%READ(TSF%LINE,CNT=ISTOP,EOF=EOF,NOSHIFT=TRUE)
            !CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,IOUT,CNT=ISTOP,EOF=EOF,NOSHIFT=TRUE)
            IF(EOF .OR. ISTOP > ONE) THEN
                CALL STOP_ERROR( LINE=TSF%LINE, INFILE=TSF%FL%IU, OUTPUT=IOUT, &
                                           MSG= 'TIME SERIES INPUT ERROR: NO COMMENTS OR BLANK LINES ARE ALLOWED WITHIN THE TIME SERIES DATA.'//NL//      &
                                                'THEY ARE ALLOWED AT THE TOP OF A TIME SERIES FILE BEFORE THE FIRST DATA ENTRY (e.g. TIME DATA),'//NL//   &
                                                'AFTER THE LAST DATA ENTRY AND TO THE RIGHT OF A DATA ENTRY.'//BLN//                                      &
                                                'THE FOLLOWING IS AN AN EXAMPLE OF WHAT IS ALLOWED:'//BLN//REPEAT('-',50)//NL//                         &
                                                '# COMMENT '//NL//'   '//NL//'  # START OF DATA'//NL//'12/31/1999  1.0'//NL//                             &
                                                '1/1/2000  2.0   # Y2K'//NL//'1/5/2000  2.00   # Comment'//NL//'  '//NL//                                 &
                                                '# end of data input'//NL//' '//NL//'#comment'//NL//REPEAT('-',50)//BLN//                                                     &
                                                'THE FOLLOWING IS AN EXAMPLE OF WHAT WILL NOT WORK DUE TO BAD COMMENT AND BAD BLANK LINE LOCATION:'//BLN//REPEAT('-',50)//NL//  &
                                                '# START OF DATA'//NL//'12/31/1999  1.0'//NL//'# BAD COMMENT LOCATION'//NL//'2000  2.0   # Y2K'//NL//'  '//NL//'1/5/2000  2.00'//NL//REPEAT('-',50) ) 
            END IF
        END DO
        !
        ! CHECK FOR DATES IN PROPERT SEQUENCE
        !
        CALL TSF%FL%REWIND()
        !
        ! CHECK FOR CONTIGUOUS INPUT AND SET UP N500 POINTERS
        !
        CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,IOUT)
        LLOC = ONE
        CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%PREV%DATE, ONLY_DYEAR=TRUE, MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
        !
        K = ONE
        DO I = TWO, TSF%N !ALREADY LOADED FIRST LINE
            CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,IOUT)
            LLOC = ONE
            CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%CUR%DATE, ONLY_DYEAR=TRUE, MSG='FAILED TO LOAD THE TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE ON THE AFORMENTIONED LINE. PLEASE CHECK THE DATE FORMAT.')
            !
            IF(TSF%CUR%DATE < TSF%PREV%DATE) THEN
                CALL STOP_ERROR( LINE=TSF%LINE, INFILE=TSF%FL%IU, OUTPUT=IOUT, MSG= 'TIME SERIES INPUT ERROR: THE TIME COLUMN (FIRST COLUMN) MUST BE IN CHRONOLOGICAL ORDER.'//NL//'THE PRESENTED ERROR LINE CONTAINS A DATE THAT IS EARLIAR THEN THE PREVIOUS LINE.'//NL//'IF ONLY USING MONTH AND DAY OR DECIMAL YEAR, THEN THOSE MUST BE IN CHRONOLOGICAL ORDER TOO!.') 
            END IF
            !
            IF(I > 499) THEN
                !
                IF(MOD(I, QUIN) == Z) THEN
                      TSF%T500(K) = TSF%CUR%DATE%DYEAR
                      K = K + ONE
                END IF
            END IF
            !
            TSF%TMP  => TSF%PREV
            !
            TSF%PREV => TSF%CUR
            TSF%CUR  => TSF%TMP
            !
            TSF%TMP  => NULL()
            !
        END DO
        !
        CALL MOVE_TO_START_OF_FILE(TSF)
        !
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_CONSTANT_VALUE(TSF, VALUE)
    CLASS(TIME_SERIES_FILE),  INTENT(INOUT):: TSF
    DOUBLE PRECISION, INTENT(IN):: VALUE
    !
    TSF%OPT  = NINER   !CONSTANT VALUE Option
    TSF%N    = THREE
    TSF%P    = THREE
    TSF%N500 = Z
    !
    TSF%MONTHDAY = FALSE
    TSF%AT_NEXT  = TRUE
    !
    TSF%PREV%TIM = ninf * HALF
    TSF%CUR %TIM =  inf * HALF
    TSF%NEXT%TIM =  inf * HALF
    !
    TSF%PREV%DAT = VALUE
    TSF%CUR %DAT = VALUE
    TSF%NEXT%DAT = VALUE
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_OPTION(TSF, OPT)
    CLASS(TIME_SERIES_FILE),  INTENT(INOUT):: TSF
    INTEGER, INTENT(IN):: OPT
    IF(TSF%OPT > Z) TSF%OPT = OPT  !FILE IS CONSTANT VALUE SO CANNOT OFFER OTHER OPTIONS
  END SUBROUTINE
  !
  SUBROUTINE GET_N_SET_OPTION(TSF, LINE, LLOC, ISTART, ISTOP, IN, CONST, DEFAULT_OPT)
    CLASS(TIME_SERIES_FILE),  INTENT(INOUT):: TSF
    CHARACTER(*),             INTENT(IN   ):: LINE
    INTEGER,                  INTENT(INOUT):: LLOC, ISTART, ISTOP
    INTEGER,         OPTIONAL,INTENT(IN   ):: IN
    DOUBLE PRECISION,OPTIONAL,INTENT(INOUT):: CONST
    CHARACTER(*),    OPTIONAL,INTENT(IN   ):: DEFAULT_OPT !IF NO KEYWORD OPTION IS FOUND THIS STRING WILL BE PARSED
    INTEGER:: N
    !
    CALL GET_OPTION(TSF, LINE, LLOC, ISTART, ISTOP, TSF%OPT, CONST)
    !CALL SET_OPTION(TSF, OPT)
    !
    IF(TSF%OPT == -2) CALL STOP_ERROR( LINE=LINE, INFILE=IN, OUTPUT=TSF%IOUT, MSG= 'TIME SERIES INPUT ERROR: FOUND KEYWORD "CONSTANT" FOR TIME SERIES FILE,'//NL//'BUT THIS INPUT THAT USES TIME SERIES FILES DOES NOT SUPPORT THE COSTANT OPTION.'//NL//'PLEASE CHOOSE ONE OF THE FOLLOWING KEYWORDS: '//NL//'INTERPOLATE'//NL//'STEP_FUNCTION'//NL//'NEXT_VALUE'//NL//'NEAREST'//NL//'TIME_MEAN'//NL//'MAX'//NL//'MIN'//NL//'SUM'//NL//'DAY_SUM'//NL//'TIME_MEAN_LOOK_BACK'//NL//'SKIP'//NL//'BEFORE SPECIFYING THE FILE LOCATION/NAME.') 
    !
    IF(TSF%OPT == -3) THEN     !OPTION NOT RECOGNIZED CHECK IF DEFAULT_OPT IS PROVIDED
        TSF%OPT = -2
        N = ONE
        IF(PRESENT(DEFAULT_OPT)) CALL GET_OPTION(TSF, DEFAULT_OPT, N, ISTART, ISTOP, TSF%OPT)
    END IF
    !
    IF(TSF%OPT == -2) CALL STOP_ERROR( LINE=LINE, INFILE=IN, OUTPUT=TSF%IOUT, MSG= 'TIME SERIES INPUT ERROR: FAILED TO IDENTIFY KEYWORD THAT DETERMINES HOW TO INTERPRET TIME SERIES DATA.'//NL//'THE FOLLOWING ARE ACCEPTIBLE KEYWORDS THAT MUST APPEAR BEFORE THE GENERIC_INPUT_FILE LOCATION:'//NL//'INTERPOLATE'//NL//'STEP_FUNCTION'//NL//'NEXT_VALUE'//NL//'NEAREST'//NL//'TIME_MEAN'//NL//'MAX'//NL//'MIN'//NL//'SUM'//NL//'DAY_SUM'//NL//'TIME_MEAN_LOOK_BACK'//NL//'SKIP'//NL//'and the keyword CONSTANT followed single number') 
    !
  END SUBROUTINE
  !
  SUBROUTINE GET_OPTION(TSF, LINE, LLOC, ISTART, ISTOP, OPT, CONST)
    CLASS(TIME_SERIES_FILE),  INTENT(IN   ):: TSF
    CHARACTER(*),             INTENT(IN   ):: LINE
    INTEGER,                  INTENT(INOUT):: LLOC, ISTART, ISTOP
    INTEGER,         OPTIONAL,INTENT(INOUT):: OPT
    DOUBLE PRECISION,OPTIONAL,INTENT(INOUT):: CONST
    CHARACTER(:), ALLOCATABLE:: WORD
    INTEGER:: N
    !
    N = LLOC
    CALL GET_WORD(LINE,LLOC,ISTART,ISTOP,WORD,IS_ALLOC=TRUE,COM_STOP=TRUE)
    !
    SELECT CASE(WORD)
    CASE('INTERP','INTERPOLATE'   ); OPT = Z
    CASE('STEP','STEP_FUNCTION'   ); OPT = ONE
    CASE('NEXT','NEXT_VALUE'      ); OPT = TWO
    CASE('NEAR','NEAREST'         ); OPT = THREE
    CASE('TIME_MEAN'              ); OPT = TEN
    CASE('MAX'                    ); OPT = 11
    CASE('MIN'                    ); OPT = 12
    CASE('SUM'                    ); OPT = 13
    CASE('DAY_SUM'                ); OPT = 14
    CASE('TIME_MEAN_LOOK_BACK'    ); OPT = 15  !NOT COMPLETE
    CASE('SKIP','NAN','NULL','NUL'); OPT = NEG
    CASE('CONSTANT')
                                     OPT = NINER
                                     IF(PRESENT(CONST)) THEN
                                         CALL GET_NUMBER(LINE,LLOC,ISTART,ISTOP,TSF%IOUT,Z,CONST,MSG='FAILED TO LOAD CONSTANT VALUE AFTER KEYWORD "CONSTANT".')
                                     ELSE
                                         OPT = -2
                                     END IF
    CASE DEFAULT
                                     OPT  = -3  !DID NOT IDENTIFY NAME
                                     LLOC = N
    END SELECT 
    !
    DEALLOCATE(WORD)
  END SUBROUTINE
  !
  PURE FUNCTION PRINT_OPTION(TSF,OPT) RESULT (WORD)
    CLASS(TIME_SERIES_FILE),  INTENT(IN):: TSF
    INTEGER,         OPTIONAL,INTENT(IN):: OPT
    CHARACTER(:), ALLOCATABLE:: WORD
    INTEGER:: OP
    !
    IF(PRESENT(OPT)) THEN
        OP = OPT
    ELSE
        OP = TSF%OPT
    END IF
    !
    SELECT CASE(OP)
    CASE(Z    ); WORD = 'INTERPOLATE'   
    CASE(ONE  ); WORD = 'STEP_FUNCTION' 
    CASE(TWO  ); WORD = 'NEXT_VALUE'    
    CASE(THREE); WORD = 'NEAREST'       
    CASE(TEN  ); WORD = 'TIME_MEAN'   
    CASE(11   ); WORD = 'MAX'           
    CASE(12   ); WORD = 'MIN'           
    CASE(13   ); WORD = 'SUM'
    CASE(14   ); WORD = 'DAY_SUM'
    CASE(15   ); WORD = 'TIME_MEAN_LOOK_BACK'  !NOT COMPLETE
    CASE(NINER); WORD = 'CONSTANT'
    CASE(NEG  ); WORD = 'SKIP'         
    CASE DEFAULT
                WORD = 'OPT_ERROR'
    END SELECT
    !
  END FUNCTION
  !
  SUBROUTINE LOOKUP_TIME_SERIES_VALUE_DATE(TSF, DATE, VALUE)
  CLASS(TIME_SERIES_FILE),      INTENT(INOUT):: TSF
  TYPE(DATE_OPERATOR),          INTENT(IN   ):: DATE
  DOUBLE PRECISION,             INTENT(  OUT):: VALUE
  !
  CALL LOOKUP_TIME_SERIES_VALUE_DYEAR(TSF, DATE%DYEAR, VALUE)
  !
  END SUBROUTINE
  !
  SUBROUTINE LOOKUP_TIME_SERIES_VALUE_DATE_DATE(TSF, DATE, VALUE, DATE0)
  CLASS(TIME_SERIES_FILE),      INTENT(INOUT):: TSF
  TYPE(DATE_OPERATOR),          INTENT(IN   ):: DATE
  DOUBLE PRECISION,             INTENT(  OUT):: VALUE
  TYPE(DATE_OPERATOR),          INTENT(IN   ):: DATE0
  !
  CALL LOOKUP_TIME_SERIES_VALUE_DYEAR(TSF, DATE%DYEAR, VALUE, DATE0%DYEAR)
  !
  END SUBROUTINE
  !
  SUBROUTINE LOOKUP_TIME_SERIES_VALUE_DYEAR(TSF, TIME, VALUE, TIME0)
  CLASS(TIME_SERIES_FILE),  INTENT(INOUT):: TSF
  DOUBLE PRECISION,         INTENT(IN   ):: TIME
  DOUBLE PRECISION,         INTENT(  OUT):: VALUE
  DOUBLE PRECISION,OPTIONAL,INTENT(IN   ):: TIME0
  INTEGER:: OPT
  !
  IF(TSF%OPT < Z) THEN !CONSTANT VALUE
      !
      VALUE = TSF%PREV%DAT
  ELSE
      OPT = TSF%OPT
      IF(OPT >= TEN .AND. .NOT. PRESENT(TIME0))  OPT = ONE
      IF(OPT >= TEN) THEN
          IF(ABS(TIME - TIME0) < YEARTOL_5    )  OPT = ONE !WITHIN 5 SECONDS OF EACH OTHER
      END IF
      !
      
      IF(OPT < TEN) THEN
          ! MOVE WINDOW TO CORRECT LOCATION
          IF(TSF%MONTHDAY) THEN
              CALL MOVE_MONTHDAY_WINDOW_TO(TSF, TIME) 
          ELSE
              CALL MOVE_TIME_WINDOW_TO(TSF, TIME) 
          END IF
          !
          IF    (ABS(TIME - TSF%PREV%TIM) < YEARTOL_5) THEN; VALUE = TSF%PREV%DAT  !WITHIN 5 SECONDS OF REQUESTED TIME
          ELSEIF(ABS(TIME - TSF%CUR%TIM ) < YEARTOL_5) THEN; VALUE = TSF%CUR %DAT
          ELSEIF(ABS(TIME - TSF%NEXT%TIM) < YEARTOL_5) THEN; VALUE = TSF%NEXT%DAT
          ELSEIF(TIME < TSF%CUR%TIM ) THEN
                                       CALL INTERP(TSF%OPT, TSF%PREV%TIM, TSF%PREV%DAT, TSF%CUR%TIM, TSF%CUR%DAT,  TIME, VALUE)
          ELSE
                                       CALL INTERP(TSF%OPT, TSF%CUR%TIM,  TSF%CUR%DAT, TSF%NEXT%TIM, TSF%NEXT%DAT, TIME, VALUE)
          END IF
      ELSE
          SELECT CASE(OPT)
          CASE(TEN);       CALL TIME_MEAN(   TSF, TIME0, TIME, VALUE)
          CASE(11);        CALL TIME_MAX(    TSF, TIME0, TIME, VALUE)
          CASE(12);        CALL TIME_MIN(    TSF, TIME0, TIME, VALUE)
          CASE(13);        CALL INTERVAL_SUM(TSF, TIME0, TIME, VALUE)
          CASE(14);        CALL TIME_SUM(    TSF, TIME0, TIME, VALUE)
          END SELECT
      END IF
  END IF
  !
  IF(TSF%FL%SCALE.NE.UNO) VALUE = VALUE*TSF%FL%SCALE
  !
  END SUBROUTINE
  !
  PURE SUBROUTINE INTERP(OPT, TIM1, VAL1, TIM2, VAL2, TIM, VAL)
    INTEGER,          INTENT(IN   ):: OPT
    DOUBLE PRECISION, INTENT(IN   ):: TIM1, VAL1, TIM2, VAL2, TIM
    DOUBLE PRECISION, INTENT(  OUT):: VAL
    !
    ! OPT = 0 INTERPOLATE
    ! OPT = 1 STEP_FUNCTION
    ! OPT = 2 NEAREST VALUE
    !
    IF(OPT==Z) THEN !INTERPOLATE
        !
        VAL = VAL1 + (TIM - TIM1) * (VAL2-VAL1) / (TIM2-TIM1)
        !
    ELSEIF(TIM <= TIM1) THEN
        !
        VAL = VAL1
        !
    ELSEIF( TIM >= TIM2 ) THEN
        !
        VAL = VAL2
        !
    ELSEIF(OPT==ONE) THEN !STEP_FUNCTION
        !
        VAL = VAL1
        !
    ELSEIF(OPT==TWO) THEN !NEXT_VALUE
        !
        VAL = VAL2
        !
    ELSEIF(OPT==THREE) THEN !NEAREST DATUE
        !
        IF( TIM - TIM1 > TIM2 - TIM) THEN  !CLOSE RTO TIM2 IF TIM2-TIM IS SMALLER
            VAL = VAL2
        ELSE
            VAL = VAL1
        END IF
        !
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_MONTHDAY(TSF, YR)
    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
    INTEGER,        INTENT(IN   ):: YR
    !
    !
    SELECT CASE(TSF%MD_FLAG)
    CASE(Z)                                 !Within File, Normal Operation
          CALL TSF%PREV%DATE%SET_YEAR(YR)
          CALL TSF%CUR %DATE%SET_YEAR(YR)
          CALL TSF%NEXT%DATE%SET_YEAR(YR)
    CASE(ONE)                               ! PREV-CUR stradles EOF
          CALL TSF%PREV%DATE%SET_YEAR(YR    )
          CALL TSF%CUR %DATE%SET_YEAR(YR+ONE)
          CALL TSF%NEXT%DATE%SET_YEAR(YR+ONE)
    CASE(TWO)                               ! CUR-NEXT stradles EOF
          CALL TSF%PREV%DATE%SET_YEAR(YR    )
          CALL TSF%CUR %DATE%SET_YEAR(YR    )
          CALL TSF%NEXT%DATE%SET_YEAR(YR+ONE)
    END SELECT
    !
    TSF%CUR%TIM = TSF%CUR%DATE%DYEAR 
    TSF%PREV%TIM = TSF%PREV%DATE%DYEAR 
    TSF%NEXT%TIM = TSF%NEXT%DATE%DYEAR
    !
  END SUBROUTINE
  !
  SUBROUTINE TIME_MEAN(TSF, TIME0, TIME1, VAL)
    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
    DOUBLE PRECISION,TARGET, INTENT(IN   ):: TIME0, TIME1
    DOUBLE PRECISION,        INTENT(  OUT):: VAL
    DOUBLE PRECISION:: DELT, DT
    DOUBLE PRECISION, POINTER:: TIM0, TIM1
    INTEGER:: YR
    LOGICAL:: EOF
    !
    IF (TIME0 > TIME1) THEN
        TIM0  => TIME1
        TIM1  => TIME0
    ELSE
        TIM0  => TIME0
        TIM1  => TIME1
    END IF
    !
    IF(INT(TIM0) .NE. INT(TIM1) ) THEN  !TIME FRAME SPANS MULTIPLE YEARS SO NEED TO TAKE INTO ACCOUNT LEAP YEARS --NOTE DELT IS IN DAYS
          !
          CALL TIME_SUM(TSF, TIM0, TIM1, VAL, DELT)
          !
    ELSE
          ! USE DECIMAL YEARS AS WEIGHTING FUNCTION SINCE TIME FRAME IS WITHIN THE SAME YEAR
          !
          ! MOVE WINDOW TO CORRECT LOCATION
          !
          IF(TSF%MONTHDAY) THEN
              CALL MOVE_MONTHDAY_WINDOW_TO(TSF, TIM0)
              YR = INT(TSF%NEXT%TIM)
          ELSE
              CALL MOVE_TIME_WINDOW_TO(TSF, TIM0) 
          END IF
          !
          DELT = DZ
          VAL  = DZ
          IF    (TIM1 < TSF%CUR%TIM) THEN
                                     DT   = TIM1 - TIM0
                                     VAL  = VAL + (TSF%PREV%DAT*DT)
                                     DELT = DELT + DT
                                     EOF  = TRUE
          ELSEIF(TIM0 < TSF%CUR%TIM) THEN
                                     DT   = TSF%CUR%TIM - TIM0
                                     VAL  = VAL + (TSF%PREV%DAT*DT)
                                     DELT = DELT + DT
                                     !
                                     IF(TIM1 < TSF%NEXT%TIM) THEN
                                         DT   = TIM1 - TSF%CUR%TIM
                                         VAL  = VAL + (TSF%CUR%DAT*DT)
                                         DELT = DELT + DT
                                         EOF  = TRUE
                                     ELSE
                                         EOF = FALSE
                                     END IF
          ELSEIF(TIM1 < TSF%NEXT%TIM) THEN
                                     DT   = TIM1 - TIM0
                                     VAL  = VAL + (TSF%CUR%DAT*DT)
                                     DELT = DELT + DT
                                     EOF  = TRUE
          ELSE
                                     DT   = TSF%NEXT%TIM - TIM0
                                     VAL  = VAL + (TSF%CUR%DAT*DT)
                                     DELT = DELT + DT
                                     IF(TSF%MONTHDAY) THEN
                                         CALL READ_NEXT_ROW_MONTHDAY(TSF)
                                     ELSE
                                         CALL READ_NEXT_ROW(TSF, EOF)
                                     END IF
                                     EOF  = FALSE
          END IF
          !
          DO WHILE (.NOT. EOF) 
                                     IF(TIM1 < TSF%NEXT%TIM) THEN
                                         DT   = TIM1 - TSF%CUR%TIM
                                         VAL  = VAL + (TSF%CUR%DAT*DT)
                                         DELT = DELT + DT
                                         EOF  = TRUE
                                     ELSE
                                         DT   = TSF%NEXT%TIM - TSF%CUR%TIM
                                         VAL  = VAL + (TSF%CUR%DAT*DT)
                                         DELT = DELT + DT
                                         IF(TSF%MONTHDAY) THEN
                                             CALL READ_NEXT_ROW_MONTHDAY(TSF)
                                         ELSE
                                             CALL READ_NEXT_ROW(TSF, EOF)
                                         END IF
                                     END IF
          END DO
          !
          IF(TIM1 > TSF%NEXT%TIM) THEN
              IF(.NOT. TSF%MONTHDAY) THEN
                                         DT   = TIM1 - TSF%NEXT%TIM
                                         VAL  = VAL + (TSF%NEXT%DAT*DT)
                                         DELT = DELT + DT
              ELSE
                    DO WHILE(TIM1 > TSF%NEXT%TIM)
                        YR = YR + ONE
                        CALL MOVE_TO_START_OF_FILE(TSF)
                        CALL SET_MONTHDAY(TSF, YR) !SET PREV, CUR, NEXT TO MONTH DAY YEAR
                        !
                        IF(TIM1 < TSF%CUR%TIM) THEN
                                     DT   = TIM1 - TSF%PREV%TIM
                                     VAL  = VAL + (TSF%PREV%DAT*DT)
                                     DELT = DELT + DT
                                     EXIT
                        ELSE
                                     DT   = TSF%CUR%TIM - TSF%PREV%TIM
                                     VAL  = VAL + (TSF%PREV%DAT*DT)
                                     DELT = DELT + DT
                        END IF
                        !
                        IF(TIM1 < TSF%NEXT%TIM) THEN
                            DT   = TIM1 - TSF%CUR%TIM
                            VAL  = VAL + (TSF%CUR%DAT*DT)
                            DELT = DELT + DT
                            EXIT
                        ELSE
                            EOF = FALSE
                            DO WHILE (.NOT. EOF) 
                                     IF(TIM1 < TSF%NEXT%TIM) THEN
                                         DT   = TIM1 - TSF%CUR%TIM
                                         VAL  = VAL + (TSF%CUR%DAT*DT)
                                         DELT = DELT + DT
                                         EOF  = TRUE
                                     ELSE
                                         DT   = TSF%NEXT%TIM - TSF%CUR%TIM
                                         VAL  = VAL + (TSF%CUR%DAT*DT)
                                         DELT = DELT + DT
                                         CALL READ_NEXT_ROW_MONTHDAY(TSF)
                                     END IF
                            END DO
                        END IF
                    END DO
              END IF
          END IF
    END IF
    !
    IF (DELT > NEARZERO_29) THEN
        VAL = VAL/DELT
    ELSE
        VAL = DZ
    END IF
    !
    NULLIFY(TIM0, TIM1)
    !
  END SUBROUTINE
  !
  SUBROUTINE INTERVAL_SUM(TSF, TIME0, TIME1, VAL)
    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
    DOUBLE PRECISION,TARGET, INTENT(IN   ):: TIME0, TIME1
    DOUBLE PRECISION,        INTENT(  OUT):: VAL
    DOUBLE PRECISION, POINTER:: TIM0, TIM1
    INTEGER:: YR
    LOGICAL:: EOF
    !
    IF (TIME0 > TIME1) THEN
        TIM0  => TIME1
        TIM1  => TIME0
    ELSE
        TIM0  => TIME0
        TIM1  => TIME1
    END IF
    !
    ! MOVE WINDOW TO CORRECT LOCATION
    !
    IF(TSF%MONTHDAY) THEN
        CALL MOVE_MONTHDAY_WINDOW_TO(TSF, TIM0)
        YR = INT(TSF%NEXT%TIM)
    ELSE
        CALL MOVE_TIME_WINDOW_TO(TSF, TIM0) 
    END IF
    !
    VAL  = DZ
    IF    (TIM1 < TSF%CUR%TIM) THEN
                               VAL  = VAL + TSF%PREV%DAT
                               EOF  = TRUE
    ELSEIF(TIM0 < TSF%CUR%TIM) THEN
                               VAL  = VAL + TSF%PREV%DAT
                               !
                               IF(TIM1 < TSF%NEXT%TIM) THEN
                                   VAL  = VAL + TSF%CUR%DAT
                                   EOF  = TRUE
                               ELSE
                                   EOF = FALSE
                               END IF
    ELSEIF(TIM1 < TSF%NEXT%TIM) THEN
                               VAL  = VAL + TSF%CUR%DAT
                               EOF  = TRUE
    ELSE
                               VAL  = VAL + TSF%CUR%DAT
                               IF(TSF%MONTHDAY) THEN
                                   CALL READ_NEXT_ROW_MONTHDAY(TSF)
                               ELSE
                                   CALL READ_NEXT_ROW(TSF, EOF)
                               END IF
                               EOF  = FALSE
    END IF
    !
    DO WHILE (.NOT. EOF) 
                               IF(TIM1 < TSF%NEXT%TIM) THEN
                                   VAL  = VAL + TSF%CUR%DAT
                                   EOF  = TRUE
                               ELSE
                                   VAL  = VAL + TSF%CUR%DAT
                                   IF(TSF%MONTHDAY) THEN
                                       CALL READ_NEXT_ROW_MONTHDAY(TSF)
                                   ELSE
                                       CALL READ_NEXT_ROW(TSF, EOF)
                                   END IF
                               END IF
    END DO
    !
    IF(TIM1 > TSF%NEXT%TIM) THEN
        IF(.NOT. TSF%MONTHDAY) THEN
                                   VAL  = VAL + TSF%NEXT%DAT
        ELSE
              DO WHILE(TIM1 > TSF%NEXT%TIM)
                  YR = YR + ONE
                  CALL MOVE_TO_START_OF_FILE(TSF)
                  CALL SET_MONTHDAY(TSF, YR) !SET PREV, CUR, NEXT TO MONTH DAY YEAR
                  !
                  IF(TIM1 < TSF%CUR%TIM) THEN
                               VAL  = VAL + TSF%PREV%DAT
                               EXIT
                  ELSE
                               VAL  = VAL + TSF%PREV%DAT
                  END IF
                  !
                  VAL  = VAL + TSF%CUR%DAT
                  IF(TIM1 < TSF%NEXT%TIM) THEN
                      EXIT
                  ELSE
                      CALL READ_NEXT_ROW_MONTHDAY(TSF)
                      DO WHILE (.NOT. EOF) 
                               VAL  = VAL + TSF%CUR%DAT
                               IF(TIM1 < TSF%NEXT%TIM) THEN
                                   EOF  = TRUE
                               ELSE
                                   CALL READ_NEXT_ROW_MONTHDAY(TSF)
                               END IF
                      END DO
                  END IF
              END DO
        END IF
    END IF
    !
    NULLIFY(TIM0, TIM1)
    !
  END SUBROUTINE
  !
  SUBROUTINE TIME_SUM(TSF, TIME0, TIME1, VAL, DAY_DELT)
    CLASS(TIME_SERIES_FILE),    INTENT(INOUT):: TSF
    DOUBLE PRECISION, TARGET,   INTENT(IN   ):: TIME0, TIME1
    DOUBLE PRECISION,           INTENT(  OUT):: VAL
    DOUBLE PRECISION, OPTIONAL, INTENT(  OUT):: DAY_DELT
    DOUBLE PRECISION, POINTER:: TIM0, TIM1
    DOUBLE PRECISION:: DELT, DT
    TYPE(DATE_OPERATOR):: DT0,DT1
    INTEGER:: YR
    LOGICAL:: EOF
    !
    IF (TIME0 > TIME1) THEN
        TIM0  => TIME1
        TIM1  => TIME0
    ELSE
        TIM0  => TIME0
        TIM1  => TIME1
    END IF
    !
    ! MOVE WINDOW TO CORRECT LOCATION
    !
    IF(TSF%MONTHDAY) THEN
        CALL MOVE_MONTHDAY_WINDOW_TO(TSF, TIM0)
        YR = INT(TSF%NEXT%TIM)
    ELSE
        CALL MOVE_TIME_WINDOW_TO(TSF, TIM0) 
        !
        CALL TSF%CUR %DATE%DYEAR_MAKE_DATE() !IN CASE DATE WAS NOT STORED FOR SPEED PURPOSES
        CALL TSF%NEXT%DATE%DYEAR_MAKE_DATE()
    END IF
    !
    CALL DT0%INIT_DYEAR(TIM0)
    CALL DT1%INIT_DYEAR(TIM1)
    !
    DELT = DZ
    VAL  = DZ
    IF    (TIM1 < TSF%CUR%TIM) THEN
                               DT   = DT1 - DT0
                               VAL  = VAL + (TSF%PREV%DAT*DT)
                               DELT = DELT + DT
                               EOF  = TRUE
    ELSEIF(TIM0 < TSF%CUR%TIM) THEN
                               DT   = TSF%CUR%DATE - DT0
                               VAL  = VAL + (TSF%PREV%DAT*DT)
                               DELT = DELT + DT
                               !
                               IF(TIM1 < TSF%NEXT%TIM) THEN
                                   DT   = DT1 - TSF%CUR%DATE
                                   VAL  = VAL + (TSF%CUR%DAT*DT)
                                   DELT = DELT + DT
                                   EOF  = TRUE
                               ELSE
                                   EOF = FALSE
                               END IF
    ELSEIF(TIM1 < TSF%NEXT%TIM) THEN
                               DT   = DT1 - DT0
                               VAL  = VAL + (TSF%CUR%DAT*DT)
                               DELT = DELT + DT
                               EOF  = TRUE
    ELSE
                               DT   = TSF%NEXT%DATE - DT0
                               VAL  = VAL + (TSF%CUR%DAT*DT)
                               DELT = DELT + DT
                               IF(TSF%MONTHDAY) THEN
                                   CALL READ_NEXT_ROW_MONTHDAY(TSF)
                               ELSE
                                   CALL READ_NEXT_ROW(TSF, EOF)
                                   CALL TSF%NEXT%DATE%DYEAR_MAKE_DATE()
                               END IF
                               EOF  = FALSE
    END IF
    !
    DO WHILE (.NOT. EOF) 
                               IF(TIM1 < TSF%NEXT%TIM) THEN
                                   DT   = DT1 - TSF%CUR%DATE
                                   VAL  = VAL + (TSF%CUR%DAT*DT)
                                   DELT = DELT + DT
                                   EOF  = TRUE
                               ELSE
                                   DT   = TSF%NEXT%DATE - TSF%CUR%DATE
                                   VAL  = VAL + (TSF%CUR%DAT*DT)
                                   DELT = DELT + DT
                                   IF(TSF%MONTHDAY) THEN
                                       CALL READ_NEXT_ROW_MONTHDAY(TSF)
                                   ELSE
                                       CALL READ_NEXT_ROW(TSF, EOF)
                                       CALL TSF%NEXT%DATE%DYEAR_MAKE_DATE()
                                   END IF
                               END IF
    END DO
    !
    IF(TIM1 > TSF%NEXT%TIM) THEN
        IF(.NOT. TSF%MONTHDAY) THEN
                                   DT   = DT1 - TSF%NEXT%DATE
                                   VAL  = VAL + (TSF%NEXT%DAT*DT)
                                   DELT = DELT + DT
        ELSE
              DO WHILE(TIM1 > TSF%NEXT%TIM)
                  YR = YR + ONE
                  CALL MOVE_TO_START_OF_FILE(TSF)
                  CALL SET_MONTHDAY(TSF, YR) !SET PREV, CUR, NEXT TO MONTH DAY YEAR
                  CALL TSF%CUR %DATE%DYEAR_MAKE_DATE() !IN CASE DATE WAS NOT STORED FOR SPEED PURPOSES
                  CALL TSF%NEXT%DATE%DYEAR_MAKE_DATE()
                  !
                  IF(TIM1 < TSF%CUR%TIM) THEN
                               DT   = DT1 - TSF%PREV%DATE
                               VAL  = VAL + (TSF%PREV%DAT*DT)
                               DELT = DELT + DT
                               EXIT
                  ELSE
                               DT   = TSF%CUR%DATE - TSF%PREV%DATE
                               VAL  = VAL + (TSF%PREV%DAT*DT)
                               DELT = DELT + DT
                  END IF
                  !
                  IF(TIM1 < TSF%NEXT%TIM) THEN
                      DT   = DT1 - TSF%CUR%DATE
                      VAL  = VAL + (TSF%CUR%DAT*DT)
                      DELT = DELT + DT
                      EXIT
                  ELSE
                      EOF = FALSE
                      DO WHILE (.NOT. EOF) 
                               IF(TIM1 < TSF%NEXT%TIM) THEN
                                   DT   = DT1 - TSF%CUR%DATE
                                   VAL  = VAL + (TSF%CUR%DAT*DT)
                                   DELT = DELT + DT
                                   EOF  = TRUE
                               ELSE
                                   DT   = TSF%NEXT%DATE - TSF%CUR%DATE
                                   VAL  = VAL + (TSF%CUR%DAT*DT)
                                   DELT = DELT + DT
                                   CALL READ_NEXT_ROW_MONTHDAY(TSF)
                               END IF
                      END DO
                  END IF
              END DO
        END IF
    END IF
    !
    IF(PRESENT(DAY_DELT)) DAY_DELT = DELT
    !
    NULLIFY(TIM0, TIM1)
    !
  END SUBROUTINE
  !
  !SUBROUTINE TIME_SUM(TSF, TIM0, TIM1, VAL, TMULT)
  !  CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
  !  DOUBLE PRECISION,        INTENT(IN   ):: TIM0, TIM1
  !  DOUBLE PRECISION,        INTENT(  OUT):: VAL
  !  LOGICAL,                 INTENT(IN   ):: TMULT
  !  DOUBLE PRECISION:: DT
  !  LOGICAL:: EOF
  !  !
  !  ! MOVE WINDOW TO CORRECT LOCATION
  !  !
  !  CALL MOVE_TIME_WINDOW_TO(TSF, TIM0)
  !  !
  !  DT   = UNO
  !  VAL  = DZ
  !  IF(TIM0 < TSF%CUR%TIM) THEN
  !                             IF(TMULT) DT = TSF%CUR%TIM - TIM0
  !                             VAL  = VAL + (TSF%PREV%DAT*DT)
  !                             !
  !                             IF(TIM1 < TSF%NEXT%TIM) THEN
  !                                 IF(TMULT) DT = TIM1 - TSF%CUR%TIM
  !                                 VAL  = VAL + (TSF%CUR%DAT*DT)
  !                                 EOF  = TRUE
  !                             ELSE
  !                                 IF(TMULT) DT = TSF%NEXT%TIM - TSF%CUR%TIM
  !                                 VAL  = VAL + (TSF%CUR%DAT*DT)
  !                                 CALL READ_NEXT_ROW(TSF, EOF)
  !                             END IF
  !  ELSE
  !        EOF  = FALSE
  !  END IF
  !  !    
  !  DO WHILE (.NOT. EOF) 
  !                             IF(TIM1 < TSF%NEXT%TIM) THEN
  !                                 IF(TMULT) DT = TIM1 - TSF%CUR%TIM
  !                                 VAL  = VAL + (TSF%CUR%DAT*DT)
  !                                 EOF  = TRUE
  !                             ELSE
  !                                 IF(TMULT) DT = TSF%NEXT%TIM - TSF%CUR%TIM
  !                                 VAL  = VAL + (TSF%CUR%DAT*DT)
  !                                 CALL READ_NEXT_ROW(TSF, EOF)
  !                             END IF
  !  END DO
  !  !
  !  IF(TIM1 > TSF%NEXT%TIM) THEN
  !                                 IF(TMULT) DT = TIM1 - TSF%NEXT%TIM
  !                                 VAL  = VAL + (TSF%NEXT%DAT*DT)
  !  END IF
  !  !
  !END SUBROUTINE
  !
  SUBROUTINE TIME_MAX(TSF, TIM0, TIM1, VAL)
    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
    DOUBLE PRECISION,        INTENT(IN   ):: TIM0, TIM1
    DOUBLE PRECISION,        INTENT(  OUT):: VAL
    !
    CALL TIME_MAXMIN(TSF, TIM0, TIM1, VAL, TRUE)
    !
  END SUBROUTINE
  !
  SUBROUTINE TIME_MIN(TSF, TIM0, TIM1, VAL)
    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
    DOUBLE PRECISION,        INTENT(IN   ):: TIM0, TIM1
    DOUBLE PRECISION,        INTENT(  OUT):: VAL
    !
    CALL TIME_MAXMIN(TSF, TIM0, TIM1, VAL, FALSE)
    !
  END SUBROUTINE
  !
  SUBROUTINE TIME_MAXMIN(TSF, TIME0, TIME1, VAL, ISMAX)
    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
    DOUBLE PRECISION,TARGET, INTENT(IN   ):: TIME0, TIME1
    DOUBLE PRECISION,        INTENT(  OUT):: VAL
    LOGICAL,                 INTENT(IN   ):: ISMAX
    DOUBLE PRECISION, POINTER:: TIM0, TIM1
    INTEGER:: YR
    LOGICAL:: EOF
    !
    IF (TIME0 > TIME1) THEN
        TIM0  => TIME1
        TIM1  => TIME0
    ELSE
        TIM0  => TIME0
        TIM1  => TIME1
    END IF
    !
    ! MOVE WINDOW TO CORRECT LOCATION
    !
    IF(TSF%MONTHDAY) THEN
        CALL MOVE_MONTHDAY_WINDOW_TO(TSF, TIM0)
        YR = INT(TSF%NEXT%TIM)
    ELSE
        CALL MOVE_TIME_WINDOW_TO(TSF, TIM0) 
    END IF
    !
    !IF(ISMAX) THEN
    !              VAL  = ninf
    !ELSE
    !              VAL  = inf
    !END IF
    !
    IF    (TIM1 < TSF%CUR%TIM) THEN
                               VAL  = TSF%PREV%DAT
                               EOF  = TRUE
    ELSEIF(TIM0 < TSF%CUR%TIM) THEN
                               VAL  = TSF%PREV%DAT
                               !
                               IF(TIM1 < TSF%NEXT%TIM) THEN
                                   IF(ISMAX) THEN
                                                 IF(VAL < TSF%CUR%DAT ) VAL = TSF%CUR%DAT
                                   ELSE
                                                 IF(VAL > TSF%CUR%DAT ) VAL = TSF%CUR%DAT
                                   END IF
                                   EOF  = TRUE
                               ELSE
                                   EOF = FALSE
                               END IF
    ELSEIF(TIM1 < TSF%NEXT%TIM) THEN
                               VAL  = TSF%CUR%DAT
                               EOF  = TRUE
    ELSE
                               VAL  = TSF%CUR%DAT
                               IF(TSF%MONTHDAY) THEN
                                   CALL READ_NEXT_ROW_MONTHDAY(TSF)
                               ELSE
                                   CALL READ_NEXT_ROW(TSF, EOF)
                               END IF
                               EOF  = FALSE
    END IF
    !
    DO WHILE (.NOT. EOF)
                               IF(ISMAX) THEN
                                             IF(VAL < TSF%CUR%DAT ) VAL = TSF%CUR%DAT
                               ELSE
                                             IF(VAL > TSF%CUR%DAT ) VAL = TSF%CUR%DAT
                               END IF 
                               !
                               IF(TIM1 < TSF%NEXT%TIM) THEN
                                   EOF  = TRUE
                               ELSE
                                   IF(TSF%MONTHDAY) THEN
                                       CALL READ_NEXT_ROW_MONTHDAY(TSF)
                                   ELSE
                                       CALL READ_NEXT_ROW(TSF, EOF)
                                   END IF
                               END IF
    END DO
    !
    IF(TIM1 > TSF%NEXT%TIM) THEN
        IF(.NOT. TSF%MONTHDAY) THEN
                               IF(ISMAX) THEN
                                             IF(VAL < TSF%NEXT%DAT ) VAL = TSF%NEXT%DAT
                               ELSE
                                             IF(VAL > TSF%NEXT%DAT ) VAL = TSF%NEXT%DAT
                               END IF 
        ELSE
              DO WHILE(TIM1 > TSF%NEXT%TIM)
                  YR = YR + ONE
                  CALL MOVE_TO_START_OF_FILE(TSF)
                  CALL SET_MONTHDAY(TSF, YR) !SET PREV, CUR, NEXT TO MONTH DAY YEAR
                  !
                  IF(ISMAX) THEN
                                IF(VAL < TSF%PREV%DAT ) VAL = TSF%PREV%DAT
                  ELSE
                                IF(VAL > TSF%PREV%DAT ) VAL = TSF%PREV%DAT
                  END IF
                  !
                  IF(TIM1 < TSF%CUR%TIM)  EXIT
                  !
                  IF(ISMAX) THEN
                                IF(VAL < TSF%CUR%DAT ) VAL = TSF%CUR%DAT
                  ELSE
                                IF(VAL > TSF%CUR%DAT ) VAL = TSF%CUR%DAT
                  END IF 
                  !
                  IF(TIM1 < TSF%NEXT%TIM) THEN
                      EXIT
                  ELSE
                      CALL READ_NEXT_ROW_MONTHDAY(TSF)
                      DO WHILE (.NOT. EOF)
                               IF(ISMAX) THEN
                                             IF(VAL < TSF%CUR%DAT ) VAL = TSF%CUR%DAT
                               ELSE
                                             IF(VAL > TSF%CUR%DAT ) VAL = TSF%CUR%DAT
                               END IF  
                               IF(TIM1 < TSF%NEXT%TIM) THEN
                                   EOF  = TRUE
                               ELSE
                                   CALL READ_NEXT_ROW_MONTHDAY(TSF)
                               END IF
                      END DO
                  END IF
              END DO
        END IF
    END IF
    !
    NULLIFY(TIM0, TIM1)
    !
  END SUBROUTINE
    
!  SUBROUTINE TIME_MAXMIN(TSF, TIM0, TIM1, VAL, ISMAX)
!    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
!    DOUBLE PRECISION,        INTENT(IN   ):: TIM0, TIM1
!    DOUBLE PRECISION,        INTENT(  OUT):: VAL
!    LOGICAL,                 INTENT(IN   ):: ISMAX
!    INTEGER:: YR
!    LOGICAL:: EOF
!    !
!    ! MOVE WINDOW TO CORRECT LOCATION
!    !
!    IF(TSF%MONTHDAY) THEN
!        CALL MOVE_MONTHDAY_WINDOW_TO(TSF, TIM0) 
!    ELSE
!        CALL MOVE_TIME_WINDOW_TO(TSF, TIM0) 
!    END IF
!    !
!    IF(ISMAX) THEN
!                  VAL  = ninf
!    ELSE
!                  VAL  = inf
!    END IF
!    IF(TIM0 < TSF%CUR%TIM) THEN
!                               IF(ISMAX) THEN
!                                             IF(VAL < TSF%PREV%DAT) VAL = TSF%PREV%DAT
!                                             IF(VAL < TSF%CUR%DAT ) VAL = TSF%CUR%DAT
!                               ELSE
!                                             IF(VAL > TSF%PREV%DAT) VAL = TSF%PREV%DAT
!                                             IF(VAL > TSF%CUR%DAT ) VAL = TSF%CUR%DAT
!                               END IF
!                               !
!                               IF(TIM1 < TSF%NEXT%TIM) THEN
!                                   EOF  = TRUE
!                               ELSEIF(TSF%MONTHDAY) THEN
!                                       YR = INT(TSF%NEXT%TIM)
!                                       CALL READ_NEXT_ROW_MONTHDAY(TSF)
!                               ELSE
!                                       CALL READ_NEXT_ROW(TSF, EOF)
!                               END IF
!    ELSE
!                               EOF  = FALSE
!    END IF
!    !    
!    IF(TSF%MONTHDAY) YR = INT(TSF%NEXT%TIM)
!    DO WHILE (.NOT. EOF) 
!                               IF(ISMAX) THEN
!                                             IF(VAL < TSF%CUR%DAT ) VAL = TSF%CUR%DAT
!                               ELSE
!                                             IF(VAL > TSF%CUR%DAT ) VAL = TSF%CUR%DAT
!                               END IF
!                               !
!                               IF(TIM1 < TSF%NEXT%TIM) THEN
!                                   EOF  = TRUE
!                               ELSEIF(TSF%MONTHDAY) THEN
!                                       CALL READ_NEXT_ROW_MONTHDAY(TSF)
!                               ELSE
!                                       CALL READ_NEXT_ROW(TSF, EOF)
!                               END IF
!    END DO
!    !
!    IF(TIM1 > TSF%NEXT%TIM) THEN
!                               IF(ISMAX) THEN
!                                             IF(VAL < TSF%NEXT%DAT ) VAL = TSF%NEXT%DAT
!                               ELSE
!                                             IF(VAL > TSF%NEXT%DAT ) VAL = TSF%NEXT%DAT
!                               END IF
!    END IF
!    !
!  END SUBROUTINE
  !
  SUBROUTINE MOVE_TO_START_OF_FILE(TSF)
    CLASS(TIME_SERIES_FILE),  INTENT(INOUT):: TSF
    INTEGER:: LLOC, ISTART, ISTOP
    LOGICAL:: EOF
    !
    IF(TSF%N == Z) RETURN
    !
    CALL TSF%FL%REWIND()
    CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
    !
    ! GET FIRST ROW
    LLOC = ONE
    CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%PREV%DATE, ONLY_DYEAR=TRUE ,MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
    TSF%PREV%TIM = TSF%PREV%DATE%DYEAR
    !
    CALL GET_NUMBER(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%PREV%DAT,MSG='FAILED TO LOAD DATA/VALUE PART (SECOND NUMBER) OF THE TIME SERIES INPUT FILE.')
    !
    CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT,EOF=EOF)
    !
    ! GET SECOND ROW
    IF(EOF) THEN
        TSF%CUR%TIM  = TSF%PREV%TIM
        TSF%CUR%DAT  = TSF%PREV%DAT
    ELSE
        LLOC = ONE
        CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%CUR%DATE, ONLY_DYEAR=TRUE ,MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
        TSF%CUR%TIM = TSF%CUR%DATE%DYEAR
        !
        CALL GET_NUMBER(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%CUR%DAT,MSG='FAILED TO LOAD DATA/VALUE PART (SECOND NUMBER) OF THE TIME SERIES INPUT FILE.')
        !
        CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT,EOF=EOF)
    END IF
    !
    ! GET THIRD ROW
    IF(EOF) THEN
        TSF%NEXT%TIM = TSF%CUR%TIM
        TSF%NEXT%DAT = TSF%CUR%DAT
    ELSE
        LLOC = ONE
        CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%NEXT%DATE, ONLY_DYEAR=TRUE ,MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
        TSF%NEXT%TIM = TSF%NEXT%DATE%DYEAR
        !
        CALL GET_NUMBER(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%NEXT%DAT,MSG='FAILED TO LOAD DATA/VALUE PART (SECOND NUMBER) OF THE TIME SERIES INPUT FILE.')
    END IF
    !
    TSF%AT_NEXT   = TRUE
    TSF%P         = THREE              ! POSITION LOCATED AFTER ROW 3
    IF(EOF) TSF%N = THREE              ! NOW HAVE THREE DATA POINTS
    !
    IF(TSF%MONTHDAY) TSF%MD_FLAG = Z   !Change flag to internal
    !
    !!!BACKSPACE(TSF%FL%IU) !POSITIONED AT FIRST LINE OF INPUT DATA
    !!!!
    !!!TSF%AT_NEXT = TRUE  !NOW LOAD FIRST THREE VALUES
    !!!!
    !!!IF(TSF%N > TWO) THEN            !LOAD FIRST THREE VALUES
    !!!    CALL READ_NEXT_ROW(TSF, EOF)
    !!!    CALL READ_NEXT_ROW(TSF, EOF)
    !!!    CALL READ_NEXT_ROW(TSF, EOF)
    !!!ELSEIF(TSF%N == TWO) THEN
    !!!    TSF%P = NINER               !JUST TO GET PAST END OF FILE CHECKS
    !!!    CALL READ_NEXT_ROW(TSF, EOF)
    !!!    CALL READ_NEXT_ROW(TSF, EOF)
    !!!    TSF%PREV%TIM = TSF%CUR%TIM
    !!!    TSF%PREV%DAT = TSF%CUR%DAT
    !!!    TSF%CUR %TIM = TSF%NEXT%TIM
    !!!    TSF%CUR %DAT = TSF%NEXT%DAT
    !!!    TSF%N = THREE              ! NOW HAVE THREE DATA POINTS
    !!!    TSF%P = THREE
    !!!ELSE!IF(TSF%N == ONE) THEN
    !!!    !
    !!!    TSF%P = NINER               ! JUST TO GET PAST END OF FILE CHECKS
    !!!    CALL READ_NEXT_ROW(TSF, EOF)
    !!!    TSF%PREV%TIM = TSF%NEXT%TIM
    !!!    TSF%PREV%DAT = TSF%NEXT%DAT
    !!!    TSF%CUR %TIM = TSF%NEXT%TIM
    !!!    TSF%CUR %DAT = TSF%NEXT%DAT
    !!!    TSF%N = THREE              ! NOW HAVE THREE DATA POINTS
    !!!    TSF%P = THREE
    !!!END IF
  END SUBROUTINE
  !
  SUBROUTINE MOVE_TIME_WINDOW_TO(TSF, TIME)
    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
    DOUBLE PRECISION,        INTENT(IN   ):: TIME
    INTEGER:: POS, I
    LOGICAL:: EOF
    !
    EOF = FALSE
    IF(TSF%PREV%TIM <= TIME .AND. TIME <= TSF%NEXT%TIM) THEN
                                                             CONTINUE !DO NOTHING CAUSE WINDOW IS WHERE IT NEEDS TO BE
    ELSEIF(TSF%N500 < TWO) THEN
        IF    (TIME < TSF%PREV%TIM) THEN
                                        DO WHILE(.NOT. EOF .AND. TIME <= TSF%PREV%TIM)
                                                                                    CALL READ_PREV_ROW(TSF, EOF)
                                        END DO
        ELSEIF(TIME > TSF%NEXT%TIM ) THEN
                                        DO WHILE(.NOT. EOF .AND. TIME >= TSF%NEXT%TIM)
                                                                                    CALL READ_NEXT_ROW(TSF, EOF)
                                        END DO
        END IF
    ELSEIF(TIME <= TSF%T500(TWO)) THEN
        !
        IF(TSF%P > HUND) CALL MOVE_TO_START_OF_FILE(TSF)
        !
        IF    (TIME < TSF%PREV%TIM) THEN
                                        DO WHILE(.NOT. EOF .AND. TIME <= TSF%PREV%TIM)
                                                                                    CALL READ_PREV_ROW(TSF, EOF)
                                        END DO
        ELSEIF(TIME > TSF%NEXT%TIM ) THEN
                                        DO WHILE(.NOT. EOF .AND. TIME >= TSF%NEXT%TIM)
                                                                                    CALL READ_NEXT_ROW(TSF, EOF)
                                        END DO
        END IF
    ELSE
        IF    (TIME < TSF%PREV%TIM) THEN
                                        POS = TSF%P / QUIN
                                        IF(POS < ONE) POS = ONE
                                        !
                                        IF(TIME < TSF%T500(POS) .OR. POS > QUIN) THEN  !MORE THAN 500 AWAY FOR AT LEAST LINE 250,000
                                            !
                                            CALL MOVE_TO_START_OF_FILE(TSF)
                                            !
                                            POS = Z
                                            DO I=TWO, TSF%N500+ONE
                                                IF(TIME < TSF%T500(I)) THEN
                                                    POS = (I - ONE)*QUIN - TEN
                                                    EXIT
                                                END IF
                                            END DO
                                            IF(POS > Z .AND. TSF%P < POS) THEN !P = 5   POS =8
                                                DO I = TSF%P + ONE, POS
                                                                       READ(TSF%FL%IU, *)
                                                END DO
                                                TSF%P = POS
                                                CALL READ_NEXT_ROW(TSF, EOF)  !LOUD INTO MEMORY THE NEXT THREE LINES
                                                CALL READ_NEXT_ROW(TSF, EOF)
                                                CALL READ_NEXT_ROW(TSF, EOF)
                                            END IF
                                            !
                                            DO WHILE(.NOT. EOF .AND. TIME >= TSF%NEXT%TIM)
                                                                                        CALL READ_NEXT_ROW(TSF, EOF)
                                            END DO
                                        ELSE
                                            DO WHILE(.NOT. EOF .AND. TIME <= TSF%PREV%TIM)
                                                                                        CALL READ_PREV_ROW(TSF, EOF)
                                            END DO
                                        END IF
        ELSEIF(TIME > TSF%NEXT%TIM ) THEN
                                        IF(.NOT. TSF%AT_NEXT) THEN
                                            READ(TSF%FL%IU, *)
                                            READ(TSF%FL%IU, *)
                                            !CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
                                            !CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
                                            TSF%AT_NEXT = TRUE
                                            TSF%P = TSF%P + TWO 
                                        END IF
                                        !
                                        POS = TSF%P / QUIN + ONE
                                        IF(TIME > TSF%T500(POS)) THEN  !TIME < TSF%T500(TSF%N500) .AND. 
                                            POS = Z
                                            DO I=TWO, TSF%N500+ONE
                                                IF(TIME < TSF%T500(I)) THEN
                                                    POS = (I - ONE)*QUIN - TEN
                                                    EXIT
                                                END IF
                                            END DO
                                            IF(POS > Z .AND. TSF%P < POS) THEN !P = 5   POS =8
                                                DO I = TSF%P + ONE, POS
                                                                       READ(TSF%FL%IU, *)
                                                END DO
                                                TSF%P = POS
                                                CALL READ_NEXT_ROW(TSF, EOF)  !LOUD INTO MEMORY THE NEXT THREE LINES
                                                CALL READ_NEXT_ROW(TSF, EOF)
                                                CALL READ_NEXT_ROW(TSF, EOF)
                                            END IF
                                        END IF
                                        !
                                        DO WHILE(.NOT. EOF .AND. TIME >= TSF%NEXT%TIM)
                                                                                    CALL READ_NEXT_ROW(TSF, EOF)
                                        END DO
        END IF
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE MOVE_MONTHDAY_WINDOW_TO(TSF, TIME)
    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
    DOUBLE PRECISION,        INTENT(IN   ):: TIME
    INTEGER:: POS, I, YR
    TYPE(DATE_OPERATOR), ALLOCATABLE:: DT
    !
    YR = INT(TIME)
    !
    CALL SET_MONTHDAY(TSF, YR) !SET PREV, CUR, NEXT TO MONTH DAY YEAR
    !
    IF(TSF%PREV%TIM <= TIME .AND. TIME <= TSF%NEXT%TIM) THEN
                                                             CONTINUE !DO NOTHING CAUSE WINDOW IS WHERE IT NEEDS TO BE
    ELSE
        IF(TIME < TSF%PREV%TIM) THEN
                                CALL MOVE_TO_START_OF_FILE(TSF)
                                CALL SET_MONTHDAY(TSF, YR) 
        END IF
        !
        IF(TIME > TSF%NEXT%TIM ) THEN
                                        DO WHILE(TIME >= TSF%NEXT%TIM)
                                                                  CALL READ_NEXT_ROW_MONTHDAY(TSF)
                                        END DO
        END IF
    END IF
    !
  END SUBROUTINE
  !
  !SUBROUTINE MOVE_MONTHDAY_WINDOW_TO(TSF, TIME)
  !  CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
  !  DOUBLE PRECISION,        INTENT(IN   ):: TIME
  !  INTEGER:: POS, I, J, K, YR
  !  TYPE(DATE_OPERATOR), ALLOCATABLE:: DT
  !  LOGICAL:: EOF
  !  !
  !  YR = INT(TIME)
  !  !
  !  CALL SET_MONTHDAY(TSF, YR) !SET PREV, CUR, NEXT TO MONTH DAY YEAR
  !  !
  !  EOF = FALSE
  !  IF(TSF%PREV%TIM <= TIME .AND. TIME <= TSF%NEXT%TIM) THEN
  !                                                           CONTINUE !DO NOTHING CAUSE WINDOW IS WHERE IT NEEDS TO BE
  !  ELSEIF(TSF%N <= HUND .OR. TSF%N500 == Z) THEN
  !      IF    (TIME < TSF%PREV%TIM) THEN
  !                                      DO WHILE(.NOT. EOF .AND. TIME <= TSF%PREV%TIM)
  !                                                                                  CALL READ_PREV_ROW_MONTHDAY(TSF, EOF, YR)
  !                                      END DO
  !      ELSEIF(TIME > TSF%NEXT%TIM ) THEN
  !                                      DO WHILE(.NOT. EOF .AND. TIME >= TSF%NEXT%TIM)
  !                                                                                  CALL READ_NEXT_ROW_MONTHDAY(TSF)
  !                                      END DO
  !      END IF
  !  ELSE
  !      IF( YR .NE. INT(TSF%T500(ONE)) ) THEN
  !         !
  !         ALLOCATE(DT)
  !         DO I = ONE, TSF%N500
  !                            CALL DT%INIT(TSF%T500(I))
  !                            CALL DT%SET_YEAR(YR)
  !                            TSF%T500(I) = DT%DYEAR
  !         END DO
  !         DEALLOCATE(DT)
  !      END IF
  !      !
  !      IF(TIME <= TSF%T500(TWO)) THEN
  !          !
  !          IF(TSF%P > HUND) THEN
  !              CALL MOVE_TO_START_OF_FILE(TSF)
  !              CALL SET_MONTHDAY(TSF, YR) !SET PREV, CUR, NEXT TO MONTH DAY YEAR
  !          END IF
  !          !
  !          IF    (TIME < TSF%PREV%TIM) THEN
  !                                          DO WHILE(.NOT. EOF .AND. TIME <= TSF%PREV%TIM)
  !                                                                                      CALL READ_PREV_ROW_MONTHDAY(TSF, EOF, YR)
  !                                          END DO
  !          ELSEIF(TIME > TSF%NEXT%TIM ) THEN
  !                                          DO WHILE(.NOT. EOF .AND. TIME >= TSF%NEXT%TIM)
  !                                                                                      CALL READ_NEXT_ROW_MONTHDAY(TSF)
  !                                          END DO
  !          END IF
  !      ELSE
  !          IF    (TIME < TSF%PREV%TIM) THEN
  !                                          POS = TSF%P / QUIN
  !                                          IF(POS < ONE) POS = ONE
  !                                          !
  !                                          IF(TIME < TSF%T500(POS) .OR. POS > QUIN) THEN  !MORE THAN 500 AWAY OR BEYOND LINE 250,000
  !                                              !
  !                                              CALL MOVE_TO_START_OF_FILE(TSF)
  !                                              CALL SET_MONTHDAY(TSF, YR) !SET PREV, CUR, NEXT TO MONTH DAY YEAR
  !                                              !
  !                                              POS = Z
  !                                              DO I=TWO, TSF%N500+ONE
  !                                                  IF(TIME < TSF%T500(I)) THEN
  !                                                      POS = (I - ONE)*QUIN - TEN
  !                                                      EXIT
  !                                                  END IF
  !                                              END DO
  !                                              IF(POS > Z .AND. TSF%P < POS) THEN !P = 5   POS =8
  !                                                  DO I = TSF%P + ONE, POS
  !                                                                         READ(TSF%FL%IU, *)
  !                                                  END DO
  !                                                  TSF%P = POS
  !                                                  CALL READ_NEXT_ROW_MONTHDAY(TSF)  !LOUD INTO MEMORY THE NEXT THREE LINES
  !                                                  CALL READ_NEXT_ROW_MONTHDAY(TSF)
  !                                                  CALL READ_NEXT_ROW_MONTHDAY(TSF)
  !                                              END IF
  !                                              !
  !                                              DO WHILE(.NOT. EOF .AND. TIME >= TSF%NEXT%TIM)
  !                                                                                          CALL READ_NEXT_ROW_MONTHDAY(TSF)
  !                                              END DO
  !                                          ELSE
  !                                              DO WHILE(.NOT. EOF .AND. TIME <= TSF%PREV%TIM)
  !                                                                                          CALL READ_PREV_ROW_MONTHDAY(TSF, EOF, YR)
  !                                              END DO
  !                                          END IF
  !          ELSEIF(TIME > TSF%NEXT%TIM ) THEN
  !                                          IF(.NOT. TSF%AT_NEXT) THEN
  !                                              READ(TSF%FL%IU, *)
  !                                              READ(TSF%FL%IU, *)
  !                                              !CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
  !                                              !CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
  !                                              TSF%AT_NEXT = TRUE
  !                                              TSF%P = TSF%P + TWO 
  !                                          END IF
  !                                          !
  !                                          POS = TSF%P / QUIN + ONE
  !                                          IF(TIME > TSF%T500(POS)) THEN  !TIME < TSF%T500(TSF%N500) .AND. 
  !                                              POS = Z
  !                                              DO I=TWO, TSF%N500+ONE
  !                                                  IF(TIME < TSF%T500(I)) THEN
  !                                                      POS = (I - ONE)*QUIN - TEN
  !                                                      EXIT
  !                                                  END IF
  !                                              END DO
  !                                              IF(POS > Z .AND. TSF%P < POS) THEN !P = 5   POS =8
  !                                                  DO I = TSF%P + ONE, POS
  !                                                                         READ(TSF%FL%IU, *)
  !                                                  END DO
  !                                                  TSF%P = POS
  !                                                  CALL READ_NEXT_ROW_MONTHDAY(TSF)  !LOUD INTO MEMORY THE NEXT THREE LINES
  !                                                  CALL READ_NEXT_ROW_MONTHDAY(TSF)
  !                                                  CALL READ_NEXT_ROW_MONTHDAY(TSF)
  !                                              END IF
  !                                          END IF
  !                                          !
  !                                          DO WHILE(.NOT. EOF .AND. TIME >= TSF%NEXT%TIM)
  !                                                                                      CALL READ_NEXT_ROW_MONTHDAY(TSF)
  !                                          END DO
  !          END IF
  !      END IF
  !  END IF
  !  !
  !END SUBROUTINE
  !
  SUBROUTINE GO_TO_TIME_SERIES_POSITION(TSF, POS)
  CLASS(TIME_SERIES_FILE),  INTENT(INOUT):: TSF
  INTEGER,                  INTENT(IN   ):: POS
  INTEGER:: P
  LOGICAL:: EOF
  !
  P = POS
  IF(P > TSF%N  ) P = TSF%N
  IF(P < THREE  ) P = THREE
  !
  CALL MOVE_TO_START_OF_FILE(TSF)
  !
  DO WHILE (TSF%P < P .OR. TSF%P .NE. TSF%N)
        CALL READ_NEXT_ROW(TSF, EOF)
  END DO
  !
  END SUBROUTINE
  !
  SUBROUTINE READ_NEXT_ROW(TSF, EOF)
  CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
  LOGICAL,                 INTENT(OUT  ):: EOF
  INTEGER:: LLOC, ISTART, ISTOP
  !
  IF(TSF%P == TSF%N .OR. (TSF%P == TSF%N - TWO .AND. .NOT. TSF%AT_NEXT) .OR. TSF%N == Z) THEN
      EOF = TRUE
  ELSE
      EOF = FALSE
      IF(.NOT. TSF%AT_NEXT) THEN
          CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
          CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
          TSF%AT_NEXT = TRUE
          TSF%P = TSF%P + TWO 
      END IF
      !
      CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
      !
      TSF%P = TSF%P + ONE 
      !
      CALL SHIFT_FORWARD(TSF)
      !
      LLOC = ONE
      CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%NEXT%DATE, ONLY_DYEAR=TRUE ,MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
      TSF%NEXT%TIM = TSF%NEXT%DATE%DYEAR
      !
      CALL GET_NUMBER(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%NEXT%DAT,MSG='FAILED TO LOAD DATA/VALUE PART (SECOND NUMBER) OF THE TIME SERIES INPUT FILE.')
      TSF%NEXT%DAT = TSF%NEXT%DAT
      !
  END IF
  !
  END SUBROUTINE
  !
  SUBROUTINE READ_PREV_ROW(TSF, EOF)
  CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
  LOGICAL,                 INTENT(OUT  ):: EOF
  INTEGER:: LLOC, ISTART, ISTOP
  !
  IF(TSF%P == ONE .OR. (TSF%P == THREE .AND. TSF%AT_NEXT) .OR. TSF%N == Z) THEN
      EOF = TRUE
  ELSE
      EOF = FALSE
      IF(TSF%AT_NEXT) THEN
          BACKSPACE(TSF%FL%IU)
          BACKSPACE(TSF%FL%IU)
          TSF%AT_NEXT = FALSE
          TSF%P = TSF%P - TWO 
      END IF
      !
      BACKSPACE(TSF%FL%IU)
      BACKSPACE(TSF%FL%IU)
      CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
      !
      TSF%P = TSF%P - ONE 
      !
      CALL SHIFT_BACKWARD(TSF)
      !
      LLOC = ONE
      CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%PREV%DATE, ONLY_DYEAR=TRUE ,MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
      TSF%PREV%TIM = TSF%PREV%DATE%DYEAR
      !
      CALL GET_NUMBER(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%PREV%DAT,MSG='FAILED TO LOAD DATA/VALUE PART (SECOND NUMBER) OF THE TIME SERIES INPUT FILE.')
      TSF%PREV%DAT = TSF%PREV%DAT
  END IF
  !
  END SUBROUTINE
  !
  SUBROUTINE SHIFT_FORWARD(TSF)
      CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
      !
      TSF%TMP => TSF%PREV
      !
      TSF%PREV => TSF%CUR
      TSF%CUR  => TSF%NEXT
      TSF%NEXT => TSF%TMP
      !
      TSF%TMP  => NULL()
      !
  END SUBROUTINE
  !
  SUBROUTINE SHIFT_BACKWARD(TSF)
      CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
      !
      TSF%TMP => TSF%NEXT
      !
      TSF%NEXT => TSF%CUR
      TSF%CUR  => TSF%PREV
      TSF%PREV => TSF%TMP
      !
      TSF%TMP  => NULL()
      !
  END SUBROUTINE
  !
  SUBROUTINE READ_NEXT_ROW_MONTHDAY(TSF)
  CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
  INTEGER:: LLOC, ISTART, ISTOP, YR
  !
  IF(TSF%P == TSF%N .OR. (TSF%P == TSF%N - TWO .AND. .NOT. TSF%AT_NEXT)) THEN  ! .OR. TSF%N == Z SCOTT ERROR?!?!
      TSF%MD_FLAG = TWO
      TSF%P = Z
      !
      CALL TSF%FL%REWIND()
      !
  ELSEIF(TSF%MD_FLAG == TWO) THEN
      TSF%MD_FLAG = ONE
  ELSE
      TSF%MD_FLAG = Z
      !
  END IF
  !
  IF(.NOT. TSF%AT_NEXT .AND. TSF%MD_FLAG == Z) THEN
      CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
      CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
      TSF%AT_NEXT = TRUE
      TSF%P = TSF%P + TWO 
  END IF
  !
  CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
  !
  TSF%P = TSF%P + ONE 
  !
  YR = TSF%NEXT%DATE%YEAR  !Get files currently assinged year
  !
  IF(TSF%MD_FLAG == TWO) YR = YR + ONE !Reached end of file, increment the year.
  !
  CALL SHIFT_FORWARD(TSF)
  !
  LLOC = ONE
  CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%NEXT%DATE ,MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
  !
  CALL TSF%NEXT%DATE%SET_YEAR( YR )
  !
  TSF%NEXT%TIM = TSF%NEXT%DATE%DYEAR
  !
  CALL GET_NUMBER(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%NEXT%DAT,MSG='FAILED TO LOAD DATA/VALUE PART (SECOND NUMBER) OF THE TIME SERIES INPUT FILE.')
  !
  END SUBROUTINE
  !
  SUBROUTINE READ_PREV_ROW_MONTHDAY(TSF, EOF, YR)
  CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
  LOGICAL,                 INTENT(OUT  ):: EOF
  INTEGER,                 INTENT(IN   ):: YR
  INTEGER:: LLOC, ISTART, ISTOP
  !
  IF(TSF%P == ONE .OR. (TSF%P == THREE .AND. TSF%AT_NEXT) .OR. TSF%N == Z) THEN
      EOF = TRUE
  ELSE
      EOF = FALSE
      IF(TSF%AT_NEXT) THEN
          BACKSPACE(TSF%FL%IU)
          BACKSPACE(TSF%FL%IU)
          TSF%AT_NEXT = FALSE
          TSF%P = TSF%P - TWO 
      END IF
      !
      BACKSPACE(TSF%FL%IU)
      BACKSPACE(TSF%FL%IU)
      CALL READ_TO_DATA(TSF%LINE,TSF%FL%IU,TSF%IOUT)
      !
      TSF%P = TSF%P - ONE 
      !
      TSF%TMP => TSF%NEXT
      !
      TSF%NEXT => TSF%CUR
      TSF%CUR  => TSF%PREV
      TSF%PREV => TSF%TMP
      !
      TSF%TMP  => NULL()
      !
      LLOC = ONE
      CALL GET_DATE(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%PREV%DATE, ONLY_DYEAR=TRUE ,MSG='FAILED TO LOAD TIME PART (FIRST NUMBER) OF THE TIME SERIES INPUT FILE.')
      !
      CALL TSF%PREV%DATE%SET_YEAR( YR )
      TSF%PREV%TIM = TSF%PREV%DATE%DYEAR
      !
      CALL GET_NUMBER(TSF%LINE,LLOC,ISTART,ISTOP,TSF%IOUT,TSF%FL%IU,TSF%PREV%DAT,MSG='FAILED TO LOAD DATA/VALUE PART (SECOND NUMBER) OF THE TIME SERIES INPUT FILE.')
      TSF%PREV%DAT = TSF%PREV%DAT
  END IF
  !
  END SUBROUTINE
  !  
  PURE ELEMENTAL FUNCTION TIME_SERIES_FILE_IN_USE(TSF) RESULT(ANS)
  CLASS(TIME_SERIES_FILE),  INTENT(IN):: TSF
  LOGICAL:: ANS
  !
  ANS = TSF%N > Z
  !
  END FUNCTION
  !
  IMPURE ELEMENTAL SUBROUTINE MOVE_TIME_SERIES_TOO(TSF, TSF2)
    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
    CLASS(TIME_SERIES_FILE), INTENT(  OUT):: TSF2
    !
    CALL DEALLOCATE_TIME_SERIES_FILE(TSF2)
    !
    ALLOCATE(TSF2%PREV, TSF2%CUR, TSF2%NEXT)
    TSF2%IOUT = TSF2%IOUT
    IF(ALLOCATED(TSF%NAM)) THEN
        ALLOCATE(TSF2%NAM, SOURCE = TSF%NAM)
    ELSE
        ALLOCATE(TSF2%NAM, SOURCE = 'n')
    END IF
    !
    TSF2%OPT      = TSF%OPT
    TSF2%MONTHDAY = TSF%MONTHDAY
    TSF2%N        = TSF%N
    TSF2%IOUT     = TSF%IOUT
    !TSF2%SFAC     = TSF%SFAC
    TSF2%OPT      = TSF%OPT
    TSF2%P        = TSF%P
    TSF2%N500     = TSF%N500
    !
    IF(TSF2%N500 > Z) ALLOCATE(TSF2%T500, SOURCE=TSF%T500)
    !
    IF(TSF%FL%SKIP) THEN
        TSF2%FL%SKIP = TRUE
        TSF2%AT_NEXT = TRUE
        !
        TSF2%PREV%TIM = ninf  
        TSF2%PREV%DAT = TSF%PREV%DAT
        TSF2%CUR %TIM = ninf
        TSF2%CUR %DAT = TSF%CUR %DAT
        TSF2%NEXT%TIM = ninf 
        TSF2%NEXT%DAT = TSF%NEXT%DAT
    ELSE
        CALL TSF%FL%MOVE( TSF2%FL )
        !
        CALL MOVE_TO_START_OF_FILE(TSF2)
    END IF
    !
    CALL DEALLOCATE_TIME_SERIES_FILE(TSF)
    !
  END SUBROUTINE
  !  
  IMPURE ELEMENTAL SUBROUTINE DEALLOCATE_TIME_SERIES_FILE(TSF)
    CLASS(TIME_SERIES_FILE), INTENT(INOUT):: TSF
    !
    IF(ASSOCIATED(TSF%PREV)) DEALLOCATE(TSF%PREV)
    IF(ASSOCIATED(TSF%CUR )) DEALLOCATE(TSF%CUR )
    IF(ASSOCIATED(TSF%NEXT)) DEALLOCATE(TSF%NEXT)
    TSF%PREV => NULL()
    TSF%CUR  => NULL()
    TSF%NEXT => NULL()
    TSF%TMP  => NULL()
    !
    IF(ALLOCATED (TSF%NAM )) DEALLOCATE(TSF%NAM )
    !
    CALL TSF%FL%CLOSE()
    !
    IF(ALLOCATED(TSF%T500)) DEALLOCATE(TSF%T500)
    TSF%N500 = Z
    !
    TSF%AT_NEXT  = FALSE
    TSF%MONTHDAY = FALSE
    TSF%BINARY   = FALSE
    TSF%IOUT = Z
    !TSF%SFAC = UNO
    TSF%N    = Z
    TSF%OPT  = Z
    TSF%P    = Z
    !TSF%CHK  = inf_I   
    !TSF%CHK_TIM = ninf
    !
  END SUBROUTINE
  !
  IMPURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_TIME_SERIES_FILE(TSF)
    TYPE(TIME_SERIES_FILE), INTENT(INOUT):: TSF
    CALL DEALLOCATE_TIME_SERIES_FILE(TSF)
  END SUBROUTINE
END MODULE

    
MODULE VARIABLE_POINTER_LIST_INTERFACE!, ONLY: VAR_POINTER_LIST
  USE CONSTANTS
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: VAR_POINTER_LIST
  !
  TYPE VAR_VAL 
    DOUBLE PRECISION, POINTER:: D => NULL()
  END TYPE
  !
  TYPE VAR_POINTER_LIST 
      INTEGER:: N = Z  !TOTAL DIM
      INTEGER:: P = Z  !ASSOCIATED DIM
      TYPE(VAR_VAL), DIMENSION(:), ALLOCATABLE:: LST
      !
      CONTAINS
      !
      PROCEDURE, PASS(VAR):: INIT     => INITIALIZE_VAR_VAL_TYPE!(N)
      PROCEDURE, PASS(VAR):: ADD      => ADD_VAL_VAR_VAL_TYPE  !(VAL)
      PROCEDURE, PASS(VAR):: SUM      => SUM_VAR_VAL_TYPE      !()
      PROCEDURE, PASS(VAR):: SUM_DIM  => SUM_RANGE_VAR_VAL_TYPE!(ISTART, [ISTOP])
      !
      PROCEDURE, PASS(VAR):: ADJUST_MAXSUM => ADJUST_MAXSUM_VAR_POINTER_LIST!(MAXSUM)            
      PROCEDURE, PASS(VAR):: REDUCE_SUM_BY                          !(REDUCER)
      PROCEDURE, PASS(VAR):: NULL     => NULLIFY_VAR_VAL_TYPE
      FINAL:: FINAL_DESTROY_VAR_VAL_TYPE
  END TYPE
    
    CONTAINS
    !
  PURE SUBROUTINE INITIALIZE_VAR_VAL_TYPE(VAR, N)  
    CLASS(VAR_POINTER_LIST), INTENT(INOUT):: VAR
    INTEGER, INTENT(IN):: N
    !
    IF(.NOT. ALLOCATED(VAR%LST)) THEN
        ALLOCATE(VAR%LST(N))
    ELSEIF(ALLOCATED(VAR%LST) .AND. SIZE(VAR%LST).NE.N) THEN
        DEALLOCATE(VAR%LST)
        ALLOCATE(VAR%LST(N))
    END IF
    !
    VAR%N = N
    VAR%P = Z
    !
  END SUBROUTINE
    !
  SUBROUTINE ADD_VAL_VAR_VAL_TYPE(VAR, VAL)  
    CLASS(VAR_POINTER_LIST),   INTENT(INOUT):: VAR
    DOUBLE PRECISION, INTENT(IN), TARGET:: VAL
    !
    TYPE(VAR_POINTER_LIST):: TMP
    INTEGER::I, P
    !
    IF(VAR%N == Z) CALL INITIALIZE_VAR_VAL_TYPE(VAR, ONE)  
    !
    VAR%P = VAR%P + ONE
    !
    P = VAR%P
    !
    IF(VAR%P > VAR%N) THEN
        !
        CALL INITIALIZE_VAR_VAL_TYPE(TMP, P)
        !
        DO I=ONE, VAR%N
                       TMP%LST(I)%D => VAR%LST(I)%D
        END DO
        !
        CALL INITIALIZE_VAR_VAL_TYPE(VAR, P)  
        !
        VAR%P = P 
        DO I=ONE, VAR%N
                       VAR%LST(I)%D => TMP%LST(I)%D
        END DO
    END IF
    !
    VAR%LST(P)%D => VAL
    !
  END SUBROUTINE
  !
  PURE FUNCTION SUM_VAR_VAL_TYPE(VAR) RESULT(SM)  
    CLASS(VAR_POINTER_LIST), INTENT(IN):: VAR
    DOUBLE PRECISION:: SM
    INTEGER::I
    !
    SM = DZ
    DO CONCURRENT (I=ONE:VAR%P); SM = SM + VAR%LST(I)%D
    END DO
    !
  END FUNCTION
  !
  PURE FUNCTION SUM_RANGE_VAR_VAL_TYPE(VAR,ISTART,ISTOP) RESULT(SM)  
    CLASS(VAR_POINTER_LIST), INTENT(IN):: VAR
    INTEGER,         INTENT(IN):: ISTART
    INTEGER,OPTIONAL,INTENT(IN):: ISTOP
    DOUBLE PRECISION:: SM
    INTEGER::I
    !
    SM = DZ
    !
    IF(PRESENT(ISTOP)) THEN
          IF (ISTOP > VAR%P) THEN 
              DO CONCURRENT (I=ISTART:VAR%P); SM = SM + VAR%LST(I)%D
              END DO
          ELSE
              DO CONCURRENT (I=ISTART:ISTOP); SM = SM + VAR%LST(I)%D
              END DO
          END IF
    ELSEIF(ISTART == VAR%P) THEN
                                              SM = VAR%LST(VAR%P)%D
    ELSEIF(ISTART <  VAR%P) THEN
              DO CONCURRENT (I=ISTART:VAR%P); SM = SM + VAR%LST(I)%D
              END DO
    END IF
    !
  END FUNCTION
  !
  PURE SUBROUTINE ADJUST_MAXSUM_VAR_POINTER_LIST(VAR, MAXSUM)
    CLASS(VAR_POINTER_LIST),  INTENT(INOUT):: VAR
    DOUBLE PRECISION, INTENT(IN   )::MAXSUM
    DOUBLE PRECISION:: TOT
    INTEGER:: I
    !
    TOT = SUM_VAR_VAL_TYPE(VAR)
    !
    DO I=ONE, VAR%P
          IF(TOT > MAXSUM) THEN
              !
              VAR%LST(I)%D = MAXSUM - SUM_RANGE_VAR_VAL_TYPE(VAR,I+ONE)
              !
              IF(VAR%LST(I)%D < DZ) VAR%LST(I)%D = DZ
              !
              TOT = SUM_VAR_VAL_TYPE(VAR)
          ELSE
              EXIT
          END IF
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE REDUCE_SUM_BY(VAR, REDUCER) !REDUCES BY THE |REDUCER|
    CLASS(VAR_POINTER_LIST), INTENT(INOUT):: VAR
    DOUBLE PRECISION,        INTENT(IN):: REDUCER
    DOUBLE PRECISION:: RED
    INTEGER:: I
    !
    IF(REDUCER .NE. DZ) THEN
        !
        IF(REDUCER < DZ) THEN
            RED = REDUCER
        ELSE
            RED = DNEG*REDUCER
        END IF
        !
        DO I=ONE, VAR%P
            VAR%LST(I)%D = VAR%LST(I)%D + RED
            IF( VAR%LST(I)%D < DZ ) THEN
                RED = VAR%LST(I)%D 
                VAR%LST(I)%D = DZ
            ELSE
                RED = DZ
                EXIT
            END IF
        END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE NULLIFY_VAR_VAL_TYPE(VAR)  
    CLASS(VAR_POINTER_LIST),   INTENT(INOUT):: VAR
    INTEGER:: I
    !
    DO I=ONE, VAR%N
                   VAR%LST(I)%D => NULL()
    END DO
    !
    VAR%P = Z
    !
  END SUBROUTINE
  !
  SUBROUTINE FINAL_DESTROY_VAR_VAL_TYPE(VAR)  
    TYPE(VAR_POINTER_LIST),   INTENT(INOUT):: VAR
    INTEGER:: I
    !
    DO I=ONE, VAR%N
                   VAR%LST(I)%D => NULL()
    END DO
    !
    IF(ALLOCATED(VAR%LST)) DEALLOCATE(VAR%LST)
    !
    VAR%P = Z
    VAR%N = Z
    !
  END SUBROUTINE
  !
END MODULE
!
!!
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
MODULE BUDGET_GROUP_INTERFACE!, ONLY: BUDGET_GROUP
  USE CONSTANTS,                        ONLY: BLNK,NL,BLN, TAB,COM,NEG,Z,ONE,TWO,TEN,DZ,UNO,DOS,DIEZ,TRUE,FALSE
  USE UTIL_INTERFACE,                   ONLY: READ_TO_DATA, FILE_IO_ERROR,STOP_ERROR,UPPER,PARSE_WORD_UP
  USE GENERIC_INPUT_FILE_INSTRUCTION,   ONLY: GENERIC_INPUT_FILE
  USE GENERIC_BLOCK_READER_INSTRUCTION, ONLY: GENERIC_BLOCK_READER
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: BUDGET_GROUP
  !
  TYPE GROUP_INDEX_LOC
            INTEGER,DIMENSION(:), ALLOCATABLE:: IDX
  END TYPE
  !
  TYPE BUDGET_GROUP
      !LOGICAL:: PRINT_BUDGET =FALSE  --NOT CURRENTLY USED
      INTEGER:: IOUT
      INTEGER:: NGRP
      LOGICAL:: BUDGET_GROUPS = FALSE
      CHARACTER(16),         DIMENSION(:), ALLOCATABLE:: GRP   !NOTE THIS IS LEFT JUSTIFICED AND MUST BE MADE RIGHT JUSTIFIED EXTERNALLY
      TYPE(GROUP_INDEX_LOC), DIMENSION(:), ALLOCATABLE:: GID
      INTEGER,               DIMENSION(:), ALLOCATABLE:: DIM
      CHARACTER(:),                        ALLOCATABLE:: PAK
      !
  CONTAINS
  !
  PROCEDURE, PASS(BD)::  INIT    => BUDGET_GROUPS_INITIALIZE !( BL, DEFAULT )
  PROCEDURE, PASS(BD)::  LOAD    => BUDGET_GROUPS_LOAD       !( BL )
  PROCEDURE, PASS(BD)::  RESET   => BUDGET_GROUPS_PREPARE_FOR_GROUP_RELOAD !( [KEEP_ALLOC] )
  GENERIC::              ADD     => BUDGET_GROUPS_ADD_NEXT_ITEM, BUDGET_GROUPS_ADD_GROUP_LIST !( IDX, GROUP ) or (GROUP(:))
  PROCEDURE, PASS(BD)::  INDEX   => BUDGET_GROUPS_GET_NEXT_INDEX!(IGRP, IDX)
  PROCEDURE, PASS(BD)::  GROUPNUM=> BUDGET_GROUPS_GET_GROUP_NUMBER!(GRP)
  PROCEDURE, PASS(BD)::  BUDGET_GROUPS_ADD_NEXT_ITEM
  PROCEDURE, PASS(BD)::  BUDGET_GROUPS_ADD_GROUP_LIST
  PROCEDURE, PASS(BD)::  DESTROY => DEALLOCATE_BUDGET_GROUPS
  FINAL:: FINAL_DEALLOCATE_BUDGET_GROUPS
  END TYPE
  !
  CONTAINS
  !
  SUBROUTINE BUDGET_GROUPS_INITIALIZE( BD, DEFAULT )
    CLASS(BUDGET_GROUP),    INTENT(INOUT):: BD
    CHARACTER(*),           INTENT(IN   ):: DEFAULT
    !
    CALL DEALLOCATE_BUDGET_GROUPS(BD)  !DEALLOCATE IN CASE IT IS ALREADY ALLOCATED  -- BD%BUDGET_GROUPS = FALSE
    !
    BD%NGRP = ONE
    ALLOCATE(BD%DIM(ONE))
    ALLOCATE(BD%GRP(ONE))
             BD%GRP(ONE) = DEFAULT
    !
    ALLOCATE(BD%GID(ONE))
    ALLOCATE(BD%GID(ONE)%IDX(ONE))
    !
    BD%PAK = DEFAULT
    !
  END SUBROUTINE
  !
  SUBROUTINE BUDGET_GROUPS_LOAD( BD,  BL )
    CLASS(BUDGET_GROUP),        INTENT(INOUT):: BD
    TYPE(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    TYPE(GENERIC_INPUT_FILE):: FL
    INTEGER:: LLOC, ISTART, ISTOP, I
    CHARACTER(5):: ERROR
    !
    IF( BL%NAME == 'BUDGET_GROUP' .OR. BL%NAME == 'BUDGET_GROUPS') THEN
       IF( BL%NLINE>Z ) THEN
           !
           WRITE(BL%IOUT,'(A)') TRIM(ADJUSTL(BD%GRP(ONE)))//' BUDGET_GROUPS BLOCK FOUND. NOW LOADING CUSTOM BUDGET GROUP NAMES.'
           !
           CALL DEALLOCATE_BUDGET_GROUPS(BD)  !DEALLOCATE IN CASE IT IS ALREADY ALLOCATED
           !
           BD%IOUT = BL%IOUT
           BD%BUDGET_GROUPS = TRUE
           ERROR = 'ERROR'
           CALL BL%START()
           IF(  BL%LINE==ERROR ) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='UNFORTUNATELY UNKNOWN BUDGET_GROUP BLOCK ERROR.'//BLN//'THIS ERROR OCCURED FOR THE PACKAGE THAT HAS THE DEFAULT BUDGET GROUP NAME "'//BD%PAK//'"'//BLN//'PLEASE DOUBLE CHECK BLOCK SET UP.')
           !
           LLOC = ONE
           CALL FL%OPEN(BL%LINE, LLOC, BL%IOUT, BL%IU, NOSTOP=TRUE, REQKEY=TRUE)  !GET LOCATION THAT HOLDS LIST OF FEEDFILE NAMES
           !
           IF (FL%IU.NE.Z) THEN                         !FOUND "EXTERNAL" OR "OPEN/CLOSE".
               CALL BL%INNER(BLNK,FL%IU,BL%IOUT)        !RELOAD LINES --READ TO BOTTOM OF FILE
               CALL BL%START()
           ELSEIF(FL%IU == Z .AND. .NOT. FL%ERROR) THEN !INTERNAL KEYWORD FOUND, MOVE ONE LINE DOWN
               CALL BL%NEXT()
           !ELSE                                        !GROUP NAMES ARE WITHIN BLOCK AND NO INTERNAL KEYWORD -- ASSUMES FIRST GROUP NAME IS ON CURRENT LINE
           !    FL%IU = Z
           END IF
           !
           IF(  BL%LINE==ERROR ) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='UNFORTUNATELY UNKNOWN BUDGET_GROUP BLOCK ERROR.'//BLN//'THIS ERROR OCCURED FOR THE PACKAGE THAT HAS THE DEFAULT BUDGET GROUP NAME "'//BD%PAK//'"'//BLN//'PLEASE DOUBLE CHECK BLOCK SET UP.')
           !
           BD%NGRP = BL%LIST%LEN() - BL%LIST%GETPOS() + ONE  !RELY ON LIST POSITION AND LENGTH TO GET NUMBER OF GROUP NAMES -- COULD DO BL%NLINE- BL%GETPOS  BUT NEED TO ADD GETPOS
           !
           ALLOCATE(BD%GRP(BD%NGRP))
           ALLOCATE(BD%GID(BD%NGRP))
           ALLOCATE(BD%DIM(BD%NGRP))
           !
           DO I=ONE, BD%NGRP
                      IF(  BL%LINE==ERROR ) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='UNFORTUNATELY UNKNOWN BUDGET_GROUP BLOCK ERROR.'//BLN//'THIS ERROR OCCURED FOR THE PACKAGE THAT HAS THE DEFAULT BUDGET GROUP NAME "'//BD%PAK//'"'//BLN//'PLEASE DOUBLE CHECK BLOCK SET UP.')
                      LLOC = ONE
                      CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP)
                      !
                      BD%GRP(I) = BL%LINE(ISTART:ISTOP)
                      !
                      CALL BL%NEXT()
           END DO
           !
           !CALL READ_TO_DATA(LINE,IU,IOUT)
       ELSE
           WRITE(BL%IOUT,'(A)') 'BUDGET_GROUPS BLOCK FOUND, BUT WAS EMPTY. PACKAGE WILL USE THE DEFAULT OneWater BUDGET NAME "'//TRIM(BD%GRP(ONE))//'"'
       END IF
    END IF
    !  BL and FL are automatically destroyed on return.
  END SUBROUTINE
  !
  SUBROUTINE BUDGET_GROUPS_PREPARE_FOR_GROUP_RELOAD( BD,  KEEP_ALLOC)
    CLASS(BUDGET_GROUP), INTENT(INOUT):: BD
    LOGICAL, OPTIONAL:: KEEP_ALLOC
    INTEGER:: I
    LOGICAL:: DEALLOC
    !
    IF(PRESENT(KEEP_ALLOC)) THEN
        DEALLOC = .NOT. KEEP_ALLOC
    ELSE
        DEALLOC = TRUE
    END IF
    !
    IF(.NOT. BD%BUDGET_GROUPS) THEN
                                                  BD%DIM(1)        = Z
                                                  BD%GID(1)%IDX(1) = Z
    ELSEIF ( BD%BUDGET_GROUPS .AND. DEALLOC) THEN
                                                  BD%DIM = Z
                                                  DO I=ONE, UBOUND(BD%GRP,ONE)
                                                                      IF(ALLOCATED(BD%GID(I)%IDX)) DEALLOCATE(BD%GID(I)%IDX)
                                                  END DO
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE BUDGET_GROUPS_ADD_NEXT_ITEM( BD, IDX, GROUP, GID )
    CLASS(BUDGET_GROUP),   INTENT(INOUT):: BD
    INTEGER,               INTENT(IN):: IDX
    CHARACTER(*),OPTIONAL, INTENT(IN   ):: GROUP
    INTEGER,     OPTIONAL, INTENT(OUT  ):: GID
    CHARACTER(16):: GRP
    INTEGER:: I, IG
    INTEGER, DIMENSION(:), ALLOCATABLE:: TMP
    !
    IF     (IDX == Z) THEN
        BD%DIM = Z
        IG     = ONE
    ELSEIF (IDX < Z) THEN
        BD%DIM = NEG * IDX
        IG     = ONE
    ELSE
        !
        IF(PRESENT(GROUP)) THEN
            GRP = GROUP
            !GRP = ADJUSTR(GRP)
        ELSE
            GRP = BD%GRP(1)
        END IF
        !
        IF ( BD%BUDGET_GROUPS ) THEN
             IG = Z
             DO CONCURRENT (I=1:BD%NGRP, BD%GRP(I)==GRP)
                 IG = I
             END DO
             IF(IG == Z) CALL STOP_ERROR(OUTPUT=BD%IOUT, MSG='BUDGET_GROUP ERROR: FAILED TO LOCATE BUDGET GROUP WITH NAME "'//GRP//'" WITHIN LIST OF NAMED BUDGET GROUPS'//BLN//'THIS ERROR OCCURED FOR THE PACKAGE THAT HAS THE DEFAULT BUDGET GROUP NAME "'//BD%PAK//'"')
             !
             IF (ALLOCATED(BD%GID(IG)%IDX)) THEN
                                              ALLOCATE( TMP, SOURCE=[BD%GID(IG)%IDX, IDX] )
                                              CALL MOVE_ALLOC(TMP,BD%GID(IG)%IDX)
             ELSE
                                              ALLOCATE( BD%GID(IG)%IDX(1), SOURCE=IDX )
             END IF
             
        ELSE
             IG = ONE
        END IF
        !
        BD%DIM(IG) = BD%DIM(IG) + ONE
        !
    END IF
    !
    IF(PRESENT(GID)) GID = IG
    !
  END SUBROUTINE
  !
  SUBROUTINE BUDGET_GROUPS_ADD_GROUP_LIST( BD, GROUP )
    CLASS(BUDGET_GROUP),                   INTENT(INOUT):: BD
    CHARACTER(*),DIMENSION(:), CONTIGUOUS, INTENT(IN   ):: GROUP
    INTEGER:: I, IG, IDX
    INTEGER, DIMENSION(:), ALLOCATABLE:: TMP
    !
    DO IDX=ONE, UBOUND(GROUP,ONE)
        !
        IF ( BD%BUDGET_GROUPS ) THEN
             IG = Z
             DO CONCURRENT (I=1:BD%NGRP, BD%GRP(I)==GROUP(IDX))
                 IG = I
             END DO
             IF(IG == Z) CALL STOP_ERROR(OUTPUT=BD%IOUT, MSG='BUDGET_GROUP ERROR: FAILED TO LOCATE BUDGET GROUP WITH NAME "'//GROUP(IDX)//'" WITHIN LIST OF NAMED BUDGET GROUPS'//BLN//'THIS ERROR OCCURED FOR THE PACKAGE THAT HAS THE DEFAULT BUDGET GROUP NAME "'//BD%PAK//'"')
             !
             IF (ALLOCATED(BD%GID(IG)%IDX)) THEN
                                              ALLOCATE( TMP, SOURCE=[BD%GID(IG)%IDX, IDX] )
                                              CALL MOVE_ALLOC(TMP,BD%GID(IG)%IDX)
             ELSE
                                              ALLOCATE( BD%GID(IG)%IDX(1), SOURCE=IDX )
             END IF
             
        ELSE
             IG = ONE
        END IF
        !
        BD%DIM(IG) = BD%DIM(IG) + ONE
        !
    END DO
    !
  END SUBROUTINE
  !
  FUNCTION BUDGET_GROUPS_GET_NEXT_INDEX( BD, IGRP, IDX ) RESULT (LOC)
    CLASS(BUDGET_GROUP),   INTENT(INOUT):: BD
    INTEGER,               INTENT(IN   ):: IGRP, IDX
    INTEGER:: LOC
    !
    IF ( BD%BUDGET_GROUPS ) THEN
         LOC = BD%GID(IGRP)%IDX(IDX)
    ELSE
         LOC = IDX
    END IF
    !
  END FUNCTION
  !
  FUNCTION BUDGET_GROUPS_GET_GROUP_NUMBER( BD, GRP ) RESULT (IGRP)
    CLASS(BUDGET_GROUP),   INTENT(IN):: BD
    CHARACTER(16),         INTENT(IN):: GRP
    INTEGER:: IGRP
    INTEGER:: I
    !
    IF ( BD%BUDGET_GROUPS ) THEN
         IGRP = Z
         DO CONCURRENT (I=1:BD%NGRP, BD%GRP(I)==GRP)
             IGRP = I
         END DO
         IF( IGRP == Z) CALL STOP_ERROR(OUTPUT=BD%IOUT, MSG='BUDGET_GROUP ERROR: FAILED TO LOCATE BUDGET GROUP WITH NAME "'//GRP//'" WITHIN LIST OF NAMED BUDGET GROUPS'//BLN//'THIS ERROR OCCURED FOR THE PACKAGE THAT HAS THE DEFAULT BUDGET GROUP NAME "'//BD%PAK//'"')
    ELSE
             IGRP = ONE
    END IF
    !
  END FUNCTION
  !
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_BUDGET_GROUPS(BD)
    CLASS(BUDGET_GROUP),   INTENT(INOUT):: BD
      BD%IOUT=Z
      BD%NGRP=Z
      BD%BUDGET_GROUPS = FALSE
      IF(ALLOCATED(BD%GRP)) DEALLOCATE(BD%GRP)
      IF(ALLOCATED(BD%GID)) DEALLOCATE(BD%GID)
      IF(ALLOCATED(BD%DIM)) DEALLOCATE(BD%DIM)
  END SUBROUTINE
  !
  SUBROUTINE FINAL_DEALLOCATE_BUDGET_GROUPS(BD)
    TYPE(BUDGET_GROUP),   INTENT(INOUT):: BD
      CALL DEALLOCATE_BUDGET_GROUPS(BD)
  END SUBROUTINE
  !
  !!!PURE SUBROUTINE BUDGET_GROUPS_DEALLOCATE(BD)
  !!!  TYPE(BUDGET_GROUP),ALLOCATABLE,INTENT(INOUT):: BD
  !!!  INTEGER:: I
  !!!  !
  !!!  DEALLOCATE(BD, STAT=I)
  !!!  !
  !!!END SUBROUTINE
  !!!!
  !!!PURE SUBROUTINE BUDGET_GROUPS_DEPOINT(BD)
  !!!  TYPE(BUDGET_GROUP),POINTER,INTENT(INOUT):: BD
  !!!  INTEGER:: I
  !!!  !
  !!!  DEALLOCATE(BD, STAT=I)
  !!!  !
  !!!END SUBROUTINE
  !
!  SUBROUTINE BUDGET_GROUPS_PREPARE_FOR_GROUP_RELOAD( BD )
!    CLASS(BUDGET_GROUP), INTENT(INOUT):: BD
!    INTEGER:: I
!    !
!    BD%IDX%DIM = 0
!    IF (BD%BUDGET_GROUPS) THEN
!        DO I=1, UBOUND(BD,1)
!            IF(ALLOCATED(BD%IDX(I))) DEALLOCATE(BD%IDX(I))
!        END DO
!    ELSE
!        BD%IDX(1)%I(1) = 0
!    END IF
!    !
END MODULE
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!  !
! CODE DEVELOPED BY SCOTT E BOYCE
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
! MODULE LISTING:
!
!   ULOAD_AND_SFAC_INTERFACE
!
!   TRANSIENT_FILE_READER_INSTRUCTION
!
!   LIST_ARRAY_INPUT_INTERFACE
!
!   SUB_BLOCK_INPUT_INTERFACE
!
!
MODULE ULOAD_AND_SFAC_INTERFACE
  ! THIS ROUTINE DOES *NOT* CHECK FOR SFAC, IT ONLY LOADS A LIST OF DATA.  --CHECK FOR SFAC FIRST WITH SFAC MODULE
  !
  ! PROVIDES A GENERIC INERFACE THAT LOADS IN EITHER AN ARRAY, VECTOR, OR SINGLE VALUE (SCALAR)
  ! PASSES IN THE UNIT NUMBER OF THE FILE AS INFILE.
  !      IF THIS IS SET FOR ZERO
  !      IT WILL CHECK FOR KEYWORD (INTERNAL,EXTERNAL, OPEN/CLOSE) AND IF THAT IS NOT FOUND THEN IT ASSUMES DATA IS WITHING "LN".
  !      IF NONZERO INFILE THEN IT WILL LOAD FROM THAT FILE UNIT NUMBER.
  !
  ! ASSUMES FILE STRUCTURE IS AS FOLLOWS:
  ! FOR ARRAY:
  ! ID_11  VAL_11  VAL_12 ... VAL_1N
  ! ID_21  VAL_21  VAL_22 ... VAL_2N
  ! ...
  ! ID_N1  VAL_N1  VAL_N2 ... VAL_NN
  !
  ! FOR VECTOR:
  ! ID_1  VAL_1
  ! ID_2  VAL_2
  ! ...
  ! ID_N  VAL_N
  !
  ! FOR SCALAR:
  ! ID_1  VAL_1
  ! ID_1  VAL_1
  ! ...
  ! ID_1  VAL_1
  !
  ! WHERE "ID" can be anything is skipped by the code. (typically used as a Farm ID or Crop ID)
  ! VAL represent the values that are either loaded into the provided array, vector or scalar.
  !
  ! SFAC IS:
  ! SKIPS PAST ONE WORD (TYPICALLY SFAC) AND THEN READS IN OPTIONAL KEYWORDS AND EITHER LOADS 1 VALUE OR A VECTOR
  ! CAN INTERPRET KEYWORDS THAT ARE PASSED WITH PASSED VECTOR SIZES
  ! ACCEPTS OPTIONS SUCH AS "OPEN/CLOSE" AND "EXTERNAL" OR ASSUMES INFORMAT IS LOCATED WITHIN PASSED CHARACTER STRING "LN"
  !
  USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: REAL32, REAL64, REAL128 !CHARACTER_STORAGE_SIZE
  !
  USE CONSTANTS
  USE SORT_INTERFACE
  USE ARRAY_DATA_TYPES,              ONLY: INTEGER_VECTOR, CHARACTER_TYPE
  USE UTIL_INTERFACE,                ONLY: READ_TO_DATA, FILE_IO_ERROR, STOP_ERROR, WARNING_MESSAGE,  &
                                           UPPER, COMMENT_INDEX, CHECK_FOR_POST_KEY,                    &
                                           GET_DATE, GET_NUMBER, GET_INTEGER, GET_WORD,                 &
                                           PARSE_WORD_UP, PARSE_WORD, IS_BLANK, SET_SEQUENCE
  USE NUM2STR_INTERFACE,             ONLY: NUM2STR
  USE ALLOC_INTERFACE,               ONLY: ALLOC
  USE DATE_OPERATOR_INSTRUCTION,     ONLY: DATE_OPERATOR
  USE GENERIC_INPUT_FILE_INSTRUCTION,ONLY: GENERIC_INPUT_FILE
  USE GENERIC_OPEN_INTERFACE,        ONLY: UTF8_BOM_OFFSET_REWIND
  USE TIME_SERIES_INSTRUCTION,       ONLY: TIME_SERIES_FILE
  USE LOOKUP_TABLE_INSTRUCTION,      ONLY: LOOKUP_TABLE_TYPE
  USE IXJ_INSTRUCTION,               ONLY: IXJ_STRUCTURE
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: SFAC_DATA, ULOAD !, ULOAD_ARRAY, ULOAD_VECTOR, ULOAD_SCALAR
  !
  !
  INTERFACE ULOAD
                      MODULE PROCEDURE ULOAD_SCALAR           !(VAR, LLOC, LN, IOUT, IN, IU, NOID, BINARY, ID,                     NOSTOP, SFAC, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM,               SCRATCH, ENTIRE_LINE, NO_INTERNAL, NO_BINARY)
                      MODULE PROCEDURE ULOAD_VECTOR           !(VAR, LLOC, LN, IOUT, IN, IU, NOID, BINARY, ID, ROW_WORD,           NOSTOP, SFAC, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM,               SCRATCH, ENTIRE_LINE, NO_INTERNAL, NO_BINARY)
                      MODULE PROCEDURE ULOAD_ARRAY            !(VAR, LLOC, LN, IOUT, IN, IU, NOID, BINARY, ID, ROW_WORD, COL_WORD, NOSTOP, SFAC, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM, READ_BY_DIM2, SCRATCH,              NO_INTERNAL, NO_BINARY)
  END INTERFACE
  !
  TYPE SFAC_DATA
      !LOGICAL:: HAS_EXTERNAL
      !
      LOGICAL:: HAS_ALL = FALSE
      LOGICAL:: HAS_ROW = FALSE
      LOGICAL:: HAS_COL = FALSE
      LOGICAL:: HAS_EX1 = FALSE
      LOGICAL:: HAS_EX2 = FALSE
      LOGICAL:: HAS_EX3 = FALSE
      REAL(REAL64),              ALLOCATABLE:: ALL
      REAL(REAL64), DIMENSION(:),ALLOCATABLE:: ROW
      REAL(REAL64), DIMENSION(:),ALLOCATABLE:: COL
      REAL(REAL64), DIMENSION(:),ALLOCATABLE:: EX1
      REAL(REAL64), DIMENSION(:),ALLOCATABLE:: EX2
      REAL(REAL64), DIMENSION(:),ALLOCATABLE:: EX3
      !INTEGER,                       ALLOCATABLE:: IU_ALL, IU_ROW, IU_COL, IU_EX1, IU_EX2
      !LOGICAL                                   :: NEW_ALL, NEW_ROW, NEW_COL, NEW_EX1, NEW_EX2
      !
      CONTAINS
      !
      PROCEDURE, PASS(SFAC):: INIT   => SFAC_INITIALIZE
      PROCEDURE, PASS(SFAC):: LOAD   => SFAC_READ_AND_RETURN   !(LN, IN, IOUT, ROW_WORD, ROW_DIM, COL_WORD, COL_DIM, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM, SKIP_SFAC, SCRATCH, NO_INTERNAL) !MUST INCLUDE ROW_WORD AND ROW_DIM TOGETHER AND/OR COL_WORD AND COL_DIM TOGETHER WHEN CALLLING
      PROCEDURE, PASS(SFAC):: SET_ALL=> SFAC_SET_ANOTHER_ALL
      !PROCEDURE, PASS(SFAC):: INIT_ALL=> SFAC_INIT_ALL         !(SCALE) --redundant subroutine
      !PROCEDURE, PASS(SFAC):: NEXT   => SFAC_READ_NEXT_EXTERNAL!(IOUT)
      GENERIC::               APPLY  => SFAC_APPLY_TO_SCALAR, SFAC_APPLY_TO_VECTOR, SFAC_APPLY_TO_ARRAY!, SFAC_APPLY_TO_SCALAR_REAL, SFAC_APPLY_TO_VECTOR_REAL, SFAC_APPLY_TO_ARRAY_REAL
      GENERIC::        ASSIGNMENT(=) => COPY_SFAC_TO_SFAC
      GENERIC::        OPERATOR(*)   => PRODUCT_SFAC_TO_SFAC
      GENERIC::        OPERATOR(/)   => DIVISOR_SFAC_TO_SFAC
      !
      PROCEDURE, PRIVATE, PASS(SFAC)::  SFAC_APPLY_TO_SCALAR
      PROCEDURE, PRIVATE, PASS(SFAC)::  SFAC_APPLY_TO_VECTOR
      PROCEDURE, PRIVATE, PASS(SFAC)::  SFAC_APPLY_TO_ARRAY
      !PROCEDURE, PRIVATE, PASS(SFAC)::  SFAC_APPLY_TO_SCALAR_REAL
      !PROCEDURE, PRIVATE, PASS(SFAC)::  SFAC_APPLY_TO_VECTOR_REAL
      !PROCEDURE, PRIVATE, PASS(SFAC)::  SFAC_APPLY_TO_ARRAY_REAL
      PROCEDURE, PRIVATE            ::  COPY_SFAC_TO_SFAC
      PROCEDURE, PRIVATE            ::  PRODUCT_SFAC_TO_SFAC
      PROCEDURE, PRIVATE            ::  DIVISOR_SFAC_TO_SFAC
      !
      PROCEDURE, PASS(SFAC):: DESTROY=> SFAC_INITIALIZE      !INIT DOES THE SAME AS DESTROY
      FINAL::                           FINAL_SFAC_DEALLOCATE
  END TYPE
  !
  TYPE SFAC_DATA_TRANSIENT
      TYPE(SFAC_DATA)::SF_NEW
      TYPE(SFAC_DATA)::SF_OLD
      INTEGER:: IU
      LOGICAL:: TRANSIENT
      LOGICAL:: OPENCLOSE
  END TYPE
  !
  CONTAINS
  !
  PURE ELEMENTAL SUBROUTINE COPY_SFAC_TO_SFAC(SFAC_OUT, SFAC_IN)
    CLASS(SFAC_DATA),INTENT(INOUT)::SFAC_OUT
    CLASS(SFAC_DATA),INTENT(IN   )::SFAC_IN
    !
    CALL SFAC_INITIALIZE(SFAC_OUT)
    !
    !SFAC_OUT%HAS_EXTERNAL = SFAC_IN%HAS_EXTERNAL
    !
    SFAC_OUT%HAS_ALL = SFAC_IN%HAS_ALL
    SFAC_OUT%HAS_ROW = SFAC_IN%HAS_ROW
    SFAC_OUT%HAS_COL = SFAC_IN%HAS_COL
    SFAC_OUT%HAS_EX1 = SFAC_IN%HAS_EX1
    SFAC_OUT%HAS_EX2 = SFAC_IN%HAS_EX2
    SFAC_OUT%HAS_EX3 = SFAC_IN%HAS_EX3
    !SFAC_OUT%NEW_ALL = SFAC_IN%NEW_ALL
    !SFAC_OUT%NEW_ROW = SFAC_IN%NEW_ROW
    !SFAC_OUT%NEW_COL = SFAC_IN%NEW_COL
    !SFAC_OUT%NEW_EX1 = SFAC_IN%NEW_EX1
    !SFAC_OUT%NEW_EX2 = SFAC_IN%NEW_EX2
    !
    IF( SFAC_IN%HAS_ALL         ) ALLOCATE(SFAC_OUT%ALL   , SOURCE = SFAC_IN%ALL   )
    IF( SFAC_IN%HAS_ROW         ) ALLOCATE(SFAC_OUT%ROW   , SOURCE = SFAC_IN%ROW   )
    IF( SFAC_IN%HAS_COL         ) ALLOCATE(SFAC_OUT%COL   , SOURCE = SFAC_IN%COL   )
    IF( SFAC_IN%HAS_EX1         ) ALLOCATE(SFAC_OUT%EX1   , SOURCE = SFAC_IN%EX1   )
    IF( SFAC_IN%HAS_EX2         ) ALLOCATE(SFAC_OUT%EX2   , SOURCE = SFAC_IN%EX2   )
    IF( SFAC_IN%HAS_EX3         ) ALLOCATE(SFAC_OUT%EX3   , SOURCE = SFAC_IN%EX3   )
    !IF(ALLOCATED(SFAC_IN%IU_ALL)) ALLOCATE(SFAC_OUT%IU_ALL, SOURCE = SFAC_IN%IU_ALL)
    !IF(ALLOCATED(SFAC_IN%IU_ROW)) ALLOCATE(SFAC_OUT%IU_ROW, SOURCE = SFAC_IN%IU_ROW)
    !IF(ALLOCATED(SFAC_IN%IU_COL)) ALLOCATE(SFAC_OUT%IU_COL, SOURCE = SFAC_IN%IU_COL)
    !IF(ALLOCATED(SFAC_IN%IU_EX1)) ALLOCATE(SFAC_OUT%IU_EX1, SOURCE = SFAC_IN%IU_EX1)
    !IF(ALLOCATED(SFAC_IN%IU_EX2)) ALLOCATE(SFAC_OUT%IU_EX2, SOURCE = SFAC_IN%IU_EX2)
    !
  END SUBROUTINE
  !
  ELEMENTAL PURE FUNCTION PRODUCT_SFAC_TO_SFAC(SF1, SF2) RESULT(SFAC)
    CLASS(SFAC_DATA),INTENT(IN)::SF1
    CLASS(SFAC_DATA),INTENT(IN)::SF2
    TYPE(SFAC_DATA):: SFAC
    !
    CALL COPY_SFAC_TO_SFAC(SFAC, SF1)
    !
    IF(.NOT. SF1%HAS_ALL     ) SFAC%HAS_ALL = SF2%HAS_ALL
    IF(.NOT. SF1%HAS_ROW     ) SFAC%HAS_ROW = SF2%HAS_ROW
    IF(.NOT. SF1%HAS_COL     ) SFAC%HAS_COL = SF2%HAS_COL
    IF(.NOT. SF1%HAS_EX1     ) SFAC%HAS_EX1 = SF2%HAS_EX1
    IF(.NOT. SF1%HAS_EX2     ) SFAC%HAS_EX2 = SF2%HAS_EX2
    IF(.NOT. SF1%HAS_EX3     ) SFAC%HAS_EX3 = SF2%HAS_EX3
    !
    IF(ALLOCATED(SFAC%ALL   ) .AND. SF2%HAS_ALL) THEN
                                                     SFAC%ALL = SFAC%ALL * SF2%ALL
    ELSEIF(SF2%HAS_ALL) THEN
                                                     ALLOCATE(SFAC%ALL   , SOURCE = SF2%ALL   )
    END IF
    !
    IF(ALLOCATED(SFAC%ROW   ) .AND. SF2%HAS_ROW) THEN
                                                     SFAC%ROW = SFAC%ROW * SF2%ROW
    ELSEIF(SF2%HAS_ROW) THEN
                                                     ALLOCATE(SFAC%ROW   , SOURCE = SF2%ROW   )
    END IF
    !
    IF(ALLOCATED(SFAC%COL   ) .AND. SF2%HAS_COL) THEN
                                                     SFAC%COL = SFAC%COL * SF2%COL
    ELSEIF(SF2%HAS_COL) THEN
                                                     ALLOCATE(SFAC%COL   , SOURCE = SF2%COL   )
    END IF
    !
    IF(ALLOCATED(SFAC%EX1   ) .AND. SF2%HAS_EX1) THEN
                                                     SFAC%EX1 = SFAC%EX1 * SF2%EX1
    ELSEIF(SF2%HAS_EX1) THEN
                                                     ALLOCATE(SFAC%EX1   , SOURCE = SF2%EX1   )
    END IF
    !
    IF(ALLOCATED(SFAC%EX2   ) .AND. SF2%HAS_EX2) THEN
                                                     SFAC%EX2 = SFAC%EX2 * SF2%EX2
    ELSEIF(SF2%HAS_EX2) THEN
                                                     ALLOCATE(SFAC%EX2   , SOURCE = SF2%EX2   )
    END IF
    !
    IF(ALLOCATED(SFAC%EX3   ) .AND. SF2%HAS_EX3) THEN
                                                     SFAC%EX3 = SFAC%EX3 * SF2%EX3
    ELSEIF(SF2%HAS_EX3) THEN
                                                     ALLOCATE(SFAC%EX3   , SOURCE = SF2%EX3   )
    END IF
    !
    !IF(ALLOCATED(SFAC%IU_ALL)) DEALLOCATE(SFAC%IU_ALL)
    !IF(ALLOCATED(SFAC%IU_ROW)) DEALLOCATE(SFAC%IU_ROW)
    !IF(ALLOCATED(SFAC%IU_COL)) DEALLOCATE(SFAC%IU_COL)
    !IF(ALLOCATED(SFAC%IU_EX1)) DEALLOCATE(SFAC%IU_EX1)
    !IF(ALLOCATED(SFAC%IU_EX2)) DEALLOCATE(SFAC%IU_EX2)
    !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION DIVISOR_SFAC_TO_SFAC(SF1, SF2) RESULT(SFAC)
    CLASS(SFAC_DATA),INTENT(IN)::SF1
    CLASS(SFAC_DATA),INTENT(IN)::SF2
    TYPE(SFAC_DATA):: SFAC
    !
    CALL COPY_SFAC_TO_SFAC(SFAC, SF1)
    !
    IF(.NOT. SF1%HAS_ALL     ) SFAC%HAS_ALL = SF2%HAS_ALL
    IF(.NOT. SF1%HAS_ROW     ) SFAC%HAS_ROW = SF2%HAS_ROW
    IF(.NOT. SF1%HAS_COL     ) SFAC%HAS_COL = SF2%HAS_COL
    IF(.NOT. SF1%HAS_EX1     ) SFAC%HAS_EX1 = SF2%HAS_EX1
    IF(.NOT. SF1%HAS_EX2     ) SFAC%HAS_EX2 = SF2%HAS_EX2
    IF(.NOT. SF1%HAS_EX3     ) SFAC%HAS_EX3 = SF2%HAS_EX3
    !
    IF(ALLOCATED(SFAC%ALL   ) .AND. SF2%HAS_ALL) THEN
                                                     IF(SF2%ALL.NE.DZ) THEN
                                                              SFAC%ALL = SFAC%ALL / SF2%ALL
                                                     ELSE
                                                              SFAC%ALL = DZ
                                                     END IF
    ELSEIF(SF2%HAS_ALL) THEN
                                                     IF(SF2%ALL.NE.DZ) THEN
                                                              ALLOCATE(SFAC%ALL   , SOURCE = UNO / SF2%ALL   )
                                                     ELSE
                                                              ALLOCATE(SFAC%ALL   , SOURCE = DZ   )
                                                     END IF
    END IF
    !
    IF(ALLOCATED(SFAC%ROW   ) .AND. SF2%HAS_ROW) THEN
                                                     WHERE(SF2%ROW.NE.DZ)
                                                              SFAC%ROW = SFAC%ROW / SF2%ROW
                                                     ELSEWHERE
                                                              SFAC%ROW = DZ
                                                     END WHERE
    ELSEIF(SF2%HAS_ROW) THEN
                                                     ALLOCATE(SFAC%ROW,  MOLD = SF2%ROW   )
                                                     WHERE(SF2%ROW.NE.DZ)
                                                              SFAC%ROW = UNO / SF2%ROW
                                                     ELSEWHERE
                                                              SFAC%ROW = DZ
                                                     END WHERE
    END IF
    !
    IF(ALLOCATED(SFAC%COL   ) .AND. SF2%HAS_COL) THEN
                                                     WHERE(SF2%COL.NE.DZ)
                                                              SFAC%COL = SFAC%COL / SF2%COL
                                                     ELSEWHERE
                                                              SFAC%COL = DZ
                                                     END WHERE
    ELSEIF(SF2%HAS_COL) THEN
                                                     ALLOCATE(SFAC%COL,  MOLD = SF2%COL   )
                                                     WHERE(SF2%COL.NE.DZ)
                                                              SFAC%COL = UNO / SF2%COL
                                                     ELSEWHERE
                                                              SFAC%COL = DZ
                                                     END WHERE
    END IF
    !
    IF(ALLOCATED(SFAC%EX1   ) .AND. SF2%HAS_EX1) THEN
                                                     WHERE(SF2%EX1.NE.DZ)
                                                              SFAC%EX1 = SFAC%EX1 / SF2%EX1
                                                     ELSEWHERE
                                                              SFAC%EX1 = DZ
                                                     END WHERE
    ELSEIF(SF2%HAS_EX1) THEN
                                                     ALLOCATE(SFAC%EX1,  MOLD = SF2%EX1   )
                                                     WHERE(SF2%EX1.NE.DZ)
                                                              SFAC%EX1 = UNO / SF2%EX1
                                                     ELSEWHERE
                                                              SFAC%EX1 = DZ
                                                     END WHERE
    END IF
    !
    IF(ALLOCATED(SFAC%EX2   ) .AND. SF2%HAS_EX2) THEN
                                                     WHERE(SF2%EX2.NE.DZ)
                                                              SFAC%EX2 = SFAC%EX2 / SF2%EX2
                                                     ELSEWHERE
                                                              SFAC%EX2 = DZ
                                                     END WHERE
    ELSEIF(SF2%HAS_EX2) THEN
                                                     ALLOCATE(SFAC%EX2,  MOLD = SF2%EX2   )
                                                     WHERE(SF2%EX2.NE.DZ)
                                                              SFAC%EX2 = UNO / SF2%EX2
                                                     ELSEWHERE
                                                              SFAC%EX2 = DZ
                                                     END WHERE
    END IF
    !
    IF(ALLOCATED(SFAC%EX3   ) .AND. SF2%HAS_EX3) THEN
                                                     WHERE(SF2%EX3.NE.DZ)
                                                              SFAC%EX3 = SFAC%EX3 / SF2%EX3
                                                     ELSEWHERE
                                                              SFAC%EX3 = DZ
                                                     END WHERE
    ELSEIF(SF2%HAS_EX3) THEN
                                                     ALLOCATE(SFAC%EX3,  MOLD = SF2%EX3   )
                                                     WHERE(SF2%EX3.NE.DZ)
                                                              SFAC%EX3 = UNO / SF2%EX3
                                                     ELSEWHERE
                                                              SFAC%EX3 = DZ
                                                     END WHERE
    END IF
    !
    !IF(ALLOCATED(SFAC%IU_ALL)) DEALLOCATE(SFAC%IU_ALL)
    !IF(ALLOCATED(SFAC%IU_ROW)) DEALLOCATE(SFAC%IU_ROW)
    !IF(ALLOCATED(SFAC%IU_COL)) DEALLOCATE(SFAC%IU_COL)
    !IF(ALLOCATED(SFAC%IU_EX1)) DEALLOCATE(SFAC%IU_EX1)
    !IF(ALLOCATED(SFAC%IU_EX2)) DEALLOCATE(SFAC%IU_EX2)
    !
  END FUNCTION
  !
  PURE ELEMENTAL SUBROUTINE SFAC_INITIALIZE(SFAC)
    CLASS(SFAC_DATA),INTENT(INOUT)::SFAC
    !
    !SFAC%HAS_EXTERNAL =FALSE
    !
    SFAC%HAS_ALL = FALSE
    SFAC%HAS_ROW = FALSE
    SFAC%HAS_COL = FALSE
    SFAC%HAS_EX1 = FALSE
    SFAC%HAS_EX2 = FALSE
    SFAC%HAS_EX3 = FALSE
    !SFAC%NEW_ALL = FALSE
    !SFAC%NEW_ROW = FALSE
    !SFAC%NEW_COL = FALSE
    !SFAC%NEW_EX1 = FALSE
    !SFAC%NEW_EX2 = FALSE
    !
    IF(ALLOCATED(SFAC%ALL   )) DEALLOCATE(SFAC%ALL)
    IF(ALLOCATED(SFAC%ROW   )) DEALLOCATE(SFAC%ROW)
    IF(ALLOCATED(SFAC%COL   )) DEALLOCATE(SFAC%COL)
    IF(ALLOCATED(SFAC%EX1   )) DEALLOCATE(SFAC%EX1)
    IF(ALLOCATED(SFAC%EX2   )) DEALLOCATE(SFAC%EX2)
    IF(ALLOCATED(SFAC%EX3   )) DEALLOCATE(SFAC%EX3)
    !IF(ALLOCATED(SFAC%IU_ALL)) DEALLOCATE(SFAC%IU_ALL)
    !IF(ALLOCATED(SFAC%IU_ROW)) DEALLOCATE(SFAC%IU_ROW)
    !IF(ALLOCATED(SFAC%IU_COL)) DEALLOCATE(SFAC%IU_COL)
    !IF(ALLOCATED(SFAC%IU_EX1)) DEALLOCATE(SFAC%IU_EX1)
    !IF(ALLOCATED(SFAC%IU_EX2)) DEALLOCATE(SFAC%IU_EX2)
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE FINAL_SFAC_DEALLOCATE(SFAC)
    TYPE(SFAC_DATA),INTENT(INOUT)::SFAC
    !
    CALL SFAC_INITIALIZE(SFAC)
    !
  END SUBROUTINE
  !
  RECURSIVE SUBROUTINE SFAC_READ_AND_RETURN(SFAC, LN, IN, IOUT, ROW_WORD, ROW_DIM, COL_WORD, COL_DIM, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM, SKIP_SFAC, SCRATCH, NO_INTERNAL) !MUST INCLUDE ROW_WORD AND ROW_DIM TOGETHER AND/OR COL_WORD AND COL_DIM TOGETHER WHEN CALLLING
    !
    CLASS(SFAC_DATA),INTENT(INOUT)::SFAC
    CHARACTER(*),    INTENT(INOUT):: LN
    INTEGER,         INTENT(IN   ):: IN, IOUT
    CHARACTER(*),    INTENT(IN   ), OPTIONAL:: ROW_WORD, COL_WORD
    INTEGER,         INTENT(IN   ), OPTIONAL:: ROW_DIM,  COL_DIM
    !
    CHARACTER(*),    INTENT(IN   ), OPTIONAL:: EX1_WORD, EX2_WORD, EX3_WORD
    INTEGER,         INTENT(IN   ), OPTIONAL:: EX1_DIM,  EX2_DIM,  EX3_DIM
    INTEGER,         INTENT(IN   ), OPTIONAL:: SCRATCH
    !
    LOGICAL,         INTENT(IN   ),OPTIONAL:: SKIP_SFAC, NO_INTERNAL
    INTEGER:: IU
    INTEGER:: LLOC, ISTART, ISTOP, OLDLOC, INFILE
    LOGICAL:: INCLUDE_SFAC, HAS_ROW, HAS_COL, HAS_ALL, HAS_EX1, HAS_EX2, HAS_EX3, EOL
    CHARACTER(:), ALLOCATABLE:: RWORD, CWORD, EXKEY1, EXKEY2, EXKEY3
    REAL(REAL64), DIMENSION(:), ALLOCATABLE:: TMP
    REAL(REAL64):: TMP_ALL
    !
    HAS_ROW      = FALSE
    HAS_COL      = FALSE
    HAS_ALL      = FALSE
    HAS_EX1      = FALSE
    HAS_EX2      = FALSE
    HAS_EX3      = FALSE
    !
    IF(PRESENT(SCRATCH)) THEN
        IF(SCRATCH.NE. Z) THEN
                              INFILE = SCRATCH
        ELSE
                              INFILE = IN
        END IF
    ELSE
        INFILE = IN
    END IF
    !
    IF(PRESENT(ROW_WORD)) THEN
        ALLOCATE(RWORD, SOURCE=ROW_WORD)
    ELSE
        ALLOCATE(RWORD, SOURCE='nR')
    END IF
    !
    IF(PRESENT(COL_WORD)) THEN
        ALLOCATE(CWORD, SOURCE=COL_WORD)
    ELSE
        ALLOCATE(CWORD, SOURCE='nC')
    END IF
    !
    IF(PRESENT(EX1_WORD)) THEN
        ALLOCATE(EXKEY1, SOURCE=EX1_WORD)
    ELSE
        ALLOCATE(EXKEY1, SOURCE='n1')
    END IF
    !
    IF(PRESENT(EX2_WORD)) THEN
        ALLOCATE(EXKEY2, SOURCE=EX2_WORD)
    ELSE
        ALLOCATE(EXKEY2, SOURCE='n2')
    END IF
    !
    IF(PRESENT(EX3_WORD)) THEN
        ALLOCATE(EXKEY3, SOURCE=EX3_WORD)
    ELSE
        ALLOCATE(EXKEY3, SOURCE='n3')
    END IF
    !
    IF(PRESENT(SKIP_SFAC)) THEN
        INCLUDE_SFAC = .NOT. SKIP_SFAC
    ELSE
        INCLUDE_SFAC = TRUE
    END IF
    !
    !
    LLOC = ONE
    IF(INCLUDE_SFAC) CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,TRUE,TRUE)  !BYPASS SFAC (or any keyword that started this subroutine)
    !
    CALL PARSE_WORD_UP(LN,LLOC,ISTART,ISTOP,TRUE, OLD_LOC=OLDLOC, EOL=EOL)
    !
    IF (IS_BLANK( LN(ISTART:ISTOP) ) .OR. EOL) THEN
                                                 CALL READ_TO_DATA(LN,IU,IOUT)
                                                 LLOC = ONE
                                                 OLDLOC = ONE
                                                 CALL PARSE_WORD_UP(LN,LLOC,ISTART,ISTOP,TRUE)
    END IF
    !
    IF     (LN(ISTART:ISTOP)== RWORD) THEN
                                                  HAS_ROW = TRUE
    ELSEIF (LN(ISTART:ISTOP)== CWORD) THEN
                                                  HAS_COL = TRUE
    ELSEIF (LN(ISTART:ISTOP)== "ALL") THEN
                                                  HAS_ALL = TRUE
    ELSEIF (LN(ISTART:ISTOP)== EXKEY1) THEN
                                                  HAS_EX1 = TRUE
    ELSEIF (LN(ISTART:ISTOP)== EXKEY2) THEN
                                                  HAS_EX2 = TRUE
    ELSEIF (LN(ISTART:ISTOP)== EXKEY3) THEN
                                                  HAS_EX3 = TRUE
    ELSE
            HAS_ALL = TRUE
            LLOC = OLDLOC
    END IF
    !
    !IF (HAS_ROW .AND. SFAC%HAS_ROW) CALL FILE_IO_ERROR( Z, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'SFAC FOUND WITH KEYWORD '//RWORD//' THAT WAS SPECIFIED TWICE WITHIN BLOCK OR STRESS PERIOD.')
    !IF (HAS_COL .AND. SFAC%HAS_COL) CALL FILE_IO_ERROR( Z, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'SFAC FOUND WITH KEYWORD '//CWORD//' THAT WAS SPECIFIED TWICE WITHIN BLOCK OR STRESS PERIOD.')
    !IF (HAS_ALL .AND. SFAC%HAS_ALL) CALL FILE_IO_ERROR( Z, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'SFAC FOUND THAT IS APPLIED TO ALL PROPERTIES HAS BEEN CALLED TWICE WITHIN BLOCK OR STRESS PERIOD.')
    !IF (HAS_EX1 .AND. SFAC%HAS_EX1) CALL FILE_IO_ERROR( Z, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'SFAC FOUND WITH KEYWORD '//EXKEY1//' THAT WAS SPECIFIED TWICE WITHIN BLOCK OR STRESS PERIOD.')
    !IF (HAS_EX2 .AND. SFAC%HAS_EX2) CALL FILE_IO_ERROR( Z, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'SFAC FOUND WITH KEYWORD '//EXKEY2//' THAT WAS SPECIFIED TWICE WITHIN BLOCK OR STRESS PERIOD.')
    !IF (HAS_EX3 .AND. SFAC%HAS_EX3) CALL FILE_IO_ERROR( Z, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'SFAC FOUND WITH KEYWORD '//EXKEY3//' THAT WAS SPECIFIED TWICE WITHIN BLOCK OR STRESS PERIOD.')
    !
    IU = Z
    IF     (HAS_ROW) THEN
                         ALLOCATE( TMP(ROW_DIM) )
                         CALL ULOAD_VECTOR(TMP, LLOC, LN, IOUT, IN, IU, SCRATCH=SCRATCH, NO_INTERNAL=NO_INTERNAL)
                         IF(SFAC%HAS_ROW) THEN
                             SFAC%ROW = SFAC%ROW * TMP
                         ELSE
                             CALL MOVE_ALLOC(TMP,SFAC%ROW)
                             SFAC%HAS_ROW = TRUE
                         END IF
                         !
                         !!!WHERE(SFAC%ROW == DZ) SFAC%ROW = UNO
                         !IF(IU.NE.Z) ALLOCATE(SFAC%IU_ROW, SOURCE=IU)
                         !SFAC%NEW_ROW = TRUE
                         !
    ELSEIF (HAS_COL) THEN
                         ALLOCATE( TMP(COL_DIM) )
                         CALL ULOAD_VECTOR(TMP, LLOC, LN, IOUT, IN, IU, SCRATCH=SCRATCH, NO_INTERNAL=NO_INTERNAL)
                         IF(SFAC%HAS_COL) THEN
                             SFAC%COL = SFAC%COL * TMP
                         ELSE
                             CALL MOVE_ALLOC(TMP,SFAC%COL)
                             SFAC%HAS_COL = TRUE
                         END IF
                         !
                         !!!WHERE(SFAC%COL == DZ) SFAC%COL = UNO
                         !IF(IU.NE.Z) ALLOCATE(SFAC%IU_COL, SOURCE=IU)
                         !SFAC%NEW_COL = TRUE
                         !
    ELSEIF (HAS_ALL) THEN
                         CALL ULOAD_SCALAR(TMP_ALL, LLOC, LN, IOUT, IN, IU, SCRATCH=SCRATCH, NO_INTERNAL=NO_INTERNAL)
                         IF(SFAC%HAS_ALL) THEN
                             SFAC%ALL = SFAC%ALL * TMP_ALL
                         ELSE
                             ALLOCATE(SFAC%ALL, SOURCE=TMP_ALL)
                             SFAC%HAS_ALL = TRUE
                         END IF
                         !
                         !!!IF(SFAC%ALL == DZ) SFAC%ALL = UNO
                         !IF(IU.NE.Z) ALLOCATE(SFAC%IU_ALL, SOURCE=IU)
                         !SFAC%NEW_ALL = TRUE
    ELSEIF (HAS_EX1) THEN
                         ALLOCATE( TMP(EX1_DIM) )
                         CALL ULOAD_VECTOR(TMP, LLOC, LN, IOUT, IN, IU, SCRATCH=SCRATCH, NO_INTERNAL=NO_INTERNAL)
                         IF(SFAC%HAS_EX1) THEN
                             SFAC%EX1 = SFAC%EX1 * TMP
                         ELSE
                             CALL MOVE_ALLOC(TMP,SFAC%EX1)
                             SFAC%HAS_EX1 = TRUE
                         END IF
                         !
                         !!!WHERE(SFAC%EX1 == DZ) SFAC%EX1 = UNO
                         !IF(IU.NE.Z) ALLOCATE(SFAC%IU_EX1, SOURCE=IU)
                         !SFAC%NEW_EX1 = TRUE
                         !
    ELSEIF (HAS_EX2) THEN
                         ALLOCATE( TMP(EX2_DIM) )
                         CALL ULOAD_VECTOR(TMP, LLOC, LN, IOUT, IN, IU, SCRATCH=SCRATCH, NO_INTERNAL=NO_INTERNAL)
                         IF(SFAC%HAS_EX2) THEN
                             SFAC%EX2 = SFAC%EX2 * TMP
                         ELSE
                             CALL MOVE_ALLOC(TMP,SFAC%EX2)
                             SFAC%HAS_EX2 = TRUE
                         END IF
                         !
                         !!!WHERE(SFAC%EX2 == DZ) SFAC%EX2 = UNO
                         !IF(IU.NE.Z) ALLOCATE(SFAC%IU_EX2, SOURCE=IU)
                         !SFAC%NEW_EX2 = TRUE
                         !
    ELSEIF (HAS_EX3) THEN
                         ALLOCATE( TMP(EX3_DIM) )
                         CALL ULOAD_VECTOR(TMP, LLOC, LN, IOUT, IN, IU, SCRATCH=SCRATCH, NO_INTERNAL=NO_INTERNAL)
                         IF(SFAC%HAS_EX3) THEN
                             SFAC%EX3 = SFAC%EX3 * TMP
                         ELSE
                             CALL MOVE_ALLOC(TMP,SFAC%EX3)
                             SFAC%HAS_EX3 = TRUE
                         END IF
                         !
                         !!!WHERE(SFAC%EX3 == DZ) SFAC%EX3 = UNO
                         !IF(IU.NE.Z) ALLOCATE(SFAC%IU_EX3, SOURCE=IU)
                         !SFAC%NEW_EX3 = TRUE
                         !
    END IF
    !
    !IF(IU.NE.Z) SFAC%HAS_EXTERNAL = TRUE
    IF(ALLOCATED(TMP)) DEALLOCATE(TMP)
    !
    END SUBROUTINE
  !
!  SUBROUTINE SFAC_READ_NEXT_EXTERNAL(SFAC, REMOVE_OLD, IOUT, NOSTOP)
!    CLASS(SFAC_DATA),INTENT(INOUT):: SFAC
!    LOGICAL,         INTENT(IN   ):: REMOVE_OLD, NOSTOP
!    INTEGER,         INTENT(IN   ):: IOUT
!    INTEGER:: LLOC, Z
!    CHARACTER(:), ALLOCATABLE:: LN
!    DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE:: DIV
!    DOUBLE PRECISION:: DIV_ALL, DZ
!    !
!    SFAC%NEW_ALL = .FALSE.
!    SFAC%NEW_ROW = .FALSE.
!    SFAC%NEW_COL = .FALSE.
!    SFAC%NEW_EX1 = .FALSE.
!    SFAC%NEW_EX2 = .FALSE.
!    !
!    IF(SFAC%HAS_EXTERNAL) THEN
!          !
!          Z = 0
!          DZ = 0D0
!          ALLOCATE(CHARACTER(700)::LN)
!          !
!          IF (ALLOCATED(SFAC%IU_ROW)) THEN
!                                         IF(REMOVE_OLD) ALLOCATE(DIV, SOURCE=SFAC%ROW)
!                                         LLOC = 1
!                                         CALL ULOAD_VECTOR(SFAC%ROW, LLOC, LN, IOUT, SFAC%IU_ROW, SFAC%IU_ROW, NOSTOP=NOSTOP)
!                                         !
!                                         IF(SFAC%IU_ROW.NE.Z) SFAC%NEW_ROW = .TRUE.
!                                         IF(SFAC%IU_ROW == Z) THEN  !FAILED TO LOAD NEXT EXTERNAL, KEEP OLD SFAC
!                                                      SFAC%ROW =  DIV
!                                         ELSEIF(REMOVE_OLD) THEN
!                                                      WHERE ( DIV .NE. DZ) SFAC%ROW = SFAC%ROW / DIV
!                                                      DEALLOCATE(DIV)
!                                         END IF
!          END IF
!          !
!          IF (ALLOCATED(SFAC%IU_COL)) THEN
!                                         IF(REMOVE_OLD) ALLOCATE(DIV, SOURCE=SFAC%COL)
!                                         LLOC = 1
!                                         CALL ULOAD_VECTOR(SFAC%COL, LLOC, LN, IOUT, SFAC%IU_COL, SFAC%IU_COL, NOSTOP=NOSTOP)
!                                         !
!                                         IF(SFAC%IU_COL.NE.Z) SFAC%NEW_COL = .TRUE.
!                                         IF(SFAC%IU_COL == Z) THEN  !FAILED TO LOAD NEXT EXTERNAL, KEEP OLD SFAC
!                                                      SFAC%COL =  DIV
!                                         ELSEIF(REMOVE_OLD) THEN
!                                                      WHERE ( DIV .NE. DZ) SFAC%COL = SFAC%COL / DIV
!                                                      DEALLOCATE(DIV)
!                                         END IF
!          END IF
!          !
!          IF (ALLOCATED(SFAC%IU_ALL)) THEN
!                                         IF(REMOVE_OLD) DIV_ALL = SFAC%ALL
!                                         LLOC = 1
!                                         CALL ULOAD_SCALAR(SFAC%ALL, LLOC, LN, IOUT, SFAC%IU_ALL, SFAC%IU_ALL, NOSTOP=NOSTOP)
!                                         !
!                                         IF(SFAC%IU_ALL.NE.Z) SFAC%NEW_ALL = .TRUE.
!                                         IF(SFAC%IU_ALL == Z ) THEN
!                                             SFAC%ALL = DIV_ALL
!                                         ELSEIF(REMOVE_OLD .AND. DIV_ALL .NE. DZ) THEN
!                                             SFAC%ALL = SFAC%ALL / DIV_ALL
!                                         END IF
!          END IF
!          !
!          IF (ALLOCATED(SFAC%IU_EX1)) THEN
!                                         IF(REMOVE_OLD) ALLOCATE(DIV, SOURCE=SFAC%EX1)
!                                         LLOC = 1
!                                         CALL ULOAD_VECTOR(SFAC%EX1, LLOC, LN, IOUT, SFAC%IU_EX1, SFAC%IU_EX1, NOSTOP=NOSTOP)
!                                         !
!                                         IF(SFAC%IU_EX1.NE.Z) SFAC%NEW_EX1 = .TRUE.
!                                         IF(SFAC%IU_EX1 == Z) THEN  !FAILED TO LOAD NEXT EXTERNAL, KEEP OLD SFAC
!                                                      SFAC%EX1 =  DIV
!                                         ELSEIF(REMOVE_OLD) THEN
!                                                      WHERE ( DIV .NE. DZ) SFAC%EX1 = SFAC%EX1 / DIV
!                                                      DEALLOCATE(DIV)
!                                         END IF
!          END IF
!          !
!          IF (ALLOCATED(SFAC%IU_EX2)) THEN
!                                         IF(REMOVE_OLD) ALLOCATE(DIV, SOURCE=SFAC%EX2)
!                                         LLOC = 1
!                                         CALL ULOAD_VECTOR(SFAC%EX2, LLOC, LN, IOUT, SFAC%IU_EX2, SFAC%IU_EX2, NOSTOP=NOSTOP)
!                                         !
!                                         IF(SFAC%IU_EX2.NE.Z) SFAC%NEW_EX2 = .TRUE.
!                                         IF(SFAC%IU_EX2 == Z) THEN  !FAILED TO LOAD NEXT EXTERNAL, KEEP OLD SFAC
!                                                      SFAC%EX2 =  DIV
!                                         ELSEIF(REMOVE_OLD) THEN
!                                                      WHERE ( DIV .NE. DZ) SFAC%EX2 = SFAC%EX2 / DIV
!                                                      DEALLOCATE(DIV)
!                                         END IF
!          END IF
!          DEALLOCATE(LN)
!    END IF
!    !
!  END SUBROUTINE
  !
  PURE SUBROUTINE SFAC_SET_ANOTHER_ALL(SFAC, SCALE)
    CLASS(SFAC_DATA), INTENT(INOUT):: SFAC
    REAL(REAL64),     INTENT(IN   ):: SCALE
    !
    IF(SCALE.NE.UNO) THEN
                      IF(SFAC%HAS_ALL) THEN
                          SFAC%ALL = SFAC%ALL * SCALE
                      ELSE
                          ALLOCATE(SFAC%ALL, SOURCE=SCALE)
                          SFAC%HAS_ALL = TRUE
                      END IF
    END IF
    !
  END SUBROUTINE
  !
  !PURE SUBROUTINE SFAC_INIT_ALL(SFAC, SCALE)
  !  CLASS(SFAC_DATA), INTENT(INOUT):: SFAC
  !  REAL(REAL64),     INTENT(IN   ):: SCALE
  !  !
  !  IF(SFAC%HAS_ALL .AND. SCALE.NE.UNO) THEN
  !      SFAC%ALL = SFAC%ALL * SCALE
  !  ELSE
  !      ALLOCATE(SFAC%ALL, SOURCE=SCALE)
  !      SFAC%HAS_ALL = TRUE
  !  END IF
  !  !
  !END SUBROUTINE
  !

  !
  PURE SUBROUTINE SFAC_APPLY_TO_SCALAR(SFAC, VAR)
    CLASS(SFAC_DATA), INTENT(INOUT):: SFAC
    CLASS(*),     INTENT(INOUT):: VAR
    !
    SELECT TYPE(VAR)
    TYPE IS (REAL(REAL64 ))  ! DOUBLE PRECISION
        IF (SFAC%HAS_ALL) VAR = VAR * SFAC%ALL
        !
        IF (SFAC%HAS_ROW) VAR = VAR * PRODUCT(SFAC%ROW) !GET PRODUCT
        !
        IF (SFAC%HAS_COL) VAR = VAR * PRODUCT(SFAC%COL)
    TYPE IS (REAL(REAL32 ))  ! SINGLE PRECISION
        IF (SFAC%HAS_ALL) VAR = VAR * SFAC%ALL
        !
        IF (SFAC%HAS_ROW) VAR = VAR * PRODUCT(SFAC%ROW) !GET PRODUCT
        !
        IF (SFAC%HAS_COL) VAR = VAR * PRODUCT(SFAC%COL)
    TYPE IS (REAL(REAL128))  ! QUAD   PRECISION
        IF (SFAC%HAS_ALL) VAR = VAR * SFAC%ALL
        !
        IF (SFAC%HAS_ROW) VAR = VAR * PRODUCT(SFAC%ROW) !GET PRODUCT
        !
        IF (SFAC%HAS_COL) VAR = VAR * PRODUCT(SFAC%COL)
    END SELECT
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SFAC_APPLY_TO_VECTOR(SFAC, VAR)
    CLASS(SFAC_DATA),                          INTENT(INOUT):: SFAC
    CLASS(*),        DIMENSION(:), CONTIGUOUS, INTENT(INOUT):: VAR
    !
    SELECT TYPE(VAR)
    TYPE IS (REAL(REAL64 ))  ! DOUBLE PRECISION
        IF (SFAC%HAS_ALL) VAR = VAR * SFAC%ALL
        !
        IF (SFAC%HAS_ROW) VAR = VAR * SFAC%ROW
        !
        IF (SFAC%HAS_COL) VAR = VAR * SFAC%COL  !ASSUMES COL IS SAME SIZE AS VAR
    TYPE IS (REAL(REAL32 ))  ! SINGLE PRECISION
        IF (SFAC%HAS_ALL) VAR = VAR * SFAC%ALL
        !
        IF (SFAC%HAS_ROW) VAR = VAR * SFAC%ROW
        !
        IF (SFAC%HAS_COL) VAR = VAR * SFAC%COL  !ASSUMES COL IS SAME SIZE AS VAR
    TYPE IS (REAL(REAL128))  ! QUAD   PRECISION
        IF (SFAC%HAS_ALL) VAR = VAR * SFAC%ALL
        !
        IF (SFAC%HAS_ROW) VAR = VAR * SFAC%ROW
        !
        IF (SFAC%HAS_COL) VAR = VAR * SFAC%COL  !ASSUMES COL IS SAME SIZE AS VAR
    END SELECT
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SFAC_APPLY_TO_ARRAY(SFAC, VAR, ROW_ON_DIM1)
    CLASS(SFAC_DATA),                     INTENT(INOUT):: SFAC
    CLASS(*), DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: VAR
    LOGICAL,          OPTIONAL,           INTENT(IN   ):: ROW_ON_DIM1
    LOGICAL:: ROW_DIM1
    INTEGER:: I
    !
    ROW_DIM1 = FALSE
    IF(PRESENT(ROW_ON_DIM1)) ROW_DIM1 = ROW_ON_DIM1
    !
    !
    SELECT TYPE(VAR)
    TYPE IS (REAL(REAL64 ))  ! DOUBLE PRECISION
        !
        IF (SFAC%HAS_ALL) VAR = VAR * SFAC%ALL
        !
        IF (SFAC%HAS_ROW) THEN
              IF(ROW_DIM1) THEN
                   DO I=1, SIZE(VAR,1)
                       VAR(:,I) = VAR(:,I) * SFAC%ROW
                   END DO
              ELSE
                   DO I=1, UBOUND(VAR,1)
                       VAR(I,:) = VAR(I,:) * SFAC%ROW
                   END DO
              END IF
        END IF
        !
        IF (SFAC%HAS_COL) THEN
              IF(ROW_DIM1) THEN
                   DO I=1, UBOUND(VAR,2)
                       VAR(I,:) = VAR(I,:) * SFAC%COL
                   END DO
              ELSE
                   DO I=1, SIZE(VAR,2)
                       VAR(:,I) = VAR(:,I) * SFAC%COL
                   END DO
              END IF
        END IF
    TYPE IS (REAL(REAL32 ))  ! SINGLE PRECISION
        !
        IF (SFAC%HAS_ALL) VAR = VAR * SFAC%ALL
        !
        IF (SFAC%HAS_ROW) THEN
              IF(ROW_DIM1) THEN
                   DO I=1, SIZE(VAR,1)
                       VAR(:,I) = VAR(:,I) * SFAC%ROW
                   END DO
              ELSE
                   DO I=1, UBOUND(VAR,1)
                       VAR(I,:) = VAR(I,:) * SFAC%ROW
                   END DO
              END IF
        END IF
        !
        IF (SFAC%HAS_COL) THEN
              IF(ROW_DIM1) THEN
                   DO I=1, UBOUND(VAR,2)
                       VAR(I,:) = VAR(I,:) * SFAC%COL
                   END DO
              ELSE
                   DO I=1, SIZE(VAR,2)
                       VAR(:,I) = VAR(:,I) * SFAC%COL
                   END DO
              END IF
        END IF
    TYPE IS (REAL(REAL128))  ! QUAD   PRECISION
        !
        IF (SFAC%HAS_ALL) VAR = VAR * SFAC%ALL
        !
        IF (SFAC%HAS_ROW) THEN
              IF(ROW_DIM1) THEN
                   DO I=1, SIZE(VAR,1)
                       VAR(:,I) = VAR(:,I) * SFAC%ROW
                   END DO
              ELSE
                   DO I=1, UBOUND(VAR,1)
                       VAR(I,:) = VAR(I,:) * SFAC%ROW
                   END DO
              END IF
        END IF
        !
        IF (SFAC%HAS_COL) THEN
              IF(ROW_DIM1) THEN
                   DO I=1, UBOUND(VAR,2)
                       VAR(I,:) = VAR(I,:) * SFAC%COL
                   END DO
              ELSE
                   DO I=1, SIZE(VAR,2)
                       VAR(:,I) = VAR(:,I) * SFAC%COL
                   END DO
              END IF
        END IF
    END SELECT
    !
  END SUBROUTINE
  !
!!!  PURE SUBROUTINE SFAC_APPLY_TO_SCALAR(SFAC, VAR)
!!!    CLASS(SFAC_DATA), INTENT(INOUT):: SFAC
!!!    DOUBLE PRECISION, INTENT(INOUT):: VAR
!!!    !
!!!    IF (SFAC%HAS_ALL) VAR = VAR * SFAC%ALL
!!!    !
!!!    IF (SFAC%HAS_ROW) VAR = VAR * PRODUCT(SFAC%ROW) !GET PRODUCT
!!!    !
!!!    IF (SFAC%HAS_COL) VAR = VAR * PRODUCT(SFAC%COL)
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  PURE SUBROUTINE SFAC_APPLY_TO_VECTOR(SFAC, VAR)
!!!    CLASS(SFAC_DATA),                           INTENT(INOUT):: SFAC
!!!    DOUBLE PRECISION, DIMENSION(:), CONTIGUOUS, INTENT(INOUT):: VAR
!!!    !
!!!    IF (SFAC%HAS_ALL) VAR = VAR * SFAC%ALL
!!!    !
!!!    IF (SFAC%HAS_ROW) VAR = VAR * SFAC%ROW
!!!    !
!!!    IF (SFAC%HAS_COL) VAR = VAR * SFAC%COL  !ASSUMES COL IS SAME SIZE AS VAR
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  PURE SUBROUTINE SFAC_APPLY_TO_ARRAY(SFAC, VAR, ROW_ON_DIM1)
!!!    CLASS(SFAC_DATA),                             INTENT(INOUT):: SFAC
!!!    DOUBLE PRECISION, DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: VAR
!!!    LOGICAL,          OPTIONAL,                   INTENT(IN   ):: ROW_ON_DIM1
!!!    LOGICAL:: ROW_DIM1
!!!    INTEGER:: I
!!!    !
!!!    ROW_DIM1 = FALSE
!!!    IF(PRESENT(ROW_ON_DIM1)) ROW_DIM1 = ROW_ON_DIM1
!!!    !
!!!    IF (SFAC%HAS_ALL) VAR = VAR * SFAC%ALL
!!!    !
!!!    IF (SFAC%HAS_ROW) THEN
!!!          IF(ROW_DIM1) THEN
!!!               DO I=1, SIZE(VAR,1)
!!!                   VAR(:,I) = VAR(:,I) * SFAC%ROW
!!!               END DO
!!!          ELSE
!!!               DO I=1, UBOUND(VAR,1)
!!!                   VAR(I,:) = VAR(I,:) * SFAC%ROW
!!!               END DO
!!!          END IF
!!!    END IF
!!!    !
!!!    IF (SFAC%HAS_COL) THEN
!!!          IF(ROW_DIM1) THEN
!!!               DO I=1, UBOUND(VAR,2)
!!!                   VAR(I,:) = VAR(I,:) * SFAC%COL
!!!               END DO
!!!          ELSE
!!!               DO I=1, SIZE(VAR,2)
!!!                   VAR(:,I) = VAR(:,I) * SFAC%COL
!!!               END DO
!!!          END IF
!!!    END IF
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  PURE SUBROUTINE SFAC_APPLY_TO_SCALAR_REAL(SFAC, VAR)
!!!    CLASS(SFAC_DATA),INTENT(INOUT):: SFAC
!!!    REAL(REAL32),    INTENT(INOUT):: VAR
!!!    !
!!!    IF (SFAC%HAS_ALL) VAR = VAR * SNGL(SFAC%ALL)
!!!    !
!!!    IF (SFAC%HAS_ROW) VAR = VAR * SNGL(PRODUCT(SFAC%ROW)) !GET PRODUCT
!!!    !
!!!    IF (SFAC%HAS_COL) VAR = VAR * SNGL(PRODUCT(SFAC%COL))
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  PURE SUBROUTINE SFAC_APPLY_TO_VECTOR_REAL(SFAC, VAR)
!!!    CLASS(SFAC_DATA),                       INTENT(INOUT):: SFAC
!!!    REAL(REAL32), DIMENSION(:), CONTIGUOUS, INTENT(INOUT):: VAR
!!!    !
!!!    IF (SFAC%HAS_ALL) VAR = VAR * SNGL(SFAC%ALL)
!!!    !
!!!    IF (SFAC%HAS_ROW) VAR = VAR * SNGL(SFAC%ROW)
!!!    !
!!!    IF (SFAC%HAS_COL) VAR = VAR * SNGL(SFAC%COL)  !ASSUMES COL IS SAME SIZE AS VAR
!!!    !
!!!  END SUBROUTINE
!!!  !
!!!  PURE SUBROUTINE SFAC_APPLY_TO_ARRAY_REAL(SFAC, VAR, ROW_ON_DIM1)
!!!    CLASS(SFAC_DATA),                         INTENT(INOUT):: SFAC
!!!    REAL(REAL32), DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: VAR
!!!    LOGICAL,                      OPTIONAL,   INTENT(IN   ):: ROW_ON_DIM1
!!!    LOGICAL:: ROW_DIM1
!!!    INTEGER:: I
!!!    !
!!!    ROW_DIM1 = FALSE
!!!    IF(PRESENT(ROW_ON_DIM1)) ROW_DIM1 = ROW_ON_DIM1
!!!    !
!!!    IF (SFAC%HAS_ALL) VAR = VAR * SFAC%ALL
!!!    !
!!!    IF (SFAC%HAS_ROW) THEN
!!!          IF(ROW_DIM1) THEN
!!!               DO I=1, SIZE(VAR,1)
!!!                   VAR(:,I) = VAR(:,I) * SNGL(SFAC%ROW)
!!!               END DO
!!!          ELSE
!!!               DO I=1, UBOUND(VAR,1)
!!!                   VAR(I,:) = VAR(I,:) * SNGL(SFAC%ROW)
!!!               END DO
!!!          END IF
!!!    END IF
!!!    !
!!!    IF (SFAC%HAS_COL) THEN
!!!          IF(ROW_DIM1) THEN
!!!               DO I=1, UBOUND(VAR,2)
!!!                   VAR(I,:) = VAR(I,:) * SNGL(SFAC%COL)
!!!               END DO
!!!          ELSE
!!!               DO I=1, SIZE(VAR,2)
!!!                   VAR(:,I) = VAR(:,I) * SNGL(SFAC%COL)
!!!               END DO
!!!          END IF
!!!    END IF
!!!    !
!!!  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !
  RECURSIVE SUBROUTINE ULOAD_SCALAR(VAR, LLOC, LN, IOUT, IN, IU, NOID, BINARY, ID, NOSTOP, SFAC, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM, SCRATCH, ENTIRE_LINE, NO_INTERNAL, NO_BINARY, NO_REPEAT, OLD_IU, TEXT, MSG)
    CLASS(*),                  INTENT(INOUT):: VAR       !Variable to set by ULOAD
    INTEGER,                   INTENT(INOUT):: LLOC      !SET TO -1 IF CHARACTER::VAR IS NOT LONG ENOUGH TO HOLD INPUT
    CHARACTER(*),              INTENT(INOUT):: LN        !Temp line to holds read input that is processed
    INTEGER,                   INTENT(IN   ):: IN, IOUT  !File that input originated from; error output location
    INTEGER,                   INTENT(INOUT):: IU        ! If IU=0 input is dermined from directives in IN or SCRATCH, IU.NE.0 indicates input is on that file unit. Same as IN having a LN = "EXTERNAL IU"
    !
    LOGICAL,         OPTIONAL, INTENT(IN   ):: NOID, BINARY, NOSTOP
    INTEGER,         OPTIONAL, INTENT(INOUT):: ID
    TYPE(SFAC_DATA), OPTIONAL, INTENT(  OUT):: SFAC
    !
    CHARACTER(*),    OPTIONAL, INTENT(IN   ):: EX1_WORD, EX2_WORD, EX3_WORD
    INTEGER,         OPTIONAL, INTENT(IN   ):: EX1_DIM,  EX2_DIM,  EX3_DIM
    INTEGER,         OPTIONAL, INTENT(IN   ):: SCRATCH
    LOGICAL,         OPTIONAL, INTENT(IN   ):: ENTIRE_LINE, NO_INTERNAL, NO_BINARY, NO_REPEAT
    INTEGER,         OPTIONAL, INTENT(INOUT):: OLD_IU
    CHARACTER(*),    OPTIONAL, INTENT(IN   ):: TEXT
    CHARACTER(*),    OPTIONAL, INTENT(IN   ):: MSG
    !
    TYPE(SFAC_DATA):: SF!1, SF2
    !
    INTEGER:: IERR, ISTART, ISTOP, I, N, INFILE, ERROR_IU, LINELEN
    TYPE(GENERIC_INPUT_FILE), ALLOCATABLE:: FL
    LOGICAL:: KEEP_IU, READ_ID, BIN, ALLOW_ERROR, CLEAR_IU, READ_FULL_LINE, NO_INTERN, NEG_LLOC, NO_MAIN_KEY
    REAL(REAL64):: SFAC_FILE, CONST !ENSURE ITS ALWAYS DOUBLE PRECISION
    CHARACTER(12):: EXT, FORM_CHK
    !
    IERR = Z
    NEG_LLOC  = FALSE
    SFAC_FILE = UNO
    ERROR_IU = IN
    NO_MAIN_KEY=FALSE
    !
    IF(PRESENT(SCRATCH)) THEN
        IF(SCRATCH.NE. Z) THEN
                              INFILE = SCRATCH
        ELSE
                              INFILE = IN
        END IF
    ELSE
        INFILE = IN
    END IF
    !
    IF(PRESENT(ID)) ID = Z
    !
    IF(PRESENT(NOID)) THEN
        READ_ID = .NOT. NOID
    ELSE
        READ_ID = TRUE
    END IF
    !
    IF(PRESENT(BINARY)) THEN
        BIN = BINARY
    ELSE
        BIN = FALSE
    END IF
    !
    IF(PRESENT(NOSTOP)) THEN
        ALLOW_ERROR = .NOT. NOSTOP
    ELSE
        ALLOW_ERROR = TRUE
    END IF
    !
    IF(PRESENT(ENTIRE_LINE)) THEN
        READ_FULL_LINE = ENTIRE_LINE
    ELSE
        READ_FULL_LINE = FALSE
    END IF
    !
    IF(PRESENT(NO_INTERNAL)) THEN
        NO_INTERN = NO_INTERNAL
    ELSE
        NO_INTERN = FALSE
    END IF
    !
    SELECT TYPE (VAR)
    TYPE IS (CHARACTER(*));  LINELEN = LEN(VAR)
    TYPE IS (IXJ_STRUCTURE); READ_ID = FALSE
    END SELECT
    !
    CLEAR_IU = FALSE
    IF(IU.NE.Z) THEN
                    INQUIRE(IU,FORM=FORM_CHK, OPENED=KEEP_IU)
                    IF(.NOT. KEEP_IU) CALL STOP_ERROR( LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ULOAD ERROR: RECIEVED UNIT NUMBER "'//NUM2STR(IU)//'" WHICH IS NOT ASSOCIATED WITH A FILE. THIS COULD BE THE RESULT OF USING "EXTERNAL" OR "DATAUNIT" WITH A UNIT THAT IS NOT OPENED BY THE NAME FILE.', MSG2=MSG)
                    BIN = FORM_CHK .NE. 'FORMATTED'
                    !
                    ERROR_IU = IU
                    KEEP_IU  = TRUE
                    LLOC     = ONE
                    IF(.NOT. ALLOW_ERROR) CLEAR_IU = TRUE
                    IF(.NOT. BIN) CALL READ_TO_DATA(LN,IU,IOUT)  !UNIT IS BEING PASSED IN SO READ IN LINE FROM IT
    ELSE
                    KEEP_IU = FALSE
    END IF
    !
    CALL SF%INIT()
    IF(PRESENT(SFAC)) CALL SFAC%INIT()
    !
    IF(.NOT. BIN) THEN
                      DO !CHECK FOR KEYWORD OF SFAC BEFORE LIST
                           N = LLOC
                           I = COMMENT_INDEX(LN)
                           CALL PARSE_WORD(LN(:I),LLOC,ISTART,ISTOP)   !GET VALUE
                           EXT = LN(ISTART:ISTOP)
                           CALL UPPER(EXT)
                           IF (EXT == 'SFAC') THEN
                               IF(IU==Z) THEN
                                             CALL SFAC_READ_AND_RETURN(SF, LN(N:), IN, IOUT, EX1_WORD=EX1_WORD, EX1_DIM=EX1_DIM, EX2_WORD=EX2_WORD, EX2_DIM=EX2_DIM, EX3_WORD=EX3_WORD, EX3_DIM=EX3_DIM, SCRATCH=SCRATCH)
                                             CALL READ_TO_DATA(LN,INFILE,IOUT)
                               ELSE
                                             CALL SFAC_READ_AND_RETURN(SF, LN(N:), IU, IOUT, EX1_WORD=EX1_WORD, EX1_DIM=EX1_DIM, EX2_WORD=EX2_WORD, EX2_DIM=EX2_DIM, EX3_WORD=EX3_WORD, EX3_DIM=EX3_DIM)
                                             CALL READ_TO_DATA(LN,IU,IOUT)
                               END IF
                               LLOC = ONE
                           ELSEIF(EXT==BLNK .OR. EXT==COM) THEN  !READ NEXT LINE IF BLANK
                               IF(IU==Z) THEN
                                             CALL READ_TO_DATA(LN,INFILE,IOUT)
                                             IF(LN==BLNK) CALL STOP_ERROR(INFILE=IN,OUTPUT=IOUT,MSG = 'ULOAD FAILED TO LOAD INPUT LINE.'//NL//'THIS MOST LIKELY OCCURED BECAUSE THE END OF FILE WAS REACHED WHILE LOADING INPUT.'//BLN//'POSSIBLE CAUSES ARE NOT ENOUGH STRESS PERIOD INPUT, AN EMPTY FILE,'//NL//'THE INPUT LINE IS EMPTY WHEN A NUMBER WAS EXPECTED,'//NL//'OR YOU SPECIFIED TRANSIENT WHEN YOU MEANT STATIC FOR A LIST-ARRAY INPUT.', MSG2=MSG)
                              ELSE
                                             CALL READ_TO_DATA(LN,IU,IOUT)
                                             IF(LN==BLNK) CALL STOP_ERROR(INFILE=IU,OUTPUT=IOUT,MSG = 'ULOAD FAILED TO LOAD INPUT LINE.'//NL//'THIS MOST LIKELY OCCURED BECAUSE THE END OF FILE WAS REACHED WHILE LOADING INPUT.'//BLN//'POSSIBLE CAUSES ARE NOT ENOUGH STRESS PERIOD INPUT, AN EMPTY FILE,'//NL//'THE INPUT LINE IS EMPTY WHEN A NUMBER WAS EXPECTED,'//NL//'OR YOU SPECIFIED TRANSIENT WHEN YOU MEANT STATIC FOR A LIST-ARRAY INPUT.', MSG2=MSG)
                               END IF
                               LLOC = ONE
                               NO_MAIN_KEY=TRUE
                           ELSE
                               LLOC = N
                               EXIT
                           END IF
                      END DO
    ELSE
                      EXT='BINARY'
    END IF
    !
    SELECT CASE (EXT)
    CASE( 'SKIP', 'NULL', 'NUL' )     !-----------------------------------------------------------------------------------------------------------------------
                       SELECT TYPE (VAR)
                       TYPE IS (REAL(REAL64));     VAR = 0.0_REAL64  ! DOUBLE PRECISION
                       TYPE IS (REAL(REAL32));     VAR = 0.0_REAL32  ! SINGLE PRECISION
                       TYPE IS (INTEGER);          VAR = 0
                       TYPE IS (CHARACTER(*));     VAR = BLNK
                       TYPE IS (CHARACTER_TYPE);   VAR = BLNK
                       TYPE IS (GENERIC_INPUT_FILE)
                                                   CALL VAR%CLOSE() ! CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: THIS INPUT READ UTILITY DOES NOT ALLOW FOR THE KEYWORD "SKIP". PLEASE USE A KEYWORD TO INDICATE WHERE DATA IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)', MSG2=MSG)
                                                   VAR%SKIP = TRUE
                       TYPE IS (TIME_SERIES_FILE);  CALL VAR%INIT('SKIP')
                       TYPE IS (LOOKUP_TABLE_TYPE); CALL VAR%DESTROY()
                       TYPE IS (DATE_OPERATOR);     CALL VAR%DESTROY()
                       TYPE IS (IXJ_STRUCTURE);     CALL VAR%LOAD(Z)
                       TYPE IS (REAL(REAL128));     VAR = 0.0_REAL128 ! QUAD PRECISION
                       END SELECT
                       LLOC = ONE
                       LN = EXT//BLNK//LN
                       RETURN
    CASE( 'CONSTANT' ) !-----------------------------------------------------------------------------------------------------------------------
                       N = LLOC
                       CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
                       CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE)
                       !
                       SELECT TYPE (VAR)
                       TYPE IS (DATE_OPERATOR)
                                                   !VAR = DATE_OPERATOR(LN(ISTART:ISTOP))  --CAUSES COMILER ERROR
                                                   CALL GET_DATE(LN,LLOC,ISTART,ISTOP,IOUT,IN,VAR,NO_PARSE_WORD=TRUE,HAS_ERROR=NEG_LLOC,NO_DATE=TRUE)
                                                   !CALL VAR%INIT(LN(ISTART:ISTOP))
                                                   IF(NEG_LLOC) THEN
                                                       IERR = 123
                                                       NEG_LLOC = TRUE
                                                   ELSE
                                                       IERR = Z
                                                   END IF
                       TYPE IS (GENERIC_INPUT_FILE)
                                                   CALL VAR%OPEN(LN,N, IOUT, IN, REQKEY=TRUE, KEY = EXT)
                                                   VAR%IU = Z !CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: THIS INPUT READ UTILITY DOES NOT ALLOW FOR THE KEYWORD "CONSTANT". PLEASE USE A KEYWORD TO INDICATE WHERE DATA IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)', MSG2=MSG)
                                                   LLOC = ONE
                                                   LN = LN(N:)  !RETURN THE LINE FROM "CONSTANT" ONWARD
                                                   RETURN
                       !TYPE IS (IXJ_STRUCTURE);
                       !                             CALL VAR%LOAD(Z)
                       !                             IERR = ONE
                       !                             IF(ALLOW_ERROR) CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: IXJ STYLE INPUT DOES NOT ALLOW FOR THE KEYWORD "CONSTANT". PLEASE USE A KEYWORD TO INDICATE WHERE DATA IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)', MSG2=MSG)
                       CLASS DEFAULT
                                                   READ(LN(ISTART:ISTOP), *, IOSTAT=IERR) CONST
                       END SELECT
                       !
                       IF(IERR.NE.Z .AND. ALLOW_ERROR)   CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ULOAD FOUND KEYWORD CONSTANT, BUT FAILED TO READ THE CONSTANT VALUE AFTER THE KEYWORD.', MSG2=MSG)
                       IF(IERR.NE.Z .AND. CLEAR_IU)  IU = Z
                       !
                       SELECT TYPE (VAR)
                       TYPE IS (REAL(REAL64));     VAR = CONST                ! DOUBLE PRECISION
                       TYPE IS (REAL(REAL32));     VAR = REAL(CONST,REAL32)   ! SINGLE PRECISION
                       TYPE IS (INTEGER)
                                                   READ(LN(ISTART:ISTOP), *, IOSTAT=IERR) I
                                                   VAR = I
                       TYPE IS (CHARACTER(*))
                                                   IF(READ_FULL_LINE) ISTOP = COMMENT_INDEX(LN)   !GET INDEX WHERE # IS OR LEN_TRIM
                                                   VAR = LN(ISTART:ISTOP)
                                                   IF(LINELEN<LEN_TRIM(LN(ISTART:ISTOP))) NEG_LLOC = TRUE
                       TYPE IS (CHARACTER_TYPE)
                                                   ISTOP = COMMENT_INDEX(LN)   !GET INDEX WHERE # IS OR LEN_TRIM
                                                   N = LEN_TRIM(LN(ISTART:ISTOP))
                                                   VAR = LN(ISTART:N)
                                                   !
                       TYPE IS (TIME_SERIES_FILE); CALL VAR%INIT(CONST)
                                                   !
                       TYPE IS (LOOKUP_TABLE_TYPE);CALL VAR%LOAD(CONST)
                                                   !
                       TYPE IS (IXJ_STRUCTURE);    CALL VAR%LOAD(Z, CONST=CONST)
                                                   !
                       TYPE IS (REAL(REAL128));    VAR = REAL(CONST,REAL128) ! QUAD PRECISION

                       END SELECT
                       !
                       CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,ISTART,ISTOP,SFAC_FILE) !ISTART, ISTOP ARE PLACE HOLDERS FOR BUF AND ISPLIT
                       !
                       IF(SFAC_FILE.NE.UNO) CALL SF%SET_ALL(SFAC_FILE)
                       !
                       IF(PRESENT(SFAC)) THEN
                                             SFAC = SF
                       ELSE
                                             SELECT TYPE (VAR)
                                             TYPE IS (REAL(REAL64));    CALL SF%APPLY(VAR)   ! DOUBLE PRECISION
                                             TYPE IS (REAL(REAL32));    CALL SF%APPLY(VAR)   ! SINGLE PRECISION
                                             TYPE IS (TIME_SERIES_FILE)
                                                                        IF(SF%HAS_ALL) VAR%FL%SCALE = VAR%FL%SCALE*SF%ALL
                                             TYPE IS (LOOKUP_TABLE_TYPE)
                                                                        IF(SF%HAS_ALL) VAR%Y = VAR%Y*SF%ALL
                                             TYPE IS (REAL(REAL128));   CALL SF%APPLY(VAR) ! QUAD PRECISION
                                             END SELECT
                       END IF
                       !
                       LLOC = ONE
                       IF(NEG_LLOC) LLOC = NEG
                       LN = EXT//BLNK//LN
                       RETURN
    CASE( 'REPEAT' )   !-----------------------------------------------------------------------------------------------------------------------
                       !
                       IF(PRESENT(NO_REPEAT)) THEN
                               IF(NO_REPEAT) CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD FOUND KEYWORD "REPEAT" BUT THIS PARTICULAR FEATURE DOES NOT SUPPORT IT.'//NL//'(NOTE APPLYING A SCALE FACTOR WITH SFAC, DOES NOT SUPPORT THIS.)'//NL//'PLEAUSE CHANGE INPUT TO USE OPEN/CLOSE TO RELOAD THE FILE INSTEAD OF REPEATING IT.', MSG2=MSG)
                       END IF
                       !
                       CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
                       CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,ISTART,ISTOP,SFAC_FILE) !ISTART, ISTOP ARE PLACE HOLDERS FOR BUF AND ISPLIT
                       !
                       !SELECT TYPE (VAR)
                       !TYPE IS (GENERIC_INPUT_FILE); VAR%IU = Z  !ZERO OUT UNIT TO INDICATE REPEAT FOUND
                       !END SELECT
                       !
                       IF(SFAC_FILE.NE.UNO) CALL SF%SET_ALL(SFAC_FILE)
                       !
                       IF(PRESENT(SFAC)) THEN
                                             SFAC = SF
                       ELSE
                                             SELECT TYPE (VAR)
                                             TYPE IS (REAL(REAL64));    CALL SF%APPLY(VAR)   ! DOUBLE PRECISION
                                             TYPE IS (REAL(REAL32));    CALL SF%APPLY(VAR)   ! SINGLE PRECISION
                                             TYPE IS (TIME_SERIES_FILE)
                                                                        IF(SF%HAS_ALL) VAR%FL%SCALE = SF%ALL
                                             TYPE IS (GENERIC_INPUT_FILE)
                                                                        IF(SF%HAS_ALL) VAR%SCALE    = SF%ALL
                                             TYPE IS (LOOKUP_TABLE_TYPE)
                                                                        IF(SF%HAS_ALL) THEN
                                                                                      IF(SF%ALL.NE.UNO)CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE LOAD ERROR - ULOAD FOUND KEYWORD "REPEAT" WITH A SCALE FACTOR THAT IS NOT EQUAL TO 1. LOOKUP TABLES IMMEDIATELY APPLY SCALE FACTORS SO THERE IS NO WAY TO KEEP THEM SEPARATE. EITHER RE-SPECIFY LOOKUP TABLE OR REMOVE SFAC OR SCALE.', MSG2=MSG)
                                                                        END IF
                                             TYPE IS (REAL(REAL128));   CALL SF%APPLY(VAR)   ! QUAD PRECISION
                                             END SELECT
                       END IF
                       !
                       LLOC = ONE
                       LN = EXT//BLNK//LN
                       RETURN
    CASE( 'RELOAD' ) !-----------------------------------------------------------------------------------------------------------------------
                       !
                       IF(IU==Z) THEN
                            IF(PRESENT(OLD_IU))  IU = OLD_IU
                            IF(ALLOW_ERROR .AND. (IU==Z .OR. .NOT. PRESENT(OLD_IU))) THEN
                                CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD FOUND KEYWORD "RELOAD" BUT THERE WAS NOT A PREVIOUSLY OPENED FILE TO USE OR THIS INPUT FEATURE DOES NOT SUPPORT THE "RELOAD" KEYWORD.'//NL//'PLEASE MAKE SURE THAT THIS ULOAD WAS PRECEDED BY AN EXTERNAL UNIT, DATAUNIT UNIT, OR DATAFILE FILE'//NL//'SO THT THE FILE CAN BE CONTINUED TO LOAD NEXT INPUT OR CHANGE KEYWORD TO ONE THAT OPENS A FILE OR POINTS TO AN EXISTING OPENED FILE.'//NL//'(e.g. THIS KEYWORD SHOULD ONLY APPEAR IN A TFR AFTER AN EXTERNAL, DATAUNIT, or DATAFILE KEYWORDS TO REUSE THEIR UNIT NUMBERS AND CONTINUE LOADING FROM THEIR FILES)', MSG2=MSG)
                            END IF
                            !
                            IF(IU.NE.Z) THEN
                                                  CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,ISTART,ISTOP,SFAC_FILE) !ISTART, ISTOP ARE PLACE HOLDERS FOR BUF AND ISPLIT
                                                  !
                                                  INQUIRE(IU,FORM=FORM_CHK, OPENED=KEEP_IU)
                                                  IF(.NOT. KEEP_IU) CALL STOP_ERROR(LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ULOAD ERROR: RECIEVED UNIT NUMBER "'//NUM2STR(IU)//'" WHICH IS NOT ASSOCIATED WITH A FILE. THIS COULD BE THE RESULT OF USING "EXTERNAL" OR "DATAUNIT" WITH A UNIT THAT IS NOT OPENED BY THE NAME FILE.', MSG2=MSG)
                                                  BIN = FORM_CHK .NE. 'FORMATTED'
                                                  !
                                                  IF(BIN) THEN
                                                      REWIND(IU) !MOVE BACK TO TOP OF FILE
                                                  ELSE
                                                      CALL UTF8_BOM_OFFSET_REWIND(IU)  !Check in case file has a UTF8 BOM header, rewind to correct location
                                                  END IF
                                                  !
                                                  ERROR_IU = IU
                                                  KEEP_IU  = TRUE
                                                  LLOC     = ONE
                                                  IF(.NOT. ALLOW_ERROR) CLEAR_IU = TRUE
                                                  IF(.NOT. BIN) CALL READ_TO_DATA(LN,IU,IOUT)  !UNIT IS BEING PASSED IN SO READ IN LINE FROM IT
                            END IF
                       ELSE
                            CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD FOUND KEYWORD "RELOAD" BUT THIS INPUT OPTION EITHER DOES NOT SUPPORT RELOAD OR THERE IS A CODE ERROR. PLEASE CHANGE RELOAD TO SOMETHING LIKE "EXTERNAL  55  REWIND"', MSG2=MSG)
                       END IF
    CASE( 'LOAD_NEXT' )!-----------------------------------------------------------------------------------------------------------------------
                       !
                       IF(IU==Z) THEN
                            IF(PRESENT(OLD_IU))  IU = OLD_IU
                            IF(ALLOW_ERROR .AND. (IU==Z .OR. .NOT. PRESENT(OLD_IU))) THEN
                                CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD FOUND KEYWORD "LOAD_NEXT" BUT THERE WAS NOT A PREVIOUSLY OPENED FILE TO USE OR THIS INPUT FEATURE DOES NOT SUPPORT THE "LOAD_NEXT" KEYWORD (viz. SFAC DOES NOT SUPPORT IT).'//NL//'PLEASE MAKE SURE THAT THIS ULOAD WAS PRECEDED BY AN EXTERNAL UNIT, DATAUNIT UNIT, OR DATAFILE FILE'//NL//'SO THT THE FILE CAN BE CONTINUED TO LOAD NEXT INPUT'//NL//'OR CHANGE KEYWORD TO ONE THAT OPENS A FILE OR POINTS TO AN EXISTING OPENED FILE.'//NL//'(e.g. THIS KEYWORD SHOULD ONLY APPEAR IN A TFR AFTER AN EXTERNAL, DATAUNIT, or DATAFILE KEYWORDS TO REUSE THEIR UNIT NUMBERS AND CONTINUE LOADING FROM THEIR FILES)', MSG2=MSG)
                            END IF
                            !
                            IF(IU.NE.Z) THEN
                                                  CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,ISTART,ISTOP,SFAC_FILE) !ISTART, ISTOP ARE PLACE HOLDERS FOR BUF AND ISPLIT
                                                  !
                                                  INQUIRE(IU,FORM=FORM_CHK, OPENED=KEEP_IU)
                                                  IF(.NOT. KEEP_IU) CALL STOP_ERROR(LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ULOAD ERROR: RECIEVED UNIT NUMBER "'//NUM2STR(IU)//'" WHICH IS NOT ASSOCIATED WITH A FILE. THIS COULD BE THE RESULT OF USING "EXTERNAL" OR "DATAUNIT" WITH A UNIT THAT IS NOT OPENED BY THE NAME FILE.', MSG2=MSG)
                                                  BIN = FORM_CHK .NE. 'FORMATTED'
                                                  !
                                                  ERROR_IU = IU
                                                  KEEP_IU  = TRUE
                                                  LLOC     = ONE
                                                  IF(.NOT. ALLOW_ERROR) CLEAR_IU = TRUE
                                                  IF(.NOT. BIN) CALL READ_TO_DATA(LN,IU,IOUT)  !UNIT IS BEING PASSED IN SO READ IN LINE FROM IT
                            END IF
                       ELSE
                            CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD FOUND KEYWORD "LOAD_NEXT" BUT THIS INPUT OPTION EITHER DOES NOT SUPPORT RELOAD OR THERE IS A CODE ERROR. PLEASE CHANGE LOAD_NEXT TO SOMETHING LIKE "DATAFILE MyFile.txt"', MSG2=MSG)
                       END IF
    END SELECT
    !
    ! CHECK IF ONLY LOADING FILE AND NOT DATA
    SELECT TYPE (VAR)
    TYPE IS (GENERIC_INPUT_FILE)
              IF(IU==Z) THEN
                    N = LLOC
                    !
                    CALL VAR%OPEN(LN,LLOC,IOUT,IN,NOSTOP=TRUE,REQKEY=TRUE, BINARY=BIN, KEY = EXT)
                    !
                    NEG_LLOC = EXT=='NOKEY'
              ELSE
                  VAR%IU = IU
                  VAR%OPENCLOSE = FALSE
                  VAR%ERROR     = FALSE
              END IF
              !BIN = VAR%BINARY
              IF(.NOT. VAR%ERROR) THEN
                                        IU = VAR%IU
                                        IF(IU.NE.Z .AND. .NOT. VAR%OPENCLOSE) KEEP_IU = TRUE  !FONUD EXTERNAL KEYWORD, SO PASS BACK WHAT WAS LOADED
                                        IF(IU.NE.Z) ERROR_IU = IU
                                        IF(IU == Z .AND. NO_INTERN) CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: THIS SPECIFIC INPUT LINE DOES NOT ALLOW FOR THE "INTERNAL" KEYWORD OR IMPLIED INTERNAL. PLEASE MOVE INTERNAL INPUT TO SEPARATE FILE AND CHANGE KEYWORD TO "OPEN/CLOSE" OR "EXTERNAL".', MSG2=MSG)
                                        IF(IU == Z) THEN
                                            IU = INFILE  !FOUND INTERNAL
                                            VAR%IU = INFILE
                                            VAR%OPENCLOSE=FALSE
                                            KEEP_IU = TRUE
                                        END IF
              ELSEIF(ALLOW_ERROR) THEN; CALL STOP_ERROR( LINE=LN, INFILE=IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: THIS PARTICULAR INPUT DOES NOT ALLOW AN IMPLIED INTERNAL. PLEASE USE A KEYWORD TO INDICATE WHERE DATA IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)', MSG2=MSG)
              END IF
              !
              IF(.NOT. KEEP_IU) IU = Z
              !
              IF(PRESENT(SFAC)) THEN
                  IF(VAR%SCALE.NE.UNO) CALL SF%SET_ALL(VAR%SCALE)
                  SFAC = SF
                  VAR%SCALE = UNO
              END IF
              !
              !RETURN -- FILE OBJECT LOADED SO DO NOT LOAD INFORMATION TO ALLOW CUSTOM LOADER
              !
    CLASS DEFAULT ! USE NORMAL ULOAD FOR SINGLE SCALAR OF INT, CHAR, DBLE, SNGL
                !
                IF(IU==Z) THEN
                      N = LLOC
                      ALLOCATE(FL)
                      !
                      CALL FL%OPEN(LN,LLOC,IOUT,IN,NOSTOP=TRUE,REQKEY=TRUE,BINARY=BIN)
                      !
                      SFAC_FILE = FL%SCALE
                      FL%SCALE = UNO
                      !
                      BIN = FL%BINARY
                      IF(.NOT. FL%ERROR) THEN
                                             IU = FL%IU
                                             IF(IU.NE.Z .AND. .NOT. FL%OPENCLOSE) KEEP_IU = TRUE  !FONUD EXTERNAL KEYWORD, SO PASS BACK WHAT WAS LOADED
                                             IF(IU.NE.Z) ERROR_IU = IU
                                             IF(IU == Z .AND. NO_INTERN) CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: THIS SPECIFIC INPUT LINE DOES NOT ALLOW FOR THE "INTERNAL" KEYWORD. PLEASE MOVE INTERNAL INPUT TO SEPARATE FILE AND CHANGE KEYWORD TO "OPEN/CLOSE" OR "EXTERNAL" OR INSTEAD USE AN IMPLIED INTERNAL BY HAVING THE INPUT DATA ITEM ON THE SAME LINE.', MSG2=MSG)
                                             IF(IU == Z) IU = INFILE  !FOUND INTERNAL
                                             LLOC = ONE
                                             IF(.NOT. BIN) CALL READ_TO_DATA(LN,IU,IOUT)
                      ELSE !NO KEYWORD FOUND SO DATA IS WITHIN LINE
                          LLOC = N
                          IU = Z
                      END IF
                END IF
                !
                IF(.NOT. BIN .AND. IU.NE.Z) THEN
                                            DO !CHECK FOR KEYWORD OF SFAC WITHIN LIST
                                                  N = LLOC
                                                  CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE)
                                                  EXT = LN(ISTART:ISTOP)
                                                  CALL UPPER(EXT)
                                                  IF (EXT == 'SFAC') THEN
                                                      CALL SFAC_READ_AND_RETURN(SF, LN(N:), IU, IOUT, EX1_WORD=EX1_WORD, EX1_DIM=EX1_DIM, EX2_WORD=EX2_WORD, EX2_DIM=EX2_DIM, EX3_WORD=EX3_WORD, EX3_DIM=EX3_DIM)
                                                      LLOC = ONE
                                                      CALL READ_TO_DATA(LN,IU,IOUT)
                                                  ELSE
                                                      LLOC = N
                                                      EXIT
                                                  END IF
                                            END DO
                END IF
                !
                IF(BIN) THEN
                            !
                            IF(IU==INFILE)                             CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: "INTERNAL" AND "BINARY" KEYWORD FOUND, BUT THIS IS NOT ALLOWED!', MSG2=MSG)
                            IF(PRESENT(NO_BINARY)) THEN; IF(NO_BINARY) CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: "BINARY" KEYWORD FOUND, BUT THIS INPUT PROPERTY DOES NOT SUPPORT BINARY FILE INPUT. PLEASE USE ASCII/TEXT INPUT INSTEAD AND REMOVE "BINARY" KEYWORD.', MSG2=MSG)
                            END IF
                            !
                            SELECT TYPE (VAR)
                            TYPE IS (REAL(REAL64));     READ(IU, IOSTAT=IERR) VAR    ! DOUBLE PRECISION
                            TYPE IS (REAL(REAL32));     READ(IU, IOSTAT=IERR) VAR    ! SINGLE PRECISION
                            TYPE IS (INTEGER);          READ(IU, IOSTAT=IERR) VAR
                            TYPE IS (CHARACTER(*));     READ(IU, IOSTAT=IERR) VAR
                            TYPE IS (DATE_OPERATOR);    READ(IU, IOSTAT=IERR) VAR
                            TYPE IS (TIME_SERIES_FILE); CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: "BINARY" KEYWORD FOUND, BUT THIS INPUT PROPERTY DOES NOT SUPPORT BINARY FILE INPUT. PLEASE USE ASCII/TEXT INPUT INSTEAD AND REMOVE "BINARY" KEYWORD.', MSG2=MSG)
                            TYPE IS (LOOKUP_TABLE_TYPE);CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: "BINARY" KEYWORD FOUND, BUT THIS INPUT PROPERTY DOES NOT SUPPORT BINARY FILE INPUT. PLEASE USE ASCII/TEXT INPUT INSTEAD AND REMOVE "BINARY" KEYWORD.', MSG2=MSG)
                            TYPE IS (CHARACTER_TYPE);   CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: "BINARY" KEYWORD FOUND, BUT THIS INPUT PROPERTY DOES NOT SUPPORT BINARY FILE INPUT. PLEASE USE ASCII/TEXT INPUT INSTEAD AND REMOVE "BINARY" KEYWORD.', MSG2=MSG)
                            TYPE IS (IXJ_STRUCTURE);    CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: "BINARY" KEYWORD FOUND, BUT IXJ STYLE INPUT DOES NOT SUPPORT BINARY FILE INPUT. PLEASE USE ASCII/TEXT INPUT INSTEAD AND REMOVE "BINARY" KEYWORD.', MSG2=MSG)
                            TYPE IS (REAL(REAL128));    READ(IU, IOSTAT=IERR) VAR    ! QUAD PRECISION
                            END SELECT
                            !
                            IF(IERR.NE.Z .AND. ALLOW_ERROR)   CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ATTEMPT MADE TO READ LIST FROM ULOAD IN A BINARY FILE, BUT IT FAILED TO LOAD INPUT DATA.', MSG2=MSG)
                            IF(IERR.NE.Z .AND. CLEAR_IU)  IU = Z
                ELSE
                    IF(IU .NE. Z) THEN  !KEYWORD FOUND SO LOAD IN NEXT LINE
                                      IF(READ_ID) THEN
                                            CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE)
                                            IF(PRESENT(ID)) THEN
                                                           READ(LN(ISTART:ISTOP), *, IOSTAT=IERR)      ID
                                                                                         IF(IERR.NE.Z) ID = Z
                                            END IF
                                      END IF
                                      CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE)
                    ELSE
                                      CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE)
                    END IF
                    !
                    IERR = Z
                    SELECT TYPE (VAR)
                    TYPE IS (REAL(REAL64));     READ(LN(ISTART:ISTOP), *, IOSTAT=IERR) VAR   ! DOUBLE PRECISION
                    TYPE IS (REAL(REAL32));     READ(LN(ISTART:ISTOP), *, IOSTAT=IERR) VAR   ! SINGLE PRECISION
                    TYPE IS (INTEGER);          READ(LN(ISTART:ISTOP), *, IOSTAT=IERR) VAR
                    TYPE IS (CHARACTER(*));
                                                IF(READ_FULL_LINE) ISTOP = COMMENT_INDEX(LN)   !GET INDEX WHERE # IS OR LEN_TRIM
                                                VAR = LN(ISTART:ISTOP)
                                                IF(LINELEN<LEN_TRIM(LN(ISTART:ISTOP))) NEG_LLOC = TRUE
                    TYPE IS (CHARACTER_TYPE)
                                                ISTOP = COMMENT_INDEX(LN)   !GET INDEX WHERE # IS OR LEN_TRIM
                                                N = LEN_TRIM(LN(ISTART:ISTOP))
                                                VAR = LN(ISTART:N)
                    TYPE IS (DATE_OPERATOR)
                                                CALL GET_DATE(LN,LLOC,ISTART,ISTOP,IOUT,IU,VAR,NO_PARSE_WORD=TRUE,HAS_ERROR=NEG_LLOC,NO_DATE=TRUE)
                                                !CALL VAR%INIT(LN(ISTART:ISTOP))
                                                IF(NEG_LLOC) IERR = 123
                    TYPE IS (TIME_SERIES_FILE)
                                                CALL VAR%INIT(LN, LLOC, IOUT, IN, FALSE, DEFAULT_OPT=TEXT)
                    TYPE IS (LOOKUP_TABLE_TYPE)
                                                CALL VAR%LOAD(LLOC,ISTART,ISTOP,LN,IU,IOUT,FALSE)
                                                !
                    TYPE IS (IXJ_STRUCTURE);
                                                IF(IU .NE. Z) THEN
                                                    CALL VAR%LOAD(IU, ERROR_IU, IOUT, TRUE, FIRST_LINE=LN)
                                                    !
                                                    IF(VAR%ERRMSG .NE. BLNK) IERR = ONE
                                                ELSE
                                                    CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: IXJ STYLE INPUT DOES NOT ALLOW FOR "IMPLIED INTERNAL" LOAD. PLEASE USE A KEYWORD TO INDICATE WHERE DATA IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)', MSG2=MSG)
                                                END IF
                                                !
                    TYPE IS (REAL(REAL128));    READ(LN(ISTART:ISTOP), *, IOSTAT=IERR) VAR   ! QUAD PRECISION
                    END SELECT
                    !
                    IF(LN(ISTART:ISTOP) == '') IERR = -1234
                    !
                    IF(IERR.NE.Z .AND. ALLOW_ERROR ) THEN
                           IF(NO_MAIN_KEY) THEN
                                CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ATTEMPT MADE TO READ LIST FROM ULOAD ON LINE, BUT IT FAILED TO LOAD THE FOLLOWING VALUE "'//LN(ISTART:ISTOP)//'"'//BLN//'NOTE THAT NO KEYWORD WAS FOUND ON THE PREVIOUS LINE, SO CODE AUTOMOVED DOWNWARD TO NEXT LINE.'//NL//'YOU MAYBE MISSING A KEYWORD (viz. INTERNAL, EXTERNAL, OPEN/CLOSE, DATEFILE, DATAUNIT).', MSG2=MSG)
                           ELSE
                                SELECT TYPE (VAR)
                                TYPE IS (DATE_OPERATOR);           CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ATTEMPT MADE TO READ A DATE WITH ULOAD ON LINE, BUT IT FAILED TO CONVERT THE FOLLOWING TO A CALENDAR DATE "'//LN(ISTART:ISTOP)//'"'//BLN//'THE ACCEPTED DATE FORMATS ARE "mm/dd/YYYY" OR "YYYY-mm-dd" IF YOU WANT TO ADD A 24-HOUR TIME TO IT YOU MUST ADD TO THE DATE "Thh:mm:ss" (e.g. "YYYY-mm-ddThh:mm:ss")', MSG2=MSG)
                                TYPE IS (GENERIC_INPUT_FILE);      CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ATTEMPT MADE TO OPEN FILE WITH ULOAD, BUT IT FAILED TO EITHER OPEN, FIND THE FILE, OR IS NOT SET UP CORRECTLY. THE FOLLOWING IS THE FILE THAT WAS ATTEMPTED TO BE OPENED "'//LN(ISTART:ISTOP)//'".', MSG2=MSG)
                                TYPE IS (IXJ_STRUCTURE);           CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR OCCURRED WILE LOADING IXJ INPUT. THE FOLLOWING IS AN ERROR MESSAGE FROM THE IXJ LOADER:'//BLN//VAR%ERRMSG, MSG2=MSG)
                                CLASS DEFAULT
                                                                   CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ATTEMPTED TO READ A SINGLE VALUE WITHIN THE FOLLOWING "'//LN(ISTART:ISTOP)//'", BUT IT FAILED TO LOAD INTO OneWater. PLEASE CHECK INPUT TO MAKE SURE FORMAT IS WHAT IS EXPECTED.', MSG2=MSG)
                                END SELECT
                           END IF
                    ELSEIF(IERR.NE.Z .AND. CLEAR_IU) THEN
                           IU = Z
                    END IF
                    !
                END IF
                !
                IF(SFAC_FILE.NE.UNO) CALL SF%SET_ALL(SFAC_FILE)
                !
                IF(PRESENT(SFAC)) THEN
                                       SFAC = SF
                ELSE
                                       SELECT TYPE (VAR)
                                       TYPE IS (REAL(REAL64));    CALL SF%APPLY(VAR)  ! DOUBLE PRECISION
                                       TYPE IS (REAL(REAL32));    CALL SF%APPLY(VAR)  ! SINGLE PRECISION
                                       TYPE IS (TIME_SERIES_FILE)
                                                                  IF(SF%HAS_ALL) VAR%FL%SCALE = VAR%FL%SCALE*SF%ALL
                                       TYPE IS (LOOKUP_TABLE_TYPE)
                                                                  IF(SF%HAS_ALL) VAR%Y = VAR%Y*SF%ALL
                                       TYPE IS (REAL(REAL128));   CALL SF%APPLY(VAR)   ! QUAD PRECISION
                                       END SELECT
                END IF
                !
                IF(.NOT. KEEP_IU) IU = Z
                !
                IF(ALLOCATED(FL))  DEALLOCATE(FL)
    END SELECT
    !
    IF(NEG_LLOC) LLOC = NEG  !SET TO NEG IF CHARACTER VAR IS NOT LARGE ENOUGH OR IF GENERIC_INPUT HAS IMPLIED INTERNAL
    !
    IF(PRESENT(OLD_IU))  OLD_IU = IU
    !
  END SUBROUTINE
  !
  RECURSIVE SUBROUTINE ULOAD_VECTOR(VAR, LLOC, LN, IOUT, IN, IU, NOID, BINARY, ID, ROW_WORD, NOSTOP, SFAC, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM, SCRATCH, ENTIRE_LINE, NO_INTERNAL, NO_BINARY, NO_REPEAT, OLD_IU, TEXT, MSG)
    CLASS(*),         DIMENSION(:), CONTIGUOUS,      INTENT(INOUT):: VAR       !Variable to set by ULOAD
    INTEGER,                                         INTENT(INOUT):: LLOC      !SET TO -1 IF CHARACTER::VAR IS NOT LONG ENOUGH TO HOLD INPUT
    CHARACTER(*),                                    INTENT(INOUT):: LN        !Temp line to holds read input that is processed
    INTEGER,                                         INTENT(IN   ):: IN, IOUT  !File that input originated from; error output location
    INTEGER,                                         INTENT(INOUT):: IU        ! If IU=0 input is dermined from directives in IN or SCRATCH, IU.NE.0 indicates input is on that file unit. Same as IN having a LN = "EXTERNAL IU"
    !
    LOGICAL,     OPTIONAL,                           INTENT(IN   ):: NOID, BINARY, NOSTOP
    INTEGER,     OPTIONAL, DIMENSION(:), ALLOCATABLE,INTENT(INOUT):: ID                   !Note that ID must be ALLOCATABLE -- This is done to check if it is read
    CHARACTER(*),OPTIONAL,                           INTENT(IN   ):: ROW_WORD
    TYPE(SFAC_DATA),OPTIONAL,                        INTENT(  OUT):: SFAC
    !
    CHARACTER(*), OPTIONAL,                          INTENT(IN   ):: EX1_WORD, EX2_WORD, EX3_WORD
    INTEGER,      OPTIONAL,                          INTENT(IN   ):: EX1_DIM,  EX2_DIM,  EX3_DIM
    INTEGER,      OPTIONAL,                          INTENT(IN   ):: SCRATCH
    LOGICAL,      OPTIONAL,                          INTENT(IN   ):: ENTIRE_LINE, NO_INTERNAL, NO_BINARY, NO_REPEAT
    INTEGER,      OPTIONAL,                          INTENT(INOUT):: OLD_IU
    CHARACTER(*), OPTIONAL,                          INTENT(IN   ):: TEXT
    CHARACTER(*), OPTIONAL,                          INTENT(IN   ):: MSG
    !
    TYPE(SFAC_DATA):: SF!1, SF2
    !
    INTEGER:: IERR, ISTART, ISTOP, I, N, DIM1, INFILE, ERROR_IU, LINELEN
    TYPE(GENERIC_INPUT_FILE), ALLOCATABLE:: FL
    LOGICAL:: KEEP_IU, READ_ID, BIN, ALLOW_ERROR, CLEAR_IU, READ_FULL_LINE, NO_INTERN, NEG_LLOC, NO_MAIN_KEY, IMPLIED_INTERNAL, SET_ID
    REAL(REAL64):: SFAC_FILE, CONST  !ENSURE IT IS ALWAYS DOUBLE PRECISION
    CHARACTER(12):: EXT, FORM_CHK
    !
       DIM1 = UBOUND(VAR, 1)
    IF(DIM1 == Z) RETURN
    !
    !
    IERR = Z
    NEG_LLOC  = FALSE
    SFAC_FILE = UNO
    ERROR_IU = IN
    NO_MAIN_KEY = FALSE
    IMPLIED_INTERNAL = FALSE
    !
    SELECT TYPE (VAR)
    TYPE IS (CHARACTER(*)      ); LINELEN = LEN(VAR)
    TYPE IS (GENERIC_INPUT_FILE); VAR%SCALE = UNO
    END SELECT
    !
    IF(PRESENT(SCRATCH)) THEN
        IF(SCRATCH.NE. Z) THEN
                              INFILE = SCRATCH
        ELSE
                              INFILE = IN
        END IF
    ELSE
        INFILE = IN
    END IF
    !
    IF(PRESENT(NOID)) THEN
        READ_ID = .NOT. NOID
    ELSE
        READ_ID = TRUE
    END IF
    !
    IF(PRESENT(BINARY)) THEN
        BIN = BINARY
    ELSE
        BIN = FALSE
    END IF
    !
    IF(PRESENT(NOSTOP)) THEN
        ALLOW_ERROR = .NOT. NOSTOP
    ELSE
        ALLOW_ERROR = TRUE
    END IF
    !
    IF(PRESENT(ENTIRE_LINE)) THEN
        READ_FULL_LINE = ENTIRE_LINE
    ELSE
        READ_FULL_LINE = FALSE
    END IF
    !
    IF(PRESENT(NO_INTERNAL)) THEN
        NO_INTERN = NO_INTERNAL
    ELSE
        NO_INTERN = FALSE
    END IF
    !
    IF(PRESENT(ID)) THEN
           SET_ID = ALLOCATED(ID)
        IF(SET_ID) THEN 
                   CALL SET_SEQUENCE(SIZE(ID), ID)
                   SET_ID = READ_ID 
        END IF
    ELSE
        SET_ID = FALSE
    END IF
    !
    CLEAR_IU = FALSE
    IF(IU.NE.Z) THEN
                    INQUIRE(IU,FORM=FORM_CHK, OPENED=KEEP_IU)
                    IF(.NOT. KEEP_IU) CALL STOP_ERROR( LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ULOAD ERROR: RECIEVED UNIT NUMBER "'//NUM2STR(IU)//'" WHICH IS NOT ASSOCIATED WITH A FILE. THIS COULD BE THE RESULT OF USING "EXTERNAL" OR "DATAUNIT" WITH A UNIT THAT IS NOT OPENED BY THE NAME FILE.', MSG2=MSG)
                    BIN = FORM_CHK .NE. 'FORMATTED'
                    !
                    ERROR_IU = IU
                    KEEP_IU  = TRUE
                    LLOC     = ONE
                    IF(.NOT. ALLOW_ERROR) CLEAR_IU = TRUE
                    IF(.NOT. BIN) CALL READ_TO_DATA(LN,IU,IOUT)  !UNIT IS BEING PASSED IN SO READ IN LINE FROM IT
    ELSE
                    KEEP_IU = FALSE
    END IF
    !
    CALL SF%INIT()
    IF(PRESENT(SFAC)) CALL SFAC%INIT()
    !
    IF(.NOT. BIN) THEN
                      DO !CHECK FOR KEYWORD OF SFAC BEFORE LIST
                           N = LLOC
                           I = COMMENT_INDEX(LN)
                           CALL PARSE_WORD(LN(:I),LLOC,ISTART,ISTOP)
                           EXT = LN(ISTART:ISTOP)
                           CALL UPPER(EXT)
                           IF (EXT == 'SFAC') THEN
                               IF(IU==Z) THEN
                                             CALL SFAC_READ_AND_RETURN(SF, LN(N:), IN, IOUT, ROW_WORD, DIM1, EX1_WORD=EX1_WORD, EX1_DIM=EX1_DIM, EX2_WORD=EX2_WORD, EX2_DIM=EX2_DIM, EX3_WORD=EX3_WORD, EX3_DIM=EX3_DIM, SCRATCH=SCRATCH)
                                             CALL READ_TO_DATA(LN,INFILE,IOUT)
                               ELSE
                                             CALL SFAC_READ_AND_RETURN(SF, LN(N:), IU, IOUT, ROW_WORD, DIM1, EX1_WORD=EX1_WORD, EX1_DIM=EX1_DIM, EX2_WORD=EX2_WORD, EX2_DIM=EX2_DIM, EX3_WORD=EX3_WORD, EX3_DIM=EX3_DIM)
                                             CALL READ_TO_DATA(LN,IU,IOUT)
                               END IF
                               LLOC = ONE
                           ELSEIF(EXT=='STATIC' .OR. EXT=='LIST') THEN; CYCLE ! FOUND LAI KEYWORDS, IGNORE THEM
                           !
                           ELSEIF(EXT==BLNK .OR. EXT==COM) THEN  !READ NEXT LINE IF BLANK
                               IF(IU==Z) THEN
                                             CALL READ_TO_DATA(LN,INFILE,IOUT)
                                             IF(LN==BLNK) CALL STOP_ERROR(INFILE=IN,OUTPUT=IOUT,MSG = 'ULOAD FAILED TO LOAD INPUT LINE.'//NL//'THIS MOST LIKELY OCCURED BECAUSE THE END OF FILE WAS REACHED WHILE LOADING INPUT.'//BLN//'POSSIBLE CAUSES ARE NOT ENOUGH STRESS PERIOD INPUT, AN EMPTY FILE,'//NL//'THE INPUT LINE IS EMPTY WHEN NUMBERS WERE EXPECTED,'//NL//'OR YOU SPECIFIED TRANSIENT WHEN YOU MEANT STATIC FOR A LIST-ARRAY INPUT.', MSG2=MSG)
                               ELSE
                                             CALL READ_TO_DATA(LN,IU,IOUT)
                                             IF(LN==BLNK) CALL STOP_ERROR(INFILE=IU,OUTPUT=IOUT,MSG = 'ULOAD FAILED TO LOAD INPUT LINE.'//NL//'THIS MOST LIKELY OCCURED BECAUSE THE END OF FILE WAS REACHED WHILE LOADING INPUT.'//BLN//'POSSIBLE CAUSES ARE NOT ENOUGH STRESS PERIOD INPUT, AN EMPTY FILE,'//NL//'THE INPUT LINE IS EMPTY WHEN NUMBERS WERE EXPECTED,'//NL//'OR YOU SPECIFIED TRANSIENT WHEN YOU MEANT STATIC FOR A LIST-ARRAY INPUT.', MSG2=MSG)
                               END IF
                               !
                               LLOC = ONE
                               NO_MAIN_KEY = TRUE
                           ELSE
                               LLOC = N
                               EXIT
                           END IF
                      END DO
    ELSE
                      EXT='BINARY'
    END IF
    !
    SELECT CASE (EXT)
    CASE( 'SKIP', 'NULL', 'NUL' )     !-----------------------------------------------------------------------------------------------------------------------
                       SELECT TYPE (VAR)
                       TYPE IS (REAL(REAL64));     VAR = 0.0_REAL64   ! DOUBLE PRECISION
                       TYPE IS (REAL(REAL32));     VAR = 0.0_REAL32   ! SINGLE PRECISION
                       TYPE IS (INTEGER);          VAR = 0
                       TYPE IS (CHARACTER(*));     VAR = BLNK
                       TYPE IS (CHARACTER_TYPE);   VAR = BLNK
                       TYPE IS (GENERIC_INPUT_FILE);
                                                    CALL VAR%CLOSE() ! CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: THIS INPUT READ UTILITY DOES NOT ALLOW FOR THE KEYWORD "SKIP". PLEASE USE A KEYWORD TO INDICATE WHERE DATA IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)', MSG2=MSG)
                                                    VAR%SKIP = TRUE
                       TYPE IS (TIME_SERIES_FILE);  CALL VAR%INIT('SKIP')
                       TYPE IS (LOOKUP_TABLE_TYPE); CALL VAR%DESTROY()
                       TYPE IS (DATE_OPERATOR);     CALL VAR%DESTROY()
                       !TYPE IS (DATE_OPERATOR)
                       !                          DO I=1, DIM1
                       !                              CALL VAR(I)%DESTROY()
                       !                          END DO
                       TYPE IS (REAL(REAL128));    VAR = 0.0_REAL128   ! QUAD PRECISION
                       END SELECT
                       LN = EXT//BLNK//LN
                       RETURN
    CASE( 'CONSTANT' ) !-----------------------------------------------------------------------------------------------------------------------
                       N = LLOC
                       CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
                       CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE)
                       !
                       SELECT TYPE (VAR)
                       TYPE IS (GENERIC_INPUT_FILE)
                                                   LLOC = N
                                                   !
                                                   CALL FL%OPEN(LN,LLOC,IOUT,IN,REQKEY=TRUE,KEY=EXT)
                                                   !
                                                   IF(IU==Z) THEN
                                                         VAR = FL
                                                         CALL FL%NOCLOSE()
                                                   ELSE
                                                       VAR%IU = IU
                                                       VAR%OPENCLOSE = FALSE
                                                       VAR%ERROR     = FALSE
                                                   END IF
                                                   LLOC = ONE
                                                   LN = LN(N:)  !RETURN THE LINE FROM "CONSTANT" ONWARD
                                                   RETURN
                       TYPE IS (DATE_OPERATOR)
                                                   !VAR = DATE_OPERATOR(LN(ISTART:ISTOP))  --CAUSES COMILER ERROR
                                                   CALL GET_DATE(LN,LLOC,ISTART,ISTOP,IOUT,IN,VAR(ONE),NO_PARSE_WORD=TRUE,HAS_ERROR=NEG_LLOC,NO_DATE=TRUE)
                                                   IF(NEG_LLOC) THEN
                                                       IERR = 123
                                                   ELSE
                                                       DO I=TWO, DIM1
                                                           VAR(I) = VAR(ONE)
                                                       END DO
                                                   END IF
                       CLASS DEFAULT
                                                   READ(LN(ISTART:ISTOP), *, IOSTAT=IERR) CONST
                       END SELECT
                       !
                       IF(IERR.NE.Z .AND. ALLOW_ERROR)   CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'FOUND KEYWORD CONSTANT, BUT FAILED TO READ THE VALUE LOCATED AFTER THE KEYWORD "CONSTANT".', MSG2=MSG)
                       IF(IERR.NE.Z .AND. CLEAR_IU)  IU = Z
                       !
                       SELECT TYPE (VAR)
                       TYPE IS (REAL(REAL64));     VAR = CONST
                       TYPE IS (REAL(REAL32));     VAR = REAL(CONST,REAL32)
                       TYPE IS (INTEGER)
                                                   READ(LN(ISTART:ISTOP), *, IOSTAT=IERR) I
                                                   VAR = I
                       TYPE IS (CHARACTER(*))
                                                   IF(READ_FULL_LINE) ISTOP = COMMENT_INDEX(LN)   !GET INDEX WHERE # IS OR LEN_TRIM
                                                   VAR = LN(ISTART:ISTOP)
                                                   IF(LINELEN<LEN_TRIM(LN(ISTART:ISTOP))) NEG_LLOC = TRUE
                       TYPE IS (CHARACTER_TYPE)
                                                   ISTOP = COMMENT_INDEX(LN)   !GET INDEX WHERE # IS OR LEN_TRIM
                                                   N = LEN_TRIM(LN(ISTART:ISTOP))
                                                   VAR = LN(ISTART:N)
                       TYPE IS (TIME_SERIES_FILE);
                                                   DO I=1, DIM1
                                                               CALL VAR(I)%INIT(CONST)
                                                   END DO
                                                   !
                       TYPE IS (LOOKUP_TABLE_TYPE);
                                                   DO CONCURRENT (I=1:DIM1);   CALL VAR(I)%LOAD(CONST)
                                                   END DO
                                                   !
                       TYPE IS (REAL(REAL128));    VAR = REAL(CONST,REAL128)   ! QUAD PRECISION
                       END SELECT
                       !
                       CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,ISTART,ISTOP,SFAC_FILE) !ISTART, ISTOP ARE PLACE HOLDERS FOR BUF AND ISPLIT
                       !
                       IF(SFAC_FILE.NE.UNO) CALL SF%SET_ALL(SFAC_FILE)
                       !
                       IF(PRESENT(SFAC)) THEN
                                             SFAC = SF
                       ELSE
                                             SELECT TYPE (VAR)
                                             TYPE IS (REAL(REAL64));    CALL SF%APPLY(VAR)    ! DOUBLE PRECISION
                                             TYPE IS (REAL(REAL32));    CALL SF%APPLY(VAR)    ! SINGLE PRECISION
                                             TYPE IS (TIME_SERIES_FILE)
                                                                        IF(SF%HAS_ALL) THEN
                                                                            DO CONCURRENT (I=1:DIM1); VAR(I)%FL%SCALE = VAR(I)%FL%SCALE*SF%ALL
                                                                            END DO
                                                                        END IF
                                             TYPE IS (LOOKUP_TABLE_TYPE)
                                                                        IF(SF%HAS_ALL) THEN
                                                                           DO CONCURRENT (I=1:DIM1); VAR(I)%Y = VAR(I)%Y*SF%ALL
                                                                           END DO
                                                                        END IF
                                             TYPE IS (REAL(REAL128));   CALL SF%APPLY(VAR)   ! QUAD PRECISION
                                             END SELECT
                       END IF
                       !
                       LLOC = ONE
                       IF(NEG_LLOC) LLOC = NEG
                       LN = EXT//BLNK//LN
                       RETURN
    CASE( 'REPEAT' )   !-----------------------------------------------------------------------------------------------------------------------
                       !
                       IF(PRESENT(NO_REPEAT)) THEN
                               IF(NO_REPEAT) CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD FOUND KEYWORD "REPEAT" BUT THIS PARTICULAR FEATURE DOES NOT SUPPORT IT.'//NL//'(NOTE APPLYING A SCALE FACTOR WITH SFAC, DOES NOT SUPPORT THIS.)'//NL//'PLEAUSE CHANGE INPUT TO USE OPEN/CLOSE TO RELOAD THE FILE INSTEAD OF REPEATING IT.', MSG2=MSG)
                       END IF
                       !
                       CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
                       CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,ISTART,ISTOP,SFAC_FILE) !ISTART, ISTOP ARE PLACE HOLDERS FOR BUF AND ISPLIT
                       !
                       IF(SFAC_FILE.NE.UNO) CALL SF%SET_ALL(SFAC_FILE)
                       !
                       IF(PRESENT(SFAC)) THEN
                                             SFAC = SF
                       ELSE
                                             SELECT TYPE (VAR)
                                             TYPE IS (REAL(REAL64));     CALL SF%APPLY(VAR)  ! DOUBLE PRECISION
                                             TYPE IS (REAL(REAL32));     CALL SF%APPLY(VAR)  ! SINGLE PRECISION
                                             TYPE IS (TIME_SERIES_FILE); VAR%FL%SCALE = SFAC_FILE
                                             TYPE IS (LOOKUP_TABLE_TYPE)
                                                                        IF(SF%HAS_ALL) THEN
                                                                                      IF(SF%ALL.NE.UNO)CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE LOAD ERROR - ULOAD FOUND KEYWORD "REPEAT" WITH A SCALE FACTOR THAT IS NOT EQUAL TO 1. LOOKUP TABLES IMMEDIATELY APPLY SCALE FACTORS SO THERE IS NO WAY TO KEEP THEM SEPARATE. EITHER RE-SPECIFY LOOKUP TABLE OR REMOVE SFAC OR SCALE.', MSG2=MSG)
                                                                        END IF
                                             TYPE IS (REAL(REAL128));    CALL SF%APPLY(VAR)  ! QUAD PRECISION
                                             END SELECT
                       END IF
                       !
                       LN = EXT//BLNK//LN
                       RETURN
    CASE( 'RELOAD' ) !-----------------------------------------------------------------------------------------------------------------------
                     !
                     IF(IU==Z) THEN
                          IF(PRESENT(OLD_IU))  IU = OLD_IU
                          IF(ALLOW_ERROR .AND. (IU==Z .OR. .NOT. PRESENT(OLD_IU))) THEN
                              CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD FOUND KEYWORD "RELOAD" BUT THERE WAS NOT A PREVIOUSLY OPENED FILE TO USE OR THIS INPUT FEATURE DOES NOT SUPPORT THE "RELOAD" KEYWORD.'//NL//'PLEASE MAKE SURE THAT THIS ULOAD WAS PRECEDED BY AN EXTERNAL UNIT, DATAUNIT UNIT, OR DATAFILE FILE'//NL//'SO THT THE FILE CAN BE CONTINUED TO LOAD NEXT INPUT OR CHANGE KEYWORD TO ONE THAT OPENS A FILE OR POINTS TO AN EXISTING OPENED FILE.'//NL//'(e.g. THIS KEYWORD SHOULD ONLY APPEAR IN A TFR AFTER AN EXTERNAL, DATAUNIT, or DATAFILE KEYWORDS TO REUSE THEIR UNIT NUMBERS AND CONTINUE LOADING FROM THEIR FILES)', MSG2=MSG)
                          END IF
                          !
                          IF(IU.NE.Z) THEN
                                                CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,ISTART,ISTOP,SFAC_FILE) !ISTART, ISTOP ARE PLACE HOLDERS FOR BUF AND ISPLIT
                                                !
                                                INQUIRE(IU,FORM=FORM_CHK, OPENED=KEEP_IU)
                                                IF(.NOT. KEEP_IU) CALL STOP_ERROR(LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ULOAD ERROR: RECIEVED UNIT NUMBER "'//NUM2STR(IU)//'" WHICH IS NOT ASSOCIATED WITH A FILE. THIS COULD BE THE RESULT OF USING "EXTERNAL" OR "DATAUNIT" WITH A UNIT THAT IS NOT OPENED BY THE NAME FILE.', MSG2=MSG)
                                                BIN = FORM_CHK .NE. 'FORMATTED'
                                                !
                                                IF(BIN) THEN
                                                    REWIND(IU) !MOVE BACK TO TOP OF FILE
                                                ELSE
                                                    CALL UTF8_BOM_OFFSET_REWIND(IU)  !Check in case file has a UTF8 BOM header, rewind to correct location
                                                END IF
                                                !
                                                ERROR_IU = IU
                                                KEEP_IU  = TRUE
                                                LLOC     = ONE
                                                IF(.NOT. ALLOW_ERROR) CLEAR_IU = TRUE
                                                IF(.NOT. BIN) CALL READ_TO_DATA(LN,IU,IOUT)  !UNIT IS BEING PASSED IN SO READ IN LINE FROM IT
                          END IF
                       ELSE
                            CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD FOUND KEYWORD "RELOAD" BUT THIS INPUT OPTION EITHER DOES NOT SUPPORT RELOAD OR THERE IS A CODE ERROR. PLEASE CHANGE RELOAD TO SOMETHING LIKE "EXTERNAL  55  REWIND"', MSG2=MSG)
                     END IF
    CASE( 'LOAD_NEXT' )!-----------------------------------------------------------------------------------------------------------------------
                       !
                       IF(IU==Z) THEN
                            IF(PRESENT(OLD_IU))  IU = OLD_IU
                            IF(ALLOW_ERROR .AND. (IU==Z .OR. .NOT. PRESENT(OLD_IU))) THEN
                                CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD FOUND KEYWORD "LOAD_NEXT" BUT THERE WAS NOT A PREVIOUSLY OPENED FILE TO USE OR THIS INPUT FEATURE DOES NOT SUPPORT THE "LOAD_NEXT" KEYWORD (viz. SFAC DOES NOT SUPPORT IT).'//NL//'PLEASE MAKE SURE THAT THIS ULOAD WAS PRECEDED BY AN EXTERNAL UNIT, DATAUNIT UNIT, OR DATAFILE FILE'//NL//'SO THT THE FILE CAN BE CONTINUED TO LOAD NEXT INPUT'//NL//'OR CHANGE KEYWORD TO ONE THAT OPENS A FILE OR POINTS TO AN EXISTING OPENED FILE.'//NL//'(e.g. THIS KEYWORD SHOULD ONLY APPEAR IN A TFR AFTER AN EXTERNAL, DATAUNIT, or DATAFILE KEYWORDS TO REUSE THEIR UNIT NUMBERS AND CONTINUE LOADING FROM THEIR FILES)', MSG2=MSG)
                            END IF
                            !
                            IF(IU.NE.Z) THEN
                                                  CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,ISTART,ISTOP,SFAC_FILE) !ISTART, ISTOP ARE PLACE HOLDERS FOR BUF AND ISPLIT
                                                  !
                                                  INQUIRE(IU,FORM=FORM_CHK, OPENED=KEEP_IU)
                                                  IF(.NOT. KEEP_IU) CALL STOP_ERROR(LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ULOAD ERROR: RECIEVED UNIT NUMBER "'//NUM2STR(IU)//'" WHICH IS NOT ASSOCIATED WITH A FILE. THIS COULD BE THE RESULT OF USING "EXTERNAL" OR "DATAUNIT" WITH A UNIT THAT IS NOT OPENED BY THE NAME FILE.', MSG2=MSG)
                                                  BIN = FORM_CHK .NE. 'FORMATTED'
                                                  !
                                                  ERROR_IU = IU
                                                  KEEP_IU  = TRUE
                                                  LLOC     = ONE
                                                  IF(.NOT. ALLOW_ERROR) CLEAR_IU = TRUE
                                                  IF(.NOT. BIN) CALL READ_TO_DATA(LN,IU,IOUT)  !UNIT IS BEING PASSED IN SO READ IN LINE FROM IT
                            END IF
                       ELSE
                            CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD FOUND KEYWORD "LOAD_NEXT" BUT THIS INPUT OPTION EITHER DOES NOT SUPPORT RELOAD OR THERE IS A CODE ERROR. PLEASE CHANGE LOAD_NEXT TO SOMETHING LIKE "DATAFILE MyFile.txt"', MSG2=MSG)
                       END IF
    END SELECT
    !
    IF(IU==Z) THEN
          N = LLOC
          ALLOCATE(FL)
          !
          CALL FL%OPEN(LN,LLOC,IOUT,IN,NOSTOP=TRUE,REQKEY=TRUE,BINARY=BIN)
          SFAC_FILE = FL%SCALE
          FL%SCALE = UNO
          BIN = FL%BINARY
          IF(.NOT. FL%ERROR) THEN
                                 IU = FL%IU
                                 IF(IU.NE.Z .AND. .NOT. FL%OPENCLOSE) KEEP_IU = TRUE  !FONUD EXTERNAL KEYWORD, SO PASS BACK WHAT WAS LOADED
                                 IF(IU.NE.Z) ERROR_IU = IU
                                 IF(IU == Z .AND. NO_INTERN) CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: THIS SPECIFIC INPUT LINE DOES NOT ALLOW FOR THE "INTERNAL" KEYWORD. PLEASE MOVE INTERNAL INPUT TO SEPARATE FILE AND CHANGE KEYWORD TO "OPEN/CLOSE" OR "EXTERNAL" OR INSTEAD USE AN IMPLIED INTERNAL BY HAVING ALL THE INPUT DATA ON THE SAME LINE.', MSG2=MSG)
                                 IF(IU == Z) IU = INFILE  !FOUND INTERNAL
                                 LLOC = ONE
                                 IF(.NOT. BIN) CALL READ_TO_DATA(LN,IU,IOUT)
          ELSE !NO KEYWORD FOUND SO DATA IS WITHIN LINE
              LLOC = N
              IU = Z
          END IF
    END IF
    !
    IF(.NOT. BIN .AND. IU.NE.Z) THEN
                                DO !CHECK FOR KEYWORD OF SFAC WITHIN LIST
                                      N = LLOC
                                      CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE)
                                      EXT = LN(ISTART:ISTOP)
                                      CALL UPPER(EXT)
                                      IF (EXT == 'SFAC') THEN
                                          CALL SFAC_READ_AND_RETURN(SF, LN(N:), IU, IOUT, ROW_WORD, DIM1, EX1_WORD=EX1_WORD, EX1_DIM=EX1_DIM, EX2_WORD=EX2_WORD, EX2_DIM=EX2_DIM, EX3_WORD=EX3_WORD, EX3_DIM=EX3_DIM)
                                          LLOC = ONE
                                          CALL READ_TO_DATA(LN,IU,IOUT)
                                      ELSE
                                          LLOC = N
                                          EXIT
                                      END IF
                                END DO
    END IF
    !
    IF(BIN) THEN
                !
                IF(IU==INFILE)                             CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: "INTERNAL" AND "BINARY" KEYWORD FOUND, BUT THIS IS NOT ALLOWED!', MSG2=MSG)
                IF(PRESENT(NO_BINARY)) THEN; IF(NO_BINARY) CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: "BINARY" KEYWORD FOUND, BUT THIS INPUT PROPERTY DOES NOT SUPPORT BINARY FILE INPUT. PLEASE USE ASCII/TEXT INPUT INSTEAD AND REMOVE "BINARY" KEYWORD.', MSG2=MSG)
                END IF
                !
                SELECT TYPE (VAR)
                TYPE IS (REAL(REAL64));       READ(IU, IOSTAT=IERR) VAR   ! DOUBLE PRECISION
                TYPE IS (REAL(REAL32));       READ(IU, IOSTAT=IERR) VAR   ! SINGLE PRECISION
                TYPE IS (INTEGER);            READ(IU, IOSTAT=IERR) VAR
                TYPE IS (CHARACTER(*));       READ(IU, IOSTAT=IERR) VAR
                TYPE IS (DATE_OPERATOR);      READ(IU, IOSTAT=IERR) VAR
                TYPE IS (GENERIC_INPUT_FILE); CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: "BINARY" KEYWORD FOUND, BUT THIS INPUT PROPERTY DOES NOT SUPPORT BINARY FILE INPUT. PLEASE USE ASCII/TEXT INPUT INSTEAD AND REMOVE "BINARY" KEYWORD.', MSG2=MSG)
                TYPE IS (TIME_SERIES_FILE);   CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: "BINARY" KEYWORD FOUND, BUT THIS INPUT PROPERTY DOES NOT SUPPORT BINARY FILE INPUT. PLEASE USE ASCII/TEXT INPUT INSTEAD AND REMOVE "BINARY" KEYWORD.', MSG2=MSG)
                TYPE IS (LOOKUP_TABLE_TYPE);  CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: "BINARY" KEYWORD FOUND, BUT THIS INPUT PROPERTY DOES NOT SUPPORT BINARY FILE INPUT. PLEASE USE ASCII/TEXT INPUT INSTEAD AND REMOVE "BINARY" KEYWORD.', MSG2=MSG)
                TYPE IS (CHARACTER_TYPE);     CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: "BINARY" KEYWORD FOUND, BUT THIS INPUT PROPERTY DOES NOT SUPPORT BINARY FILE INPUT. PLEASE USE ASCII/TEXT INPUT INSTEAD AND REMOVE "BINARY" KEYWORD.', MSG2=MSG)
                TYPE IS (REAL(REAL128));      READ(IU, IOSTAT=IERR) VAR   ! QUAD PRECISION
                END SELECT
                !
                IF(IERR.NE.Z .AND. ALLOW_ERROR)   CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ATTEMPT MADE TO READ LIST FROM ULOAD IN A BINARY FILE, BUT IT FAILED TO LOAD. PLEASURE ENSURE THAT BINARY FORMAT COMPLIES TO WHAT IS EXPECTED TO BE LOADED.', MSG2=MSG)
                IF(IERR.NE.Z .AND. CLEAR_IU)  IU = Z
    ELSE
        IF(IU == Z) THEN  !NO KEYWORD, SO ASSUME IT IS ON CURRENT LINE
              IMPLIED_INTERNAL = TRUE
              SELECT TYPE (VAR)
              TYPE IS (REAL(REAL64))
                                     CALL GET_NUMBER(LN,LLOC,ISTART,ISTOP,IOUT,IN,VAR,IOSTAT=IERR)      !READ(LN(LLOC:), *, IOSTAT=IERR) VAR  ! DOUBLE PRECISION
                                     !
                                     CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE) !Check for SFAC
                                     IF(ISTOP - ISTART == THREE ) THEN
                                        EXT = LN(ISTART:ISTOP)
                                        CALL UPPER(EXT)
                                        IF (EXT == 'SFAC')  CALL SFAC_READ_AND_RETURN(SF, LN(LLOC:), IN, IOUT, ROW_WORD, DIM1, EX1_WORD=EX1_WORD, EX1_DIM=EX1_DIM, EX2_WORD=EX2_WORD, EX2_DIM=EX2_DIM, EX3_WORD=EX3_WORD, EX3_DIM=EX3_DIM, SCRATCH=SCRATCH, SKIP_SFAC=TRUE)
                                     END IF
              TYPE IS (REAL(REAL32))
                                     CALL GET_NUMBER(LN,LLOC,ISTART,ISTOP,IOUT,IN,VAR,IOSTAT=IERR)      !READ(LN(LLOC:), *, IOSTAT=IERR) VAR  ! SINGLE PRECISION
                                     !
                                     CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE) !Check for SFAC
                                     IF(ISTOP - ISTART == THREE ) THEN
                                        EXT = LN(ISTART:ISTOP)
                                        CALL UPPER(EXT)
                                        IF (EXT == 'SFAC')  CALL SFAC_READ_AND_RETURN(SF, LN(LLOC:), IN, IOUT, ROW_WORD, DIM1, EX1_WORD=EX1_WORD, EX1_DIM=EX1_DIM, EX2_WORD=EX2_WORD, EX2_DIM=EX2_DIM, EX3_WORD=EX3_WORD, EX3_DIM=EX3_DIM, SCRATCH=SCRATCH, SKIP_SFAC=TRUE)
                                     END IF
                                     !
              TYPE IS (INTEGER);     READ(LN(LLOC:), *, IOSTAT=IERR) VAR
              TYPE IS (CHARACTER(*))
                                   DO I=1, DIM1
                                                  CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE)
                                                  VAR(I) = LN(ISTART:ISTOP)
                                                  IF(LN(ISTART:ISTOP)=='') THEN
                                                      IERR = 69
                                                      EXIT
                                                  ELSEIF(LINELEN<LEN_TRIM(LN(ISTART:ISTOP))) THEN
                                                      NEG_LLOC = TRUE
                                                  END IF
                                   END DO
              TYPE IS (CHARACTER_TYPE)
                                       IF( DIM1 == ONE) THEN
                                          ISTOP = COMMENT_INDEX(LN)   !GET INDEX WHERE # IS OR LEN_TRIM
                                          N = LEN_TRIM(LN(ISTART:ISTOP))
                                          VAR(ONE) = LN(ISTART:N)
                                       ELSE
                                          IF(ALLOW_ERROR) THEN
                                                 CALL STOP_ERROR( LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ULOAD ERROR: THIS PARTICULAR INPUT CANNOT BE LOADED WITH IMPLIED INTERNAL. PLEASE USE A KEYWORD TO INDICATE WHERE THE INPUT IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)', MSG2=MSG)
                                          END IF
                                          IF(CLEAR_IU) THEN
                                             IU = Z
                                             LLOC = Z
                                          END IF
                                          RETURN
                                       END IF
              TYPE IS (GENERIC_INPUT_FILE)
                                   DO I=1, DIM1
                                                  CALL VAR(I)%OPEN(LN,LLOC,IOUT,IN,NOSTOP=TRUE,NOPOSTKEY=TRUE)
                                                  !
                                                  IF(VAR(I)%ERROR) THEN
                                                      IERR = 222
                                                      EXIT
                                                  END IF
                                   END DO
              TYPE IS (DATE_OPERATOR)
                                   DO I=1, DIM1
                                                  CALL GET_DATE(LN,LLOC,ISTART,ISTOP,IOUT,IN,VAR(I),HAS_ERROR=NEG_LLOC,NO_DATE=TRUE)
                                                  IF( NEG_LLOC ) THEN
                                                      IERR = 123
                                                      EXIT
                                                  END IF
                                   END DO
              TYPE IS (TIME_SERIES_FILE)
                                       IF( DIM1 == ONE) THEN
                                           CALL VAR(ONE)%INIT(LN, LLOC, IOUT, IN, FALSE, DEFAULT_OPT=TEXT)
                                       ELSE
                                          IF(ALLOW_ERROR) THEN
                                                 CALL STOP_ERROR( LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ULOAD ERROR: TIME SERIES FILE LOADING OF MORE THEN ONE FILE CANNOT BE LOADED WITH IMPLIED INTERNAL. PLEASE USE A KEYWORD TO INDICATE WHERE TIME SERIES FILES ARE LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)', MSG2=MSG)
                                          END IF
                                          IF(CLEAR_IU) THEN
                                             IU = Z
                                             LLOC = Z
                                          END IF
                                          RETURN
                                       END IF
                                       !
              TYPE IS (LOOKUP_TABLE_TYPE)
                                       IF( DIM1 == ONE) THEN
                                           CALL VAR(ONE)%LOAD(LLOC,ISTART,ISTOP,LN,INFILE,IOUT,FALSE,NO_INTERNAL)
                                       ELSE
                                          IF(ALLOW_ERROR) THEN
                                                 CALL STOP_ERROR( LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'LOOKUP TABLE LOAD - ULOAD ERROR: LOOKUP TABLE LOADING OF MORE THEN ONE FILE CANNOT BE LOADED WITH IMPLIED INTERNAL. PLEASE USE A KEYWORD TO INDICATE WHERE TIME SERIES FILES ARE LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)', MSG2=MSG)
                                          END IF
                                          IF(CLEAR_IU) THEN
                                             IU = Z
                                             LLOC = Z
                                          END IF
                                          RETURN
                                       END IF
                                       !
              TYPE IS (REAL(REAL128))
                                     CALL GET_NUMBER(LN,LLOC,ISTART,ISTOP,IOUT,IN,VAR,IOSTAT=IERR)      !READ(LN(LLOC:), *, IOSTAT=IERR) VAR   ! QUAD PRECISION
                                     !
                                     CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE) !Check for SFAC
                                     IF(ISTOP - ISTART == THREE ) THEN
                                        EXT = LN(ISTART:ISTOP)
                                        CALL UPPER(EXT)
                                        IF (EXT == 'SFAC')  CALL SFAC_READ_AND_RETURN(SF, LN(LLOC:), IN, IOUT, ROW_WORD, DIM1, EX1_WORD=EX1_WORD, EX1_DIM=EX1_DIM, EX2_WORD=EX2_WORD, EX2_DIM=EX2_DIM, EX3_WORD=EX3_WORD, EX3_DIM=EX3_DIM, SCRATCH=SCRATCH, SKIP_SFAC=TRUE)
                                     END IF
              END SELECT
        ELSE
            DO I=1, DIM1
                  IF(I>ONE) CALL READ_TO_DATA(LN,IU,IOUT)
                  LLOC   = ONE
                  IF(READ_ID) THEN
                        CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE)
                        IF(SET_ID) THEN
                                       READ(LN(ISTART:ISTOP), *, IOSTAT=IERR)      ID(I)
                                                                     IF(IERR.NE.Z) ID(I) = Z
                        END IF
                  END IF
                  !
                  CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE)
                  !
                  SELECT TYPE (VAR)
                  TYPE IS (REAL(REAL64));     READ(LN(ISTART:ISTOP), *, IOSTAT=IERR) VAR(I)  ! DOUBLE PRECISION
                  TYPE IS (REAL(REAL32));     READ(LN(ISTART:ISTOP), *, IOSTAT=IERR) VAR(I)  ! SINGLE PRECISION
                  TYPE IS (INTEGER);          READ(LN(ISTART:ISTOP), *, IOSTAT=IERR) VAR(I)
                  TYPE IS (CHARACTER(*));
                                              IF(READ_FULL_LINE) ISTOP = COMMENT_INDEX(LN)
                                              IF(LINELEN<LEN_TRIM(LN(ISTART:ISTOP))) NEG_LLOC = TRUE
                                              VAR(I) = LN(ISTART:ISTOP)
                  TYPE IS (CHARACTER_TYPE)
                                              ISTOP = COMMENT_INDEX(LN)   !GET INDEX WHERE # IS OR LEN_TRIM
                                              N = LEN_TRIM(LN(ISTART:ISTOP))
                                              VAR(I) = LN(ISTART:N)
                  TYPE IS (GENERIC_INPUT_FILE)
                                              LLOC = ISTART
                                              CALL VAR(I)%OPEN(LN,LLOC,IOUT,IN,NOSTOP=TRUE,KEY=EXT)
                                              !
                                              IF(VAR(I)%SKIP) THEN
                                                  VAR(I)%ERROR = FALSE
                                              ELSEIF(VAR(I)%ERROR) THEN
                                                  IERR = 222
                                                  EXIT
                                              END IF
                  TYPE IS (DATE_OPERATOR)
                                              !CALL VAR(I)%INIT(LN(ISTART:ISTOP))
                                              !IF( VAR(I)%NOT_SET() ) IERR = 123
                                              CALL GET_DATE(LN,LLOC,ISTART,ISTOP,IOUT,IN,VAR(I),NO_PARSE_WORD=TRUE,HAS_ERROR=NEG_LLOC,NO_DATE=TRUE)
                                              IF( NEG_LLOC ) IERR = 123
                  TYPE IS (TIME_SERIES_FILE)
                                              LLOC = ISTART
                                              CALL VAR(I)%INIT(LN, LLOC, IOUT, IN, FALSE, DEFAULT_OPT=TEXT)
                                              !
                   TYPE IS (LOOKUP_TABLE_TYPE)
                                              LLOC = ISTART
                                              CALL VAR(I)%LOAD(LLOC,ISTART,ISTOP,LN,IU,IOUT,FALSE,NO_INTERNAL)
                  TYPE IS (REAL(REAL128));    READ(LN(ISTART:ISTOP), *, IOSTAT=IERR) VAR(I)   ! QUAD PRECISION
                  END SELECT
                  !
                  IF(LN(ISTART:ISTOP) == '') IERR = -1234
                  IF(IERR.NE.Z) EXIT
            END DO
        END IF
        !
        IF(IERR.NE.Z .AND. ALLOW_ERROR) THEN
               IF(NO_MAIN_KEY) THEN
                    CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ATTEMPT MADE TO READ LIST FROM ULOAD ON LINE, BUT IT FAILED TO LOAD THE FOLLOWING VALUE "'//LN(ISTART:ISTOP)//'"'//BLN//'NOTE THAT NO KEYWORD WAS FOUND ON THE PREVIOUS LINE, SO CODE AUTOMOVED DOWNWARD TO NEXT LINE.'//NL//'YOU MAYBE MISSING A KEYWORD (viz. INTERNAL, EXTERNAL, OPEN/CLOSE, DATEFILE, DATAUNIT).', MSG2=MSG)
               ELSE
                    SELECT TYPE (VAR)
                    TYPE IS (DATE_OPERATOR);           CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ATTEMPT MADE TO READ DATE FROM ULOAD LIST ON LINE, BUT IT FAILED TO CONVERT THE FOLLOWING TO A CALENDAR DATE "'//LN(ISTART:ISTOP)//'"'//BLN//'THE ACCEPTED DATE FORMATS ARE "mm/dd/YYYY" OR "YYYY-mm-dd" IF YOU WANT TO ADD A 24-HOUR TIME TO IT YOU MUST ADD TO THE DATE "Thh:mm:ss" (e.g. "YYYY-mm-ddThh:mm:ss")', MSG2=MSG)
                    TYPE IS (GENERIC_INPUT_FILE);      CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ATTEMPT MADE TO OPEN FILE FROM LIST OF FILES BEING LOADED WITH ULOAD, BUT IT FAILED TO EITHER OPEN, FIND THE FILE, OR IS NOT SET UP CORRECTLY. THE FOLLOWING IS THE FILE THAT WAS ATTEMPTED TO BE OPENED "'//LN(ISTART:ISTOP)//'".', MSG2=MSG)
                    CLASS DEFAULT
                                                       IF(IMPLIED_INTERNAL) THEN
                                                           CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ATTEMPT MADE TO READ LIST FROM ULOAD ON LINE'//NL//'BUT IT FAILED TO IDENFIY GENERIC INPUT/ULOAD KEYWORD (e.g. INTERNAL, OPEN/CLOSE),'//BLN//'SO ULOAD ATTEMPED AN IMPLIED INTERNAL LOAD'//BLN//'ULOAD FAILED TO READ THE VALUES WITH IMPLIED INTERNAL LOAD,'//BLN//'PERHAPS INPUT DOES NOT SUPPORT IMPLIED INTERNAL,'//BLN//'A BAD VALUE WAS SPECIFIED,'//BLN//'YOU DO NOT HAVE '//NUM2STR(SIZE(VAR))//' INPUT VALUES SPECIFIED ALONG THE LINE,'//BLN//'OR THE PRELOADED LINE WAS NOT LONG ENOUGH TO READ ENTIRE INPUT.'//NL//'THE MAX LINE LENGTH IS '//NUM2STR(LEN(LN))//' CHARACTERS.'//NL//'IF USING A TRANSIENT FILE READER (TFR), YOU CAN INCREASE THE LENGTH OF THE PRE-LOADED LINE'//NL//'WITH THE POST-KEYWORD "DIM" FOLLOWED BY THE SIZE OF THE LINE.'//NL//'FOR EXAMPLE:'//NL//'           "ROOT_DEPTH  TRANSIENT  LIST  OPEN/CLOSE  Input.txt  DIM 2000"'//NL//'INDICATE THAT THE MAX LINE LENGTH IS 2000 CHARACTERS.', MSG2=MSG)
                                                       ELSE
                                                           CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ATTEMPT MADE TO READ LIST FROM ULOAD ON LINE, BUT IT FAILED TO LOAD THE FOLLOWING VALUE "'//LN(ISTART:ISTOP)//'"', MSG2=MSG)
                                                       END IF
                    END SELECT

               END IF
        ELSEIF(IERR.NE.Z .AND. CLEAR_IU) THEN
               IU = Z
               LLOC = Z
        END IF
        !
    END IF
    !
    IF(SFAC_FILE.NE.UNO) CALL SF%SET_ALL(SFAC_FILE)
    !
    IF(PRESENT(SFAC)) THEN
                           SFAC = SF
    ELSE
                           SELECT TYPE (VAR)
                           TYPE IS (REAL(REAL64));    CALL SF%APPLY(VAR)   ! DOUBLE PRECISION
                           TYPE IS (REAL(REAL32));    CALL SF%APPLY(VAR)   ! SINGLE PRECISION
                           TYPE IS (TIME_SERIES_FILE)
                                                      IF(SF%HAS_ALL) THEN
                                                          DO CONCURRENT (I=1:DIM1); VAR(I)%FL%SCALE = VAR(I)%FL%SCALE*SF%ALL
                                                          END DO
                                                      END IF
                           TYPE IS (LOOKUP_TABLE_TYPE)
                                                      IF(SF%HAS_ALL) THEN
                                                         DO CONCURRENT (I=1:DIM1); VAR(I)%Y = VAR(I)%Y*SF%ALL
                                                         END DO
                                                      END IF
                           TYPE IS (GENERIC_INPUT_FILE)
                                                      IF(SF%HAS_ALL) THEN
                                                          DO CONCURRENT (I=1:DIM1); VAR(I)%SCALE = VAR(I)%SCALE*SF%ALL
                                                          END DO
                                                      END IF
                           TYPE IS (REAL(REAL128));   CALL SF%APPLY(VAR)   ! QUAD PRECISION
                           END SELECT
    END IF
    !
    IF(.NOT. KEEP_IU)    IU     = Z
    IF(NEG_LLOC)         LLOC   = NEG
    IF(PRESENT(OLD_IU))  OLD_IU = IU
    !
    IF(ALLOCATED(FL))  DEALLOCATE(FL)
    !
  END SUBROUTINE
  !
  RECURSIVE SUBROUTINE ULOAD_ARRAY(VAR, LLOC, LN, IOUT, IN, IU, NOID, BINARY, ID, ROW_WORD, COL_WORD, NOSTOP, SFAC, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM, READ_BY_DIM2, SCRATCH, NO_INTERNAL, NO_BINARY, NO_REPEAT, OLD_IU, MSG)
    CLASS(*), DIMENSION(:,:), CONTIGUOUS,            INTENT(INOUT):: VAR       !Variable to set by ULOAD
    INTEGER,                                         INTENT(INOUT):: LLOC      !SET TO -1 IF CHARACTER::VAR IS NOT LONG ENOUGH TO HOLD INPUT
    CHARACTER(*),                                    INTENT(INOUT):: LN        !Temp line to holds read input that is processed
    INTEGER,                                         INTENT(IN   ):: IN, IOUT  !File that input originated from; error output location
    INTEGER,                                         INTENT(INOUT):: IU        ! If IU=0 input is dermined from directives in IN or SCRATCH, IU.NE.0 indicates input is on that file unit. Same as IN having a LN = "EXTERNAL IU"
    !
    LOGICAL,     OPTIONAL,                           INTENT(IN   ):: NOID, BINARY, NOSTOP, READ_BY_DIM2
    INTEGER,     OPTIONAL, DIMENSION(:), ALLOCATABLE,INTENT(INOUT):: ID                   !Note that ID must be ALLOCATABLE -- This is done to check if it is read
    CHARACTER(*),OPTIONAL,                           INTENT(IN   ):: ROW_WORD, COL_WORD
    TYPE(SFAC_DATA),OPTIONAL,                        INTENT(  OUT):: SFAC
    !
    CHARACTER(*), OPTIONAL,                          INTENT(IN   ):: EX1_WORD, EX2_WORD, EX3_WORD
    INTEGER,      OPTIONAL,                          INTENT(IN   ):: EX1_DIM,  EX2_DIM,  EX3_DIM
    INTEGER,      OPTIONAL,                          INTENT(IN   ):: SCRATCH
    LOGICAL,      OPTIONAL,                          INTENT(IN   ):: NO_INTERNAL, NO_BINARY, NO_REPEAT
    INTEGER,      OPTIONAL,                          INTENT(INOUT):: OLD_IU
    CHARACTER(*), OPTIONAL,                          INTENT(IN   ):: MSG
    !
    TYPE(SFAC_DATA):: SF!1, SF2
    !
    INTEGER:: IERR, ISTART, ISTOP, I, J, N, DIM1, DIM2, INFILE, ERROR_IU, IID, LINELEN, SET_ID
    TYPE(GENERIC_INPUT_FILE), ALLOCATABLE:: FL
    LOGICAL:: KEEP_IU, READ_ID, BIN, ALLOW_ERROR, CLEAR_IU, READ_BY_DIM1, NO_INTERN, NEG_LLOC, NO_MAIN_KEY
    REAL(REAL64):: SFAC_FILE, CONST  !ENSURE IT IS ALWAYS DOUBLE PRECISION
    CHARACTER(12):: EXT, FORM_CHK
    !
    DIM1 = UBOUND(VAR, 1)
    DIM2 = UBOUND(VAR, 2)
    !
    IF(DIM1==Z .OR. DIM2==Z) RETURN
    !
    IERR = Z
    NEG_LLOC  = FALSE
    SFAC_FILE = UNO
    ERROR_IU = IN
    NO_MAIN_KEY=FALSE
    !
    SELECT TYPE (VAR)
    TYPE IS (CHARACTER(*)); LINELEN = LEN(VAR)
    END SELECT
    !
    IF(PRESENT(SCRATCH)) THEN
        IF(SCRATCH.NE. Z) THEN
                              INFILE = SCRATCH
        ELSE
                              INFILE = IN
        END IF
    ELSE
        INFILE = IN
    END IF
    !
    IF(PRESENT(NOID)) THEN
        READ_ID = .NOT. NOID
    ELSE
        READ_ID = TRUE
    END IF
    !
    IF(PRESENT(BINARY)) THEN
        BIN = BINARY
    ELSE
        BIN = FALSE
    END IF
    !
    IF(PRESENT(NOSTOP)) THEN
        ALLOW_ERROR = .NOT. NOSTOP
    ELSE
        ALLOW_ERROR = TRUE
    END IF
    !
    IF(PRESENT(NO_INTERNAL)) THEN
        NO_INTERN = NO_INTERNAL
    ELSE
        NO_INTERN = FALSE
    END IF
    !
    IF(PRESENT(READ_BY_DIM2)) THEN
        READ_BY_DIM1 = .NOT. READ_BY_DIM2
    ELSE
        READ_BY_DIM1 = TRUE
    END IF
    !
    IF(PRESENT(ID)) THEN
           SET_ID = ALLOCATED(ID)
        IF(SET_ID) THEN 
                   CALL SET_SEQUENCE(SIZE(ID), ID)
                   SET_ID = READ_ID 
        END IF
    ELSE
        SET_ID = FALSE
    END IF
    !
    CLEAR_IU = FALSE
    IF(IU.NE.Z) THEN
                    INQUIRE(IU,FORM=FORM_CHK, OPENED=KEEP_IU)
                    IF(.NOT. KEEP_IU) CALL STOP_ERROR( LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ULOAD ERROR: RECIEVED UNIT NUMBER "'//NUM2STR(IU)//'" WHICH IS NOT ASSOCIATED WITH A FILE. THIS COULD BE THE RESULT OF USING "EXTERNAL" OR "DATAUNIT" WITH A UNIT THAT IS NOT OPENED BY THE NAME FILE.', MSG2=MSG)
                    BIN = FORM_CHK .NE. 'FORMATTED'
                    !
                    ERROR_IU = IU
                    KEEP_IU  = TRUE
                    LLOC     = ONE
                    IF(.NOT. ALLOW_ERROR) CLEAR_IU = TRUE
                    IF(.NOT. BIN) CALL READ_TO_DATA(LN,IU,IOUT)  !UNIT IS BEING PASSED IN SO READ IN LINE FROM IT
    ELSE
                    KEEP_IU = FALSE
    END IF
    !
    CALL SF%INIT()
    IF(PRESENT(SFAC)) CALL SFAC%INIT()
    !
    IF(.NOT. BIN) THEN
                      DO !CHECK FOR KEYWORD OF SFAC BEFORE LIST
                           N = LLOC
                           I = COMMENT_INDEX(LN)
                           CALL PARSE_WORD(LN(:I),LLOC,ISTART,ISTOP)
                           EXT = LN(ISTART:ISTOP)
                           CALL UPPER(EXT)
                           SELECT CASE(EXT)
                           CASE ('SFAC')
                               IF(IU==Z) THEN
                                             CALL SFAC_READ_AND_RETURN(SF, LN(N:), IN, IOUT, ROW_WORD, DIM1, COL_WORD, DIM2, EX1_WORD=EX1_WORD, EX1_DIM=EX1_DIM, EX2_WORD=EX2_WORD, EX2_DIM=EX2_DIM, EX3_WORD=EX3_WORD, EX3_DIM=EX3_DIM, SCRATCH=SCRATCH)
                                             CALL READ_TO_DATA(LN,INFILE,IOUT)
                               ELSE
                                             CALL SFAC_READ_AND_RETURN(SF, LN(N:), IU, IOUT, ROW_WORD, DIM1, COL_WORD, DIM2, EX1_WORD=EX1_WORD, EX1_DIM=EX1_DIM, EX2_WORD=EX2_WORD, EX2_DIM=EX2_DIM, EX3_WORD=EX3_WORD, EX3_DIM=EX3_DIM)
                                             CALL READ_TO_DATA(LN,IU,IOUT)
                               END IF
                               LLOC = ONE
                           CASE (BLNK,COM)   !READ NEXT LINE IF BLANK
                               IF(IU==Z) THEN
                                             CALL READ_TO_DATA(LN,INFILE,IOUT)
                                             IF(LN==BLNK) CALL STOP_ERROR(INFILE=IN,OUTPUT=IOUT,MSG = 'ULOAD FAILED TO LOAD INPUT LINE.'//NL//'THIS MOST LIKELY OCCURED BECAUSE THE END OF FILE WAS REACHED WHILE LOADING INPUT.'//BLN//'POSSIBLE CAUSES ARE NOT ENOUGH STRESS PERIOD INPUT, AN EMPTY FILE,'//NL//'THE INPUT LINE IS EMPTY WHEN NUMBERS WERE EXPECTED,'//NL//'OR YOU SPECIFIED TRANSIENT WHEN YOU MEANT STATIC FOR A LIST-ARRAY INPUT.', MSG2=MSG)
                               ELSE
                                             CALL READ_TO_DATA(LN,IU,IOUT)
                                             IF(LN==BLNK) CALL STOP_ERROR(INFILE=IU,OUTPUT=IOUT,MSG = 'ULOAD FAILED TO LOAD INPUT LINE.'//NL//'THIS MOST LIKELY OCCURED BECAUSE THE END OF FILE WAS REACHED WHILE LOADING INPUT.'//BLN//'POSSIBLE CAUSES ARE NOT ENOUGH STRESS PERIOD INPUT, AN EMPTY FILE,'//NL//'THE INPUT LINE IS EMPTY WHEN NUMBERS WERE EXPECTED,'//NL//'OR YOU SPECIFIED TRANSIENT WHEN YOU MEANT STATIC FOR A LIST-ARRAY INPUT.', MSG2=MSG)
                               END IF
                               LLOC = ONE
                               NO_MAIN_KEY = TRUE
                           CASE ('ARRAY','STATIC','TRANSIENT')   !IN CASE LIST ARRAY INPUT CALLS DIRECTLY ULOAD, BY PASS KEYWORDS
                               CYCLE
                           CASE ('LIST')    !IN CASE LIST ARRAY INPUT CALLS DIRECTLY ULOAD, ERROR ON LIST KEYWORD
                               IF(IU==Z) IU = IN
                               CALL STOP_ERROR( LINE=LN, INFILE=IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: EXPECTED TO LOAD A 2D ARRAY, BUT FOUND KEYWORD LIST. PLEASE REMOVE KEYWORD OR SWITCH IT TO "ARRAY".', MSG2=MSG)
                           CASE DEFAULT
                               LLOC = N
                               EXIT
                           END SELECT
                      END DO
    ELSE
        EXT='BINARY'
    END IF
    !
    SELECT CASE (EXT)
    CASE( 'SKIP', 'NULL', 'NUL' )     !-----------------------------------------------------------------------------------------------------------------------
                       SELECT TYPE (VAR)
                       TYPE IS (REAL(REAL64));     VAR = 0.0_REAL64  ! DOUBLE PRECISION
                       TYPE IS (REAL(REAL32));     VAR = 0.0_REAL32  ! SINGLE PRECISION
                       TYPE IS (INTEGER);          VAR = 0
                       TYPE IS (CHARACTER(*));     VAR = ''
                       TYPE IS (DATE_OPERATOR);    CALL VAR%DESTROY()
                       TYPE IS (REAL(REAL128));    VAR = 0.0_REAL128 ! QUAD PRECISION
                       END SELECT
                       LN = EXT//BLNK//LN
                       RETURN
    CASE( 'CONSTANT' ) !-----------------------------------------------------------------------------------------------------------------------
                       CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
                       CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE)
                       !
                       SELECT TYPE (VAR)
                       TYPE IS (DATE_OPERATOR)
                                                   !VAR = DATE_OPERATOR(LN(ISTART:ISTOP))  !--CAUSES COMILER ERROR
                                                   CALL GET_DATE(LN,LLOC,ISTART,ISTOP,IOUT,IN,VAR(ONE,ONE),NO_PARSE_WORD=TRUE,HAS_ERROR=NEG_LLOC,NO_DATE=TRUE)
                                                   IF(NEG_LLOC) THEN
                                                       IERR = 123
                                                   ELSE
                                                       DO CONCURRENT (J=ONE:DIM2, I=ONE:DIM1, I.NE.ONE.AND.J.NE.ONE ); VAR(I,J) = VAR(ONE,ONE)
                                                       END DO
                                                   END IF
                                                   !DO I=ONE, DIM1
                                                   !DO J=ONE, DIM2
                                                   !      CALL VAR(I,J)%INIT(LN(ISTART:ISTOP))
                                                   !      IF( VAR(I,J)%NOT_SET() ) THEN
                                                   !          IERR = 123
                                                   !          EXIT
                                                   !      END IF
                                                   !END DO
                                                   !END DO
                       CLASS DEFAULT
                                                   READ(LN(ISTART:ISTOP), *, IOSTAT=IERR) CONST
                       END SELECT
                       !
                       IF(IERR.NE.Z .AND. ALLOW_ERROR)   CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'FOUND KEYWORD CONSTANT, BUT FAILED TO READ THE VALUE LOCATED AFTER THE KEYWORD "CONSTANT".', MSG2=MSG)
                       IF(IERR.NE.Z .AND. CLEAR_IU)  IU = Z
                       !
                       SELECT TYPE (VAR)
                       TYPE IS (REAL(REAL64));     VAR = CONST
                       TYPE IS (REAL(REAL32));     VAR = REAL(CONST, REAL32)
                       TYPE IS (INTEGER)
                                                   READ(LN(ISTART:ISTOP), *, IOSTAT=IERR) I
                                                   VAR = I
                       TYPE IS (CHARACTER(*))
                                                   VAR = LN(ISTART:ISTOP)
                                                   IF(LINELEN<LEN_TRIM(LN(ISTART:ISTOP))) NEG_LLOC = TRUE
                                                   !
                       TYPE IS (REAL(REAL128));    VAR = REAL(CONST, REAL128)
                       END SELECT
                       !
                       CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,ISTART,ISTOP,SFAC_FILE) !ISTART, ISTOP ARE PLACE HOLDERS FOR BUF AND ISPLIT
                       !
                       IF(SFAC_FILE.NE.UNO) CALL SF%SET_ALL(SFAC_FILE)
                       !
                       IF(PRESENT(SFAC)) THEN
                                             SFAC = SF
                       ELSE
                                             SELECT TYPE (VAR)
                                             TYPE IS (REAL(REAL64 )); CALL SF%APPLY(VAR)  ! DOUBLE PRECISION
                                             TYPE IS (REAL(REAL32 )); CALL SF%APPLY(VAR)  ! SINGLE PRECISION
                                             TYPE IS (REAL(REAL128)); CALL SF%APPLY(VAR)  ! QUAD PRECISION
                                             END SELECT
                       END IF
                       !
                       LLOC=ONE
                       IF(NEG_LLOC) LLOC = NEG
                       LN = EXT//BLNK//LN
                       RETURN
    CASE( 'REPEAT' )   !-----------------------------------------------------------------------------------------------------------------------
                       !
                       IF(PRESENT(NO_REPEAT)) THEN
                               IF(NO_REPEAT) CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD FOUND KEYWORD "REPEAT" BUT THIS PARTICULAR FEATURE DOES NOT SUPPORT IT.'//NL//'(NOTE APPLYING A SCALE FACTOR WITH SFAC, DOES NOT SUPPORT THIS.)'//NL//'PLEAUSE CHANGE INPUT TO USE OPEN/CLOSE TO RELOAD THE FILE INSTEAD OF REPEATING IT.', MSG2=MSG)
                       END IF
                       !
                       CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
                       CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,ISTART,ISTOP,SFAC_FILE) !ISTART, ISTOP ARE PLACE HOLDERS FOR BUF AND ISPLIT
                       !
                       IF(SFAC_FILE.NE.UNO) CALL SF%SET_ALL(SFAC_FILE)
                       !
                       IF(PRESENT(SFAC)) THEN
                                             SFAC = SF
                       ELSE
                                             SELECT TYPE (VAR)
                                             TYPE IS (REAL(REAL64 )); CALL SF%APPLY(VAR)  ! DOUBLE PRECISION
                                             TYPE IS (REAL(REAL32 )); CALL SF%APPLY(VAR)  ! SINGLE PRECISION
                                             TYPE IS (REAL(REAL128)); CALL SF%APPLY(VAR)  ! QUAD PRECISION
                                             END SELECT
                       END IF
                       !
                       LN = EXT//BLNK//LN
                       RETURN
    CASE( 'RELOAD' ) !-----------------------------------------------------------------------------------------------------------------------
                     !
                     CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
                     IF(IU==Z) THEN
                          IF(PRESENT(OLD_IU))  IU = OLD_IU
                          IF(ALLOW_ERROR .AND. (IU==Z .OR. .NOT. PRESENT(OLD_IU))) THEN
                              CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD FOUND KEYWORD "RELOAD" BUT THERE WAS NOT A PREVIOUSLY OPENED FILE TO USE OR THIS INPUT FEATURE DOES NOT SUPPORT THE "RELOAD" KEYWORD.'//NL//'PLEASE MAKE SURE THAT THIS ULOAD WAS PRECEDED BY AN EXTERNAL UNIT, DATAUNIT UNIT, OR DATAFILE FILE'//NL//'SO THT THE FILE CAN BE CONTINUED TO LOAD NEXT INPUT OR CHANGE KEYWORD TO ONE THAT OPENS A FILE OR POINTS TO AN EXISTING OPENED FILE.'//NL//'(e.g. THIS KEYWORD SHOULD ONLY APPEAR IN A TFR AFTER AN EXTERNAL, DATAUNIT, or DATAFILE KEYWORDS TO REUSE THEIR UNIT NUMBERS AND CONTINUE LOADING FROM THEIR FILES)', MSG2=MSG)
                          END IF
                          !
                          IF(IU.NE.Z) THEN
                                                CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,ISTART,ISTOP,SFAC_FILE) !ISTART, ISTOP ARE PLACE HOLDERS FOR BUF AND ISPLIT
                                                !
                                                INQUIRE(IU,FORM=FORM_CHK, OPENED=KEEP_IU)
                                                IF(.NOT. KEEP_IU) CALL STOP_ERROR(LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ULOAD ERROR: RECIEVED UNIT NUMBER "'//NUM2STR(IU)//'" WHICH IS NOT ASSOCIATED WITH A FILE. THIS COULD BE THE RESULT OF USING "EXTERNAL" OR "DATAUNIT" WITH A UNIT THAT IS NOT OPENED BY THE NAME FILE.', MSG2=MSG)
                                                BIN = FORM_CHK .NE. 'FORMATTED'
                                                !
                                                IF(BIN) THEN
                                                    REWIND(IU) !MOVE BACK TO TOP OF FILE
                                                ELSE
                                                    CALL UTF8_BOM_OFFSET_REWIND(IU)  !Check in case file has a UTF8 BOM header, rewind to correct location
                                                END IF
                                                !
                                                ERROR_IU = IU
                                                KEEP_IU  = TRUE
                                                LLOC     = ONE
                                                IF(.NOT. ALLOW_ERROR) CLEAR_IU = TRUE
                                                IF(.NOT. BIN) CALL READ_TO_DATA(LN,IU,IOUT)  !UNIT IS BEING PASSED IN SO READ IN LINE FROM IT
                          END IF
                       ELSE
                            CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD FOUND KEYWORD "RELOAD" BUT THIS INPUT OPTION EITHER DOES NOT SUPPORT RELOAD OR THERE IS A CODE ERROR. PLEASE CHANGE RELOAD TO SOMETHING LIKE "EXTERNAL  55  REWIND"', MSG2=MSG)
                     END IF
    CASE( 'LOAD_NEXT' )!-----------------------------------------------------------------------------------------------------------------------
                       !
                       IF(IU==Z) THEN
                            IF(PRESENT(OLD_IU))  IU = OLD_IU
                            IF(ALLOW_ERROR .AND. (IU==Z .OR. .NOT. PRESENT(OLD_IU))) THEN
                                CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD FOUND KEYWORD "LOAD_NEXT" BUT THERE WAS NOT A PREVIOUSLY OPENED FILE TO USE OR THIS INPUT FEATURE DOES NOT SUPPORT THE "LOAD_NEXT" KEYWORD (viz. SFAC DOES NOT SUPPORT IT).'//NL//'PLEASE MAKE SURE THAT THIS ULOAD WAS PRECEDED BY AN EXTERNAL UNIT, DATAUNIT UNIT, OR DATAFILE FILE'//NL//'SO THT THE FILE CAN BE CONTINUED TO LOAD NEXT INPUT'//NL//'OR CHANGE KEYWORD TO ONE THAT OPENS A FILE OR POINTS TO AN EXISTING OPENED FILE.'//NL//'(e.g. THIS KEYWORD SHOULD ONLY APPEAR IN A TFR AFTER AN EXTERNAL, DATAUNIT, or DATAFILE KEYWORDS TO REUSE THEIR UNIT NUMBERS AND CONTINUE LOADING FROM THEIR FILES)', MSG2=MSG)
                            END IF
                            !
                            IF(IU.NE.Z) THEN
                                                  CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,ISTART,ISTOP,SFAC_FILE) !ISTART, ISTOP ARE PLACE HOLDERS FOR BUF AND ISPLIT
                                                  !
                                                  INQUIRE(IU,FORM=FORM_CHK, OPENED=KEEP_IU)
                                                  IF(.NOT. KEEP_IU) CALL STOP_ERROR(LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ULOAD ERROR: RECIEVED UNIT NUMBER "'//NUM2STR(IU)//'" WHICH IS NOT ASSOCIATED WITH A FILE. THIS COULD BE THE RESULT OF USING "EXTERNAL" OR "DATAUNIT" WITH A UNIT THAT IS NOT OPENED BY THE NAME FILE.', MSG2=MSG)
                                                  BIN = FORM_CHK .NE. 'FORMATTED'
                                                  !
                                                  ERROR_IU = IU
                                                  KEEP_IU  = TRUE
                                                  LLOC     = ONE
                                                  IF(.NOT. ALLOW_ERROR) CLEAR_IU = TRUE
                                                  IF(.NOT. BIN) CALL READ_TO_DATA(LN,IU,IOUT)  !UNIT IS BEING PASSED IN SO READ IN LINE FROM IT
                            END IF
                       ELSE
                            CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD FOUND KEYWORD "LOAD_NEXT" BUT THIS INPUT OPTION EITHER DOES NOT SUPPORT RELOAD OR THERE IS A CODE ERROR. PLEASE CHANGE LOAD_NEXT TO SOMETHING LIKE "DATAFILE MyFile.txt"', MSG2=MSG)
                       END IF
    END SELECT
    !
    IF(IU==Z) THEN
          ALLOCATE(FL)
          !
          CALL FL%OPEN(LN,LLOC,IOUT,IN,NOSTOP=TRUE,REQKEY=TRUE,BINARY=BIN)
          !
          SFAC_FILE = FL%SCALE
          FL%SCALE = UNO
          !
          BIN = FL%BINARY
          IF(.NOT. FL%ERROR) THEN
                                 IU = FL%IU
                                 IF(IU.NE.Z .AND. .NOT. FL%OPENCLOSE) KEEP_IU = TRUE  !FONUD EXTERNAL KEYWORD, SO PASS BACK WHAT WAS LOADED
                                 IF(IU.NE.Z) ERROR_IU = IU
                                 IF(IU == Z .AND. NO_INTERN) CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: THIS SPECIFIC INPUT LINE DOES NOT ALLOW FOR THE "INTERNAL" KEYWORD. PLEASE MOVE INTERNAL INPUT TO SEPARATE FILE AND CHANGE KEYWORD TO "OPEN/CLOSE" OR "EXTERNAL".', MSG2=MSG)
                                 IF(IU == Z) IU = INFILE  !FOUND INTERNAL
                                 LLOC = ONE
                                 IF(.NOT. BIN) CALL READ_TO_DATA(LN,IU,IOUT)
          ELSE !NO KEYWORD FOUND, BUT THIS IS REQUIRED FOR 2D
              !
              IF(ALLOW_ERROR) THEN
                     CALL STOP_ERROR( LINE=LN, INFILE=IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: 2D ARRAYS CANNOT BE LOADED WITH IMPLIED INTERNAL. PLEASE USE A KEYWORD TO INDICATE WHERE DATA IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)', MSG2=MSG)
              ELSEIF(CLEAR_IU) THEN
                     IU = Z
                     LLOC = Z
              END IF
              RETURN
          END IF
    END IF
    !
    IF(.NOT. BIN .AND. IU.NE.Z) THEN
                                DO !CHECK FOR KEYWORD OF SFAC WITHIN LIST
                                      N = LLOC
                                      CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE)
                                      EXT = LN(ISTART:ISTOP)
                                      CALL UPPER(EXT)
                                      IF (EXT == 'SFAC') THEN
                                          CALL SFAC_READ_AND_RETURN(SF, LN(N:), IU, IOUT, ROW_WORD, DIM1, COL_WORD, DIM2, EX1_WORD=EX1_WORD, EX1_DIM=EX1_DIM, EX2_WORD=EX2_WORD, EX2_DIM=EX2_DIM, EX3_WORD=EX3_WORD, EX3_DIM=EX3_DIM)
                                          LLOC = ONE
                                          CALL READ_TO_DATA(LN,IU,IOUT)
                                      ELSE
                                          LLOC = N
                                          EXIT
                                      END IF
                                END DO
    END IF
    !
    IF(BIN) THEN
                !
                IF(IU==INFILE)                             CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: "INTERNAL" AND "BINARY" KEYWORD FOUND, BUT THIS IS NOT ALLOWED!', MSG2=MSG)
                IF(PRESENT(NO_BINARY)) THEN; IF(NO_BINARY) CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: "BINARY" KEYWORD FOUND, BUT THIS INPUT PROPERTY DOES NOT SUPPORT BINARY FILE INPUT. PLEASE USE ASCII/TEXT INPUT INSTEAD AND REMOVE "BINARY" KEYWORD.', MSG2=MSG)
                END IF
                !
                SELECT TYPE (VAR)
                TYPE IS (REAL(REAL64));     READ(IU, IOSTAT=IERR) VAR   ! DOUBLE PRECISION
                TYPE IS (REAL(REAL32));     READ(IU, IOSTAT=IERR) VAR   ! SINGLE PRECISION
                TYPE IS (INTEGER);          READ(IU, IOSTAT=IERR) VAR
                TYPE IS (CHARACTER(*));     READ(IU, IOSTAT=IERR) VAR
                TYPE IS (DATE_OPERATOR);    READ(IU, IOSTAT=IERR) VAR
                TYPE IS (REAL(REAL128));    READ(IU, IOSTAT=IERR) VAR   ! QUAD PRECISION
                END SELECT
                !
                IF(IERR.NE.Z .AND. ALLOW_ERROR)   CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ATTEMPT MADE TO READ AN ARRAY WITH ULOAD IN A BINARY FILE, BUT IT FAILED TO LOAD. PLEASE CHECK THAT INPUT FORMAT IS IN THE EXPECTED BINARY STRUCTURE AND ORDERED CORRECTLY', MSG2=MSG)
                IF(IERR.NE.Z .AND. CLEAR_IU)  IU = Z
    ELSE
        IF(READ_BY_DIM1) THEN
                             DO I=1, DIM2
                                            IF(I>ONE) CALL READ_TO_DATA(LN,IU,IOUT)
                                            IF(LN=='') THEN
                                                IERR = -1
                                                EXIT
                                            END IF
                                            BACKSPACE(IU)
                                            IF(READ_ID) THEN
                                                            SELECT TYPE (VAR)
                                                            TYPE IS (REAL(REAL64));     READ(IU, *, IOSTAT=IERR) IID, VAR(:,I)   ! DOUBLE PRECISION
                                                            TYPE IS (REAL(REAL32));     READ(IU, *, IOSTAT=IERR) IID, VAR(:,I)   ! SINGLE PRECISION
                                                            TYPE IS (INTEGER);          READ(IU, *, IOSTAT=IERR) IID, VAR(:,I)
                                                            TYPE IS (CHARACTER(*))
                                                                                        READ(IU, '(A)', IOSTAT=IERR) LN
                                                                                        LLOC=ONE
                                                                                        CALL GET_INTEGER(LN,LLOC,ISTART,ISTOP,IOUT,IU,IID,MSG='NOSTOP');  IF(IID==inf_I) IERR = TWO  !FLAG ERROR
                                                                                        DO J=ONE, DIM1
                                                                                             CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE)
                                                                                             VAR(J,I) = LN(ISTART:ISTOP)
                                                                                             IF(LINELEN<LEN_TRIM(LN(ISTART:ISTOP))) NEG_LLOC = TRUE
                                                                                        END DO
                                                            TYPE IS (DATE_OPERATOR);    READ(IU, *, IOSTAT=IERR) IID, VAR(:,I)
                                                            TYPE IS (REAL(REAL128));    READ(IU, *, IOSTAT=IERR) IID, VAR(:,I)   ! QUAD PRECISION
                                                            END SELECT
                                                            !
                                                            IF(SET_ID)  ID(I) = IID
                                            ELSE
                                                            SELECT TYPE (VAR)
                                                            TYPE IS (REAL(REAL64));     READ(IU, *, IOSTAT=IERR) VAR(:,I)    ! DOUBLE PRECISION
                                                            TYPE IS (REAL(REAL32));     READ(IU, *, IOSTAT=IERR) VAR(:,I)    ! SINGLE PRECISION
                                                            TYPE IS (INTEGER);          READ(IU, *, IOSTAT=IERR) VAR(:,I)
                                                            TYPE IS (CHARACTER(*))
                                                                                        READ(IU, '(A)', IOSTAT=IERR) LN
                                                                                        LLOC=ONE
                                                                                        DO J=ONE, DIM1
                                                                                             CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE)
                                                                                             VAR(J,I) = LN(ISTART:ISTOP)
                                                                                             IF(LINELEN<LEN_TRIM(LN(ISTART:ISTOP))) NEG_LLOC = TRUE
                                                                                        END DO
                                                            TYPE IS (DATE_OPERATOR);    READ(IU, *, IOSTAT=IERR) VAR(:,I)
                                                            TYPE IS (REAL(REAL128));    READ(IU, *, IOSTAT=IERR) VAR(:,I)   ! QUAD PRECISION
                                                            END SELECT
                                            END IF
                                            !
                                            IF(IERR.NE.Z)  EXIT
                             END DO
        ELSE !READ_BY_DIM2
                             DO I=1, DIM1
                                            IF(I>ONE) CALL READ_TO_DATA(LN,IU,IOUT)
                                            IF(LN=='') THEN
                                                IERR = -1
                                                EXIT
                                            END IF
                                            BACKSPACE(IU)
                                            IF(READ_ID) THEN
                                                            SELECT TYPE (VAR)
                                                            TYPE IS (REAL(REAL64));     READ(IU, *, IOSTAT=IERR) IID, VAR(I,:)  ! DOUBLE PRECISION
                                                            TYPE IS (REAL(REAL32));     READ(IU, *, IOSTAT=IERR) IID, VAR(I,:)  ! SINGLE PRECISION
                                                            TYPE IS (INTEGER);          READ(IU, *, IOSTAT=IERR) IID, VAR(I,:)
                                                            TYPE IS (CHARACTER(*))
                                                                                        READ(IU, '(A)', IOSTAT=IERR) LN
                                                                                        LLOC=ONE
                                                                                        CALL GET_INTEGER(LN,LLOC,ISTART,ISTOP,IOUT,IU,IID,MSG='NOSTOP');  IF(IID==inf_I) IERR = TWO  !FLAG ERROR
                                                                                        DO J=ONE, DIM2
                                                                                             CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE)
                                                                                             VAR(I,J) = LN(ISTART:ISTOP)
                                                                                             IF(LINELEN<LEN_TRIM(LN(ISTART:ISTOP))) NEG_LLOC = TRUE
                                                                                        END DO
                                                            TYPE IS (DATE_OPERATOR);    READ(IU, *, IOSTAT=IERR) IID, VAR(I,:)
                                                            TYPE IS (REAL(REAL128));    READ(IU, *, IOSTAT=IERR) IID, VAR(I,:)   ! QUAD PRECISION
                                                            END SELECT
                                                            !
                                                            IF(SET_ID)  ID(I) = IID
                                            ELSE
                                                            SELECT TYPE (VAR)
                                                            TYPE IS (REAL(REAL64));     READ(IU, *, IOSTAT=IERR) VAR(I,:)   ! DOUBLE PRECISION
                                                            TYPE IS (REAL(REAL32));     READ(IU, *, IOSTAT=IERR) VAR(I,:)   ! SINGLE PRECISION
                                                            TYPE IS (INTEGER);          READ(IU, *, IOSTAT=IERR) VAR(I,:)
                                                            TYPE IS (CHARACTER(*))
                                                                                        READ(IU, '(A)', IOSTAT=IERR) LN
                                                                                        LLOC=ONE
                                                                                        DO J=ONE, DIM2
                                                                                             CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP,COM_STOP=TRUE)
                                                                                             VAR(I,J) = LN(ISTART:ISTOP)
                                                                                             IF(LINELEN<LEN_TRIM(LN(ISTART:ISTOP))) NEG_LLOC = TRUE
                                                                                        END DO
                                                            TYPE IS (DATE_OPERATOR);    READ(IU, *, IOSTAT=IERR) VAR(I,:)
                                                            TYPE IS (REAL(REAL128));    READ(IU, *, IOSTAT=IERR) VAR(I,:)   ! QUAD PRECISION
                                                            END SELECT
                                            END IF
                                            !
                                            IF(IERR.NE.Z)  EXIT
                             END DO
        END IF
        !IF(READ_BY_DIM1) THEN
        !                     DO I=1, DIM2
        !                                    IF(I>ONE) CALL READ_TO_DATA(LN,IU,IOUT)
        !                                    LLOC = ONE
        !                                    IF(READ_ID) THEN
        !                                          CALL URWORD(LN,LLOC,ISTART,ISTOP,Z,N,R,IOUT,IU)
        !                                          IF(PRESENT(ID)) THEN
        !                                                         READ(LN(ISTART:ISTOP), *, IOSTAT=IERR)      ID(I)
        !                                                                                       IF(IERR.NE.Z) ID(I) = Z
        !                                          END IF
        !                                    END IF
        !                                    !
        !                                    SELECT TYPE (VAR)
        !                                    TYPE IS (DOUBLE PRECISION); READ(LN(LLOC:), *, IOSTAT=IERR) VAR(:,I)
        !                                    TYPE IS (REAL);             READ(LN(LLOC:), *, IOSTAT=IERR) VAR(:,I)
        !                                    TYPE IS (INTEGER);          READ(LN(LLOC:), *, IOSTAT=IERR) VAR(:,I)
        !                                    TYPE IS (CHARACTER(*))
        !                                                                DO J=ONE, DIM1
        !                                                                     CALL URWORD(LN,LLOC,ISTART,ISTOP,Z,N,R,IOUT,IU)
        !                                                                     VAR(J,I) = LN(ISTART:ISTOP)
        !                                                                END DO
        !                                    END SELECT
        !                                    IF(IERR.NE.Z)  EXIT
        !                     END DO
        !ELSE !READ_BY_DIM2
        !                     DO I=1, DIM1
        !                                    IF(I>ONE) CALL READ_TO_DATA(LN,IU,IOUT)
        !                                    LLOC = ONE
        !                                    IF(READ_ID) THEN
        !                                          CALL URWORD(LN,LLOC,ISTART,ISTOP,Z,N,R,IOUT,IU)
        !                                          IF(PRESENT(ID)) THEN
        !                                                         READ(LN(ISTART:ISTOP), *, IOSTAT=IERR)      ID(I)
        !                                                                                       IF(IERR.NE.Z) ID(I) = Z
        !                                          END IF
        !                                    END IF
        !                                    !
        !                                    SELECT TYPE (VAR)
        !                                    TYPE IS (DOUBLE PRECISION); READ(LN(LLOC:), *, IOSTAT=IERR) VAR(I,:)
        !                                    TYPE IS(REAL);              READ(LN(LLOC:), *, IOSTAT=IERR) VAR(I,:)
        !                                    TYPE IS (INTEGER);          READ(LN(LLOC:), *, IOSTAT=IERR) VAR(I,:)
        !                                    TYPE IS (CHARACTER(*))
        !                                                                DO J=ONE, DIM2
        !                                                                    CALL URWORD(LN,LLOC,ISTART,ISTOP,Z,N,R,IOUT,IU)
        !                                                                    VAR(I,J) = LN(ISTART:ISTOP)
        !                                                                END DO
        !                                    END SELECT
        !                                    IF(IERR.NE.Z)  EXIT
        !                     END DO
        !END IF
        !
        IF(IERR.NE.Z .AND. ALLOW_ERROR) THEN
               IF(NO_MAIN_KEY) THEN
                    CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ATTEMPT MADE TO READ LIST FROM ULOAD ON LINE, BUT IT FAILED TO LOAD THE FOLLOWING VALUE "'//LN(ISTART:ISTOP)//'"'//BLN//'NOTE THAT NO KEYWORD WAS FOUND ON THE PREVIOUS LINE, SO CODE AUTOMOVED DOWNWARD TO NEXT LINE.'//NL//'YOU MAYBE MISSING A KEYWORD (viz. INTERNAL, EXTERNAL, OPEN/CLOSE, DATEFILE, DATAUNIT).', MSG2=MSG)
               ELSE
                    SELECT TYPE (VAR)
                    TYPE IS (DATE_OPERATOR);           CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ATTEMPT MADE TO READ ROW OF DATES FROM ULOAD ON LINE, BUT IT FAILED TO CONVERT THE FOLLOWING TO A CALENDAR DATE "'//LN(ISTART:ISTOP)//'"'//BLN//'THE ACCEPTED DATE FORMATS ARE "mm/dd/YYYY" OR "YYYY-mm-dd" IF YOU WANT TO ADD A 24-HOUR TIME TO IT YOU MUST ADD TO THE DATE "Thh:mm:ss" (e.g. "YYYY-mm-ddThh:mm:ss")', MSG2=MSG)
                    TYPE IS (GENERIC_INPUT_FILE);      CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ATTEMPT MADE TO OPEN ROW OF FILES WITH ULOAD, BUT IT FAILED TO EITHER OPEN, FIND THE FILE, OR IS NOT SET UP CORRECTLY. THE FOLLOWING IS THE FILE THAT WAS ATTEMPTED TO BE OPENED "'//LN(ISTART:ISTOP)//'".', MSG2=MSG)
                    CLASS DEFAULT
                                                       CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ATTEMPT MADE TO READ A ROW OF NUMBERS FROM ULOAD ON LINE, BUT IT FAILED TO LOAD.'//NL//' (NOTE THAT ERROR CODE -1 MAY INDICATE THAT YOU DO NOT HAVE ENOUGH NUMBERS ON THE LINE'//NL//'  e.g. EXPECTS 5 NUMBERS BUT ONLY 4 NUMBERS ON LINE)', MSG2=MSG)
                    END SELECT

               END IF
        ELSEIF(IERR.NE.Z .AND. CLEAR_IU) THEN
               IU = Z
               LLOC = Z
        END IF
        !
    END IF
    !
    IF(SFAC_FILE.NE.UNO) CALL SF%SET_ALL(SFAC_FILE)
    !
    IF(PRESENT(SFAC)) THEN
                           SFAC = SF
    ELSE
                           SELECT TYPE (VAR)
                           TYPE IS (REAL(REAL64));  CALL SF%APPLY(VAR)   ! DOUBLE PRECISION
                           TYPE IS (REAL(REAL32));  CALL SF%APPLY(VAR)   ! SINGLE PRECISION
                           TYPE IS (REAL(REAL128)); CALL SF%APPLY(VAR)   ! QUAD PRECISION
                           END SELECT
    END IF
    !
    IF(.NOT. KEEP_IU)    IU     = Z
    IF(NEG_LLOC)         LLOC   = NEG
    IF(PRESENT(OLD_IU))  OLD_IU = IU
    !
    IF(ALLOCATED(FL))  DEALLOCATE(FL)
    !
  END SUBROUTINE
  !
END MODULE
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
MODULE TRANSIENT_FILE_READER_INSTRUCTION
  USE CONSTANTS
  USE UTIL_INTERFACE,                    ONLY: READ_TO_DATA, COMMENT_INDEX, UPPER, PARSE_WORD, GET_WORD, STOP_ERROR
  USE GENERIC_INPUT_FILE_INSTRUCTION,    ONLY: GENERIC_INPUT_FILE
  USE ULOAD_AND_SFAC_INTERFACE,          ONLY: SFAC_DATA, ULOAD
  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
  USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: REAL32, REAL64, REAL128
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: TRANSIENT_FILE_READER
  !
  INTEGER, PARAMETER:: MAX_LINE_LEN=700  !THIS SETS THE LENGTH OF SOME HARD WIRED STRINGS => CHARACTER(MAX_LINE_LEN)::LN
  !
  TYPE, EXTENDS(GENERIC_INPUT_FILE):: TRANSIENT_FILE_READER
    !TYPE(SFAC_DATA):: SFAC, SFAC_OLD
    CHARACTER(:), ALLOCATABLE:: LN
    CHARACTER(:), ALLOCATABLE:: ROW_WORD, COL_WORD, EX1_WORD, EX2_WORD, EX3_WORD, BLOCK_END_KEY
    INTEGER:: EX1_DIM, EX2_DIM, EX3_DIM
    LOGICAL:: NOID, READ_BY_DIM2
    LOGICAL:: LOAD_NEXT_FILE
    LOGICAL:: NO_BINARY   = FALSE
    LOGICAL:: ENTIRE_LINE = FALSE
    LOGICAL:: BEGIN_END_OPTIONAL = FALSE
    LOGICAL:: TRUNCATED   = FALSE  !IF BLOCK INPUT THEN SET TO TRY WHEN END IS NOT FOUND
    LOGICAL:: REPEAT      = FALSE  !SET TO TRUE IF KEYWORD REPEAT WAS FOUND
    INTEGER:: OLD_IU      = Z
    !REAL(REAL64):: GLOBAL_SCALE = UNO
    !
    CONTAINS
    PROCEDURE,    NOPASS:: LOAD_BLOCK => LOAD_NEXT_FILE_BLOCK
    PROCEDURE, PASS(TFR):: ALLOC_LN   => ALLOC_TFR_LINE
    PROCEDURE, PASS(TFR):: DESTROY    => DEALLOCATE_FILE_READER
    !
    GENERIC:: INIT => INITIALIZE_FILE_READER_LINE,INITIALIZE_FILE_READER_FILE, INITIALIZE_FILE_READER_FID
    GENERIC:: NEXT => LOAD_NEXT_FILE_SCALAR, LOAD_NEXT_FILE_VECTOR, LOAD_NEXT_FILE_ARRAY  !(VAR, SFAC, ROW_WORD, COL_WORD, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM, READ_BY_DIM2)
    !              => LOAD_NEXT_FILE_SCALAR calls LOAD_NEXT_FILE_BLOCK if BL is passed in
    !
    PROCEDURE, PASS(TFR), PRIVATE :: INITIALIZE_FILE_READER_LINE   ! <= INIT
    PROCEDURE, PASS(TFR), PRIVATE :: INITIALIZE_FILE_READER_FILE   ! <= INIT
    PROCEDURE, PASS(TFR), PRIVATE :: INITIALIZE_FILE_READER_FID    ! <= INIT
    PROCEDURE, PASS(TFR), PRIVATE :: LOAD_NEXT_FILE_SCALAR
    PROCEDURE, PASS(TFR), PRIVATE :: LOAD_NEXT_FILE_VECTOR
    PROCEDURE, PASS(TFR), PRIVATE :: LOAD_NEXT_FILE_ARRAY
    !
    FINAL:: DEALLOCATE_FILE_READER_FINAL
  END TYPE
  !
  CONTAINS
  !
  PURE SUBROUTINE ALLOC_TFR_LINE(TFR, LEN_LN, DIM)
    CLASS(TRANSIENT_FILE_READER), INTENT(INOUT):: TFR
    INTEGER,      OPTIONAL,       INTENT(IN   ):: LEN_LN
    INTEGER,      OPTIONAL,       INTENT(IN   ):: DIM
    INTEGER:: N, M
    !
    M = Z
    IF(PRESENT(LEN_LN))                 M = LEN_LN
    IF(PRESENT(DIM   )) THEN; IF(DIM>Z) M = DIM
    END IF
    !    
    IF(ALLOCATED(TFR%LN)) THEN
       N = LEN(TFR%LN)
       IF(M > Z) THEN
                 IF(N.NE.M) THEN
                     DEALLOCATE(TFR%LN)
                       ALLOCATE(CHARACTER(M):: TFR%LN)
                 END IF
       ELSE
                 IF(N.NE.MAX_LINE_LEN) THEN
                     DEALLOCATE(TFR%LN)
                       ALLOCATE(CHARACTER(MAX_LINE_LEN):: TFR%LN)
                 END IF
           
       END IF
    ELSE
                IF(M > Z) THEN
                    ALLOCATE(CHARACTER(M):: TFR%LN)
                ELSE
                    ALLOCATE(CHARACTER(MAX_LINE_LEN):: TFR%LN)
                END IF
    END IF
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_FILE_READER_LINE(TFR,LLOC,LINE,IOUT,IN,NOID, ROW_WORD, COL_WORD, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM, READ_BY_DIM2, NO_BINARY,ENTIRE_LINE, BLOCK_END_KEY, BEGIN_END_OPTIONAL, LEN_LN)
    CLASS(TRANSIENT_FILE_READER):: TFR
    INTEGER,                INTENT(INOUT):: LLOC
    CHARACTER(*),           INTENT(IN   ):: LINE
    INTEGER,                INTENT(IN   ):: IOUT, IN
    LOGICAL,                INTENT(IN   ):: NOID
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: ROW_WORD, COL_WORD, EX1_WORD, EX2_WORD, EX3_WORD
    INTEGER,      OPTIONAL, INTENT(IN   ):: EX1_DIM, EX2_DIM, EX3_DIM
    LOGICAL, OPTIONAL,      INTENT(IN   ):: READ_BY_DIM2, NO_BINARY
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: BLOCK_END_KEY
    LOGICAL,      OPTIONAL, INTENT(IN   ):: ENTIRE_LINE, BEGIN_END_OPTIONAL
    INTEGER,      OPTIONAL, INTENT(IN   ):: LEN_LN
    INTEGER:: DIM
    CHARACTER(8):: KEY
    !
    CALL DEALLOCATE_FILE_READER(TFR)
    !
    DIM = Z
    KEY = BLNK
    !
    CALL TFR%OPEN(LINE,LLOC,IOUT,IN,KEY=KEY, DIM=DIM)
    !
    IF(TFR%IU == Z         ) CALL STOP_ERROR(LINE,IN,IOUT,'TRANSIENT FILE READER ERROR: TRANSIENT FILE (THE FILE THAT CONTAINS THE LIST OF FILES) IS SPECIFIED WITH "INTERNAL". THIS IS NOT ALLOWED. INSTEAD SPECIFY THE TRANSIENT FILE (FILE OF FILES) WITH EITHER "OPEN/CLOSE", "EXTERNAL", "DATAUNIT", OR "DATAFILE."')
    IF(KEY    == 'CONSTANT') CALL STOP_ERROR(LINE,IN,IOUT,'TRANSIENT FILE READER ERROR: TRANSIENT FILE (THE FILE THAT CONTAINS THE LIST OF FILES) IS SPECIFIED WITH "CONSTANT". THIS IS NOT ALLOWED. INSTEAD SPECIFY THE TRANSIENT FILE (FILE OF FILES) WITH EITHER "OPEN/CLOSE", "EXTERNAL", "DATAUNIT", OR "DATAFILE."')
    !
    TFR%LOAD_NEXT_FILE = KEY.NE.'DATAFILE' .AND. KEY.NE.'DATAUNIT'  !IF TFR%OPEN SUCESSFUN THEN KEYWORD PLACED TO THE LEFT OF LINE, SO LINE_IN HAS LINE_OUT = "KEYWORD LINE_OUT"
    !
    CALL ALLOC_TFR_LINE(TFR, LEN_LN, DIM)
    !
    TFR%NOID = NOID
    !
    IF(PRESENT(ROW_WORD)) THEN
           TFR%ROW_WORD = ROW_WORD
    ELSE
           TFR%ROW_WORD = 'n'
    END IF
    !
    IF(PRESENT(COL_WORD)) THEN
           TFR%COL_WORD = COL_WORD
    ELSE
           TFR%COL_WORD = 'n'
    END IF
    !
    IF(PRESENT(EX1_WORD)) THEN
           TFR%EX1_WORD = EX1_WORD
           TFR%EX1_DIM  = EX1_DIM
    ELSE
           TFR%EX1_WORD = 'n'
           TFR%EX1_DIM  = Z
    END IF
    !
    IF(PRESENT(EX2_WORD)) THEN
           TFR%EX2_WORD = EX2_WORD
           TFR%EX2_DIM  = EX2_DIM
    ELSE
           TFR%EX2_WORD = 'n'
           TFR%EX2_DIM  = Z
    END IF
    !
    IF(PRESENT(EX3_WORD)) THEN
           TFR%EX3_WORD = EX3_WORD
           TFR%EX3_DIM  = EX3_DIM
    ELSE
           TFR%EX3_WORD = 'n'
           TFR%EX3_DIM  = Z
    END IF
    !
    IF(PRESENT(READ_BY_DIM2)) THEN
        TFR%READ_BY_DIM2 = READ_BY_DIM2
    ELSE
        TFR%READ_BY_DIM2 = FALSE
    END IF
    !
    IF(PRESENT(NO_BINARY))    TFR%NO_BINARY = NO_BINARY
    !
    IF(PRESENT(BLOCK_END_KEY)) THEN
        TFR%BLOCK_END_KEY = TRIM(ADJUSTL(BLOCK_END_KEY))
    ELSE
        TFR%BLOCK_END_KEY = 'END'
    END IF
    !
    IF(PRESENT(BEGIN_END_OPTIONAL)) THEN
        TFR%BEGIN_END_OPTIONAL = BEGIN_END_OPTIONAL
    ELSE
        TFR%BEGIN_END_OPTIONAL = FALSE
    END IF
    !
    IF(PRESENT(ENTIRE_LINE)) THEN
        TFR%ENTIRE_LINE = ENTIRE_LINE
    ELSE
        TFR%ENTIRE_LINE = FALSE
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_FILE_READER_FID(TFR, FID, IOUT, IN, NOID, ROW_WORD, COL_WORD, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM, READ_BY_DIM2, NO_BINARY, DATAFILE,ENTIRE_LINE, BLOCK_END_KEY, GLOBAL_SCALE, BEGIN_END_OPTIONAL, LEN_LN)
    CLASS(TRANSIENT_FILE_READER):: TFR
    INTEGER,                    INTENT(IN):: FID
    INTEGER,                    INTENT(IN):: IOUT, IN
    LOGICAL,                    INTENT(IN):: NOID
    CHARACTER(*),     OPTIONAL, INTENT(IN):: ROW_WORD, COL_WORD, EX1_WORD, EX2_WORD, EX3_WORD
    INTEGER,          OPTIONAL, INTENT(IN):: EX1_DIM, EX2_DIM, EX3_DIM
    LOGICAL,          OPTIONAL, INTENT(IN):: READ_BY_DIM2, NO_BINARY, DATAFILE
    CHARACTER(*),     OPTIONAL, INTENT(IN):: BLOCK_END_KEY
    REAL(REAL64),     OPTIONAL, INTENT(IN):: GLOBAL_SCALE
    LOGICAL,          OPTIONAL, INTENT(IN):: ENTIRE_LINE, BEGIN_END_OPTIONAL
    INTEGER,          OPTIONAL, INTENT(IN):: LEN_LN
    INTEGER:: LLOC
    !
    CALL DEALLOCATE_FILE_READER(TFR)
    !
    CALL ALLOC_TFR_LINE(TFR, LEN_LN)
    !
    TFR%LN(:)=BLNK
    TFR%NOID = NOID
    !
    LLOC = ONE
    !
    TFR%IU = FID !CALL TFR%OPEN(LLOC,LINE,IOUT,IN,IU=FID)
    TFR%BINARY    = FALSE
    TFR%ERROR     = FALSE
    TFR%OPENCLOSE = FALSE
    TFR%IOUT = IOUT
    !
    IF(PRESENT(DATAFILE)) THEN
        TFR%LOAD_NEXT_FILE =  .NOT. DATAFILE
    ELSE
        TFR%LOAD_NEXT_FILE = TRUE
    END IF
    !
    IF(PRESENT(ROW_WORD)) THEN
           TFR%ROW_WORD = ROW_WORD
    ELSE
           TFR%ROW_WORD = 'n'
    END IF
    !
    IF(PRESENT(COL_WORD)) THEN
           TFR%COL_WORD = COL_WORD
    ELSE
           TFR%COL_WORD = 'n'
    END IF
    !
    IF(PRESENT(EX1_WORD)) THEN
           TFR%EX1_WORD = EX1_WORD
           TFR%EX1_DIM  = EX1_DIM
    ELSE
           TFR%EX1_WORD = 'n'
           TFR%EX1_DIM  = Z
    END IF
    !
    IF(PRESENT(EX2_WORD)) THEN
           TFR%EX2_WORD = EX2_WORD
           TFR%EX2_DIM  = EX2_DIM
    ELSE
           TFR%EX2_WORD = 'n'
           TFR%EX2_DIM  = Z
    END IF
    !
    IF(PRESENT(EX3_WORD)) THEN
           TFR%EX3_WORD = EX3_WORD
           TFR%EX3_DIM  = EX3_DIM
    ELSE
           TFR%EX3_WORD = 'n'
           TFR%EX3_DIM  = Z
    END IF
    !
    IF(PRESENT(READ_BY_DIM2)) THEN
        TFR%READ_BY_DIM2 = READ_BY_DIM2
    ELSE
        TFR%READ_BY_DIM2 = FALSE
    END IF
    !
    IF(PRESENT(NO_BINARY))    TFR%NO_BINARY = NO_BINARY
    !
    IF(PRESENT(BLOCK_END_KEY)) THEN
        TFR%BLOCK_END_KEY = TRIM(ADJUSTL(BLOCK_END_KEY))
    ELSE
        TFR%BLOCK_END_KEY = 'END'
    END IF
    !
    IF(PRESENT(BEGIN_END_OPTIONAL)) THEN
        TFR%BEGIN_END_OPTIONAL = BEGIN_END_OPTIONAL
    ELSE
        TFR%BEGIN_END_OPTIONAL = FALSE
    END IF
    !
    IF(PRESENT(ENTIRE_LINE)) THEN
        TFR%ENTIRE_LINE = ENTIRE_LINE
    ELSE
        TFR%ENTIRE_LINE = FALSE
    END IF
    !
    IF(PRESENT(GLOBAL_SCALE)) TFR%SCALE = GLOBAL_SCALE
    !
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_FILE_READER_FILE(TFR, FILE, IOUT, IN, NOID, ROW_WORD, COL_WORD, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM, READ_BY_DIM2, NO_BINARY,ENTIRE_LINE, BLOCK_END_KEY, BEGIN_END_OPTIONAL, LEN_LN)
    CLASS(TRANSIENT_FILE_READER):: TFR
    CHARACTER(*),           INTENT(IN   ):: FILE
    INTEGER,                INTENT(IN   ):: IOUT, IN
    LOGICAL,                INTENT(IN   ):: NOID
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: ROW_WORD, COL_WORD, EX1_WORD, EX2_WORD, EX3_WORD
    INTEGER, OPTIONAL,      INTENT(IN   ):: EX1_DIM, EX2_DIM, EX3_DIM
    LOGICAL, OPTIONAL,      INTENT(IN   ):: READ_BY_DIM2, NO_BINARY
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: BLOCK_END_KEY
    LOGICAL,      OPTIONAL, INTENT(IN   ):: ENTIRE_LINE, BEGIN_END_OPTIONAL
    INTEGER,      OPTIONAL, INTENT(IN   ):: LEN_LN
    INTEGER:: LLOC
    INTEGER:: DIM
    CHARACTER(8):: KEY
    !
    CALL DEALLOCATE_FILE_READER(TFR)
    !
    DIM  = Z
    LLOC = ONE
    KEY  = BLNK
    !
    CALL TFR%OPEN(FILE,LLOC,IOUT,IN,KEY=KEY,DIM=DIM)
    !
    TFR%LOAD_NEXT_FILE =  KEY.NE.'DATAFILE' .AND. KEY.NE.'DATAUNIT'
    !
    CALL ALLOC_TFR_LINE(TFR, LEN_LN, DIM)
    !
    TFR%NOID = NOID
    !
    IF(PRESENT(ROW_WORD)) THEN
           TFR%ROW_WORD = ROW_WORD
    ELSE
           TFR%ROW_WORD = 'n'
    END IF
    !
    IF(PRESENT(COL_WORD)) THEN
           TFR%COL_WORD = COL_WORD
    ELSE
           TFR%COL_WORD = 'n'
    END IF
    !
    IF(PRESENT(EX1_WORD)) THEN
           TFR%EX1_WORD = EX1_WORD
           TFR%EX1_DIM  = EX1_DIM
    ELSE
           TFR%EX1_WORD = 'n'
           TFR%EX1_DIM  = Z
    END IF
    !
    IF(PRESENT(EX2_WORD)) THEN
           TFR%EX2_WORD = EX2_WORD
           TFR%EX2_DIM  = EX2_DIM
    ELSE
           TFR%EX2_WORD = 'n'
           TFR%EX2_DIM  = Z
    END IF
    !
    IF(PRESENT(EX3_WORD)) THEN
           TFR%EX3_WORD = EX3_WORD
           TFR%EX3_DIM  = EX3_DIM
    ELSE
           TFR%EX3_WORD = 'n'
           TFR%EX3_DIM  = Z
    END IF
    !
    IF(PRESENT(READ_BY_DIM2)) THEN
        TFR%READ_BY_DIM2 = READ_BY_DIM2
    ELSE
        TFR%READ_BY_DIM2 = FALSE
    END IF
    !
    IF(PRESENT(NO_BINARY))    TFR%NO_BINARY = NO_BINARY
    !
    IF(PRESENT(BLOCK_END_KEY)) THEN
        TFR%BLOCK_END_KEY = TRIM(ADJUSTL(BLOCK_END_KEY))
    ELSEIF(ALLOCATED(TFR%BLOCK_END_KEY)) THEN
         DEALLOCATE (TFR%BLOCK_END_KEY)
    END IF
    !
    IF(PRESENT(BEGIN_END_OPTIONAL)) THEN
        TFR%BEGIN_END_OPTIONAL = BEGIN_END_OPTIONAL
    ELSE
        TFR%BEGIN_END_OPTIONAL = FALSE
    END IF
    !
    IF(PRESENT(ENTIRE_LINE)) THEN
        TFR%ENTIRE_LINE = ENTIRE_LINE
    ELSE
        TFR%ENTIRE_LINE = FALSE
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_NEXT_TFR_BLOCK(TFR, BL, LLOC, IU, SKIP_END_KEY)  !ONLY CALLED FROM LOAD_NEXT_FILE_SCALAR
    ! ASSUMES THAT COLUMNS ARE STORED IN FIRST DIMENSION (STFRDARD STRUCTURE FOR MF)
    CLASS(TRANSIENT_FILE_READER), INTENT(INOUT):: TFR
    CLASS(GENERIC_BLOCK_READER),  INTENT(INOUT):: BL
    INTEGER,                      INTENT(INOUT):: LLOC, IU
    CHARACTER(*), DIMENSION(:),   INTENT(IN   ), OPTIONAL:: SKIP_END_KEY
    !
    IF(.NOT. ALLOCATED(TFR%BLOCK_END_KEY)) TFR%BLOCK_END_KEY='END'
    !                                                                                                   !FOUND_BEGIN   ,  FOUND_END
    CALL LOAD_NEXT_FILE_BLOCK(BL, LLOC, IU, TFR%OLD_IU, TFR%LN, TFR%IOUT, TFR%IU, TFR%SKIP, TFR%REPEAT, TFR%ENTIRE_LINE, TFR%TRUNCATED, TFR%BEGIN_END_OPTIONAL, TFR%BLOCK_END_KEY, TFR%NOID, TFR%EX1_WORD, TFR%EX1_DIM, TFR%EX2_WORD, TFR%EX2_DIM, TFR%EX3_WORD, TFR%EX3_DIM, TFR%NO_BINARY, SKIP_END_KEY)
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_NEXT_FILE_BLOCK(BL, LLOC, IU, OLD_IU, LINE, IOUT, IN, SKIP, IS_REPEAT, FOUND_BEGIN, FOUND_END, BEGIN_END_OPTIONAL, BLOCK_END_KEY, NOID, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM, NO_BINARY, SKIP_END_KEY)
    ! ASSUMES THAT COLUMNS ARE STORED IN FIRST DIMENSION (STFRDARD STRUCTURE FOR MF)
    CLASS(GENERIC_BLOCK_READER),  INTENT(INOUT):: BL
    INTEGER,       INTENT(INOUT):: LLOC, IU, OLD_IU
    CHARACTER(*),  INTENT(INOUT):: LINE
    INTEGER,       INTENT(IN   ):: IOUT, IN
    LOGICAL,       INTENT(  OUT):: SKIP, FOUND_BEGIN, FOUND_END, IS_REPEAT
    LOGICAL,       INTENT(IN   ):: BEGIN_END_OPTIONAL
    CHARACTER(*),  INTENT(IN   ):: BLOCK_END_KEY
    LOGICAL,       INTENT(IN   ), OPTIONAL:: NOID, NO_BINARY
    CHARACTER(*),  INTENT(IN   ), OPTIONAL:: EX1_WORD, EX2_WORD, EX3_WORD
    INTEGER,       INTENT(IN   ), OPTIONAL:: EX1_DIM,  EX2_DIM,  EX3_DIM
    CHARACTER(*),  INTENT(IN   ), DIMENSION(:),OPTIONAL:: SKIP_END_KEY
    INTEGER:: ISTART,ISTOP, N
    CHARACTER(12):: EXT
    LOGICAL:: ERROR
    !
    TYPE(GENERIC_INPUT_FILE):: FL
    !
    IS_REPEAT = FALSE
    !
    SKIP = FALSE
    N=ONE
    CALL GET_WORD( LINE,N,ISTART,ISTOP,EXT)
    IF(EXT == 'BEGIN') THEN
        LLOC = ONE
        IU = IN
        BACKSPACE(IU)
    ELSEIF (IU == Z) THEN
        !
        N = LLOC
        CALL ULOAD(FL, LLOC, LINE, IOUT, IN, IU, NOID=NOID, NOSTOP=TRUE, EX1_WORD=EX1_WORD, EX1_DIM=EX1_DIM, EX2_WORD=EX2_WORD, EX2_DIM=EX2_DIM, EX3_WORD=EX3_WORD, EX3_DIM=EX3_DIM, NO_BINARY=NO_BINARY, OLD_IU=OLD_IU)
        !
        IF(LINE(1:8) == 'CONSTANT') CALL STOP_ERROR( LINE=LINE, OUTPUT=BL%IOUT, MSG= 'TRANSIENT FILE READER - BLOCK READER ERROR:  THE KEYWORD "CONSTANT" IS NOT ALLOWED.')
        !
        IF(LLOC < Z) THEN  !FAILED TO INDENTIFY KEYWORD, CHECK IF FILE NAME IS JUST SPECIFIED.
            CALL FL%OPEN(LINE,N,IOUT,IN,NOSTOP=TRUE,REQKEY=FALSE,BINARY=FALSE) !,SFAC=SFAC_FILE
        END IF
        !
        SKIP = FL%SKIP
        IF(SKIP) THEN
            IU = Z
            LLOC = ONE
            RETURN
        END IF
        IF(FL%ERROR) CALL STOP_ERROR( LINE=LINE, OUTPUT=BL%IOUT, MSG= 'TRANSIENT FILE READER - BLOCK READER ERROR:  UNKNOW FAILURE WHILE PROCESSING LINE (MAYBE THE FILE HAS A BAD PATH???)')
        !
        IF(FL%IU == Z) THEN
            IU = IN
        ELSE
            IU = FL%IU
        END IF
    END IF
    !
    IF(LLOC < Z) LLOC = ONE
    CALL PARSE_WORD( LINE,LLOC,ISTART,ISTOP)
    SELECT CASE(LINE(ISTART:ISTOP))
    !CASE('SKIP');     SKIP = TRUE
    CASE('CONSTANT'); CALL STOP_ERROR( LINE=LINE(LLOC:), OUTPUT=BL%IOUT, MSG= 'TRANSIENT FILE READER - BLOCK READER ERROR:  THIS INPUT READ UTILITY DOES NOT ALLOW FOR THE KEYWORD "CONSTANT". PLEASE USE A KEYWORD TO INDICATE WHERE DATA IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)')
    CASE('REPEAT'  )
                      BL%LN = 'REPEAT'
                      IS_REPEAT = TRUE
    CASE DEFAULT
                      CALL BL%LOAD(IU, IOUT, END_KEY=BLOCK_END_KEY, FOUND_BEGIN=FOUND_BEGIN, END_NOT_FOUND=ERROR, BEGIN_OPTIONAL=BEGIN_END_OPTIONAL, SKIP_END_KEY=SKIP_END_KEY)
                      !
                      FOUND_END = .NOT. ERROR
                      !
                      IF(ERROR)  THEN; IF(.NOT. BEGIN_END_OPTIONAL)  CALL STOP_ERROR( LINE,IU,IOUT, MSG= 'TRANSIENT FILE READER - BLOCK READER ERROR: REACHED THE END OF THE FILE BEFORE LOCATING THE KEYWORD TO CLOSE THE BLOCK. THE BLOCK THAT WAS BEING LOADED IS "'//BL%NAME//'" AND WAS EXPECTING THE FOLLOWING KEYWORD TO CLOSE/END THE BLOCK:"'//BLOCK_END_KEY//'". PLEASE CHECK INPUT TO ENSURE THAT THE BLOCK WAS PROPERLY CLOSED WITH THAT KEYWORD.')
                      END IF

    END SELECT
    !
  END SUBROUTINE
  !
!  SUBROUTINE LOAD_NEXT_FILE_BLOCK(TFR, BL, LLOC, IU)  !ONLY CALLED FROM LOAD_NEXT_FILE_SCALAR
!    ! ASSUMES THAT COLUMNS ARE STORED IN FIRST DIMENSION (STFRDARD STRUCTURE FOR MF)
!    CLASS(TRANSIENT_FILE_READER), INTENT(INOUT):: TFR
!    CLASS(GENERIC_BLOCK_READER),  INTENT(INOUT):: BL
!    INTEGER, INTENT(INOUT):: LLOC, IU
!    INTEGER:: ISTART,ISTOP, N
!    CHARACTER(8):: EXT
!    LOGICAL:: ERROR
!    !
!    TYPE(GENERIC_INPUT_FILE):: FL
!    !
!    N=ONE
!    CALL GET_WORD( TFR%LN,N,ISTART,ISTOP,EXT)
!    IF(EXT == 'BEGIN') THEN
!        LLOC = ONE
!        IU = TFR%IU
!        BACKSPACE(IU)
!    ELSEIF (IU == Z) THEN
!        !
!        CALL ULOAD(FL, LLOC, TFR%LN, TFR%IOUT, TFR%IU, IU, NOID=TFR%NOID, NOSTOP=TRUE, EX1_WORD=TFR%EX1_WORD, EX1_DIM=TFR%EX1_DIM, EX2_WORD=TFR%EX2_WORD, EX2_DIM=TFR%EX2_DIM, EX3_WORD=TFR%EX3_WORD, EX3_DIM=TFR%EX3_DIM, NO_BINARY=TFR%NO_BINARY, OLD_IU=TFR%OLD_IU)
!        !
!        IU = FL%IU
!        IF(IU==Z) IU = TFR%IU
!        IF(LLOC < Z) THEN  !FOUND IMPLIED INTERNAL
!            BACKSPACE(IU)
!            LLOC = ONE
!        ELSEIF(FL%ERROR) THEN
!            CALL STOP_ERROR( LINE=TFR%LN, OUTPUT=BL%IOUT, MSG= 'TRANSIENT FILE READER - BLOCK READER ERROR:  UNKNOW FAILURE WHILE PROCESSING LINE (MAYBE THE FILE HAS A BAD PATH???)')
!        END IF
!    END IF
!    !
!    IF(.NOT. ALLOCATED(TFR%BLOCK_END_KEY)) TFR%BLOCK_END_KEY='END'
!    !
!    TFR%SKIP = FALSE
!    CALL PARSE_WORD( TFR%LN,LLOC,ISTART,ISTOP)
!    SELECT CASE(TFR%LN(ISTART:ISTOP))
!    CASE('SKIP');     TFR%SKIP = TRUE
!    CASE('CONSTANT'); CALL STOP_ERROR( LINE=TFR%LN(LLOC:), OUTPUT=BL%IOUT, MSG= 'TRANSIENT FILE READER - BLOCK READER ERROR:  THIS INPUT READ UTILITY DOES NOT ALLOW FOR THE KEYWORD "CONSTANT". PLEASE USE A KEYWORD TO INDICATE WHERE DATA IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)')
!    CASE('REPEAT');   BL%LN = 'REPEAT'
!    CASE DEFAULT
!                      CALL BL%LOAD(IU, TFR%IOUT, TFR%IOUT, END_KEY=TFR%BLOCK_END_KEY, FOUND_BEGIN=TFR%ENTIRE_LINE, END_NOT_FOUND=ERROR)
!                      !
!                      TFR%TRUNCATED = .NOT. ERROR
!                      !
!                      IF(ERROR)  THEN; IF(.NOT. TFR%BEGIN_END_OPTIONAL)  CALL STOP_ERROR( TFR%LN,IU,TFR%IOUT, MSG= 'TRANSIENT FILE READER - BLOCK READER ERROR: REACHED THE END OF THE FILE BEFORE LOCATING THE KEYWORD TO CLOSE THE BLOCK. THE BLOCK THAT WAS BEING LOADED IS "'//BL%NAME//'" AND WAS EXPECTING THE FOLLOWING KEYWORD TO CLOSE/END THE BLOCK:"'//TFR%BLOCK_END_KEY//'". PLEASE CHECK INPUT TO ENSURE THAT THE BLOCK WAS PROPERLY CLOSED WITH THAT KEYWORD.')
!                      END IF
!
!    END SELECT
!    !
!  END SUBROUTINE
  !
  SUBROUTINE LOAD_NEXT_FILE_SCALAR(TFR, VAR, SFAC, ID, SKIP_END_KEY, MSG)
    USE OPENSPEC
    ! ASSUMES THAT COLUMNS ARE STORED IN FIRST DIMENSION (STFRDARD STRUCTURE FOR MF)
    CLASS(TRANSIENT_FILE_READER):: TFR
    CLASS(*),                                INTENT(INOUT):: VAR
    TYPE(SFAC_DATA), OPTIONAL,               INTENT(INOUT):: SFAC
    INTEGER,         OPTIONAL,               INTENT(INOUT):: ID
    CHARACTER(*),    OPTIONAL, DIMENSION(:), INTENT(IN   ):: SKIP_END_KEY
    CHARACTER(*),    OPTIONAL,               INTENT(IN   ):: MSG
    !
    INTEGER:: LLOC, IU
    !TFR%SFAC_OLD = TFR%SFAC
    !
    IF (TFR%LOAD_NEXT_FILE) THEN
        IU = Z
        CALL READ_TO_DATA(TFR%LN,TFR%IU,TFR%IOUT)  !UNIT IS BEING PASSED IN SO READ IN LINE FROM IT
        IF(TFR%LN==BLNK) CALL STOP_ERROR(INFILE=TFR%IU,OUTPUT=TFR%IOUT,MSG = 'TRANSIENT FILE READER FAILED TO LOAD NEXT LINE WHICH POINTS TO NEXT FILE TO LOAD.'//NL//'THIS MOST LIKELY OCCURED BECAUSE THE END OF FILE WAS REACHED.'//BLN//'POSSIBLE CAUSES ARE NOT ENOUGH STRESS PERIOD INPUT, AN EMPTY FILE,'//NL//'OR YOU SPECIFIED TRANSIENT WHEN YOU MEANT STATIC FOR A LIST-ARRAY INPUT.', MSG2=MSG)
    ELSE
        IU = TFR%IU
    END IF
    !
    LLOC = ONE
    !
    SELECT TYPE(VAR)
    CLASS IS (GENERIC_BLOCK_READER)
                 CALL LOAD_NEXT_TFR_BLOCK(TFR, VAR, LLOC, IU, SKIP_END_KEY)
    CLASS DEFAULT
                 CALL ULOAD(VAR, LLOC, TFR%LN, TFR%IOUT, TFR%IU, IU, NOID=TFR%NOID, ID=ID, SFAC=SFAC, EX1_WORD=TFR%EX1_WORD, EX1_DIM=TFR%EX1_DIM, EX2_WORD=TFR%EX2_WORD, EX2_DIM=TFR%EX2_DIM, EX3_WORD=TFR%EX3_WORD, EX3_DIM=TFR%EX3_DIM, NO_BINARY=TFR%NO_BINARY, ENTIRE_LINE=TFR%ENTIRE_LINE, OLD_IU=TFR%OLD_IU, MSG=MSG)
                 IF(TFR%SCALE.NE.UNO) CALL SFAC%SET_ALL(TFR%SCALE)
                 TFR%TRUNCATED = LLOC < Z
                 TFR%REPEAT = 'REPEAT' == TFR%LN(1:8)
    END SELECT
    !
    !IF (TFR%LN(1:8) == 'REPEAT' ) THEN
    !    SFAC = TFR%SFAC / TFR%SFAC_OLD
    !ELSE
    !    SFAC = TFR%SFAC
    !END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_NEXT_FILE_VECTOR(TFR, VAR, SFAC, ID, MSG)
    USE OPENSPEC
    ! ASSUMES THAT COLUMNS ARE STORED IN FIRST DIMENSION (STFRDARD STRUCTURE FOR MF)
    CLASS(TRANSIENT_FILE_READER):: TFR
    CLASS(*),                  DIMENSION(:), CONTIGUOUS,  INTENT(INOUT):: VAR
    TYPE(SFAC_DATA), OPTIONAL,                            INTENT(INOUT):: SFAC
    INTEGER,         OPTIONAL, DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: ID
    CHARACTER(*),    OPTIONAL,                            INTENT(IN   ):: MSG
    !
    INTEGER:: LLOC, IU
    !TFR%SFAC_OLD = TFR%SFAC
    !
    IF (TFR%LOAD_NEXT_FILE) THEN
        IU = Z
        CALL READ_TO_DATA(TFR%LN,TFR%IU,TFR%IOUT)  !UNIT IS BEING PASSED IN SO READ IN LINE FROM IT
        IF(TFR%LN==BLNK) CALL STOP_ERROR(INFILE=TFR%IU,OUTPUT=TFR%IOUT,MSG = 'TRANSIENT FILE READER FAILED TO LOAD NEXT LINE WHICH POINTS TO NEXT FILE TO LOAD.'//NL//'THIS MOST LIKELY OCCURED BECAUSE THE END OF FILE WAS REACHED.'//BLN//'POSSIBLE CAUSES ARE NOT ENOUGH STRESS PERIOD INPUT, AN EMPTY FILE,'//NL//'OR YOU SPECIFIED TRANSIENT WHEN YOU MEANT STATIC FOR A LIST-ARRAY INPUT.', MSG2=MSG)
    ELSE
        IU = TFR%IU
    END IF
    !
    LLOC = ONE
    !
    CALL ULOAD(VAR, LLOC, TFR%LN, TFR%IOUT, TFR%IU, IU, NOID=TFR%NOID, ID=ID, ROW_WORD=TFR%ROW_WORD, SFAC=SFAC, EX1_WORD=TFR%EX1_WORD, EX1_DIM=TFR%EX1_DIM, EX2_WORD=TFR%EX2_WORD, EX2_DIM=TFR%EX2_DIM, EX3_WORD=TFR%EX3_WORD, EX3_DIM=TFR%EX3_DIM, NO_BINARY=TFR%NO_BINARY, ENTIRE_LINE=TFR%ENTIRE_LINE, OLD_IU=TFR%OLD_IU, MSG=MSG)
    !
    IF(TFR%SCALE.NE.UNO) CALL SFAC%SET_ALL(TFR%SCALE)
    TFR%TRUNCATED = LLOC < Z
    TFR%REPEAT = 'REPEAT' == TFR%LN(1:8)
    !
    !IF (TFR%LN(1:8) == 'REPEAT' ) THEN
    !    SFAC = TFR%SFAC / TFR%SFAC_OLD
    !ELSE
    !    SFAC = TFR%SFAC
    !END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_NEXT_FILE_ARRAY(TFR, VAR, SFAC, ID, MSG)
    USE OPENSPEC
    ! ASSUMES THAT COLUMNS ARE STORED IN FIRST DIMENSION (STFRDARD STRUCTURE FOR MF)
    CLASS(TRANSIENT_FILE_READER):: TFR
    CLASS(*),                  DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: VAR
    TYPE(SFAC_DATA), OPTIONAL,                             INTENT(INOUT):: SFAC
    INTEGER,         OPTIONAL, DIMENSION(:), ALLOCATABLE,  INTENT(INOUT):: ID
    CHARACTER(*),    OPTIONAL,                             INTENT(IN   ):: MSG
    !
    INTEGER:: LLOC, IU
    !TFR%SFAC_OLD = TFR%SFAC
    !
    IF (TFR%LOAD_NEXT_FILE) THEN
        IU = Z
        CALL READ_TO_DATA(TFR%LN,TFR%IU,TFR%IOUT)  !UNIT IS BEING PASSED IN SO READ IN LINE FROM IT
        IF(TFR%LN==BLNK) CALL STOP_ERROR(INFILE=TFR%IU,OUTPUT=TFR%IOUT,MSG = 'TRANSIENT FILE READER FAILED TO LOAD NEXT LINE WHICH POINTS TO NEXT FILE TO LOAD.'//NL//'THIS MOST LIKELY OCCURED BECAUSE THE END OF FILE WAS REACHED.'//BLN//'POSSIBLE CAUSES ARE NOT ENOUGH STRESS PERIOD INPUT, AN EMPTY FILE,'//NL//'OR YOU SPECIFIED TRANSIENT WHEN YOU MEANT STATIC FOR A LIST-ARRAY INPUT.', MSG2=MSG)
    ELSE
        IU = TFR%IU
    END IF
    !
    LLOC = ONE
    !
    CALL ULOAD(VAR, LLOC, TFR%LN, TFR%IOUT, TFR%IU, IU, NOID=TFR%NOID, ID=ID, ROW_WORD=TFR%ROW_WORD, COL_WORD=TFR%COL_WORD, SFAC=SFAC, EX1_WORD=TFR%EX1_WORD, EX1_DIM=TFR%EX1_DIM, EX2_WORD=TFR%EX2_WORD, EX2_DIM=TFR%EX2_DIM, EX3_WORD=TFR%EX3_WORD, EX3_DIM=TFR%EX3_DIM, READ_BY_DIM2=TFR%READ_BY_DIM2, NO_BINARY=TFR%NO_BINARY, OLD_IU=TFR%OLD_IU, MSG=MSG)
    !
    IF(TFR%SCALE.NE.UNO) CALL SFAC%SET_ALL(TFR%SCALE)
    TFR%TRUNCATED = LLOC < Z
    TFR%REPEAT = 'REPEAT' == TFR%LN(1:8)
    !
    !IF (TFR%LN(1:8) == 'REPEAT' ) THEN
    !    SFAC = TFR%SFAC / TFR%SFAC_OLD
    !ELSE
    !    SFAC = TFR%SFAC
    !END IF
    !
  END SUBROUTINE
  !
  !PURE SUBROUTINE ALLOC_LN(TFR)
  !  CLASS(TRANSIENT_FILE_READER), INTENT(INOUT):: TFR
  !  IF(.NOT. ALLOCATED(TFR%LN)) ALLOCATE( CHARACTER(MAX_LINE_LEN):: TFR%LN )
  !END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_FILE_READER(TFR)
    CLASS(TRANSIENT_FILE_READER), INTENT(INOUT):: TFR
    !
    TFR%NOID               = FALSE
    TFR%READ_BY_DIM2       = FALSE
    TFR%LOAD_NEXT_FILE     = FALSE
    TFR%NO_BINARY          = FALSE
    TFR%ENTIRE_LINE        = FALSE
    TFR%BEGIN_END_OPTIONAL = FALSE
    TFR%TRUNCATED          = FALSE  !IF BLOCK INPUT THEN SET TO TRY WHEN END IS NOT FOUND
    TFR%REPEAT             = FALSE  !SET TO TRUE IF KEYWORD REPEAT WAS FOUND
    TFR%OLD_IU = Z
    !
    IF(ALLOCATED(TFR%LN)      ) DEALLOCATE(TFR%LN)
    IF(ALLOCATED(TFR%ROW_WORD)) DEALLOCATE(TFR%ROW_WORD)
    IF(ALLOCATED(TFR%COL_WORD)) DEALLOCATE(TFR%COL_WORD)
    IF(ALLOCATED(TFR%EX1_WORD)) DEALLOCATE(TFR%EX1_WORD)
    IF(ALLOCATED(TFR%EX2_WORD)) DEALLOCATE(TFR%EX2_WORD)
    IF(ALLOCATED(TFR%EX3_WORD)) DEALLOCATE(TFR%EX3_WORD)
    !
    IF(ALLOCATED(TFR%BLOCK_END_KEY)) DEALLOCATE(TFR%BLOCK_END_KEY)
    !
    !TFR%GLOBAL_SCALE = UNO
    !
    CALL TFR%CLOSE()
    !
    !CALL TFR%SFAC%INIT()
    !CALL TFR%SFAC_OLD%INIT()
    !
  END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_FILE_READER_FINAL(TFR)
    TYPE(TRANSIENT_FILE_READER), INTENT(INOUT):: TFR
    !
    CALL DEALLOCATE_FILE_READER(TFR)
    !
  END SUBROUTINE

END MODULE
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
MODULE LIST_ARRAY_INPUT_INTERFACE
  !CHECKS FOR FLAGS LIST/ARRAY AND THEN STATIC/TRANSIENT AND THEN LOADS FIRST LIST/ARRAY
  USE CONSTANTS
  USE ULOAD_AND_SFAC_INTERFACE
  USE, INTRINSIC:: IEEE_ARITHMETIC,      ONLY: IEEE_VALUE, IEEE_QUIET_NAN
  USE UTIL_INTERFACE,                    ONLY: STOP_ERROR, WARNING_MESSAGE, FILE_IO_ERROR,             &
                                               GET_WORD, GET_INTEGER, GET_NUMBER, SET_SEQUENCE,        &
                                               UPPER, READ_TO_DATA, PARSE_WORD_UP, MAX_UNCOMMENTED_LINE_LEN
  USE NUM2STR_INTERFACE,                 ONLY: NUM2STR
  USE TRANSIENT_FILE_READER_INSTRUCTION, ONLY: TRANSIENT_FILE_READER
  USE GENERIC_INPUT_FILE_INSTRUCTION,    ONLY: GENERIC_INPUT_FILE
  USE IXJ_INSTRUCTION,                   ONLY: IXJ_STRUCTURE
  USE, INTRINSIC:: ISO_FORTRAN_ENV,      ONLY: REAL32, REAL64, REAL128
  IMPLICIT NONE
  !
  PRIVATE
  PUBLIC:: GENERIC_LINE_INPUT, LIST_ARRAY_INPUT, LIST_ARRAY_INPUT_INT, LIST_ARRAY_INPUT_STR
  !
  ! -------------------------------------------------------------------------------------------------------
  !
  TYPE, ABSTRACT:: GENERIC_LINE_INPUT
        !
        ! LOADING UNIT IS AT FL%IU
        ! IF FL%IU IS ZERO THEN CHECK LINE FOR KEYWORD SKIP, CONSTANT, OR REPEAT
        LOGICAL:: INUSE     = FALSE     ! TRUE WHEN OBJECT HAS BE INITIALIZED
        LOGICAL:: TRANSIENT = FALSE     ! TRUE WHEN TRANSIENT KEYWORD FOUND
        LOGICAL:: NO_BINARY = FALSE     ! IS SET TO TRUE WHEN BINARY FILE INPUT IS NOT ALLOWED -- TYPICALLY BECAUSE THERE IS TEXT PROCESSING DONE OUTSIDE OF ROUTINE
        LOGICAL:: RAN_LOAD=FALSE
        LOGICAL:: PULL_PARRENT = FALSE
        LOGICAL:: IS_CONSTANT  = FALSE
        INTEGER:: IOUT
        CHARACTER(:), ALLOCATABLE:: TYP
        CHARACTER(:), ALLOCATABLE:: ERRMSG
        !
        TYPE(SFAC_DATA):: SFAC
        !
        TYPE(GENERIC_INPUT_FILE):: FL
        TYPE(TRANSIENT_FILE_READER):: TFR
        !
        CONTAINS
        !
        PROCEDURE, PASS(GIN):: INIT => INITIALIZE_GENERIC_LINE_INPUT
        PROCEDURE, PASS(GIN):: NEXT => LOAD_NEXT_GENERIC_LINE_INPUT
        PROCEDURE, PASS(GIN):: DESTROY_BASE => DEALLOCATE_NEXT_GENERIC_LINE_INPUT
        !
        PROCEDURE(DUMMY_GIN_LOAD_ROUTINE ), PASS(GIN), DEFERRED:: LOAD     !=> DUMMY_LOAD_ROUTINE
        PROCEDURE(DUMMY_GIN_ALLOC_ROUTINE), PASS(GIN), DEFERRED:: ALLOC    !=> DUMMY_GIN_ALLOC_ROUTINE
        !PROCEDURE(DUMMY_GIN_ROUTINE), PASS(GIN), DEFERRED:: CONSTANT !=> DUMMY_CONSTANT_ROUTINE
        !
  END TYPE
  !
  ABSTRACT INTERFACE
                    SUBROUTINE DUMMY_GIN_LOAD_ROUTINE(GIN, LLOC, LINE, IU, WILD_IN, WILD_OUT, WILD_1D_IN, WILD_1D_OUT)
                      IMPORT:: GENERIC_LINE_INPUT
                      CLASS(GENERIC_LINE_INPUT),                       INTENT(INOUT):: GIN      !GENERIC_LINE_INPUT DATA TYPE THAT IS EXTENDED TO SPECIFIC TYPE
                      INTEGER,                                         INTENT(INOUT):: LLOC     !CURRENT LLOC
                      CHARACTER(*),                                    INTENT(INOUT):: LINE     !CURRENT STORED LINE AND SCRATCH LINE FOR ANY NEEDS
                      INTEGER,                                         INTENT(IN   ):: IU       !UNIT TO LOAD DATA FROM
                      CLASS(*),    OPTIONAL,                           INTENT(IN   ):: WILD_IN  !ANY OPTIONAL DATA TYPE THAT MAYBE SET OR NECESSARY TO PASS IN (WILD CARD)
                      CLASS(*),    OPTIONAL,                           INTENT(INOUT):: WILD_OUT
                      CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(IN   ):: WILD_1D_IN  !ANY OPTIONAL DATA TYPE THAT MAYBE SET OR NECESSARY TO PASS IN (WILD CARD)
                      CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(INOUT):: WILD_1D_OUT
                    END SUBROUTINE
                    !
                    SUBROUTINE DUMMY_GIN_ALLOC_ROUTINE(GIN, DIM, WILD_IN, WILD_OUT, WILD_1D_IN, WILD_1D_OUT) !EVEN IF NOT USED IT MUST BE DECLAURED AS A DUMMY ROUTINE
                      IMPORT:: GENERIC_LINE_INPUT
                      CLASS(GENERIC_LINE_INPUT),                       INTENT(INOUT):: GIN      !GENERIC_LINE_INPUT DATA TYPE THAT IS EXTENDED TO SPECIFIC TYPE
                      INTEGER,               DIMENSION(:), CONTIGUOUS, INTENT(IN   ):: DIM
                      CLASS(*),    OPTIONAL,                           INTENT(IN   ):: WILD_IN  !ANY OPTIONAL DATA TYPE THAT MAYBE SET OR NECESSARY TO PASS IN (WILD CARD)
                      CLASS(*),    OPTIONAL,                           INTENT(INOUT):: WILD_OUT
                      CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(IN   ):: WILD_1D_IN  
                      CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(INOUT):: WILD_1D_OUT
                    END SUBROUTINE
  END INTERFACE
  !
  ! -------------------------------------------------------------------------------------------------------
  !
  TYPE LIST_ARRAY_INPUT_BASE
        LOGICAL:: INUSE        = FALSE   ! TRUE WHEN OBJECT HAS BE INITIALIZED
        LOGICAL:: TRANSIENT    = FALSE   ! TRUE WHEN TRANSIENT KEYWORD FOUND
        LOGICAL:: LISTLOAD     = FALSE   ! TRUE WHEN LIST KEYWORD IS FOUND
        LOGICAL:: LISTARRAY    = FALSE   ! TRUE WHEN LIST KEYWORD IS FOUND, BUT LIST IS STORED AS AN ARRAY
        LOGICAL:: HAS_IXJ      = FALSE   ! TRUE WHEN ARRAY IS LOADED AS A RECORD BASED INPUT
        LOGICAL:: READ_BYROW   = FALSE   ! TRUE WHEN LIST AND HAS KEYWORD LIST_TRANSPOSE - READ INPUT BY ROW
        LOGICAL:: NO_BINARY    = FALSE   ! IS SET TO TRUE WHEN BINARY FILE INPUT IS NOT ALLOWED -- TYPICALLY BECAUSE THERE IS TEXT PROCESSING DONE OUTSIDE OF ROUTINE
        LOGICAL:: PULL_PARRENT = FALSE
        LOGICAL:: IS_CONSTANT  = FALSE
        LOGICAL:: STORE_ID     = FALSE
        CHARACTER(:), ALLOCATABLE:: TYP
        CHARACTER(:), ALLOCATABLE:: ERRMSG
        !
        INTEGER, DIMENSION(:), ALLOCATABLE:: ID
        !
        TYPE(TRANSIENT_FILE_READER):: TFR
        !
        CONTAINS
        !
        PROCEDURE, PASS(LAI):: DESTROY => LIST_ARRAY_INPUT_DEALLOCATE_ALL_TYPES
        !
  END TYPE
  !
  TYPE, EXTENDS(LIST_ARRAY_INPUT_BASE):: LIST_ARRAY_INPUT
        !
        LOGICAL:: NONEG_ALLOWED=FALSE
        !
        REAL(REAL64),     DIMENSION(:),   ALLOCATABLE:: LIST
        REAL(REAL64),     DIMENSION(:,:), ALLOCATABLE:: ARRAY
        TYPE(IXJ_STRUCTURE),              ALLOCATABLE:: IXJ
        !LOGICAL:: ERROR = FALSE
        !
        TYPE(SFAC_DATA):: SFAC
        !
        CONTAINS
        !
        GENERIC::              INIT => INITIALIZE_LIST_ARRAY_INPUT,        & !(TYP, LLOC, LINE, IOUT, IN, LDIM1, LDIM2, NROW, NCOL, EX1_DIM, EX1_WORD, EX2_DIM, EX2_WORD, EX3_DIM, EX3_WORD, SCRATCH, NO_TRANSIENT, NO_BINARY, LISTARRAY, CDIM, MSG)
                                       INITIALIZE_LIST_ARRAY_INPUT_AS_VALUE  !(TYP, VAL, IOUT, IN, LDIM1, LDIM2, NROW, NCOL)
        !
        PROCEDURE, PASS(LAI):: NEXT => LOAD_NEXT_INPUT!()
        PROCEDURE, PASS(LAI):: GET  => GET_VALUE!(LAI, ID, DIM1, DIM2, LDIM2)
        !
        PROCEDURE, PASS(LAI), PRIVATE:: INITIALIZE_LIST_ARRAY_INPUT
        PROCEDURE, PASS(LAI), PRIVATE:: INITIALIZE_LIST_ARRAY_INPUT_AS_VALUE
        !
        FINAL:: FINAL_LIST_ARRAY_INPUT
  END TYPE
  !
  TYPE, EXTENDS(LIST_ARRAY_INPUT_BASE):: LIST_ARRAY_INPUT_INT
        !
        INTEGER, DIMENSION(:),   ALLOCATABLE:: LIST
        INTEGER, DIMENSION(:,:), ALLOCATABLE:: ARRAY
        TYPE(IXJ_STRUCTURE),     ALLOCATABLE:: IXJ
        !
        CONTAINS
        !
        GENERIC::              INIT => INITIALIZE_LIST_ARRAY_INPUT_INT,        &!(TYP, LLOC, LINE, IOUT, IN, LDIM1, LDIM2, NROW, NCOL, SCRATCH, NO_TRANSIENT)
                                       INITIALIZE_LIST_ARRAY_INPUT_INT_AS_VALUE !(TYP, VAL, IOUT, IN, LDIM1, LDIM2, NROW, NCOL)
        PROCEDURE, PASS(LAI):: NEXT => LOAD_NEXT_INPUT_INT!()
        PROCEDURE, PASS(LAI):: GET  => GET_VALUE_INT!(LAI, ID, DIM1, DIM2, LDIM2)
        !
        PROCEDURE, PASS(LAI), PRIVATE:: INITIALIZE_LIST_ARRAY_INPUT_INT
        PROCEDURE, PASS(LAI), PRIVATE:: INITIALIZE_LIST_ARRAY_INPUT_INT_AS_VALUE
        !
        FINAL:: FINAL_LIST_ARRAY_INPUT_INT
  END TYPE
  !
  TYPE, EXTENDS(LIST_ARRAY_INPUT_BASE):: LIST_ARRAY_INPUT_STR
        !
        CHARACTER(:), DIMENSION(:),   ALLOCATABLE:: LIST
        CHARACTER(:), DIMENSION(:,:), ALLOCATABLE:: ARRAY
        INTEGER:: LINLEN
        LOGICAL:: TRUNCATED
        !
        TYPE(SFAC_DATA):: SFAC
        !
        CONTAINS
        !
        GENERIC::              INIT => INITIALIZE_LIST_ARRAY_INPUT_STR,        &!(TYP, LLOC, LINE, IOUT, IN, LDIM1, LDIM2, NROW, NCOL,LINLEN, EX1_DIM, EX1_WORD, EX2_DIM, EX2_WORD, EX3_DIM, EX3_WORD, SCRATCH, NO_TRANSIENT, NO_BINARY, ENTIRE_LINE)
                                       INITIALIZE_LIST_ARRAY_INPUT_STR_AS_VALUE !(TYP, VAL, IOUT, IN, LDIM1, LDIM2, NROW, NCOL, LINLEN)
        PROCEDURE, PASS(LAI):: NEXT => LOAD_NEXT_INPUT_STR!()
        PROCEDURE, PASS(LAI):: GET  => GET_VALUE_STR!(ID, DIM1, DIM2, LDIM2)
        PROCEDURE, PASS(LAI):: GET_LINES => COMBINE_LAI_TO_LINES
        !
        PROCEDURE, PASS(LAI), PRIVATE:: INITIALIZE_LIST_ARRAY_INPUT_STR
        PROCEDURE, PASS(LAI), PRIVATE:: INITIALIZE_LIST_ARRAY_INPUT_STR_AS_VALUE
        !
        FINAL:: FINAL_LIST_ARRAY_INPUT_STR
  END TYPE
  !
  ! -------------------------------------------------------------------------------------------------------
  !
  CONTAINS
  !
  SUBROUTINE INITIALIZE_GENERIC_LINE_INPUT(GIN, TYP, LLOC, LINE, IOUT, IN, EX1_DIM, EX1_WORD, EX2_DIM, EX2_WORD, EX3_DIM, EX3_WORD, SCRATCH, NO_TRANSIENT, NO_BINARY, DIM, WILD_IN, WILD_OUT, WILD_1D_IN, WILD_1D_OUT, MSG)
    ! TYP   NAME OF LIST_ARRAY
    ! IN    IS FILE TO LOAD INFORMATION FROM OR TO CLAIM OCCURED AT
    !
    ! LDIM1 LENGTHIN OF LIST (row dimension) --SET TO ZERO TO NOT ALLOW LIST LOAD
    ! LDIM2 NUMBER OF PROPERTIES (col dim)   --If >0 THEN IT WILL ALLOCATE ARRAY, IF =0 THEN IT IT WILL ALLOCATE A LIST WHEN REQUESTED
    ! NROW  ROWS IN ARRAY                    --SET TO ZERO TO NOT ALLOW ARRAY LOADING
    ! NCOL  COL IN ARRAY
    !
    ! OPTIONAL ARGUMENTS:
    !                    EX1_DIM, EX1_WORD ARE DIMENSION AND KEYWORD USED FOR SFAC ROUTING  (eg NFARM, 'BYWBS')
    !                    SCARTCH IS THE UNIT NUMBER TO LOAD INFORMATION FROM, WHEN IN IS ONLY MEANT TO BE USED FOR ERROR REPORTING
    CLASS(GENERIC_LINE_INPUT),INTENT(INOUT):: GIN
    CHARACTER(*),             INTENT(IN   ):: TYP
    CHARACTER(*),             INTENT(IN   ):: LINE
    INTEGER,                  INTENT(INOUT):: LLOC
    INTEGER,                  INTENT(IN   ):: IOUT, IN
    INTEGER,  OPTIONAL,       INTENT(IN   ):: EX1_DIM, EX2_DIM, EX3_DIM
    CHARACTER(*),OPTIONAL,    INTENT(IN   ):: EX1_WORD,EX2_WORD,EX3_WORD
    INTEGER,     OPTIONAL,    INTENT(IN   ):: SCRATCH
    LOGICAL,     OPTIONAL,    INTENT(IN   ):: NO_TRANSIENT, NO_BINARY
    !
    INTEGER,     OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(IN   ):: DIM
    CLASS(*),    OPTIONAL,                           INTENT(IN   ):: WILD_IN  !ANY OPTIONAL DATA TYPE THAT MAYBE SET OR NECESSARY TO PASS IN (WILD CARD)
    CLASS(*),    OPTIONAL,                           INTENT(INOUT):: WILD_OUT
    CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(IN   ):: WILD_1D_IN
    CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(INOUT):: WILD_1D_OUT
    !
    CHARACTER(*),OPTIONAL,  INTENT(IN   ):: MSG
    !
    CHARACTER(9):: LAI_KEY
    INTEGER:: IU,I,N
    LOGICAL:: ONLY_STATIC, FOUND_TEMPORAL
    !
    IF(GIN%INUSE) THEN
        CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY "'//TYP//'" IS BEING LOADED A SECOND TIME!!!'//BLN//'MAYBE YOU ACCIDENTALLY SPECIFIED THE SAME KEYWORD TWICE???'//BLN//'THE PREVIOUS LINE THAT THE KEYWORD WAS FOUND WILL BE IGNORED'//NL//'AND THE LINE PRESENTED IN THIS WARNING WILL BE USED INSTEAD.')
        CALL DEALLOCATE_NEXT_GENERIC_LINE_INPUT(GIN)
    END IF
    !
    GIN%IOUT = IOUT
    GIN%IS_CONSTANT   = FALSE
    FOUND_TEMPORAL= FALSE
    !
    ONLY_STATIC = FALSE
    IF(PRESENT(NO_TRANSIENT)) ONLY_STATIC = NO_TRANSIENT
    IU = Z
    GIN%INUSE = TRUE
    ALLOCATE(GIN%TYP, SOURCE = TYP)
    !
    IF(PRESENT(MSG)) THEN
        GIN%ERRMSG=MSG
    ELSE
        GIN%ERRMSG=BLNK
    END IF
    !
    IF(PRESENT(DIM)) CALL GIN%ALLOC(DIM, WILD_IN, WILD_OUT, WILD_1D_IN, WILD_1D_OUT)
    !
    CALL GIN%TFR%ALLOC_LN()  !Make use of already alloctable ln
    GIN%TFR%LN(:) = LINE
    !
    DO I=ONE, TWO
      !
      CALL GET_WORD(LAI_KEY,LINE,LLOC,N)
      !
      SELECT CASE (LAI_KEY)
                                     CASE('TRANSIENT')
                                                        GIN%TRANSIENT = TRUE
                                                        FOUND_TEMPORAL= TRUE
                                     CASE('STATIC')
                                                        GIN%TRANSIENT = FALSE
                                                        FOUND_TEMPORAL= TRUE
                                     CASE('LIST','ARRAY','COMPRESS', 'COMPRESSE','DIM','DIMENSION','AUTO','AUTOCOUNT','AUTO-COUN')
                                                      CONTINUE
                                                      !CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY "'//TYP//'" DOES NOT REQUIRE "'//TRIM(LAI_KEY)//'" KEYWORD.'//BLN//'IT WILL BE IGNORED.'//BLN//'PROGRAM WILL CONTINUE AS IF IT WAS NOT SPECIFIED.', INLINE=TRUE)
                                     CASE('PARRENT')
                                                        GIN%PULL_PARRENT = TRUE
                                                        GIN%TRANSIENT = FALSE
                                                        LLOC = N
                                                        CALL GIN%LOAD(LLOC, GIN%TFR%LN, IU, WILD_IN, WILD_OUT, WILD_1D_IN, WILD_1D_OUT)
                                                        RETURN
                                     CASE('CONSTANT')
                                                        GIN%IS_CONSTANT = TRUE
                                                        LLOC = N
                                                        EXIT
                                     CASE('INTERNAL')
                                                        IF(GIN%TRANSIENT) THEN
                                                            GIN%TRANSIENT = FALSE
                                                            CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY "'//TYP//'" FOUND KEYWORD INTERNAL, BUT THIS ONLY WORKS WITHIN THE STATIC OPTION OR IF TRANSIENT IS USED THEN IT MAY ONLY RESIDE WITHIN THE TRANSIENTE FILE READER (TFR).'//BLN//'THE TEMPORAL INPUT WAS CHANGED TO "STATIC INTERNAL".', INLINE=TRUE)
                                                        END IF
                                                        FOUND_TEMPORAL= TRUE
                                                        LLOC = N
                                                        EXIT
                                     CASE DEFAULT
                                                        LLOC = N
                                                        EXIT
      END SELECT
    END DO
    !
    IF(.NOT. GIN%IS_CONSTANT .AND. .NOT. ONLY_STATIC .AND. .NOT. FOUND_TEMPORAL) CALL STOP_ERROR(LINE,IN,IOUT,'LIST-ARRAY INPUT (LAI) PROPERTY '//TYP//'. FOUND KEYWORD THAT SHOULD BE FOLLOWED BY EITHER "TRANSIENT" OR "STATIC" KEYWORD', MSG2=GIN%ERRMSG)
    !
    IF(GIN%IS_CONSTANT) GIN%TRANSIENT = FALSE
    !
    IF(ONLY_STATIC .AND. GIN%TRANSIENT) CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY "'//TYP//'" CAN ONLY BE LOADED ONCE, BUT "TRANSIENT" KEYWORD WAS FOUND. PROGRAM WILL CONTINUE AS IF "STATIC" WAS SPECIFIED.')
    IF(ONLY_STATIC) GIN%TRANSIENT = FALSE
    !
    IF(GIN%IS_CONSTANT) THEN
                                  CALL GIN%LOAD(LLOC, GIN%TFR%LN, IU, WILD_IN, WILD_OUT, WILD_1D_IN, WILD_1D_OUT)  ! IU = Z
    ELSEIF (.NOT. GIN%TRANSIENT ) THEN
                                  CALL    ULOAD(GIN%FL, LLOC, GIN%TFR%LN, IOUT, IN, IU, NOID=TRUE, EX1_DIM=EX1_DIM, EX1_WORD=EX1_WORD, EX2_DIM=EX2_DIM, EX2_WORD=EX2_WORD, EX3_DIM=EX3_DIM, EX3_WORD=EX3_WORD, SFAC=GIN%SFAC, SCRATCH=SCRATCH, NO_BINARY=NO_BINARY, MSG=GIN%TYP)
                                  CALL GIN%LOAD(        LLOC, GIN%TFR%LN, GIN%FL%IU, WILD_IN, WILD_OUT, WILD_1D_IN, WILD_1D_OUT)
    ELSE
        CALL GIN%TFR%INIT( LLOC, LINE, IOUT, IN, NOID=TRUE, EX1_DIM=EX1_DIM, EX1_WORD=EX1_WORD, EX2_DIM=EX2_DIM, EX2_WORD=EX2_WORD, EX3_DIM=EX3_DIM, EX3_WORD=EX3_WORD, NO_BINARY=NO_BINARY)
        !
        CALL LOAD_NEXT_GENERIC_LINE_INPUT(GIN, WILD_IN, WILD_OUT, WILD_1D_IN, WILD_1D_OUT)
    END IF
    !
    GIN%RAN_LOAD = TRUE
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_NEXT_GENERIC_LINE_INPUT(GIN, WILD_IN, WILD_OUT, WILD_1D_IN, WILD_1D_OUT)
    CLASS(GENERIC_LINE_INPUT), INTENT(INOUT):: GIN
    CLASS(*),       OPTIONAL,  INTENT(IN   ):: WILD_IN  !ANY OPTIONAL DATA TYPE THAT MAYBE SET OR NECESSARY TO PASS IN (WILD CARD)
    CLASS(*),       OPTIONAL,  INTENT(INOUT):: WILD_OUT
    CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(IN   ):: WILD_1D_IN
    CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(INOUT):: WILD_1D_OUT
    INTEGER:: LLOC, IU
    !
    IF(GIN%TRANSIENT) THEN
          LLOC = ONE
          CALL GIN%TFR%NEXT(GIN%FL, GIN%SFAC, MSG=GIN%ERRMSG)
          !
          IF(GIN%TFR%REPEAT) THEN  !EITHER PASSS IU=0 TO INDICATE GIN%TFR%LN HOLDS 'REPEAT', 'CONSTANT', OR 'SKIP'
              IU = Z
          ELSE                     !OR PASS FILE UNIT TO LOAD DATA FROM
              IU = GIN%FL%IU
          END IF
          !
          CALL GIN%LOAD(LLOC, GIN%TFR%LN, IU, WILD_IN, WILD_OUT, WILD_1D_IN, WILD_1D_OUT)
          GIN%RAN_LOAD = TRUE
    ELSE
          GIN%RAN_LOAD = FALSE
    END IF
  END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_NEXT_GENERIC_LINE_INPUT(GIN)
    CLASS(GENERIC_LINE_INPUT), INTENT(INOUT):: GIN
        GIN%INUSE        = FALSE
        GIN%TRANSIENT    = FALSE
        GIN%NO_BINARY    = FALSE
        GIN%RAN_LOAD     = FALSE
        GIN%PULL_PARRENT = FALSE
        GIN%IOUT = Z
        !
        IF(ALLOCATED(GIN%TYP)) DEALLOCATE(GIN%TYP)
        !
        CALL GIN%SFAC%INIT()
        !
        CALL GIN%FL%CLOSE()
        CALL GIN%TFR%DESTROY()
        !
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_LIST_ARRAY_INPUT_AS_VALUE(LAI, TYP, VAL, IOUT, IN, LDIM1, LDIM2, NROW, NCOL,LISTARRAY, STORE_ID)
    CLASS(LIST_ARRAY_INPUT),INTENT(INOUT):: LAI
    CHARACTER(*),           INTENT(IN   ):: TYP
    REAL(REAL64),           INTENT(IN   ):: VAL
    INTEGER,                INTENT(IN   ):: IOUT, IN, LDIM1, LDIM2, NROW, NCOL
    LOGICAL, OPTIONAL,      INTENT(IN   ):: LISTARRAY  ! FORCE LISTARRAY EVEN THOUGH LDIM2=1
    LOGICAL, OPTIONAL,      INTENT(IN   ):: STORE_ID
    !
    IF(LAI%INUSE) THEN
        CALL WARNING_MESSAGE(INFILE=IN,OUTPUT=IOUT,MSG='LIST-ARRAY INPUT PROPERTY "'//TYP//'" IS BEING LOADED A SECOND TIME!!!'//BLN//'MAYBE YOU ACCIDENTALLY SPECIFIED THE SAME KEYWORD TWICE???'//BLN//'THE PREVIOUS LINE THAT THE KEYWORD WAS FOUND WILL BE IGNORED'//NL//'AND THE LINE PRESENTED IN THIS WARNING WILL BE USED INSTEAD.')
        CALL LIST_ARRAY_INPUT_DEALLOCATE_ALL_TYPES(LAI)
    END IF
    !
    LAI%INUSE = TRUE
    ALLOCATE(LAI%TYP, SOURCE = TYP)
    LAI%ERRMSG=BLNK
    !
    LAI%NONEG_ALLOWED=FALSE
    LAI%READ_BYROW = FALSE
    LAI%TRANSIENT = FALSE
    LAI%HAS_IXJ = FALSE
    LAI%LISTARRAY = LDIM2  > ONE  !USED TO BE >Z
    !
    IF(PRESENT(LISTARRAY) .AND. LDIM2 > Z) LAI%LISTARRAY = LISTARRAY
    !
    IF (LDIM1 > Z) THEN
            !
            IF(LAI%LISTARRAY) THEN
                                   LAI%LISTLOAD  = FALSE
                                   ALLOCATE(LAI%ARRAY(LDIM2,LDIM1), SOURCE=VAL)
            ELSE
                                   LAI%LISTLOAD  = TRUE
                                   ALLOCATE(LAI%LIST(LDIM1), SOURCE=VAL)
            END IF
    ELSE
                                   LAI%LISTLOAD  = FALSE
                                   ALLOCATE(LAI%ARRAY(NCOL,NROW), SOURCE=VAL)
    END IF
    !
    IF(PRESENT(STORE_ID)) THEN                  
                          LAI%STORE_ID = STORE_ID  ! Implied .NOT. NOID
    ELSE
                          LAI%STORE_ID = FALSE
    END IF
    !
    IF(LAI%STORE_ID) THEN
                     IF(LAI%LISTARRAY .OR. LAI%LISTLOAD) THEN
                                                         ALLOCATE(LAI%ID(LDIM1))
                                                         CALL SET_SEQUENCE(LDIM1, LAI%ID)
                     ELSE
                                                         LAI%STORE_ID = FALSE
                     END IF
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_LIST_ARRAY_INPUT(LAI, TYP, LLOC, LINE, IOUT, IN, LDIM1, LDIM2, NROW, NCOL, EX1_DIM, EX1_WORD, EX2_DIM, EX2_WORD, EX3_DIM, EX3_WORD, SCRATCH, NO_TRANSIENT, NO_BINARY, LISTARRAY, STORE_ID, CDIM, NONEG, MSG)
    ! TYP   NAME OF LIST_ARRAY
    ! IN    IS FILE TO LOAD INFORMATION FROM OR TO CLAIM OCCURED AT
    !
    ! LDIM1 LENGTHIN OF LIST (row dimension) --SET TO ZERO TO NOT ALLOW LIST LOAD
    ! LDIM2 NUMBER OF PROPERTIES (col dim)   --If >0 THEN IT WILL ALLOCATE ARRAY, IF =0 THEN IT IT WILL ALLOCATE A LIST WHEN REQUESTED
    ! NROW  ROWS IN ARRAY                    --SET TO ZERO TO NOT ALLOW ARRAY LOADING
    ! NCOL  COL IN ARRAY
    !
    ! OPTIONAL ARGUMENTS:
    !                    EX1_DIM, EX1_WORD ARE DIMENSION AND KEYWORD USED FOR SFAC ROUTING  (eg NFARM, 'BYWBS')
    !                    SCARTCH IS THE UNIT NUMBER TO LOAD INFORMATION FROM, WHEN IN IS ONLY MEANT TO BE USED FOR ERROR REPORTING
    CLASS(LIST_ARRAY_INPUT),INTENT(INOUT):: LAI
    CHARACTER(*),           INTENT(IN   ):: TYP
    CHARACTER(*),           INTENT(INOUT):: LINE
    INTEGER,                INTENT(INOUT):: LLOC
    INTEGER,                INTENT(IN   ):: IOUT, IN, LDIM1, LDIM2, NROW, NCOL
    INTEGER,     OPTIONAL,  INTENT(IN   ):: EX1_DIM, EX2_DIM, EX3_DIM
    CHARACTER(*),OPTIONAL,  INTENT(IN   ):: EX1_WORD,EX2_WORD,EX3_WORD
    INTEGER,  OPTIONAL,     INTENT(IN   ):: SCRATCH
    LOGICAL, OPTIONAL,      INTENT(IN   ):: NO_TRANSIENT, NO_BINARY, STORE_ID
    LOGICAL, OPTIONAL,      INTENT(IN   ):: LISTARRAY   ! FORCE LISTARRAY EVEN THOUGH LDIM2=1
    INTEGER, DIMENSION(:), CONTIGUOUS, OPTIONAL, INTENT(IN):: CDIM ! ALLOW COMPRESSED ARRAY STORAGE
    LOGICAL, OPTIONAL,      INTENT(IN   ):: NONEG !IF TRUE THEN NEGAVTIVE VALUES ARE SET TO ZERO
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: MSG
    CHARACTER(12):: LAI_KEY
    INTEGER:: IU,ISTART,ISTOP,N, DIM
    LOGICAL:: NOID, ONLYARRAY, ONLYLIST, ONLYIXJ, ONLY_STATIC, FOUND_TEMPORAL, FOUND_SPATIAL
    !
    IF(LAI%INUSE) THEN
        CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY "'//TYP//'" IS BEING LOADED A SECOND TIME!!!'//BLN//'MAYBE YOU ACCIDENTALLY SPECIFIED THE SAME KEYWORD TWICE???'//BLN//'THE PREVIOUS LINE THAT THE KEYWORD WAS FOUND WILL BE IGNORED'//NL//'AND THE LINE PRESENTED IN THIS WARNING WILL BE USED INSTEAD.')
        CALL LIST_ARRAY_INPUT_DEALLOCATE_ALL_TYPES(LAI)
    END IF
    !
    DIM= Z
    !
    LAI%IS_CONSTANT = FALSE
    FOUND_TEMPORAL  = FALSE
    FOUND_SPATIAL   = FALSE
    !
    ONLY_STATIC = FALSE
    IF(PRESENT(NO_TRANSIENT)) ONLY_STATIC = NO_TRANSIENT
    IU = Z
    !
    LAI%INUSE = TRUE
    ALLOCATE(LAI%TYP, SOURCE = TYP)
    !
    IF(PRESENT(MSG)) THEN
        LAI%ERRMSG=MSG
    ELSE
        LAI%ERRMSG=BLNK
    END IF
    !
    ONLYARRAY     = LDIM1 == Z
    LAI%LISTARRAY = LDIM2  > ONE  !USED TO BE >Z
    ONLYLIST      = NROW  == Z
    LAI%HAS_IXJ   = FALSE
    LAI%READ_BYROW= FALSE
    !
    IF(PRESENT(STORE_ID)) THEN                  
                          LAI%STORE_ID = STORE_ID  ! Can be overrulled by NOID
    ELSE
                          LAI%STORE_ID = FALSE
    END IF
    !
    IF(PRESENT(CDIM)) THEN
        ONLYIXJ = ANY(CDIM>Z) .AND. LDIM1 == Z .AND. NROW  == Z
    ELSE
        ONLYIXJ = FALSE
    END IF
    !
    IF(PRESENT(NONEG)) THEN
        LAI%NONEG_ALLOWED = NONEG
    ELSE
        LAI%NONEG_ALLOWED = FALSE
    END IF
    !
    IF(PRESENT(LISTARRAY) .AND. LDIM2 > Z) LAI%LISTARRAY = LISTARRAY
    !
    DO WHILE (.NOT. (FOUND_TEMPORAL .AND. FOUND_SPATIAL) )
      !
      CALL GET_WORD(LAI_KEY,LINE,LLOC,N)
      !
      SELECT CASE (LAI_KEY)
                                     CASE('TRANSIENT')
                                                      LAI%TRANSIENT = TRUE
                                                      FOUND_TEMPORAL= TRUE
                                     CASE('STATIC')
                                                      LAI%TRANSIENT = FALSE
                                                      FOUND_TEMPORAL= TRUE
                                     CASE('LIST')
                                                      LAI%LISTLOAD = TRUE
                                                      FOUND_SPATIAL= TRUE
                                                      IF(ONLYARRAY) CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY '//TYP//' CAN ONLY BE LOADED AS "ARRAY", BUT "LIST" KEYWORD FOUND.'//NL//'PROGRAM WILL CONTINUE AS IF ARRAY WAS SPECIFIED.')
                                                      !WRITE(IOUT, '(A,/A/)') 'WARNING: FMP PROPERTY '//TYP//' CAN ONLY BE LOADED AS "ARRAY", BUT "LIST" KEYWORD FOUND. PROGRAM WILL CONTINUE AS IF ARRAY WAS SPECIFIED. THE FOLLOWING LINE CONTAINS THE PROBLEM:',TRIM(LINE)
                                     CASE('ARRAY')
                                                      LAI%LISTLOAD  = FALSE
                                                      LAI%LISTARRAY = FALSE
                                                      FOUND_SPATIAL = TRUE
                                                      IF(ONLYLIST) CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY '//TYP//' CAN ONLY BE LOADED AS "LIST", BUT "ARRAY" KEYWORD FOUND. PROGRAM WILL CONTINUE AS IF LIST WAS SPECIFIED.')
                                                      !WRITE(IOUT, '(A,/A/)') 'WARNING: FMP PROPERTY '//TYP//' CAN ONLY BE LOADED AS LIST, BUT ARRAY KEYWORD FOUND. PROGRAM WILL CONTINUE AS IF LIST WAS SPECIFIED. THE FOLLOWING LINE CONTAINS THE PROBLEM:',TRIM(LINE)
                                     CASE('NODE', 'IXJ') !'COMPRESSE' ==> 'COMPRESSED' and 'COMPRESSED_ARRAY'
                                                      !
                                                      FOUND_SPATIAL = FALSE
                                                      IF(.NOT. PRESENT(CDIM)) THEN
                                                          FOUND_SPATIAL = TRUE
                                                      ELSEIF(ALL(CDIM==Z)) THEN
                                                          FOUND_SPATIAL = TRUE
                                                      END IF
                                                      IF(FOUND_SPATIAL) CALL STOP_ERROR(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY '//TYP//' DOES NOT SUPPORT "IXJ" INPUT FORMAT, BUT "'//LAI_KEY//'" KEYWORD WAS FOUND. PROGRAM CANNOT CONITUE WITH A "IXJ" INPUT FORMAT FOR THIS INPUT TYPE. PLEASE CHANGE TO "LIST" OR "ARRAY" STYLE INPUT.', MSG2=MSG)
                                                      !
                                                      !IF(ONLYLIST)    CALL STOP_ERROR(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY '//TYP//' CAN ONLY BE LOADED AS "LIST", BUT "COMPRESS" KEYWORD FOUND. PROGRAM CANNOT CONITUE WITH A COMPRESS ARRAY INPUT FORMAT FOR THIS INPUT TYPE. PLEASE CHANGE TO "LIST" STYLE INPUT.')
                                                      !
                                                      LAI%HAS_IXJ = TRUE
                                                      LAI%LISTLOAD  = FALSE
                                                      LAI%LISTARRAY = FALSE
                                                      FOUND_SPATIAL = TRUE
                                     CASE('LIST_TRANSPOSE')
                                                      LAI%READ_BYROW = TRUE
                                                      LAI%LISTLOAD   = TRUE
                                                      FOUND_SPATIAL  = TRUE
                                     CASE ('DIM','DIMENSION')
                                                       CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IN,DIM,MSG='LIST_ARRAY_INPUT (LAI/ULOAD) FOUND KEYWORD "'//TRIM(LAI_KEY)//'", WHICH MUST BE FOLLOWED BY AN INTEGER THAT REPRESENTS THE NUMBER OF ROWS TO LOAD FOR COMPRESS ARRAY STORAGE (YOU MUST ALSO SPECIFY THE "COMPRESS" KEYWORD)')
                                     CASE ('AUTO','AUTOCOUNT','AUTO-COUNT')
                                                       DIM=Z
                                     CASE('PARRENT')
                                                        LAI%PULL_PARRENT = TRUE
                                                        LAI%TRANSIENT = FALSE
                                                        RETURN
                                     CASE('INTERNAL')
                                                        IF(LAI%TRANSIENT) THEN
                                                            LAI%TRANSIENT = FALSE
                                                            CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY "'//TYP//'" FOUND KEYWORD INTERNAL, BUT THIS ONLY WORKS WITHIN THE STATIC OPTION OR IF TRANSIENT IS USED THEN IT MAY ONLY RESIDE WITHIN THE TRANSIENTE FILE READER (TFR).'//BLN//'THE TEMPORAL INPUT WAS CHANGED TO "STATIC INTERNAL".', INLINE=TRUE)
                                                        END IF
                                                        FOUND_TEMPORAL= TRUE
                                                        LLOC = N
                                                        EXIT
                                     CASE('CONSTANT')
                                                        LAI%IS_CONSTANT = TRUE
                                                        LLOC = N
                                                        EXIT
                                     CASE DEFAULT
                                                        LLOC = N
                                                        EXIT
      END SELECT
    END DO
    !
    IF(ONLYIXJ .AND. .NOT. LAI%HAS_IXJ) THEN
                           LAI%HAS_IXJ   = TRUE
                           LAI%LISTLOAD  = FALSE
                           LAI%LISTARRAY = FALSE
                           FOUND_SPATIAL = TRUE
    END IF
    !
    IF(.NOT. LAI%IS_CONSTANT) THEN
        !
        IF(.NOT. ONLY_STATIC                       .AND. .NOT. FOUND_TEMPORAL) CALL STOP_ERROR(LINE,IN,IOUT,'LIST-ARRAY INPUT (LAI) PROPERTY '//TYP//'. FAILED TO LOCATE "STATIC" OR "TRANSIENT" KEYWORD, WHICH IS REQUIRED FOR THIS PROPERTY.', MSG2=MSG)
        IF(.NOT. ONLYLIST    .AND. .NOT. ONLYARRAY .AND. .NOT. FOUND_SPATIAL ) CALL STOP_ERROR(LINE,IN,IOUT,'LIST-ARRAY INPUT (LAI) PROPERTY '//TYP//'. FAILED TO LOCATE "LIST" OR "ARRAY" KEYWORD, WHICH IS REQUIRED FOR THIS PROPERTY.', MSG2=MSG)
        !
        IF(LAI%READ_BYROW    .AND. (LAI%LISTARRAY .OR. ONLYARRAY)            ) CALL STOP_ERROR(LINE,IN,IOUT,'LIST-ARRAY INPUT (LAI) PROPERTY '//TYP//'. FOUND KEYWORD LIST_TRANSPOSE, BUT INPUT PROPERTY DOES NOT SUPPORT IT. PLEASE CHECK TO SEE IF "LIST" OR "ARRAY" KEYWORD ARE SUPPOSED TO BE USED.', MSG2=MSG)
        !
    END IF
    !
    IF(ONLYARRAY) LAI%LISTLOAD = FALSE
    !
    IF(ONLYLIST .AND. .NOT. LAI%HAS_IXJ) LAI%LISTLOAD = TRUE
    !
    IF(LAI%IS_CONSTANT) THEN
                        IF(ONLYIXJ) CALL STOP_ERROR(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY '//TYP//' DOES NOT SUPPORT "CONSTANT" KEYWORD DUE TO ONLY SUPPORTING THE "IXJ" INPUT OPTION.', MSG2=MSG)
                        LAI%TRANSIENT = FALSE
                        LAI%HAS_IXJ   = FALSE
                        IF(ONLYARRAY) THEN
                                         LAI%LISTLOAD = FALSE
                        ELSE
                                         LAI%LISTLOAD = TRUE
                        END IF
    END IF
    !
    IF(ONLY_STATIC .AND. LAI%TRANSIENT)  CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY "'//TYP//'" CAN ONLY BE LOADED ONCE, BUT "TRANSIENT" KEYWORD WAS FOUND. PROGRAM WILL CONTINUE AS IF "STATIC" WAS SPECIFIED.')
    IF(ONLY_STATIC) LAI%TRANSIENT = FALSE
    !
    IF (LAI%LISTLOAD) THEN
            NOID        = FALSE  ! LIST LOADING REQUIRES ID TO BE SPECIFIED ON FIRST COLUMN
            LAI%HAS_IXJ = FALSE  ! ENSURE THAT IXJ IS DISABLED
            !
            IF(LAI%READ_BYROW) NOID = TRUE  ! LIST LOADING WITH LIST_TRANSPOSE DOES NOT READ ID
            !
            IF(LAI%LISTARRAY) THEN
                                   LAI%LISTLOAD  = FALSE
                                   ALLOCATE(LAI%ARRAY(LDIM2,LDIM1))
            ELSE
                                   ALLOCATE(LAI%LIST(LDIM1))
            END IF
    ELSEIF(LAI%HAS_IXJ) THEN
                                   ALLOCATE(LAI%IXJ)
                                   CALL LAI%IXJ%INIT(CDIM, IOUT)
                                   NOID = TRUE
    ELSE
                                   ALLOCATE(LAI%ARRAY(NCOL,NROW))
                                   !
                                   NOID        = TRUE   !ARRAY LOADING DOES NOT INCLUDE ID IN FIRST COLUMN
                                   LAI%HAS_IXJ = FALSE  ! ENSURE THAT IXJ IS DISABLED
    END IF
    !
    IF(LAI%STORE_ID) THEN
        IF(LAI%READ_BYROW .OR. .NOT. NOID) THEN
                                           ALLOCATE(LAI%ID(LDIM1), SOURCE=Z)
        ELSE
            LAI%STORE_ID = FALSE
        END IF
    END IF
    !
    !
    IF(LAI%READ_BYROW) THEN
            !
            CALL LAI%SFAC%INIT()  !Must setup the SFAC
            !
            CALL LAI%TFR%INIT( LLOC, LINE, IOUT, IN, NOID=TRUE, EX1_DIM=EX1_DIM, EX1_WORD=EX1_WORD, EX2_DIM=EX2_DIM, EX2_WORD=EX2_WORD, EX3_DIM=EX3_DIM, EX3_WORD=EX3_WORD, NO_BINARY=NO_BINARY, LEN_LN=ONE)
            !
            CALL LAI%TFR%SET_FNAME()
            !
            DIM = MAX_UNCOMMENTED_LINE_LEN(LAI%TFR%FNAME) + TWO
            IF(DIM > 10000) DIM = 10000 !Limit length to 10000
            !
            IF(ALLOCATED(LAI%TFR%LN)) DEALLOCATE(LAI%TFR%LN)
            ALLOCATE(CHARACTER(DIM):: LAI%TFR%LN) !Scratch space for reading LIST_TRANSPOSE
            !
            CALL READ_LIST_TRANSPOSE(LAI)
            !
            CALL SET_SEQUENCE(LDIM1, LAI%ID)
            !
    ELSEIF (.NOT. LAI%TRANSIENT ) THEN
        IF (LAI%LISTLOAD  ) THEN
                            CALL ULOAD(LAI%LIST,  LLOC, LINE, IOUT, IN, IU, NOID=NOID, ID=LAI%ID, SFAC=LAI%SFAC, EX1_DIM=EX1_DIM, EX1_WORD=EX1_WORD, EX2_DIM=EX2_DIM, EX2_WORD=EX2_WORD, EX3_DIM=EX3_DIM, EX3_WORD=EX3_WORD, SCRATCH=SCRATCH, NO_BINARY=NO_BINARY, MSG=LAI%ERRMSG)
        ELSEIF(LAI%HAS_IXJ) THEN
                            CALL ULOAD(LAI%IXJ,   LLOC, LINE, IOUT, IN, IU, NOID=NOID,            SFAC=LAI%SFAC, EX1_DIM=EX1_DIM, EX1_WORD=EX1_WORD, EX2_DIM=EX2_DIM, EX2_WORD=EX2_WORD, EX3_DIM=EX3_DIM, EX3_WORD=EX3_WORD, SCRATCH=SCRATCH, NO_BINARY=NO_BINARY, MSG=LAI%ERRMSG)
        ELSE
                            CALL ULOAD(LAI%ARRAY, LLOC, LINE, IOUT, IN, IU, NOID=NOID, ID=LAI%ID, SFAC=LAI%SFAC, EX1_DIM=EX1_DIM, EX1_WORD=EX1_WORD, EX2_DIM=EX2_DIM, EX2_WORD=EX2_WORD, EX3_DIM=EX3_DIM, EX3_WORD=EX3_WORD, SCRATCH=SCRATCH, NO_BINARY=NO_BINARY, MSG=LAI%ERRMSG)
        END IF
        !
        IF(LAI%NONEG_ALLOWED) THEN
           IF (LAI%LISTLOAD ) THEN
                                         WHERE ( LAI%LIST < DZ ) LAI%LIST = DZ
           ELSEIF(.NOT. LAI%HAS_IXJ) THEN
                                         WHERE ( LAI%ARRAY < DZ ) LAI%ARRAY = DZ
           END IF
        END IF
    ELSE
        CALL LAI%TFR%INIT( LLOC, LINE, IOUT, IN, NOID=NOID, EX1_DIM=EX1_DIM, EX1_WORD=EX1_WORD, EX2_DIM=EX2_DIM, EX2_WORD=EX2_WORD, EX3_DIM=EX3_DIM, EX3_WORD=EX3_WORD, NO_BINARY=NO_BINARY)
        !IF (LAI%LISTLOAD ) THEN
        !                       CALL LAI%TFR%INIT(        LLOC, LINE, IOUT, IN, NOID=NOID, EX1_DIM=EX1_DIM, EX1_WORD=EX1_WORD, EX2_DIM=EX2_DIM, EX2_WORD=EX2_WORD, EX3_DIM=EX3_DIM, EX3_WORD=EX3_WORD, NO_BINARY=NO_BINARY)
        !ELSE
        !                       CALL LAI%TFR%INIT(        LLOC, LINE, IOUT, IN, NOID=NOID, EX1_DIM=EX1_DIM, EX1_WORD=EX1_WORD, EX2_DIM=EX2_DIM, EX2_WORD=EX2_WORD, EX3_DIM=EX3_DIM, EX3_WORD=EX3_WORD, NO_BINARY=NO_BINARY)
        !END IF
        !
        CALL LOAD_NEXT_INPUT(LAI)
    END IF
    !
    IF (LAI%LISTLOAD .OR. LAI%LISTARRAY) THEN
        LINE = 'PROPERTY IS SET TO BE READ IN AS A  LIST OF PROPERTIES THAT IS READ'
    ELSEIF(LAI%HAS_IXJ) THEN
        LINE = 'PROPERTY IS SET TO BE READ IN AS A  IXJ-STRUCTURED SET OF PROPERTIES THAT IS READ'
    ELSE
        LINE = 'PROPERTY IS SET TO BE READ IN AS AN ARRAY (NROW,NCOL)  THAT IS READ'
    END IF
    !
    IF (LAI%TRANSIENT) THEN
        LINE = TRIM(LINE)//' IN EVERY STRESS PERIOD'
    ELSE
        LINE = TRIM(LINE)//' ONCE FOR THE SIMULATION'
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE SET_UP_LIST_TRANSPOSE(LAI,LLOC,LINE,IOUT,IN)
    CLASS(LIST_ARRAY_INPUT_BASE), INTENT(INOUT):: LAI
    CHARACTER(*),                 INTENT(IN   ):: LINE
    INTEGER,                      INTENT(INOUT):: LLOC
    INTEGER,                      INTENT(IN   ):: IOUT,IN
    !
    CHARACTER(64):: TXT
    INTEGER:: DIM !,ISTART,ISTOP
    !
    !CALL LAI%TFR%INIT( LLOC, LINE, IOUT, IN, NOID=NOID, NO_BINARY=NO_BINARY, LEN_LN=ONE)
    !IF(LAI%READ_BYROW) CALL LAI%TFR%INIT( LLOC, LINE, IOUT, IN, NOID=NOID, EX1_DIM=EX1_DIM, EX1_WORD=EX1_WORD, EX2_DIM=EX2_DIM, EX2_WORD=EX2_WORD, EX3_DIM=EX3_DIM, EX3_WORD=EX3_WORD, NO_BINARY=NO_BINARY, LEN_LN=ONE)
    !
    CALL LAI%TFR%OPEN(LINE,LLOC,IOUT,IN,KEY=TXT)
    !
    CALL LAI%TFR%SET_FNAME()
    !
    DIM = MAX_UNCOMMENTED_LINE_LEN(LAI%TFR%FNAME) + TWO
    IF(DIM > 10000) DIM = 10000 !Limit length to 10000
    !
    SELECT TYPE(LAI)
    TYPE IS(LIST_ARRAY_INPUT); CALL LAI%SFAC%INIT()  !Must setup the SFAC
    END SELECT
    !
    IF(ALLOCATED(LAI%TFR%LN)) DEALLOCATE(LAI%TFR%LN)
    !!
    ALLOCATE(CHARACTER(DIM):: LAI%TFR%LN) !Scratch space for reading LIST_TRANSPOSE
    !
    LAI%TFR%NOID = TRUE
    LAI%TFR%IOUT = IOUT
    !
    IF(LAI%TFR%IU == Z         ) CALL STOP_ERROR(LINE,IN,IOUT,'LIST-ARRAY INPUT (LAI) PROPERTY '//LAI%TYP//'. FOUND KEYWORD LIST_TRANSPOSE, BUT THE FILE WAS SPECIFIED WITH "INTERNAL". THIS IS NOT ALLOWED. INSTEAD SPECIFY THE FILE WITH EITHER "OPEN/CLOSE", "EXTERNAL", "DATAUNIT", OR "DATAFILE."', MSG2=LAI%ERRMSG)
    IF(TXT        == 'CONSTANT') CALL STOP_ERROR(LINE,IN,IOUT,'LIST-ARRAY INPUT (LAI) PROPERTY '//LAI%TYP//'. FOUND KEYWORD LIST_TRANSPOSE, BUT THE FILE WAS SPECIFIED WITH "CONSTANT". THIS IS NOT ALLOWED. PLEASE REMOVE THE LIST_TRANSPOSE KEYWORD AD INSTEAD USE "LIST" OR "ARRAY".', MSG2=LAI%ERRMSG)
    !
    !DO    !CHECK IF FEEDFILE HAS "STRESS PERIOD" FLAG IS REACHED
    !  CALL READ_TO_DATA(TXT,LAI%TFR%IU,IOUT,EOF=EOF)
    !  !
    !  IF(EOF) THEN         !NOT FOUND, REWIND
    !      REWIND(LAI%TFR%IU)
    !      EXIT
    !  END IF
    !  !
    !  LLOC = ONE
    !  CALL PARSE_WORD_UP(TXT,LLOC,ISTART,ISTOP,TRUE)
    !  IF(TXT(ISTART:ISTOP)=='TEMPORAL') THEN !Temporal Input
    !      EXIT
    !  ELSEIF(TXT(ISTART:ISTOP)=='STRESS' ) THEN
    !      CALL PARSE_WORD_UP(TXT,LLOC,ISTART,ISTOP,TRUE)
    !      IF(TXT(ISTART:ISTOP)=='PERIOD' ) EXIT
    !  END IF
    !  !
    !END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE READ_LIST_TRANSPOSE(LAI)
    CLASS(LIST_ARRAY_INPUT), INTENT(INOUT):: LAI
    !
    INTEGER:: IERR, LLOC, ISTART, ISTOP
    LOGICAL:: HAS_ERROR
    !
    CALL READ_TO_DATA(LAI%TFR%LN, LAI%TFR%IU)
    !
    LLOC = ONE
    CALL GET_NUMBER(LAI%TFR%LN,LLOC,ISTART,ISTOP, LAI%TFR%IOUT,LAI%TFR%IU,LAI%LIST,HAS_ERROR=HAS_ERROR)
    !
    IF(.NOT. HAS_ERROR) THEN !Check for SFAC
        !
        CALL LAI%SFAC%INIT()
        !
        CALL PARSE_WORD_UP(LAI%TFR%LN, LLOC, ISTART, ISTOP)
        !
        IF(LAI%TFR%LN(ISTART:ISTOP) == 'SFAC') CALL LAI%SFAC%LOAD( LAI%TFR%LN(LLOC:), LAI%TFR%IU, LAI%TFR%IOUT, EX1_WORD=LAI%TFR%EX1_WORD, EX1_DIM=LAI%TFR%EX1_DIM, EX2_WORD=LAI%TFR%EX2_WORD, EX2_DIM=LAI%TFR%EX2_DIM, EX3_WORD=LAI%TFR%EX3_WORD, EX3_DIM=LAI%TFR%EX3_DIM, SKIP_SFAC=TRUE)
    ELSE
       BACKSPACE(LAI%TFR%IU)
       !
       READ(LAI%TFR%IU,*,IOSTAT=IERR) LAI%LIST
       !
       IF(IERR.NE.Z) CALL FILE_IO_ERROR(IERR,LAI%TFR%IU,LINE=LAI%TFR%LN,INFILE=LAI%TFR%IU,OUTPUT=LAI%TFR%IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY '//LAI%TYP//' HAS LIST_TRANSPOSE OPTION, BUT FAILED TO READ LINE.'//BLN//'NOTE THAT ERROR<0 CAN ALSO MEAN NOT ENOUGH NUMBERS OF LINE.'//NL//'THIS FILE EXPECTED TO LOAD '//NUM2STR(SIZE(LAI%LIST))//' NUMBERS ON EACH LINE.')
    END IF
    !
    IF(ANY(LAI%LIST.NE.LAI%LIST)) CALL STOP_ERROR(LAI%TFR%LN,LAI%TFR%IU,LAI%TFR%IOUT,'LIST-ARRAY INPUT (LAI) PROPERTY '//LAI%TYP//' HAS LIST_TRANSPOSE OPTION, BUT FOUND A NaN ON THE CURRENT LINE BEING READ.'//BLN//'AT THIS POINT IN TIME LIST-ARRAY INPUT WITH LIST_TRANSPOSE DOES NOT SUPPORT "NaN" INPUT.', MSG2=LAI%ERRMSG)
    !
    IF(LAI%TFR%SCALE.NE.UNO) LAI%LIST = LAI%LIST * LAI%TFR%SCALE
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_NEXT_INPUT(LAI)
    CLASS(LIST_ARRAY_INPUT), INTENT(INOUT):: LAI
    !
    IF(LAI%TRANSIENT) THEN
          IF    (LAI%READ_BYROW)THEN
                               CALL READ_LIST_TRANSPOSE(LAI)
          ELSEIF(LAI%LISTLOAD) THEN
                               CALL LAI%TFR%NEXT(LAI%LIST, LAI%SFAC, ID=LAI%ID, MSG=LAI%ERRMSG)
          ELSEIF(LAI%HAS_IXJ) THEN
                               CALL LAI%TFR%NEXT(LAI%IXJ,  LAI%SFAC,            MSG=LAI%ERRMSG)
          ELSE
                               CALL LAI%TFR%NEXT(LAI%ARRAY,LAI%SFAC, ID=LAI%ID, MSG=LAI%ERRMSG)
          END IF
          !
          IF(LAI%NONEG_ALLOWED) THEN
             IF (LAI%LISTLOAD ) THEN
                                           WHERE ( LAI%LIST < DZ ) LAI%LIST = DZ
             ELSEIF(.NOT. LAI%HAS_IXJ) THEN
                                           WHERE ( LAI%ARRAY < DZ ) LAI%ARRAY = DZ
             END IF
          END IF
    END IF
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_LIST_ARRAY_INPUT_INT_AS_VALUE(LAI, TYP, VAL, IOUT, IN, LDIM1, LDIM2, NROW, NCOL, LISTARRAY, STORE_ID)
    CLASS(LIST_ARRAY_INPUT_INT),INTENT(INOUT):: LAI
    CHARACTER(*),               INTENT(IN   ):: TYP
    INTEGER,                    INTENT(IN   ):: VAL
    INTEGER,                    INTENT(IN   ):: IOUT, IN, LDIM1, LDIM2, NROW, NCOL
    LOGICAL, OPTIONAL,          INTENT(IN   ):: LISTARRAY  ! FORCE LISTARRAY EVEN THOUGH LDIM2=1
    LOGICAL, OPTIONAL,          INTENT(IN   ):: STORE_ID
    !
    IF(LAI%INUSE) THEN
        CALL WARNING_MESSAGE(INFILE=IN,OUTPUT=IOUT,MSG='LIST-ARRAY INPUT PROPERTY "'//TYP//'" IS BEING LOADED A SECOND TIME!!!'//BLN//'MAYBE YOU ACCIDENTALLY SPECIFIED THE SAME KEYWORD TWICE???'//BLN//'THE PREVIOUS LINE THAT THE KEYWORD WAS FOUND WILL BE IGNORED'//NL//'AND THE LINE PRESENTED IN THIS WARNING WILL BE USED INSTEAD.')
        CALL LIST_ARRAY_INPUT_DEALLOCATE_ALL_TYPES(LAI)
    END IF
    !
    LAI%INUSE = TRUE
    ALLOCATE(LAI%TYP, SOURCE = TYP)
    !
    LAI%ERRMSG=BLNK
    !
    LAI%TRANSIENT = FALSE
    LAI%LISTARRAY = LDIM2  > ONE  !USED TO BE >Z
    !
    IF(PRESENT(LISTARRAY) .AND. LDIM2 > Z) LAI%LISTARRAY = LISTARRAY
    !
    IF (LDIM1 > Z) THEN
            !
            IF(LAI%LISTARRAY) THEN
                                   LAI%LISTLOAD  = FALSE
                                   ALLOCATE(LAI%ARRAY(LDIM2,LDIM1), SOURCE=VAL)
            ELSE
                                   LAI%LISTLOAD  = TRUE
                                   ALLOCATE(LAI%LIST(LDIM1), SOURCE=VAL)
            END IF
    ELSE
                                   LAI%LISTLOAD  = FALSE
                                   ALLOCATE(LAI%ARRAY(NCOL,NROW), SOURCE=VAL)
    END IF
    !
    IF(PRESENT(STORE_ID)) THEN                  
                          LAI%STORE_ID = STORE_ID  ! Implied .NOT. NOID
    ELSE
                          LAI%STORE_ID = FALSE
    END IF
    !
    IF(LAI%STORE_ID) THEN
                     IF(LAI%LISTARRAY .OR. LAI%LISTLOAD) THEN
                                                         ALLOCATE(LAI%ID(LDIM1))
                                                         CALL SET_SEQUENCE(LDIM1, LAI%ID)
                     ELSE
                                                         LAI%STORE_ID = FALSE
                     END IF
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_LIST_ARRAY_INPUT_INT(LAI, TYP, LLOC, LINE, IOUT, IN, LDIM1, LDIM2, NROW, NCOL, SCRATCH, NO_TRANSIENT, LISTARRAY, STORE_ID, CDIM, MSG)
    ! LDIM1 LENGTHIN OF LIST (row dimension) --SET TO ZERO TO NOT ALLOW LIST LOAD
    ! LDIM2 NUMBER OF PROPERTIES (col dim)   --If >0 THEN IT WILL ALLOCATE ARRAY, IF =0 THEN IT IT WILL ALLOCATE A LIST WHEN REQUESTED
    ! NROW  ROWS IN ARRAY                    --SET TO ZERO TO NOT ALLOW ARRAY LOADING
    ! NCOL  COL IN ARRAY
    CLASS(LIST_ARRAY_INPUT_INT),INTENT(INOUT):: LAI
    CHARACTER(*),           INTENT(IN   ):: TYP
    CHARACTER(*),           INTENT(INOUT):: LINE
    INTEGER,                INTENT(INOUT):: LLOC
    INTEGER,                INTENT(IN   ):: IOUT, IN, LDIM1, LDIM2, NROW, NCOL
    INTEGER, OPTIONAL,      INTENT(IN   ):: SCRATCH
    LOGICAL, OPTIONAL,      INTENT(IN   ):: NO_TRANSIENT, STORE_ID
    LOGICAL, OPTIONAL,      INTENT(IN   ):: LISTARRAY  ! FORCE LISTARRAY EVEN THOUGH LDIM2=1
    INTEGER, DIMENSION(:), CONTIGUOUS, OPTIONAL, INTENT(IN):: CDIM ! ALLOW COMPRESSED ARRAY STORAGE
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: MSG
    CHARACTER(12):: LAI_KEY
    INTEGER:: IU,ISTART,ISTOP,N, DIM
    LOGICAL:: NOID, ONLYARRAY, ONLYLIST, ONLYIXJ, ONLY_STATIC, FOUND_TEMPORAL, FOUND_SPATIAL, NO_IMPLIED
    !
    IF(LAI%INUSE) THEN
        CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT PROPERTY "'//TYP//'" IS BEING LOADED A SECOND TIME!!!'//BLN//'MAYBE YOU ACCIDENTALLY SPECIFIED THE SAME KEYWORD TWICE???'//BLN//'THE PREVIOUS LINE THAT THE KEYWORD WAS FOUND WILL BE IGNORED'//NL//'AND THE LINE PRESENTED IN THIS WARNING WILL BE USED INSTEAD.')
        CALL LIST_ARRAY_INPUT_DEALLOCATE_ALL_TYPES(LAI)
    END IF
    !
    DIM = Z
    !
    LAI%IS_CONSTANT = FALSE
    FOUND_TEMPORAL  = FALSE
    FOUND_SPATIAL   = FALSE
    !
    ONLY_STATIC = FALSE
    IF(PRESENT(NO_TRANSIENT)) ONLY_STATIC = NO_TRANSIENT
    IU = Z
    LAI%INUSE = TRUE
    ALLOCATE(LAI%TYP, SOURCE = TYP)
    !
    IF(PRESENT(MSG)) THEN
        LAI%ERRMSG=MSG
    ELSE
        LAI%ERRMSG=BLNK
    END IF
    !
    LAI%ERRMSG=BLNK
    !
    ONLYARRAY     = LDIM1 == Z
    LAI%LISTARRAY = LDIM2  > ONE  !USED TO BE >Z
    ONLYLIST      = NROW  == Z
    !
    IF(PRESENT(STORE_ID)) THEN                  
                          LAI%STORE_ID = STORE_ID  ! Can be overrulled by NOID
    ELSE
                          LAI%STORE_ID = FALSE
    END IF
    !
    IF(PRESENT(CDIM)) THEN
        ONLYIXJ = ANY(CDIM>Z) .AND. LDIM1 == Z .AND. NROW  == Z
    ELSE
        ONLYIXJ = FALSE
    END IF
    !
    IF(PRESENT(LISTARRAY) .AND. LDIM2 > Z) LAI%LISTARRAY = LISTARRAY
    !
    DO WHILE (.NOT. (FOUND_TEMPORAL .AND. FOUND_SPATIAL) )
      !
      CALL GET_WORD(LAI_KEY,LINE,LLOC,OLD_LOC=N)
      !
      SELECT CASE (LAI_KEY)
                                     CASE('TRANSIENT')
                                                        LAI%TRANSIENT = TRUE
                                                        FOUND_TEMPORAL= TRUE
                                     CASE('STATIC')
                                                        LAI%TRANSIENT = FALSE
                                                        FOUND_TEMPORAL= TRUE
                                     CASE('LIST')
                                                      LAI%LISTLOAD = TRUE
                                                      FOUND_SPATIAL= TRUE
                                                      IF(ONLYARRAY) CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY "'//TYP//'" CAN ONLY BE LOADED AS "ARRAY", BUT "LIST" KEYWORD FOUND.'//NL//'PROGRAM WILL CONTINUE AS IF ARRAY WAS SPECIFIED.')
                                                      !WRITE(IOUT, '(A,/A/)') 'WARNING: FMP PROPERTY '//TYP//' CAN ONLY BE LOADED AS "ARRAY", BUT "LIST" KEYWORD FOUND. PROGRAM WILL CONTINUE AS IF ARRAY WAS SPECIFIED. THE FOLLOWING LINE CONTAINS THE PROBLEM:',TRIM(LINE)
                                     CASE('ARRAY')
                                                      LAI%LISTLOAD  = FALSE
                                                      LAI%LISTARRAY = FALSE
                                                      FOUND_SPATIAL = TRUE
                                                      IF(ONLYLIST) CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY "'//TYP//'" CAN ONLY BE LOADED AS "LIST", BUT "ARRAY" KEYWORD FOUND. PROGRAM WILL CONTINUE AS IF LIST WAS SPECIFIED.')
                                                      !WRITE(IOUT, '(A,/A/)') 'WARNING: FMP PROPERTY '//TYP//' CAN ONLY BE LOADED AS LIST, BUT ARRAY KEYWORD FOUND. PROGRAM WILL CONTINUE AS IF LIST WAS SPECIFIED. THE FOLLOWING LINE CONTAINS THE PROBLEM:',TRIM(LINE)
                                     CASE('PARRENT')
                                                        LAI%PULL_PARRENT = TRUE
                                                        LAI%TRANSIENT = FALSE
                                                        RETURN
                                     CASE('INTERNAL')
                                                        IF(LAI%TRANSIENT) THEN
                                                            LAI%TRANSIENT = FALSE
                                                            CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY "'//TYP//'" FOUND KEYWORD INTERNAL, BUT THIS ONLY WORKS WITHIN THE STATIC OPTION OR IF TRANSIENT IS USED THEN IT MAY ONLY RESIDE WITHIN THE TRANSIENT FILE READER (TFR).'//BLN//'THE TEMPORAL INPUT WAS CHANGED TO "STATIC INTERNAL".', INLINE=TRUE)
                                                        END IF
                                                        FOUND_TEMPORAL= TRUE
                                                        LLOC = N
                                                        EXIT
                                     CASE('CONSTANT')
                                                        LAI%IS_CONSTANT = TRUE
                                                        LLOC = N
                                                        EXIT
                                     CASE('NODE', 'IXJ') !'COMPRESSE' ==> 'COMPRESSED' and 'COMPRESSED_ARRAY'
                                                      !
                                                      FOUND_SPATIAL = FALSE
                                                      IF(.NOT. PRESENT(CDIM)) THEN
                                                          FOUND_SPATIAL = TRUE
                                                      ELSEIF(ALL(CDIM==Z)) THEN
                                                          FOUND_SPATIAL = TRUE
                                                      END IF
                                                      IF(FOUND_SPATIAL) CALL STOP_ERROR(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY '//TYP//' DOES NOT SUPPORT "IXJ" INPUT FORMAT, BUT "'//LAI_KEY//'" KEYWORD WAS FOUND. PROGRAM CANNOT CONITUE WITH A "IXJ" INPUT FORMAT FOR THIS INPUT TYPE. PLEASE CHANGE TO "LIST" OR "ARRAY" STYLE INPUT.', MSG2=MSG)
                                                      !
                                                      !IF(ONLYLIST)    CALL STOP_ERROR(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY '//TYP//' CAN ONLY BE LOADED AS "LIST", BUT "'//LAI_KEY//'" KEYWORD FOUND. PROGRAM CANNOT CONITUE WITH A IXJ INPUT FORMAT FOR THIS INPUT TYPE. PLEASE CHANGE TO "LIST" STYLE INPUT.')
                                                      !
                                                      LAI%HAS_IXJ   = TRUE
                                                      LAI%LISTLOAD  = FALSE
                                                      LAI%LISTARRAY = FALSE
                                                      FOUND_SPATIAL = TRUE
                                     CASE ('DIM','DIMENSION')
                                                       CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IN,DIM,MSG='LIST_ARRAY_INPUT (LAI/ULOAD) FOUND KEYWORD "'//TRIM(LAI_KEY)//'", WHICH MUST BE FOLLOWED BY AN INTEGER THAT REPRESENTS THE NUMBER OF ROWS TO LOAD FOR COMPRESS ARRAY STORAGE (YOU MUST ALSO SPECIFY THE "COMPRESS" KEYWORD)')
                                     CASE ('AUTO','AUTOCOUNT','AUTO-COUNT')
                                                       DIM=Z
                                     CASE DEFAULT
                                                        LLOC = N
                                                        EXIT
      END SELECT
    END DO
    !
    IF(ONLYIXJ .AND. .NOT. LAI%HAS_IXJ) THEN
                           LAI%HAS_IXJ   = TRUE
                           LAI%LISTLOAD  = FALSE
                           LAI%LISTARRAY = FALSE
                           FOUND_SPATIAL = TRUE
    END IF
    !
    IF(.NOT. LAI%IS_CONSTANT) THEN
        !
        IF(      .NOT. LAI%LISTARRAY .AND. .NOT. ONLYARRAY .AND. .NOT. LAI%HAS_IXJ .AND. .NOT. ONLYIXJ   &
           .AND. .NOT. ( (FOUND_TEMPORAL.OR.ONLY_STATIC).AND.(FOUND_SPATIAL.OR.ONLYLIST)) ) THEN
            READ(LAI_KEY,'(I9)',IOSTAT=N) ISTART
            NO_IMPLIED = N.NE.Z
        ELSE
            NO_IMPLIED = TRUE
        END IF
        !
        IF(.NOT. ONLY_STATIC                       .AND. .NOT. FOUND_TEMPORAL .AND. NO_IMPLIED) CALL STOP_ERROR(LINE,IN,IOUT,'LIST-ARRAY INPUT (LAI) PROPERTY "'//TYP//'". FAILED TO LOCATE "STATIC" OR "TRANSIENT" KEYWORD, WHICH IS REQUIRED FOR THIS PROPERTY.', MSG2=MSG)
        IF(.NOT. ONLYLIST    .AND. .NOT. ONLYARRAY .AND. .NOT. FOUND_SPATIAL  .AND. NO_IMPLIED) CALL STOP_ERROR(LINE,IN,IOUT,'LIST-ARRAY INPUT (LAI) PROPERTY "'//TYP//'". FAILED TO LOCATE "LIST" OR "ARRAY" KEYWORD, WHICH IS REQUIRED FOR THIS PROPERTY.', MSG2=MSG)
        !
        IF(.NOT. NO_IMPLIED) THEN
           IF(.NOT. FOUND_TEMPORAL) LAI%TRANSIENT = FALSE
           IF(.NOT. FOUND_SPATIAL ) LAI%LISTLOAD  = TRUE
        END IF
        !
    END IF
    !
    IF(ONLYARRAY) LAI%LISTLOAD = FALSE
    IF(ONLYLIST ) LAI%LISTLOAD = TRUE
    !
    IF(LAI%IS_CONSTANT) THEN
                        IF(ONLYIXJ) CALL STOP_ERROR(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY '//TYP//' DOES NOT SUPPORT "CONSTANT" KEYWORD DUE TO ONLY SUPPORTING THE "IXJ" INPUT OPTION.', MSG2=MSG)
                        LAI%TRANSIENT = FALSE
                        LAI%HAS_IXJ   = FALSE
                        IF(ONLYARRAY) THEN
                                         LAI%LISTLOAD = FALSE
                        ELSE
                                         LAI%LISTLOAD = TRUE
                        END IF
    END IF
    !
    IF(ONLY_STATIC .AND. LAI%TRANSIENT) CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY "'//TYP//'" CAN ONLY BE LOADED ONCE, BUT "TRANSIENT" KEYWORD WAS FOUND. PROGRAM WILL CONTINUE AS IF "STATIC" WAS SPECIFIED.')
    IF(ONLY_STATIC) LAI%TRANSIENT = FALSE
    !
    IF (LAI%LISTLOAD) THEN
            NOID        = FALSE  !LIST LOADING REQUIRES ID TO BE SPECIFIED ON FIRST COLUMN
            LAI%HAS_IXJ = FALSE  ! ENSURE THAT IXJ IS DISABLED
            !
            IF(LAI%LISTARRAY) THEN
                                   LAI%LISTLOAD  = FALSE
                                   ALLOCATE(LAI%ARRAY(LDIM2,LDIM1))
            ELSE
                                   ALLOCATE(LAI%LIST(LDIM1))
            END IF
    ELSEIF(LAI%HAS_IXJ) THEN
                                   ALLOCATE(LAI%IXJ)
                                   CALL LAI%IXJ%INIT(CDIM, IOUT)
                                   NOID = TRUE
    ELSE
                                   ALLOCATE(LAI%ARRAY(NCOL,NROW))
                                   !
                                   NOID        = TRUE   !ARRAY LOADING DOES NOT INCLUDE ID IN FIRST COLUMN
                                   LAI%HAS_IXJ = FALSE  ! ENSURE THAT IXJ IS DISABLED
    END IF
    !
    IF(LAI%STORE_ID) THEN
        IF(.NOT. NOID) THEN                                                    !LAI%READ_BYROW .OR. 
                       ALLOCATE(LAI%ID(LDIM1), SOURCE=Z)
        ELSE
                       LAI%STORE_ID = FALSE
        END IF
    END IF
    !
    IF (.NOT. LAI%TRANSIENT ) THEN
        IF (LAI%LISTLOAD ) THEN
                               CALL ULOAD(LAI%LIST,  LLOC, LINE, IOUT, IN, IU, NOID=NOID, ID=LAI%ID, SCRATCH=SCRATCH, MSG=LAI%ERRMSG)
        ELSEIF(LAI%HAS_IXJ) THEN
                               CALL ULOAD(LAI%IXJ,   LLOC, LINE, IOUT, IN, IU, NOID=NOID,            SCRATCH=SCRATCH, MSG=LAI%ERRMSG)
        ELSE
                               CALL ULOAD(LAI%ARRAY, LLOC, LINE, IOUT, IN, IU, NOID=NOID, ID=LAI%ID, SCRATCH=SCRATCH, MSG=LAI%ERRMSG)
        END IF
    ELSE
        CALL LAI%TFR%INIT(LLOC, LINE, IOUT, IN, NOID=NOID)
        !
        CALL LOAD_NEXT_INPUT_INT(LAI)
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE READ_LIST_TRANSPOSE_INT(LAI)
    CLASS(LIST_ARRAY_INPUT_INT), INTENT(INOUT):: LAI
    !
    CHARACTER(200):: LINE
    INTEGER:: IERR
    !
    CALL READ_TO_DATA(LINE, LAI%TFR%IU)
    BACKSPACE(LAI%TFR%IU)
    !
    READ(LAI%TFR%IU,*,IOSTAT=IERR) LAI%LIST
    !
    IF(IERR.NE.Z) CALL FILE_IO_ERROR(IERR,LAI%TFR%IU,LINE=LINE,INFILE=LAI%TFR%IU,OUTPUT=LAI%TFR%IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY '//LAI%TYP//' HAS LIST_TRANSPOSE OPTION, BUT FAILED TO READ LINE.'//BLN//'NOTE THAT ERROR<0 CAN ALSO MEAN NOT ENOUGH NUMBERS OF LINE.'//NL//'LIST_TRANSPOSE INPUT EXPECTED TO LOAD '//NUM2STR(SIZE(LAI%LIST))//' NUMBERS ON EACH LINE.'//BLN//'ALSO NOTE THE USE OF LIST_TRANSPOSE WITH LIST-ARRAY INPUT DOES NOT SUPPORT THE USE OF "NAN" ON AN INPUT LINE.')
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_NEXT_INPUT_INT(LAI)
    CLASS(LIST_ARRAY_INPUT_INT), INTENT(INOUT):: LAI
    !
    IF(LAI%TRANSIENT) THEN
          IF(LAI%LISTLOAD) THEN
                               CALL LAI%TFR%NEXT(LAI%LIST,  ID=LAI%ID, MSG=LAI%ERRMSG)
          ELSEIF(LAI%HAS_IXJ) THEN
                               CALL LAI%TFR%NEXT(LAI%IXJ,              MSG=LAI%ERRMSG)
          ELSE
                               CALL LAI%TFR%NEXT(LAI%ARRAY, ID=LAI%ID, MSG=LAI%ERRMSG)
          END IF
    END IF
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_LIST_ARRAY_INPUT_STR_AS_VALUE(LAI, TYP, VAL, IOUT, IN, LDIM1, LDIM2, NROW, NCOL, LINLEN, LISTARRAY)
    CLASS(LIST_ARRAY_INPUT_STR),INTENT(INOUT):: LAI
    CHARACTER(*),               INTENT(IN   ):: TYP
    CHARACTER(*),               INTENT(IN   ):: VAL
    INTEGER,                    INTENT(IN   ):: IOUT, IN, LDIM1, LDIM2, NROW, NCOL, LINLEN
    LOGICAL, OPTIONAL,          INTENT(IN   ):: LISTARRAY  ! FORCE LISTARRAY EVEN THOUGH LDIM2=1
    !
    IF(LAI%INUSE) THEN
        CALL WARNING_MESSAGE(INFILE=IN,OUTPUT=IOUT,MSG='LIST-ARRAY INPUT PROPERTY "'//TYP//'" IS BEING LOADED A SECOND TIME!!!'//BLN//'MAYBE YOU ACCIDENTALLY SPECIFIED THE SAME KEYWORD TWICE???'//BLN//'THE PREVIOUS LINE THAT THE KEYWORD WAS FOUND WILL BE IGNORED'//NL//'AND THE LINE PRESENTED IN THIS WARNING WILL BE USED INSTEAD.')
        CALL LIST_ARRAY_INPUT_DEALLOCATE_ALL_TYPES(LAI)
    END IF
    !
    LAI%INUSE = TRUE
    ALLOCATE(LAI%TYP, SOURCE = TYP)
    LAI%ERRMSG=BLNK
    !
    LAI%LINLEN = LINLEN
    !
    LAI%TRANSIENT = FALSE
    LAI%LISTARRAY = LDIM2  > ONE  !USED TO BE >Z
    !
    IF(PRESENT(LISTARRAY) .AND. LDIM2 > Z) LAI%LISTARRAY = LISTARRAY
    !
    IF (LDIM1 > Z) THEN
            !
            IF(LAI%LISTARRAY) THEN
                                   LAI%LISTLOAD  = FALSE
                                   ALLOCATE(CHARACTER(LINLEN):: LAI%ARRAY(LDIM2,LDIM1))
            ELSE
                                   LAI%LISTLOAD  = TRUE
                                   ALLOCATE(CHARACTER(LINLEN):: LAI%LIST(LDIM1))
            END IF
            LAI%LIST = VAL
    ELSE
                                   LAI%LISTLOAD  = FALSE
                                   ALLOCATE(CHARACTER(LINLEN):: LAI%ARRAY(NCOL,NROW))
            LAI%ARRAY = VAL
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_LIST_ARRAY_INPUT_STR(LAI, TYP, LLOC, LINE, IOUT, IN, LDIM1, LDIM2, NROW, NCOL,LINLEN, EX1_DIM, EX1_WORD, EX2_DIM, EX2_WORD, EX3_DIM, EX3_WORD, SCRATCH, NO_TRANSIENT, NO_BINARY, ENTIRE_LINE, LISTARRAY, MSG)
    ! TYP   NAME OF LIST_ARRAY
    ! IN    IS FILE TO LOAD INFORMATION FROM OR TO CLAIM OCCURED AT
    !
    ! LDIM1 LENGTHIN OF LIST (row dimension) --SET TO ZERO TO NOT ALLOW LIST LOAD
    ! LDIM2 NUMBER OF PROPERTIES (col dim)   --If >0 THEN IT WILL ALLOCATE ARRAY, IF =0 THEN IT IT WILL ALLOCATE A LIST WHEN REQUESTED
    ! NROW  ROWS IN ARRAY                    --SET TO ZERO TO NOT ALLOW ARRAY LOADING
    ! NCOL  COL IN ARRAY
    !
    ! OPTIONAL ARGUMENTS:
    !                    EX1_DIM, EX1_WORD ARE DIMENSION AND KEYWORD USED FOR SFAC ROUTING  (eg NFARM, 'BYWBS')
    !                    SCARTCH IS THE UNIT NUMBER TO LOAD INFORMATION FROM, WHEN IN IS ONLY MEANT TO BE USED FOR ERROR REPORTING
    CLASS(LIST_ARRAY_INPUT_STR),INTENT(INOUT):: LAI
    CHARACTER(*),               INTENT(IN   ):: TYP
    CHARACTER(*),               INTENT(INOUT):: LINE
    INTEGER,                    INTENT(INOUT):: LLOC
    INTEGER,                    INTENT(IN   ):: IOUT, IN, LDIM1, LDIM2, NROW, NCOL, LINLEN
    INTEGER,  OPTIONAL,         INTENT(IN   ):: EX1_DIM, EX2_DIM, EX3_DIM
    CHARACTER(*),OPTIONAL,      INTENT(IN   ):: EX1_WORD,EX2_WORD,EX3_WORD
    INTEGER,  OPTIONAL,         INTENT(IN   ):: SCRATCH
    LOGICAL, OPTIONAL,          INTENT(IN   ):: NO_TRANSIENT, NO_BINARY, ENTIRE_LINE
    LOGICAL, OPTIONAL,          INTENT(IN   ):: LISTARRAY  ! FORCE LISTARRAY EVEN THOUGH LDIM2=1
    CHARACTER(*), OPTIONAL,     INTENT(IN   ):: MSG
    CHARACTER(9):: LAI_KEY
    INTEGER:: IU,N
    LOGICAL:: NOID, ONLYARRAY, ONLYLIST, ONLY_STATIC, FOUND_TEMPORAL, FOUND_SPATIAL
    !
    IF(LAI%INUSE) THEN
        CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT PROPERTY "'//TYP//'" IS BEING LOADED A SECOND TIME!!!'//BLN//'MAYBE YOU ACCIDENTALLY SPECIFIED THE SAME KEYWORD TWICE???'//BLN//'THE PREVIOUS LINE THAT THE KEYWORD WAS FOUND WILL BE IGNORED'//NL//'AND THE LINE PRESENTED IN THIS WARNING WILL BE USED INSTEAD.')
        CALL LIST_ARRAY_INPUT_DEALLOCATE_ALL_TYPES(LAI)
    END IF
    !
    LAI%LINLEN = LINLEN
    !
    LAI%IS_CONSTANT = FALSE
    FOUND_TEMPORAL  = FALSE
    FOUND_SPATIAL   = FALSE
    !
    ONLY_STATIC = FALSE
    IF(PRESENT(NO_TRANSIENT)) ONLY_STATIC = NO_TRANSIENT
    IU = Z
    LAI%INUSE = TRUE
    ALLOCATE(LAI%TYP, SOURCE = TYP)
    !
    IF(PRESENT(MSG)) THEN
        LAI%ERRMSG=MSG
    ELSE
        LAI%ERRMSG=BLNK
    END IF
    !
    ONLYARRAY     = LDIM1 == Z
    LAI%LISTARRAY = LDIM2  > ONE  !USED TO BE >Z
    ONLYLIST      = NROW  == Z
    !
    IF(PRESENT(LISTARRAY) .AND. LDIM2 > Z) LAI%LISTARRAY = LISTARRAY
    !
    DO WHILE (.NOT. (FOUND_TEMPORAL .AND. FOUND_SPATIAL) )
      !
      CALL GET_WORD(LAI_KEY,LINE,LLOC,N)
      !
      SELECT CASE (LAI_KEY)
                                     CASE('TRANSIENT')
                                                        LAI%TRANSIENT = TRUE
                                                        FOUND_TEMPORAL= TRUE
                                     CASE('STATIC')
                                                        LAI%TRANSIENT = FALSE
                                                        FOUND_TEMPORAL= TRUE
                                     CASE('LIST')
                                                      LAI%LISTLOAD = TRUE
                                                      FOUND_SPATIAL= TRUE
                                                      IF(ONLYARRAY) CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY "'//TYP//'" CAN ONLY BE LOADED AS "ARRAY", BUT "LIST" KEYWORD FOUND.'//NL//'PROGRAM WILL CONTINUE AS IF ARRAY WAS SPECIFIED.')
                                                      !WRITE(IOUT, '(A,/A/)') 'WARNING: FMP PROPERTY '//TYP//' CAN ONLY BE LOADED AS "ARRAY", BUT "LIST" KEYWORD FOUND. PROGRAM WILL CONTINUE AS IF ARRAY WAS SPECIFIED. THE FOLLOWING LINE CONTAINS THE PROBLEM:',TRIM(LINE)
                                     CASE('ARRAY')
                                                      LAI%LISTLOAD  = FALSE
                                                      LAI%LISTARRAY = FALSE
                                                      FOUND_SPATIAL = TRUE
                                                      IF(ONLYLIST) CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY "'//TYP//'" CAN ONLY BE LOADED AS "LIST", BUT "ARRAY" KEYWORD FOUND. PROGRAM WILL CONTINUE AS IF LIST WAS SPECIFIED.')
                                                      !WRITE(IOUT, '(A,/A/)') 'WARNING: FMP PROPERTY '//TYP//' CAN ONLY BE LOADED AS LIST, BUT ARRAY KEYWORD FOUND. PROGRAM WILL CONTINUE AS IF LIST WAS SPECIFIED. THE FOLLOWING LINE CONTAINS THE PROBLEM:',TRIM(LINE)
                                     CASE('PARRENT')
                                                        LAI%PULL_PARRENT = TRUE
                                                        LAI%TRANSIENT = FALSE
                                                        RETURN
                                     CASE('INTERNAL')
                                                        IF(LAI%TRANSIENT) THEN
                                                            LAI%TRANSIENT = FALSE
                                                            CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY "'//TYP//'" FOUND KEYWORD INTERNAL, BUT THIS ONLY WORKS WITHIN THE STATIC OPTION OR IF TRANSIENT IS USED THEN IT MAY ONLY RESIDE WITHIN THE TRANSIENTE FILE READER (TFR).'//BLN//'THE TEMPORAL INPUT WAS CHANGED TO "STATIC INTERNAL".', INLINE=TRUE)
                                                        END IF
                                                        FOUND_TEMPORAL= TRUE
                                                        LLOC = N
                                                        EXIT
                                     CASE('CONSTANT')
                                                        LAI%IS_CONSTANT = TRUE
                                                        LLOC = N
                                                        EXIT
                                     CASE('IXJ', 'NODE','DIM','DIMENSION','AUTO','AUTOCOUNT','AUTO-COUN')!T
                                                      CALL STOP_ERROR(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY '//TYP//' DOES NOT SUPPORT COMPRESS ARRAY INPUT FORMAT, BUT "COMPRESS" KEYWORD WAS FOUND. PROGRAM CANNOT CONITUE WITH A COMPRESS ARRAY INPUT FORMAT FOR THIS INPUT TYPE. PLEASE CHANGE TO "LIST" OR "ARRAY" STYLE INPUT.', MSG2=MSG)
                                     CASE DEFAULT
                                                        LLOC = N
                                                        EXIT
      END SELECT
    END DO
    !
    IF(.NOT. LAI%IS_CONSTANT) THEN
        !
        IF(.NOT. ONLY_STATIC                       .AND. .NOT. FOUND_TEMPORAL) CALL STOP_ERROR(LINE,IN,IOUT,'LIST-ARRAY INPUT (LAI) PROPERTY '//TYP//'. FAILED TO LOCATE "STATIC" OR "TRANSIENT" KEYWORD, WHICH IS REQUIRED FOR THIS PROPERTY.', MSG2=MSG)
        IF(.NOT. ONLYLIST    .AND. .NOT. ONLYARRAY .AND. .NOT. FOUND_SPATIAL ) CALL STOP_ERROR(LINE,IN,IOUT,'LIST-ARRAY INPUT (LAI) PROPERTY '//TYP//'. FAILED TO LOCATE "LIST" OR "ARRAY" KEYWORD, WHICH IS REQUIRED FOR THIS PROPERTY.', MSG2=MSG)
        !
    END IF
    !
    IF(ONLYARRAY) LAI%LISTLOAD = FALSE
    IF(ONLYLIST ) LAI%LISTLOAD = TRUE
    !
    IF(LAI%IS_CONSTANT) THEN
                        LAI%TRANSIENT = FALSE
                        IF(ONLYARRAY) THEN
                                         LAI%LISTLOAD = FALSE
                        ELSE
                                         LAI%LISTLOAD = TRUE
                        END IF
    END IF
    !
    IF(ONLY_STATIC .AND. LAI%TRANSIENT)  CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) PROPERTY "'//TYP//'" CAN ONLY BE LOADED ONCE, BUT "TRANSIENT" KEYWORD WAS FOUND. PROGRAM WILL CONTINUE AS IF "STATIC" WAS SPECIFIED.')
    IF(ONLY_STATIC) LAI%TRANSIENT = FALSE
    !
    IF (LAI%LISTLOAD) THEN
            NOID = FALSE  !LIST LOADING REQUIRES ID TO BE SPECIFIED ON FIRST COLUMN
            !
            IF(LAI%LISTARRAY) THEN
                                   LAI%LISTLOAD  = FALSE
                                   ALLOCATE(CHARACTER(LINLEN):: LAI%ARRAY(LDIM2,LDIM1))
            ELSE
                                   ALLOCATE(CHARACTER(LINLEN):: LAI%LIST(LDIM1))
            END IF
    ELSE
                                   ALLOCATE(CHARACTER(LINLEN):: LAI%ARRAY(NCOL,NROW))
                                   !
                                   NOID = TRUE   !ARRAY LOADING DOES NOT INCLUDE ID IN FIRST COLUMN
    END IF
    !
    IF (.NOT. LAI%TRANSIENT ) THEN
        IF (LAI%LISTLOAD ) THEN
                               CALL ULOAD(LAI%LIST,  LLOC, LINE, IOUT, IN, IU, NOID=NOID, EX1_DIM=EX1_DIM, EX1_WORD=EX1_WORD, EX2_DIM=EX2_DIM, EX2_WORD=EX2_WORD, EX3_DIM=EX3_DIM, EX3_WORD=EX3_WORD, SFAC=LAI%SFAC, SCRATCH=SCRATCH, NO_BINARY=NO_BINARY, ENTIRE_LINE=ENTIRE_LINE, MSG=LAI%ERRMSG)
        ELSE
                               CALL ULOAD(LAI%ARRAY, LLOC, LINE, IOUT, IN, IU, NOID=NOID, EX1_DIM=EX1_DIM, EX1_WORD=EX1_WORD, EX2_DIM=EX2_DIM, EX2_WORD=EX2_WORD, EX3_DIM=EX3_DIM, EX3_WORD=EX3_WORD, SFAC=LAI%SFAC, SCRATCH=SCRATCH, NO_BINARY=NO_BINARY, MSG=LAI%ERRMSG) !CANNOT DO ARRAY OF ENTIRE LINE
        END IF
        LAI%TRUNCATED = LLOC < Z
    ELSE
        IF (LAI%LISTLOAD ) THEN
                               CALL LAI%TFR%INIT(        LLOC, LINE, IOUT, IN, NOID=NOID, EX1_DIM=EX1_DIM, EX1_WORD=EX1_WORD, EX2_DIM=EX2_DIM, EX2_WORD=EX2_WORD, EX3_DIM=EX3_DIM, EX3_WORD=EX3_WORD, NO_BINARY=NO_BINARY, ENTIRE_LINE=ENTIRE_LINE)
        ELSE
                               CALL LAI%TFR%INIT(        LLOC, LINE, IOUT, IN, NOID=NOID, EX1_DIM=EX1_DIM, EX1_WORD=EX1_WORD, EX2_DIM=EX2_DIM, EX2_WORD=EX2_WORD, EX3_DIM=EX3_DIM, EX3_WORD=EX3_WORD, NO_BINARY=NO_BINARY)
        END IF
        !
        CALL LOAD_NEXT_INPUT_STR(LAI)
    END IF
    !
    IF (LAI%LISTLOAD .OR. LAI%LISTARRAY) THEN
        LINE = 'PROPERTY IS SET TO BE READ IN AS A  LIST OF PROPERTIES THAT IS READ '
    ELSE
        LINE = 'PROPERTY IS SET TO BE READ IN AS AN ARRAY (NROW,NCOL)  THAT IS READ '
    END IF
    !
    IF (LAI%TRANSIENT) THEN
        LINE = TRIM(LINE)//' IN EVERY STRESS PERIOD'
    ELSE
        LINE = TRIM(LINE)//' ONCE FOR THE SIMULATION'
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_NEXT_INPUT_STR(LAI)
    CLASS(LIST_ARRAY_INPUT_STR), INTENT(INOUT):: LAI
    !
    IF(LAI%TRANSIENT) THEN
          IF(LAI%LISTLOAD) THEN
                               CALL LAI%TFR%NEXT(LAI%LIST, LAI%SFAC, MSG=LAI%ERRMSG)
          ELSE
                               CALL LAI%TFR%NEXT(LAI%ARRAY,LAI%SFAC, MSG=LAI%ERRMSG)
          END IF
          LAI%TRUNCATED = LAI%TFR%TRUNCATED
    END IF
  END SUBROUTINE
  !
  PURE FUNCTION GET_VALUE(LAI, ID, DIM1, DIM2, LDIM, ID_COL, IR, IC, IV, FROM_START)  RESULT(VAL)  !NOTE EXPECTS INDEXES ARE CORRECT -- NO CHECKING
    CLASS(LIST_ARRAY_INPUT), INTENT(IN):: LAI   
    INTEGER,                 INTENT(IN):: ID
    INTEGER,       OPTIONAL, INTENT(IN):: DIM1, DIM2
    INTEGER,       OPTIONAL, INTENT(IN):: LDIM
    INTEGER,       OPTIONAL, INTENT(IN):: ID_COL, IR, IC, IV
    LOGICAL,       OPTIONAL, INTENT(IN):: FROM_START
    REAL(REAL64):: VAL
    !
    IF(LAI%LISTLOAD) THEN
                               VAL = LAI%LIST(ID)
    ELSEIF(LAI%LISTARRAY) THEN
                               VAL = LAI%ARRAY(LDIM,ID)
    !!!ELSEIF(LAI%HAS_IXJ) THEN                            ! SCOTT change back to (IN)
    !!!                           CALL LAI%IXJ%GET_VALUE_IXJ(VAL, IV, ID, ID_COL, DIM1, IR, DIM2, IC, FROM_START=FROM_START)
    ELSE
                               VAL = LAI%ARRAY(DIM1, DIM2)
    END IF
  END FUNCTION
  !
  PURE FUNCTION GET_VALUE_INT(LAI, ID, DIM1, DIM2, LDIM, ID_COL, IR, IC, IV, FROM_START)  RESULT(VAL)  !NOTE EXPECTS INDEXES ARE CORRECT -- NO CHECKING
    CLASS(LIST_ARRAY_INPUT_INT), INTENT(IN):: LAI   
    INTEGER,                     INTENT(IN):: ID
    INTEGER,       OPTIONAL,     INTENT(IN):: DIM1, DIM2
    INTEGER,       OPTIONAL,     INTENT(IN):: LDIM
    INTEGER,       OPTIONAL,     INTENT(IN):: ID_COL, IR, IC, IV
    LOGICAL,       OPTIONAL,     INTENT(IN):: FROM_START
    INTEGER:: VAL
    !
    IF(LAI%LISTLOAD) THEN
                               VAL = LAI%LIST(ID)
    ELSEIF(LAI%LISTARRAY) THEN
                               VAL = LAI%ARRAY(LDIM,ID)
    !!!ELSEIF(LAI%HAS_IXJ) THEN
    !!!                           CALL LAI%IXJ%GET_J_IXJ(VAL, IV, ID, ID_COL, DIM1, IR, DIM2, IC, FROM_START=FROM_START)  ! SCOTT change back to (IN)
    ELSE
                               VAL = LAI%ARRAY(DIM1, DIM2)
    END IF
  END FUNCTION
  !
  FUNCTION GET_VALUE_STR(LAI, ID, DIM1, DIM2, LDIM)  RESULT(VAL)  !NOTE EXPECTS INDEXES ARE CORRECT -- NO CHECKING
    CLASS(LIST_ARRAY_INPUT_STR), INTENT(IN):: LAI
    INTEGER,                     INTENT(IN):: ID
    INTEGER,       OPTIONAL,     INTENT(IN):: DIM1, DIM2
    INTEGER,       OPTIONAL,     INTENT(IN):: LDIM
    CHARACTER(:), ALLOCATABLE:: VAL
    !
    ALLOCATE(CHARACTER(LAI%LINLEN):: VAL)
    !
    IF(LAI%LISTLOAD) THEN
                               VAL(:) = LAI%LIST(ID)
    ELSEIF(LAI%LISTARRAY) THEN
                               VAL(:) = LAI%ARRAY(LDIM,ID)
    ELSE
                               VAL(:) = LAI%ARRAY(DIM1, DIM2)
    END IF
  END FUNCTION
  !
  PURE FUNCTION COMBINE_LAI_TO_LINES(LAI)  RESULT(VAL)  !NOTE EXPECTS INDEXES ARE CORRECT -- NO CHECKING
    CLASS(LIST_ARRAY_INPUT_STR), INTENT(IN):: LAI
    CHARACTER(:), ALLOCATABLE:: VAL
    INTEGER:: I,J
    !
    VAL=NL
    IF(LAI%LISTLOAD) THEN
                         DO I=1, UBOUND(LAI%LIST, 1)
                               VAL = VAL//'"'//TRIM(LAI%LIST(I))//'"'//NL
                         END DO
    ELSE
                         DO I=1, UBOUND(LAI%ARRAY, 2)
                         DO J=1, UBOUND(LAI%ARRAY, 1)
                               VAL = VAL//'"'//LAI%ARRAY(J,I)//'"  '
                         END DO
                         VAL = VAL//NL
                         END DO
    END IF
  END FUNCTION
  !
  SUBROUTINE LIST_ARRAY_INPUT_BASE_DEALLOCATE(LAI)
    CLASS(LIST_ARRAY_INPUT_BASE), INTENT(INOUT)::LAI
    !
    LAI%INUSE        = FALSE
    LAI%TRANSIENT    = FALSE
    LAI%LISTLOAD     = FALSE
    LAI%LISTARRAY    = FALSE
    LAI%NO_BINARY    = FALSE
    LAI%IS_CONSTANT  = FALSE
    LAI%PULL_PARRENT = FALSE
    LAI%STORE_ID     = FALSE
    IF(ALLOCATED(LAI%TYP   )) DEALLOCATE(LAI%TYP)
    IF(ALLOCATED(LAI%ERRMSG)) DEALLOCATE(LAI%ERRMSG)
    IF(ALLOCATED(LAI%ID    )) DEALLOCATE(LAI%ID)
    CALL LAI%TFR%DESTROY()
    !
  END SUBROUTINE
  !
  SUBROUTINE LIST_ARRAY_INPUT_DEALLOCATE_ALL_TYPES(LAI)
    CLASS(LIST_ARRAY_INPUT_BASE), INTENT(INOUT)::LAI
    !
    CALL LIST_ARRAY_INPUT_BASE_DEALLOCATE(LAI)
    !
    SELECT TYPE(LAI)
    TYPE IS (LIST_ARRAY_INPUT)
                                   IF(ALLOCATED(LAI%LIST) ) DEALLOCATE(LAI%LIST)
                                   IF(ALLOCATED(LAI%ARRAY)) DEALLOCATE(LAI%ARRAY)
                                   IF(ALLOCATED(LAI%IXJ)  ) DEALLOCATE(LAI%IXJ)
                                   !
                                   CALL LAI%SFAC%DESTROY()
    TYPE IS (LIST_ARRAY_INPUT_INT)
                                   IF(ALLOCATED(LAI%LIST) ) DEALLOCATE(LAI%LIST)
                                   IF(ALLOCATED(LAI%ARRAY)) DEALLOCATE(LAI%ARRAY)
                                   !
    TYPE IS (LIST_ARRAY_INPUT_STR)
                                   IF(ALLOCATED(LAI%LIST) ) DEALLOCATE(LAI%LIST)
                                   IF(ALLOCATED(LAI%ARRAY)) DEALLOCATE(LAI%ARRAY)
                                   !
                                   LAI%LINLEN = Z
                                   CALL LAI%SFAC%INIT()
    END SELECT
    !
  END SUBROUTINE
  !
  SUBROUTINE FINAL_LIST_ARRAY_INPUT(LAI)
    TYPE(LIST_ARRAY_INPUT),INTENT(INOUT)::LAI
    !
    CALL LIST_ARRAY_INPUT_DEALLOCATE_ALL_TYPES(LAI)
    !
  END SUBROUTINE
  !
  SUBROUTINE FINAL_LIST_ARRAY_INPUT_INT(LAI)
    TYPE(LIST_ARRAY_INPUT_INT),INTENT(INOUT)::LAI
    !
    CALL LIST_ARRAY_INPUT_DEALLOCATE_ALL_TYPES(LAI)
    !
  END SUBROUTINE
  !
  SUBROUTINE FINAL_LIST_ARRAY_INPUT_STR(LAI)
    TYPE(LIST_ARRAY_INPUT_STR),INTENT(INOUT)::LAI
    !
    CALL LIST_ARRAY_INPUT_DEALLOCATE_ALL_TYPES(LAI)
    !
  END SUBROUTINE
  !
END MODULE
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
MODULE SUB_BLOCK_INPUT_INTERFACE!, ONLY: SUB_BLOCK_INPUT
  !CHECKS FOR FLAGS LIST/ARRAY AND THEN STATIC/TRANSIENT AND THEN LOADS FIRST LIST/ARRAY
  USE CONSTANTS
  USE UTIL_INTERFACE,                    ONLY: STOP_ERROR, WARNING_MESSAGE, GET_WORD
  USE TRANSIENT_FILE_READER_INSTRUCTION, ONLY: TRANSIENT_FILE_READER
  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
  USE GENERIC_INPUT_FILE_INSTRUCTION,    ONLY: GENERIC_INPUT_FILE
  IMPLICIT NONE
  !
  PRIVATE
  PUBLIC:: SUB_BLOCK_INPUT
  !
  TYPE SUB_BLOCK_INPUT
        LOGICAL:: INUSE     = FALSE     ! TRUE WHEN OBJECT HAS BE INITIALIZED
        LOGICAL:: TRANSIENT = FALSE     ! TRUE WHEN TRANSIENT KEYWORD FOUND
        LOGICAL:: UPCASE    = FALSE
        LOGICAL:: PULL_PARRENT = TRUE
        LOGICAL:: REPEAT       = FALSE
        LOGICAL:: FOUND_BEGIN  = FALSE
        LOGICAL:: FOUND_END    = FALSE
        LOGICAL:: BEGIN_END_OPTIONAL = FALSE
        LOGICAL:: SKIP               = TRUE
        LOGICAL:: HAS_SKIP_END_KEY   = FALSE
        CHARACTER(:), ALLOCATABLE:: TYP
        CHARACTER(:),DIMENSION(:), ALLOCATABLE:: SKIP_END_KEY
        TYPE(GENERIC_BLOCK_READER):: BL  !HOLDS BLOCK DATA
        !
        TYPE(TRANSIENT_FILE_READER):: TFR
        !
        CONTAINS
        !
        PROCEDURE, PASS(INP):: INIT    => INITIALIZE_SUB_BLOCK_INPUT!(INP, TYP, LLOC, LINE, IOUT, IN, SCRATCH, NO_TRANSIENT, END_KEY, ALLOW_INTERNAL, BEGIN_END_OPTIONAL, SKIP_END_KEY)
        PROCEDURE, PASS(INP):: NEXT    => LOAD_NEXT_INPUT!()
        PROCEDURE, PASS(INP):: DESTROY => DEALLOCATE_SUB_BLOCK_INPUT!()
        !
        FINAL:: DEALLOCATE_SUB_BLOCK_INPUT_FINAL
        !
  END TYPE
  !
  CONTAINS
  !
  SUBROUTINE DEALLOCATE_SUB_BLOCK_INPUT(INP)
    CLASS(SUB_BLOCK_INPUT), INTENT(INOUT):: INP
    !
    INP%INUSE     = FALSE     ! TRUE WHEN OBJECT HAS BE INITIALIZED
    INP%TRANSIENT = FALSE     ! TRUE WHEN TRANSIENT KEYWORD FOUND
    INP%UPCASE    = FALSE
    INP%PULL_PARRENT = TRUE
    INP%REPEAT       = FALSE
    INP%FOUND_BEGIN  = FALSE
    INP%FOUND_END    = FALSE
    INP%BEGIN_END_OPTIONAL = FALSE
    INP%SKIP               = TRUE
    INP%HAS_SKIP_END_KEY   = FALSE
    !
    IF(ALLOCATED(INP%TYP)) DEALLOCATE(INP%TYP)
    IF(ALLOCATED(INP%SKIP_END_KEY)) DEALLOCATE(INP%SKIP_END_KEY)
    !
    CALL INP% BL%DESTROY()
    CALL INP%TFR%DESTROY()
    !
  END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_SUB_BLOCK_INPUT_FINAL(INP)
    TYPE(SUB_BLOCK_INPUT), INTENT(INOUT):: INP
    !
    CALL DEALLOCATE_SUB_BLOCK_INPUT(INP)
    !
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_SUB_BLOCK_INPUT(INP, TYP, LLOC, LINE, IOUT, IN, SCRATCH, NO_TRANSIENT, END_KEY, ALLOW_INTERNAL, BEGIN_END_OPTIONAL, SKIP_END_KEY)
    ! TYP   NAME OF BLOCKS TO BE LOADED
    ! IN    IS FILE TO LOAD INFORMATION FROM OR TO CLAIM OCCURED AT
    !
    ! OPTIONAL ARGUMENTS:
    !                    EX1_DIM, EX1_WORD ARE DIMENSION AND KEYWORD USED FOR SFAC ROUTING  (eg NFARM, 'BYWBS')
    !                    SCARTCH IS THE UNIT NUMBER TO LOAD INFORMATION FROM, WHEN IN IS ONLY MEANT TO BE USED FOR ERROR REPORTING
    CLASS(SUB_BLOCK_INPUT),INTENT(INOUT):: INP
    CHARACTER(*),          INTENT(IN   ):: TYP
    CHARACTER(*),          INTENT(IN   ):: LINE
    INTEGER,               INTENT(INOUT):: LLOC
    INTEGER,               INTENT(IN   ):: IOUT, IN
    INTEGER,     OPTIONAL, INTENT(IN   ):: SCRATCH
    LOGICAL,     OPTIONAL, INTENT(IN   ):: NO_TRANSIENT
    CHARACTER(*),OPTIONAL, INTENT(IN   ):: END_KEY
    LOGICAL,     OPTIONAL, INTENT(IN   ):: ALLOW_INTERNAL, BEGIN_END_OPTIONAL
    CHARACTER(*), DIMENSION(:),OPTIONAL,INTENT(IN):: SKIP_END_KEY
    !
    !TYPE(GENERIC_INPUT_FILE):: FL
    INTEGER:: IU,N
    LOGICAL::ONLY_STATIC, NO_INTERNAL
    CHARACTER(:), ALLOCATABLE:: KEY
    CHARACTER(9):: LAI_KEY
    !
    IF(INP%INUSE) THEN
        CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY BLOCK INPUT (LAI) PROPERTY "'//TYP//'" IS BEING LOADED A SECOND TIME!!!'//BLN//'MAYBE YOU ACCIDENTALLY SPECIFIED THE SAME KEYWORD TWICE???'//BLN//'THE PREVIOUS LINE THAT THE KEYWORD WAS FOUND WILL BE IGNORED'//NL//'AND THE LINE PRESENTED IN THIS WARNING WILL BE USED INSTEAD.')
        CALL DEALLOCATE_SUB_BLOCK_INPUT(INP)
    END IF
    !
    ONLY_STATIC = FALSE
    IF(PRESENT(NO_TRANSIENT)) ONLY_STATIC = NO_TRANSIENT
    INP%INUSE = TRUE
    ALLOCATE(INP%TYP, SOURCE = TYP)
    !
    INP%TRANSIENT = FALSE
    !
    IF(PRESENT(END_KEY)) THEN
        ALLOCATE(KEY, SOURCE = END_KEY)
    ELSE
        ALLOCATE(KEY, SOURCE = 'END')
    END IF
    !
    IF(PRESENT(ALLOW_INTERNAL)) THEN
        NO_INTERNAL = .NOT. ALLOW_INTERNAL
    ELSE
        NO_INTERNAL = TRUE
    END IF
    !
    IF(PRESENT(BEGIN_END_OPTIONAL)) THEN
        INP%BEGIN_END_OPTIONAL = BEGIN_END_OPTIONAL
    ELSE
        INP%BEGIN_END_OPTIONAL = FALSE
    END IF
    !
    CALL GET_WORD(LAI_KEY,LINE,LLOC,N)
    !
    SELECT CASE (LAI_KEY)
                                   CASE('TRANSIENT'); INP%TRANSIENT = TRUE
                                   CASE('STATIC');    INP%TRANSIENT = FALSE
                                   CASE('PARRENT')
                                                      INP%PULL_PARRENT = TRUE
                                                      INP%TRANSIENT = FALSE
                                                      RETURN
                                   CASE('CONSTANT')
                                                      CALL STOP_ERROR(LINE,IN,IOUT,'FMP BLOCK ERROR FOR PROPERTY "'//TYP//'". FOUND KEYWORD "CONSTANT", WHICH IS NOT ALLOWED FOR SUB-BLOCK LOADING')

                                   CASE('LIST','ARRAY','COMPRESS', 'COMPRESSE','DIM','DIMENSION','AUTO','AUTOCOUNT','AUTO-COUN')
                                                      CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) BLOCK LOADER PROPERTY "'//TYP//'" DOES NOT REQUIRE/USE "'//TRIM(LAI_KEY)//'" KEYWORD.'//BLN//'IT WILL BE IGNORED.'//BLN//'PROGRAM WILL CONTINUE AS IF IT WAS NOT SPECIFIED.', INLINE=TRUE)
                                   CASE DEFAULT
                                                      IF(.NOT. ONLY_STATIC) CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) BLOCK LOADER PROPERTY "'//TYP//'" DID NOT IDENTIFY THE KEYWORD "STATIC" OR "TRANSIENT".'//BLN//'PROGRAM WILL CONTINUE AS IF THE KEYWORD "STATIC" WAS SPECIFEID.')
                                                      LLOC = N
    END SELECT
    !
    CALL GET_WORD(LAI_KEY,LINE,LLOC,N)
    !
    SELECT CASE (LAI_KEY)
                                   CASE('BLOCK','SUBBLOCK','SUB_BLOCK')
                                                 CONTINUE
                                   CASE('CONSTANT')
                                                   CALL STOP_ERROR(LINE,IN,IOUT,'FMP BLOCK ERROR FOR PROPERTY "'//TYP//'". FOUND KEYWORD "CONSTANT", WHICH IS NOT ALLOWED FOR SUB-BLOCK LOADING')
                                   CASE DEFAULT
                                                 LLOC = N
    END SELECT
    !
    IF(ONLY_STATIC .AND. INP%TRANSIENT .AND. IOUT.NE.Z) WRITE(IOUT, '(A,/A/)') 'WARNING: GENERIC BLOCK LOADER FOR PROPERTY "'//TYP//'" CAN ONLY BE LOADED ONCE, BUT "TRANSIENT" KEYWORD WAS FOUND. PROGRAM WILL CONTINUE AS IF "STATIC" WAS SPECIFIED. THE FOLLOWING LINE CONTAINS THE PROBLEM:',TRIM(LINE)
    IF(ONLY_STATIC) INP%TRANSIENT = FALSE
    !
    !
    IF (.NOT. INP%TRANSIENT ) THEN                 !NOTE INP%REPEAT = FALSE BY DEFAULT
        !
        IU = Z
        INP%TFR%OLD_IU = Z
        !CALL INP%TFR%ALLOC_LN()
        ALLOCATE(INP%TFR%LN, SOURCE=TRIM(LINE))
        !
        CALL INP%TFR%LOAD_BLOCK(INP%BL, LLOC, IU, INP%TFR%OLD_IU, INP%TFR%LN, IOUT, IN, INP%TFR%SKIP, INP%TFR%REPEAT, INP%FOUND_BEGIN, INP%FOUND_END, INP%BEGIN_END_OPTIONAL, KEY, NOID=TRUE, NO_BINARY=TRUE, SKIP_END_KEY=SKIP_END_KEY) !, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM
        !
        DEALLOCATE(INP%TFR%LN)
        !
        INP%SKIP = INP%TFR%SKIP
        !
        IF(INP%SKIP) THEN
                    INP%REPEAT      = FALSE
                    INP%FOUND_BEGIN = TRUE
                    INP%FOUND_END   = TRUE
        ELSE
                    CALL SUB_BLOCK_ERROR_CHECK(INP)
        END IF

    ELSE
        IF(PRESENT(SKIP_END_KEY)) THEN
                                  ALLOCATE(INP%SKIP_END_KEY, SOURCE=SKIP_END_KEY)
                                  INP%HAS_SKIP_END_KEY = TRUE
        ELSE
            INP%HAS_SKIP_END_KEY = FALSE
        END IF
        !
        CALL INP%TFR%INIT( LLOC, LINE, IOUT, IN, NOID=TRUE, NO_BINARY=TRUE, BLOCK_END_KEY=KEY, BEGIN_END_OPTIONAL=BEGIN_END_OPTIONAL)
        !
        CALL LOAD_NEXT_INPUT(INP)
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE SUB_BLOCK_ERROR_CHECK(INP)
    CLASS(SUB_BLOCK_INPUT),INTENT(INOUT):: INP
    !
    IF((.NOT. INP%FOUND_BEGIN .OR. .NOT. INP%FOUND_END) .AND. .NOT. INP%BEGIN_END_OPTIONAL)  THEN
            IF(.NOT. INP%FOUND_BEGIN) THEN
                CALL STOP_ERROR( INFILE=INP%BL%IU, OUTPUT=INP%BL%IOUT, MSG= 'SUB_BLOCK_LOAD ERROR: FAILD TO IDENTIFY THE KEYWORD "BEGIN" TO INTIATE A BLOCK INPUT LOAD. THE BLOCK VARIABLE THAT WAS BEING LOADED IS "'//INP%TYP//'" AND WAS EXPECTING THE FOLLOWING KEYWORD TO CLOSE/END THE BLOCK:"'//TRIM(INP%BL%END_KEY)//'". PLEASE CHECK INPUT TO ENSURE THAT THE BLOCK WAS PROPERLY OPENED AND CLOSED.')
            ELSE
                CALL STOP_ERROR( INFILE=INP%BL%IU, OUTPUT=INP%BL%IOUT, MSG= 'SUB_BLOCK_LOAD ERROR: REACHED THE END OF THE FILE BEFORE LOCATING THE KEYWORD TO CLOSE THE BLOCK. THE BLOCK THAT WAS BEING LOADED IS "'//INP%BL%NAME//'" FOR VARIABLE "'//INP%TYP//'" AND WAS EXPECTING THE FOLLOWING KEYWORD TO CLOSE/END THE BLOCK:"'//TRIM(INP%BL%END_KEY)//'". PLEASE CHECK INPUT TO ENSURE THAT THE BLOCK WAS PROPERLY CLOSED WITH THAT KEYWORD.')
            END IF
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_NEXT_INPUT(INP)
    CLASS(SUB_BLOCK_INPUT), INTENT(INOUT):: INP
    !
    IF(INP%INUSE) THEN
          IF(INP%TRANSIENT) THEN
              !
              IF(INP%HAS_SKIP_END_KEY) THEN
                                       CALL INP%TFR%NEXT(INP%BL, SKIP_END_KEY=INP%SKIP_END_KEY)
              ELSE
                                       CALL INP%TFR%NEXT(INP%BL)
              END IF

              !
              INP%SKIP = INP%TFR%SKIP
              !
              IF(INP%BL%LN == 'REPEAT') THEN
                    INP%REPEAT      = TRUE
                    INP%FOUND_BEGIN = TRUE
                    INP%FOUND_END   = TRUE
              ELSEIF(INP%SKIP) THEN
                    INP%REPEAT      = FALSE
                    INP%FOUND_BEGIN = TRUE
                    INP%FOUND_END   = TRUE
              ELSE
                    INP%REPEAT      = FALSE
                    !
                    INP%FOUND_BEGIN = INP%TFR%ENTIRE_LINE  !NOTE THIS VARIABLE IS BEING USED TO DETERMINE IF THE BEING VARIABLE WAS FOUND
                    INP%FOUND_END   = INP%TFR%TRUNCATED    !NOTE THIS VARIABLE IS BEING USED TO DETERMINE IF THE END   VARIABLE WAS FOUND
                    !
                    CALL SUB_BLOCK_ERROR_CHECK(INP)
                    !
              END IF
          ELSE
                    INP%FOUND_BEGIN = TRUE
                    INP%FOUND_END   = TRUE
          END IF
    END IF
    !
  END SUBROUTINE
    !
END MODULE
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!MODULE COMPRESSED_ARRAY_STORAGE_INTERFACE !--INCOMPLETE DO NOT USE UNLESS THOROUGHLY CHECKED!
!  !TYPE  COMPRESS_ARRAY_ENTRY
!  !    INTEGER:: ROW, COL
!  !    DOUBLE PRECISION:: VAL
!  !END TYPE
!  !
!  !TYPE  COMPRESS_ARRAY_ENTRY_NOVAL
!  !    INTEGER:: ROW, COL
!  !END TYPE
!  !TYPE(COMPRESS_ARRAY_ENTRY), DIMENSION(:), ALLOCATABLE:: DAT
!  !
!  TYPE COMPRESSED_ARRAY_STORAGE_BASE
!      INTEGER:: DIM,NLOC
!      LOGICAL:: IS_CONSTANT = FALSE
!      LOGICAL:: HAS_VAL = FALSE
!      LOGICAL:: HAS_ID  = FALSE
!      LOGICAL:: HAS_IDX = FALSE
!      LOGICAL:: HAS_RC  = FALSE
!      INTEGER,             DIMENSION(:), ALLOCATABLE:: ID  !ID(DIM)
!      INTEGER,             DIMENSION(:), ALLOCATABLE:: IDX !IDX(NLOC)   NLOC=# UNIQUE IDs
!      INTEGER,             DIMENSION(:), ALLOCATABLE:: ROW, COL !ROW(DIM), COL(DIM)
!      TYPE(INTEGER_VECTOR),DIMENSION(:), ALLOCATABLE:: LOC
!      CONTAINS
!      PROCEDURE, PASS(CAS):: INIT            => INITITIALIZE_COMPRESSED_ARRAY_STORAGE !()
!      PROCEDURE, PASS(CAS):: ALLOC           => ALLOCATE_COMPRESSED_ARRAY_STORAGE     !(N,ID,RC,VAL) ==> LOGICAL:: ID,RC,VAL TO INDICATE ALLOCATION
!      PROCEDURE, PASS(CAS):: SET_VAL         => SET_VAL_COMPRESSED_ARRAY_STORAGE      !(CAS,CAS_OUT, CIN, COUT) !MUST PASS BOTH N AND NULL, OTHERWISE DO NOT PASS EITHER
!
!      PROCEDURE, PASS(CAS):: MOVE            => MOVE_COMPRESSED_ARRAY_STORAGE         !(CAS_OUT,[N,NULL])
!      PROCEDURE, PASS(CAS):: BUILD_IDX       => SETUP_IDX_LOC_COMPRESSED_ARRAY_STORAGE!()
!      PROCEDURE, PASS(CAS):: FIND_IDX        => FIND_IDX_ID_COMPRESSED_ARRAY_STORAGE  !(ID)
!      PROCEDURE, PASS(CAS):: DUPLICATE_CHECK => DUBLICATE_ROW_COL_CHECK_COMPRESSED_ARRAY_STORAGE!(IOUT, OPT)  OPT=1 IS SUM, OPT=0 IS STOP PROGRAM FOR DUBLICATE
!      PROCEDURE, PASS(CAS):: DESTROY         => INITITIALIZE_COMPRESSED_ARRAY_STORAGE !()
!      FINAL:: FINAL_COMPRESSED_ARRAY_STORAGE_BASE
!  END TYPE
!  !
!  TYPE, EXTENDS(COMPRESSED_ARRAY_STORAGE_BASE):: COMPRESSED_ARRAY_STORAGE
!      DOUBLE PRECISION,    DIMENSION(:), ALLOCATABLE:: VAL
!      CONTAINS
!      FINAL:: FINAL_COMPRESSED_ARRAY_STORAGE
!  END TYPE
!  !
!  TYPE, EXTENDS(COMPRESSED_ARRAY_STORAGE_BASE):: COMPRESSED_ARRAY_STORAGE_INT
!      INTEGER,    DIMENSION(:), ALLOCATABLE:: VAL
!      CONTAINS
!      FINAL:: FINAL_COMPRESSED_ARRAY_STORAGE_INT
!  END TYPE
!  !
!  CONTAINS
!  !
!  RECURSIVE SUBROUTINE ULOAD_COMPRESSED_ARRAY(VAR, LLOC, LN, IOUT, IN, IU, ROWDIM, NOID, BINARY, NOSTOP, SFAC, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM, SCRATCH, NO_INTERNAL, NO_BINARY, NO_REPEAT, OLD_IU, REQ_TERM, NOVAL)
!    CLASS(COMPRESSED_ARRAY_STORAGE_BASE), INTENT(INOUT):: VAR
!    INTEGER,                         INTENT(INOUT):: LLOC
!    CHARACTER(*),                    INTENT(INOUT):: LN
!    INTEGER,                         INTENT(IN   ):: IN, IOUT
!    INTEGER,                         INTENT(INOUT):: IU
!    INTEGER,     OPTIONAL,           INTENT(IN   ):: ROWDIM
!    !
!    LOGICAL,     OPTIONAL,           INTENT(IN   ):: NOID, BINARY, NOSTOP
!    TYPE(SFAC_DATA),OPTIONAL,        INTENT(  OUT):: SFAC
!    !
!    CHARACTER(*), OPTIONAL,          INTENT(IN   ):: EX1_WORD, EX2_WORD, EX3_WORD
!    INTEGER,      OPTIONAL,          INTENT(IN   ):: EX1_DIM,  EX2_DIM,  EX3_DIM
!    INTEGER,      OPTIONAL,          INTENT(IN   ):: SCRATCH
!    LOGICAL,      OPTIONAL,          INTENT(IN   ):: NO_INTERNAL, NO_BINARY, REQ_TERM, NOVAL, NO_REPEAT
!    INTEGER,      OPTIONAL,          INTENT(INOUT):: OLD_IU
!    !
!    TYPE(SFAC_DATA):: SF!1, SF2
!    !
!    INTEGER:: IERR, ISTART, ISTOP, I, N, INFILE, ERROR_IU, DIM, IDUM
!    DOUBLE PRECISION:: DDUM
!    TYPE(GENERIC_INPUT_FILE), ALLOCATABLE:: FL
!    LOGICAL:: KEEP_IU, READ_ID, BIN, ALLOW_ERROR, CLEAR_IU, NO_INTERN, EOF, REQ_TERMINTOR, HAS_VAL
!    DOUBLE PRECISION:: SFAC_FILE, CONST
!    CHARACTER(9 ):: EXT
!    CHARACTER(12):: FORM_CHK
!    CHARACTER(6):: NOERR
!    !
!    IERR = Z
!    SFAC_FILE = UNO
!    ERROR_IU = IN
!    NOERR="NOSTOP"
!    VAR%HAS_RC = TRUE
!    !
!    IF(PRESENT(SCRATCH)) THEN
!        INFILE = SCRATCH
!    ELSE
!        INFILE = IN
!    END IF
!    !
!    IF(PRESENT(NOID)) THEN
!        READ_ID = .NOT. NOID
!    ELSE
!        READ_ID = TRUE
!    END IF
!    VAR%HAS_ID      = READ_ID
!    VAR%HAS_IDX     = READ_ID
!    !
!    IF(PRESENT(NOVAL)) THEN
!        HAS_VAL = .NOT. NOVAL
!    ELSE
!        HAS_VAL = TRUE
!    END IF
!    VAR%HAS_VAL     = HAS_VAL
!    !
!    IF(PRESENT(BINARY)) THEN
!        BIN = BINARY
!    ELSE
!        BIN = FALSE
!    END IF
!    !
!    IF(PRESENT(NOSTOP)) THEN
!        ALLOW_ERROR = .NOT. NOSTOP
!    ELSE
!        ALLOW_ERROR = TRUE
!    END IF
!    !
!    IF(PRESENT(NO_INTERNAL)) THEN
!        NO_INTERN = NO_INTERNAL
!    ELSE
!        NO_INTERN = FALSE
!    END IF
!    !
!    IF(PRESENT(REQ_TERM)) THEN
!        REQ_TERMINTOR = REQ_TERM
!    ELSE
!        REQ_TERMINTOR = FALSE
!    END IF
!    !
!    IF(PRESENT(ROWDIM)) THEN
!        DIM = ROWDIM
!    ELSE
!        DIM = Z
!    END IF
!    !
!    CLEAR_IU = FALSE
!    IF(IU.NE.Z) THEN
!                    INQUIRE(IU,FORM=FORM_CHK, OPENED=KEEP_IU)
!                    IF(.NOT. KEEP_IU) CALL STOP_ERROR( LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ULOAD ERROR: RECIEVED UNIT NUMBER "'//NUM2STR(IU)//'" WHICH IS NOT ASSOCIATED WITH A FILE. THIS COULD BE THE RESULT OF USING "EXTERNAL" OR "DATAUNIT" WITH A UNIT THAT IS NOT OPENED BY THE NAME FILE.')
!                    BIN = FORM_CHK .NE. 'FORMATTED'
!                    !
!                    ERROR_IU = IU
!                    KEEP_IU  = TRUE
!                    LLOC     = ONE
!                    IF(.NOT. ALLOW_ERROR) CLEAR_IU = TRUE
!                    IF(.NOT. BIN) CALL READ_TO_DATA(LN,IU,IOUT)  !UNIT IS BEING PASSED IN SO READ IN LINE FROM IT
!    ELSE
!                    KEEP_IU = FALSE
!    END IF
!    !
!    CALL SF%INIT()
!    IF(PRESENT(SFAC)) CALL SFAC%INIT()
!    !
!    IF(.NOT. BIN) THEN
!                      DO !CHECK FOR KEYWORD OF SFAC BEFORE LIST
!                           CALL GET_WORD(EXT,LN,LLOC,N,TRUE)
!                           SELECT CASE(EXT)
!                           CASE ('DIM','DIMENSION')
!                                             CALL GET_INTEGER(LN,LLOC,ISTART,ISTOP,IOUT,IU,DIM,MSG='ULOAD FOUND KEYWORD "'//TRIM(EXT)//'", WHICH MUST BE FOLLOWED BY AN INTEGER THAT REPRESENTS THE NUMBER OF ROWS TO LOAD')
!                           CASE ('AUTO','AUTOCOUNT','AUTO-COUN')!T
!                                             DIM=Z
!                           CASE ('SFAC')
!                               IF(IU==Z) THEN
!                                             CALL SFAC_READ_AND_RETURN(SF, LN(N:), IN, IOUT, EX1_WORD=EX1_WORD, EX1_DIM=EX1_DIM, EX2_WORD=EX2_WORD, EX2_DIM=EX2_DIM, EX3_WORD=EX3_WORD, EX3_DIM=EX3_DIM, SCRATCH=SCRATCH)
!                                             CALL READ_TO_DATA(LN,INFILE,IOUT)
!                               ELSE
!                                             CALL SFAC_READ_AND_RETURN(SF, LN(N:), IU, IOUT, EX1_WORD=EX1_WORD, EX1_DIM=EX1_DIM, EX2_WORD=EX2_WORD, EX2_DIM=EX2_DIM, EX3_WORD=EX3_WORD, EX3_DIM=EX3_DIM)
!                                             CALL READ_TO_DATA(LN,IU,IOUT)
!                               END IF
!                               LLOC = ONE
!                           CASE (BLNK,COM)   !READ NEXT LINE IF BLANK
!                               IF(IU==Z) THEN
!                                             CALL READ_TO_DATA(LN,INFILE,IOUT)
!                                             IF(LN==BLNK) CALL STOP_ERROR(INFILE=IN,OUTPUT=IOUT,MSG = 'ULOAD FAILED TO LOAD INPUT LINE.'//NL//'THIS MOST LIKELY OCCURED BECAUSE THE END OF FILE WAS REACHED WHILE LOADING INPUT.'//NL//'POSSIBLE CAUSES ARE NOT ENOUGH STRESS PERIOD INPUT, AN EMPTY FILE,'//NL//'THE INPUT LINE IS EMPTY WHEN NUMBERS WERE EXPECTED,'//NL//'OR YOU SPECIFIED TRANSIENT WHEN YOU MEANT STATIC FOR A LIST-ARRAY INPUT.')
!                               ELSE
!                                             CALL READ_TO_DATA(LN,IU,IOUT)
!                                             IF(LN==BLNK) CALL STOP_ERROR(INFILE=IU,OUTPUT=IOUT,MSG = 'ULOAD FAILED TO LOAD INPUT LINE.'//NL//'THIS MOST LIKELY OCCURED BECAUSE THE END OF FILE WAS REACHED WHILE LOADING INPUT.'//NL//'POSSIBLE CAUSES ARE NOT ENOUGH STRESS PERIOD INPUT, AN EMPTY FILE,'//NL//'THE INPUT LINE IS EMPTY WHEN NUMBERS WERE EXPECTED,'//NL//'OR YOU SPECIFIED TRANSIENT WHEN YOU MEANT STATIC FOR A LIST-ARRAY INPUT.')
!                               END IF
!                               LLOC = ONE
!                           CASE ('STATIC','TRANSIENT', 'COMPRESS', 'COMPRESSE') !'COMPRESSE' ==> 'COMPRESSED' and 'COMPRESSED_ARRAY'   --IN CASE LIST ARRAY INPUT CALLS DIRECTLY ULOAD, BY PASS KEYWORDS
!                               CYCLE
!                           CASE ('LIST')    !IN CASE LIST ARRAY INPUT CALLS DIRECTLY ULOAD, ERROR ON LIST KEYWORD
!                               IF(IU==Z) IU = IN
!                               CALL STOP_ERROR( LINE=LN, INFILE=IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: EXPECTED TO LOAD A COMPRESSED ARRAY, BUT FOUND KEYWORD LIST. PLEASE REMOVE KEYWORD OR SWITCH IT TO "COMPRESSED_ARRAY".')
!                           CASE ('ARRAY')    !IN CASE LIST ARRAY INPUT CALLS DIRECTLY ULOAD, ERROR ON LIST KEYWORD
!                               IF(IU==Z) IU = IN
!                               CALL STOP_ERROR( LINE=LN, INFILE=IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: EXPECTED TO LOAD A COMPRESSED ARRAY, BUT FOUND KEYWORD ARRAY. PLEASE REMOVE KEYWORD OR SWITCH IT TO "COMPRESSED_ARRAY".')
!                           CASE DEFAULT
!                               LLOC = N
!                               EXIT
!                           END SELECT
!                      END DO
!    ELSE
!        EXT='BINARY'
!    END IF
!    !
!    SELECT CASE (EXT)
!    CASE( 'SKIP' )     !-----------------------------------------------------------------------------------------------------------------------
!                       CALL VAR%ALLOC(ONE, READ_ID,   TRUE, HAS_VAL)
!                       IF(READ_ID) VAR%ID = NEG
!                       VAR%ROW=Z
!                       VAR%COL=Z
!                       IF(HAS_VAL) THEN
!                          SELECT TYPE(VAR)
!                          CLASS IS (COMPRESSED_ARRAY_STORAGE    ); VAR%VAL=DZ
!                          CLASS IS (COMPRESSED_ARRAY_STORAGE_INT); VAR%VAL= Z
!                          END SELECT
!                       END IF
!                       !
!                       LN = EXT//BLNK//LN
!                       RETURN
!    CASE( 'CONSTANT' ) !-----------------------------------------------------------------------------------------------------------------------
!                       CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
!                       CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
!                       READ(LN(ISTART:ISTOP), *, IOSTAT=IERR) CONST
!                       !
!                       IF(IERR.NE.Z .AND. ALLOW_ERROR)   CALL FILE_IO_ERROR( IERR, UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'FOUND KEYWORD CONSTANT, BUT FAILED TO READ THE VALUE LOCATED AFTER THE KEYWORD "CONSTANT".', MSG2=MSG)
!                       IF(IERR.NE.Z .AND. CLEAR_IU)  IU = Z
!                       !
!                       CALL VAR%ALLOC(ONE, READ_ID,   TRUE, HAS_VAL)
!                       IF(READ_ID) VAR%ID = Z
!                       VAR%ROW=Z
!                       VAR%COL=Z
!                       IF(HAS_VAL) THEN
!                          SELECT TYPE(VAR)
!                          CLASS IS (COMPRESSED_ARRAY_STORAGE    ); VAR%VAL=CONST
!                          CLASS IS (COMPRESSED_ARRAY_STORAGE_INT); VAR%VAL=NINT(CONST)
!                          END SELECT
!                       END IF
!                       VAR%IS_CONSTANT = TRUE
!                       !
!                       CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,ISTART,ISTOP,SFAC_FILE,DIM=DIM) !ISTART, ISTOP ARE PLACE HOLDERS FOR BUF AND ISPLIT
!                       !
!                       IF(SFAC_FILE.NE.UNO) CALL SF%SET_ALL(SFAC_FILE)
!                       !
!                       IF(PRESENT(SFAC)) THEN
!                                             SFAC = SF
!                       ELSE
!                           SELECT TYPE(VAR)
!                           CLASS IS (COMPRESSED_ARRAY_STORAGE    ); CALL SF%APPLY(VAR%VAL)
!                           END SELECT
!                       END IF
!                       !
!                       LLOC=ONE
!                       LN = EXT//BLNK//LN
!                       RETURN
!    CASE( 'REPEAT' )   !-----------------------------------------------------------------------------------------------------------------------
!                       !
!                       IF(PRESENT(NO_REPEAT)) THEN
!                               IF(NO_REPEAT) CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD FOUND KEYWORD "REPEAT" BUT THIS PARTICULAR FEATURE DOES NOT SUPPORT IT.'//NL//'(NOTE APPLYING A SCALE FACTOR WITH SFAC, DOES NOT SUPPORT THIS.)'//NL//'PLEAUSE CHANGE INPUT TO USE OPEN/CLOSE TO RELOAD THE FILE INSTEAD OF REPEATING IT.')
!                       END IF
!                       !
!                       CALL PARSE_WORD(LN,LLOC,ISTART,ISTOP)
!                       CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,ISTART,ISTOP,SFAC_FILE,DIM=DIM) !ISTART, ISTOP ARE PLACE HOLDERS FOR BUF AND ISPLIT
!                       !
!                       IF(SFAC_FILE.NE.UNO) CALL SF%SET_ALL(SFAC_FILE)
!                       !
!                       IF(PRESENT(SFAC)) THEN
!                                             SFAC = SF
!                       ELSE
!                           SELECT TYPE(VAR)
!                           CLASS IS (COMPRESSED_ARRAY_STORAGE    ); CALL SF%APPLY(VAR%VAL)
!                           END SELECT
!                       END IF
!                       !
!                       LN = EXT//BLNK//LN
!                       RETURN
!    CASE( 'LOAD_NEXT' )!-----------------------------------------------------------------------------------------------------------------------
!                       !
!                       IF(IU==Z) THEN
!                            IF(PRESENT(OLD_IU))  IU = OLD_IU
!                            IF(ALLOW_ERROR .AND. (IU==Z .OR. .NOT. PRESENT(OLD_IU))) THEN
!                                CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD FOUND KEYWORD '//EXT//' BUT THERE WAS NOT A PREVIOUSLY OPENED FILE TO USE. PLEASE MAKE SURE THAT THIS ULOAD WAS PRECEDED BY AN EXTERNAL UNIT, DATAUNIT UNIT, OR DATAFILE FILE SO THT THE FILE CAN BE CONTINUED TO LOAD NEXT INPUT OR CHANGE KEYWORD TO ONE THAT OPENS A FILE OR POINTS TO AN EXISTING OPENED FILE. (e.g. THIS KEYWORD SHOULD ONLY APPEAR IN A TFR AFTER AN EXTERNAL, DATAUNIT, or DATAFILE KEYWORDS TO REUSE THEIR UNIT NUMBERS AND CONTINUE LOADING FROM THEIR FILES)')
!                            END IF
!                            !
!                            IF(IU.NE.Z) THEN
!                                                  CALL CHECK_FOR_POST_KEY(LLOC,LN,IN,IOUT,ISTART,ISTOP,SFAC_FILE,DIM=DIM) !ISTART, ISTOP ARE PLACE HOLDERS FOR BUF AND ISPLIT
!                                                  !
!                                                  INQUIRE(IU,FORM=FORM_CHK, OPENED=KEEP_IU)
!                                                  IF(.NOT. KEEP_IU) CALL STOP_ERROR(LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ULOAD ERROR: RECIEVED UNIT NUMBER "'//NUM2STR(IU)//'" WHICH IS NOT ASSOCIATED WITH A FILE. THIS COULD BE THE RESULT OF USING "EXTERNAL" OR "DATAUNIT" WITH A UNIT THAT IS NOT OPENED BY THE NAME FILE.')
!                                                  BIN = FORM_CHK .NE. 'FORMATTED'
!                                                  !
!                                                  ERROR_IU = IU
!                                                  KEEP_IU  = TRUE
!                                                  LLOC     = ONE
!                                                  IF(.NOT. ALLOW_ERROR) CLEAR_IU = TRUE
!                                                  IF(.NOT. BIN) CALL READ_TO_DATA(LN,IU,IOUT)  !UNIT IS BEING PASSED IN SO READ IN LINE FROM IT
!                            END IF
!                       END IF
!    END SELECT
!    !
!    IF(IU==Z) THEN
!          ALLOCATE(FL)
!          !
!          CALL FL%OPEN(LN,LLOC,IOUT,IN,NOSTOP=TRUE,REQKEY=TRUE,BINARY=BIN,SFAC=SFAC_FILE, DIM=DIM)
!          BIN = FL%BINARY
!          IF(.NOT. FL%ERROR) THEN
!                                 IU = FL%IU
!                                 IF(IU.NE.Z .AND. .NOT. FL%OPENCLOSE) KEEP_IU = TRUE  !FONUD EXTERNAL KEYWORD, SO PASS BACK WHAT WAS LOADED
!                                 IF(IU.NE.Z) ERROR_IU = IU
!                                 IF(IU == Z .AND. DIM < ONE) REQ_TERMINTOR = TRUE !CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: COMPRESSED_ARRAY_STORAGE MUST SPECIFY THE NUMBER OF ROWS TO LOAD IF USING "INTERNAL" KEYWORD. PLEASE EITHER SPECIFY THE NUMBER OF ROWS WITH THE KEYWORD "DIM NROW" WHERE NROW IS THE NUMBER OF ROWS THAT ARE GOING TO BE READ OR MOVE INTERNAL INPUT TO SEPARATE FILE AND CHANGE KEYWORD TO "OPEN/CLOSE" OR "EXTERNAL". NOTE THAT AUTO-COUNTING REQUIRES ONLY THE INPUT DATA AND COMMENTS WITHIN THE FILE TO GET AN ACCURATE COUNT.')
!                                 IF(IU == Z .AND. NO_INTERN) CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: THIS SPECIFIC INPUT LINE DOES NOT ALLOW FOR THE "INTERNAL" KEYWORD. PLEASE MOVE INTERNAL INPUT TO SEPARATE FILE AND CHANGE KEYWORD TO "OPEN/CLOSE" OR "EXTERNAL".')
!                                 IF(IU == Z) IU = INFILE  !FOUND INTERNAL
!                                 LLOC = ONE
!                                 IF(.NOT. BIN) CALL READ_TO_DATA(LN,IU,IOUT)
!          ELSE !NO KEYWORD FOUND, BUT THIS IS REQUIRED FOR 2D
!              !
!              IF(ALLOW_ERROR) THEN
!                     CALL STOP_ERROR( LINE=LN, INFILE=IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: 2D ARRAYS CANNOT BE LOADED WITH IMPLIED INTERNAL. PLEASE USE A KEYWORD TO INDICATE WHERE DATA IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)')
!              ELSEIF(CLEAR_IU) THEN
!                     IU = Z
!                     LLOC = Z
!              END IF
!              RETURN
!          END IF
!    END IF
!    !
!    IF(.NOT. BIN .AND. IU.NE.Z) THEN
!                                DO !CHECK FOR KEYWORD OF SFAC WITHIN LIST
!                                      CALL GET_WORD(EXT,LN,LLOC,N,TRUE)
!                                      IF (EXT == 'SFAC') THEN
!                                          CALL SFAC_READ_AND_RETURN(SF, LN(N:), IU, IOUT, EX1_WORD=EX1_WORD, EX1_DIM=EX1_DIM, EX2_WORD=EX2_WORD, EX2_DIM=EX2_DIM, EX3_WORD=EX3_WORD, EX3_DIM=EX3_DIM)
!                                          LLOC = ONE
!                                          CALL READ_TO_DATA(LN,IU,IOUT)
!                                      ELSE
!                                          LLOC = N
!                                          EXIT
!                                      END IF
!                                END DO
!    END IF
!    !
!    IF(BIN) THEN
!                !
!                CALL STOP_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: "BINARY" KEYWORD FOUND, BUT THIS INPUT PROPERTY DOES NOT SUPPORT BINARY FILE INPUT. PLEASE USE ASCII/TEXT INPUT INSTEAD AND REMOVE "BINARY" KEYWORD.')
!                !IF(IU==INFILE)                             CALL FILE_IO_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: "INTERNAL" AND "BINARY" KEYWORD FOUND, BUT THIS IS NOT ALLOWED!', MSG2=MSG)
!                !IF(PRESENT(NO_BINARY)) THEN; IF(NO_BINARY) CALL FILE_IO_ERROR( LINE=LN, INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ERROR: "BINARY" KEYWORD FOUND, BUT THIS INPUT PROPERTY DOES NOT SUPPORT BINARY FILE INPUT. PLEASE USE ASCII/TEXT INPUT INSTEAD AND REMOVE "BINARY" KEYWORD.', MSG2=MSG)
!                !END IF
!                !!
!                !SELECT TYPE (VAR)
!                !TYPE IS (DOUBLE PRECISION); READ(IU, IOSTAT=IERR) VAR
!                !TYPE IS (REAL);              READ(IU, IOSTAT=IERR) VAR
!                !TYPE IS (INTEGER);          READ(IU, IOSTAT=IERR) VAR
!                !TYPE IS (CHARACTER(*));     READ(IU, IOSTAT=IERR) VAR
!                !END SELECT
!                !!
!                !IF(IERR.NE.Z .AND. ALLOW_ERROR)   CALL FILE_IO_ERROR( IERR, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ATTEMPT MADE TO READ AN ARRAY WITH ULOAD IN A BINARY FILE, BUT IT FAILED TO LOAD.', MSG2=MSG)
!                !IF(IERR.NE.Z .AND. CLEAR_IU)  IU = Z
!    ELSE
!        N = ONE
!        I = ONE
!        EOF = FALSE
!        IERR = Z
!        IF(DIM > Z .AND. DIM .NE. VAR%DIM ) THEN                    !HAS_ID, HAS_RC, HAS_VAL
!                                                CALL VAR%ALLOC(DIM, READ_ID,   TRUE, HAS_VAL)
!        ELSEIF(DIM < ONE) THEN
!             CALL VAR%INIT()    !INITIALIZE
!             DIM = Z
!             EXT=BLNK
!             DO WHILE (IERR==Z .AND. .NOT. EOF)
!                 !
!                 LLOC=ONE
!                 IF(READ_ID) CALL GET_INTEGER(LN,LLOC,ISTART,ISTOP,IOUT,IU,IDUM, MSG=NOERR);  IF(IDUM == inf_I)      IERR = TWO
!                             CALL GET_INTEGER(LN,LLOC,ISTART,ISTOP,IOUT,IU,IDUM, MSG=NOERR);  IF(IDUM == inf_I)      IERR = TWO
!                             CALL GET_INTEGER(LN,LLOC,ISTART,ISTOP,IOUT,IU,IDUM, MSG=NOERR);  IF(IDUM == inf_I)      IERR = TWO
!                 IF(HAS_VAL) THEN
!                       SELECT TYPE(VAR)
!                       CLASS IS (COMPRESSED_ARRAY_STORAGE    ); CALL GET_NUMBER( LN,LLOC,ISTART,ISTOP,IOUT,IU,DDUM, MSG=NOERR);  IF(DDUM.NE.DDUM)  IERR = TWO
!                       CLASS IS (COMPRESSED_ARRAY_STORAGE_INT); CALL GET_INTEGER(LN,LLOC,ISTART,ISTOP,IOUT,IU,IDUM, MSG=NOERR);  IF(IDUM == inf_I) IERR = TWO
!                       END SELECT
!                 END IF
!                 !
!                 IF(IERR == Z) THEN
!                             DIM = DIM + ONE
!                             CALL READ_TO_DATA(LN,IU,IOUT,CNT=I,EOF=EOF)
!                             N = N + I
!                             !
!                             LLOC = ONE
!                             CALL GET_WORD(EXT,LN,LLOC)
!                             SELECT CASE(EXT)
!                             CASE('INPUT_END', 'TERMINATE'); EXIT
!                             END SELECT
!                 END IF
!                 !
!             END DO
!             !
!             DO I=ONE, N; BACKSPACE(IU)  !MOVE BACK TO START OF LOAD
!             END DO
!             CALL READ_TO_DATA(LN,IU,IOUT) !LOAD FIRST LINE
!             !
!             IF(DIM==Z .AND. ALLOW_ERROR) THEN
!                 CALL STOP_ERROR(INFILE=ERROR_IU, OUTPUT=IOUT, MSG= 'ULOAD ATTEMPTED TO DETERMINE THE SIZE OF COMPRESSED ARRAY,'//NL//'BUT THE FINAL SIZE WAS SET TO ZERO. EITHER THE FIRST ROW OF INPUT IS FAULTY, THE FILE WAS EMPTY OR THE TERMINATOR WORD "TERMINATE" WAS FOUND PREMATURELY.'//BLN//'NOTE THAT ULOAD DETERMINES THE COMPRESSED ARRAY NUMBER OF ENTRIES/ROWS AS THE NUMBER OF SUCESSFUL SEQUENTIAL, UNCOMMETED COMPRESSED ARRAY READS.'//NL//'THAT IS IT READS ON EACH LINE THE COMPRESSED ARRAY INFORMATION (ID, ROW, COL, VALUE)'//NL//'AND IF IT FAILS TO LOAD THE DATA IT ASSUMES THAT IS THE FILE SIZE AND THEN CHECKS IF IT MATCHES THE KEYWORD "TERMINATE".')
!             ELSEIF(DIM==Z) THEN
!                    IERR = TWO
!             ELSE                       !HAS_ID, HAS_RC, HAS_VAL
!                    CALL VAR%ALLOC(DIM, READ_ID,   TRUE, HAS_VAL)
!                    !
!                    IERR = Z
!                    IF(EXT.NE.'TERMINATE' .AND. EXT.NE.'INPUT_END' .AND. .NOT. EOF) THEN
!                        IF(REQ_TERMINTOR .AND. ALLOW_ERROR) THEN
!                            CALL STOP_ERROR(LN,ERROR_IU,IOUT,MSG='ULOAD COMPRESSED ARRAY LOAD FAILED TO IDENTIFY KEYWORDS "TERMINATE" OR "INPUT_END"'//NL//'OR REACH THE END OF THE FILE WHILE LOADING INPUT PROPERTY.'//NL//'THE LINE PRINTED HERE IS THE LAST NIGHT LOADED'//NL//'AND THE FINAL SIZE OF THIS INPUT IS '//NUM2STR(DIM)//BLN//'MAKE SURE THIS SIZE IS CORRENT AND LOAD ULITILTY DID NOT PREMATURELY STOP LOADING INFORMATION DO TO A BAD DATA INPUT.')
!                        ELSE
!                            CALL WARNING_MESSAGE(LN,ERROR_IU,IOUT,MSG='ULOAD COMPRESSED ARRAY LOAD FAILED TO IDENTIFY KEYWORDS "TERMINATE" OR "INPUT_END"'//NL//'OR REACH THE END OF THE FILE WHILE LOADING INPUT PROPERTY.'//NL//'THE LINE PRINTED HERE IS THE LAST NIGHT LOADED'//NL//'AND THE FINAL SIZE OF THIS INPUT IS '//NUM2STR(DIM)//BLN//'MAKE SURE THIS SIZE IS CORRENT AND LOAD ULITILTY DID NOT PREMATURELY STOP LOADING INFORMATION DO TO A BAD DATA INPUT.')
!                            IF(REQ_TERMINTOR) IERR = TWO
!                        END IF
!                    END IF
!             END IF
!        END IF
!        !
!        IF(IERR==Z) THEN
!                DO I=1, DIM
!                           LLOC = ONE
!                           IF(READ_ID) CALL GET_INTEGER(LN,LLOC,ISTART,ISTOP,IOUT,IU,VAR%ID(I),  MSG=NOERR);  IF(VAR%ID(I)  == inf_I)      IERR = TWO
!                                       CALL GET_INTEGER(LN,LLOC,ISTART,ISTOP,IOUT,IU,VAR%ROW(I), MSG=NOERR);  IF(VAR%ROW(I) == inf_I)      IERR = TWO
!                                       CALL GET_INTEGER(LN,LLOC,ISTART,ISTOP,IOUT,IU,VAR%COL(I), MSG=NOERR);  IF(VAR%COL(I) == inf_I)      IERR = TWO
!                           IF(HAS_VAL) THEN
!                                 SELECT TYPE(VAR)
!                                 CLASS IS (COMPRESSED_ARRAY_STORAGE    ); CALL GET_NUMBER( LN,LLOC,ISTART,ISTOP,IOUT,IU,VAR%VAL(I), MSG=NOERR);  IF(VAR%VAL(I).NE.VAR%VAL(I)) IERR = TWO
!                                 CLASS IS (COMPRESSED_ARRAY_STORAGE_INT); CALL GET_INTEGER(LN,LLOC,ISTART,ISTOP,IOUT,IU,VAR%VAL(I), MSG=NOERR);  IF(VAR%VAL(I) == inf_I)      IERR = TWO
!                                 END SELECT
!                           END IF
!                           !
!                           IF(IERR.NE.Z)  EXIT
!                           CALL READ_TO_DATA(LN,IU,IOUT)
!                END DO
!                !
!                LLOC=ONE
!                CALL GET_WORD(EXT,LN,LLOC)
!                IF(EXT.NE.'TERMINATE' .AND. EXT.NE.'INPUT_END' .AND. .NOT. EOF) BACKSPACE(IU)
!        END IF
!        !
!        IF    (IERR.NE.Z .AND. ALLOW_ERROR) THEN
!               CALL FILE_IO_ERROR( UNIT=ERROR_IU, LINE=LN, INFILE=IN, OUTPUT=IOUT, MSG= 'ATTEMPT MADE TO READ A LINE CONTAINING COMPRESSED ARRAY INPUT AND FAILED TO LOAD ONE OF ITS COMPONENTS (ID, ROW, COL, VALUE)', MSG2=MSG)
!        ELSEIF(IERR.NE.Z .AND. CLEAR_IU) THEN
!               IU = Z
!               LLOC = Z
!        ELSEIF(IERR==Z .AND. READ_ID) THEN
!               CALL SETUP_IDX_LOC_COMPRESSED_ARRAY_STORAGE(VAR)
!        END IF
!        !
!    END IF
!    !
!    IF(SFAC_FILE.NE.UNO) CALL SF%SET_ALL(SFAC_FILE)
!    !
!    IF(PRESENT(SFAC)) THEN
!                           SFAC = SF
!    ELSEIF(.NOT. BIN .AND. HAS_VAL) THEN
!                       SELECT TYPE(VAR)
!                       CLASS IS (COMPRESSED_ARRAY_STORAGE    ); CALL SF%APPLY(VAR%VAL)
!                       END SELECT
!    END IF
!    !
!    IF(.NOT. KEEP_IU) IU = Z
!    IF(PRESENT(OLD_IU))  OLD_IU = IU
!    !
!    IF(ALLOCATED(FL))  DEALLOCATE(FL)
!    !
!  END SUBROUTINE
!  !
!  PURE SUBROUTINE INITITIALIZE_COMPRESSED_ARRAY_STORAGE(CAS)
!    CLASS(COMPRESSED_ARRAY_STORAGE_BASE), INTENT(INOUT):: CAS
!    IF(ALLOCATED(CAS%ID )) DEALLOCATE(CAS%ID )
!    IF(ALLOCATED(CAS%ROW)) DEALLOCATE(CAS%ROW)
!    IF(ALLOCATED(CAS%COL)) DEALLOCATE(CAS%COL)
!    !
!    IF(ALLOCATED(CAS%IDX)) DEALLOCATE(CAS%IDX)
!    IF(ALLOCATED(CAS%LOC)) DEALLOCATE(CAS%LOC)
!    !
!    SELECT TYPE(CAS)
!    CLASS IS (COMPRESSED_ARRAY_STORAGE    ); IF(ALLOCATED(CAS%VAL)) DEALLOCATE(CAS%VAL)
!    CLASS IS (COMPRESSED_ARRAY_STORAGE_INT); IF(ALLOCATED(CAS%VAL)) DEALLOCATE(CAS%VAL)
!    END SELECT
!    !
!    CAS%DIM=Z
!    CAS%NLOC=Z
!    CAS%IS_CONSTANT = FALSE
!    CAS%HAS_VAL     = FALSE
!    CAS%HAS_ID      = FALSE
!    CAS%HAS_IDX     = FALSE
!    CAS%HAS_RC      = FALSE
!  END SUBROUTINE
!  !
!  PURE SUBROUTINE ALLOCATE_COMPRESSED_ARRAY_STORAGE(CAS,N,ID,RC,VAL) !UNLESS PASSED IN, USES PRE-SET VALUES OF HAS_XXX
!    CLASS(COMPRESSED_ARRAY_STORAGE_BASE), INTENT(INOUT):: CAS
!    INTEGER,           INTENT(IN):: N
!    LOGICAL, OPTIONAL, INTENT(IN):: ID,RC,VAL
!    !
!    IF(ALLOCATED(CAS%ID )) DEALLOCATE(CAS%ID )
!    IF(ALLOCATED(CAS%ROW)) DEALLOCATE(CAS%ROW)
!    IF(ALLOCATED(CAS%COL)) DEALLOCATE(CAS%COL)
!    !
!    IF(ALLOCATED(CAS%IDX)) DEALLOCATE(CAS%IDX)
!    IF(ALLOCATED(CAS%LOC)) DEALLOCATE(CAS%LOC)
!    !
!    SELECT TYPE(CAS)
!    CLASS IS (COMPRESSED_ARRAY_STORAGE    ); IF(ALLOCATED(CAS%VAL)) DEALLOCATE(CAS%VAL)
!    CLASS IS (COMPRESSED_ARRAY_STORAGE_INT); IF(ALLOCATED(CAS%VAL)) DEALLOCATE(CAS%VAL)
!    END SELECT
!    !
!    CAS%NLOC=Z
!    CAS%DIM=N
!    CAS%IS_CONSTANT = FALSE
!    CAS%HAS_IDX     = FALSE
!    !
!    IF(PRESENT(ID)) CAS%HAS_ID  = ID
!    !IF(PRESENT(ID)) CAS%HAS_IDX = ID
!    IF(PRESENT(RC)) CAS%HAS_RC  = RC
!    IF(PRESENT(VAL))CAS%HAS_VAL = VAL
!    !
!    IF(CAS%HAS_ID) THEN
!                ALLOCATE(CAS%ID(N))
!    END IF
!    !
!    IF(CAS%HAS_RC) THEN
!                ALLOCATE(CAS%ROW(N))
!                ALLOCATE(CAS%COL(N))
!    END IF
!    !
!    IF(CAS%HAS_VAL) THEN
!          SELECT TYPE(CAS)
!          CLASS IS (COMPRESSED_ARRAY_STORAGE    )
!                                                 ALLOCATE(CAS%VAL(N))
!          CLASS IS (COMPRESSED_ARRAY_STORAGE_INT)
!                                                 ALLOCATE(CAS%VAL(N))
!          END SELECT
!    END IF
!    !
!  END SUBROUTINE
!  !
!  PURE SUBROUTINE SET_VAL_COMPRESSED_ARRAY_STORAGE(CAS,CAS_OUT, CIN, COUT) !MUST PASS BOTH N AND NULL, OTHERWISE DO NOT PASS EITHER
!    CLASS(COMPRESSED_ARRAY_STORAGE_BASE), INTENT(IN   ):: CAS
!    CLASS(COMPRESSED_ARRAY_STORAGE_BASE), INTENT(  OUT):: CAS_OUT
!    INTEGER, OPTIONAL,                    INTENT(   IN):: CIN, COUT !MUST SPECIFY BOTH OR NONE AT ALL
!    !
!    IF(CAS%HAS_VAL .AND. CAS_OUT%HAS_VAL) THEN
!        !
!        SELECT TYPE(CAS_OUT)
!        CLASS IS (COMPRESSED_ARRAY_STORAGE)
!                 SELECT TYPE(CAS)
!                 CLASS IS (COMPRESSED_ARRAY_STORAGE)
!                     IF(PRESENT(COUT)) THEN
!                            CAS_OUT%VAL(COUT) = CAS%VAL(CIN)
!                     ELSE
!                            CAS_OUT%VAL = CAS%VAL
!                     END IF
!                 END SELECT
!        CLASS IS (COMPRESSED_ARRAY_STORAGE_INT)
!                 SELECT TYPE(CAS)
!                 CLASS IS (COMPRESSED_ARRAY_STORAGE_INT)
!                     IF(PRESENT(COUT)) THEN
!                            CAS_OUT%VAL(COUT) = CAS%VAL(CIN)
!                     ELSE
!                            CAS_OUT%VAL = CAS%VAL
!                     END IF
!                 END SELECT
!        END SELECT
!        !
!    END IF
!    !
!  END SUBROUTINE
!  !
!  PURE SUBROUTINE MOVE_COMPRESSED_ARRAY_STORAGE(CAS,CAS_OUT,NULL) !MUST PASS BOTH N AND NULL, OTHERWISE DO NOT PASS EITHER
!    CLASS(COMPRESSED_ARRAY_STORAGE_BASE), INTENT(INOUT):: CAS
!    CLASS(COMPRESSED_ARRAY_STORAGE_BASE), INTENT(  OUT):: CAS_OUT
!    INTEGER, OPTIONAL,               INTENT(IN   ):: NULL
!    INTEGER:: I,J,DIM, INCLUDE_IDX
!    !
!    CALL CAS_OUT%INIT()
!    !
!    IF(PRESENT(NULL)) THEN
!        IF(CAS%HAS_RC) THEN
!            DIM = COUNT(CAS%ROW.NE.NULL)
!        ELSEIF(CAS%HAS_ID) THEN
!            DIM = COUNT(CAS%ID.NE.NULL)
!        ELSE
!            DIM = CAS%DIM
!        END IF
!    ELSE
!            DIM = CAS%DIM
!    END IF
!    !
!    INCLUDE_IDX = DIM == CAS%DIM
!    !
!    CALL CAS_OUT%ALLOC(DIM, CAS%HAS_ID, CAS%HAS_RC, CAS%HAS_VAL)
!    !
!    IF(DIM.NE.CAS%DIM) THEN
!       J=Z
!       IF(CAS%HAS_RC) THEN
!          DO CONCURRENT (I=ONE:CAS%DIM, CAS%ROW(I).NE.NULL)
!                  J=J+1
!                  CAS_OUT%ROW(J) = CAS%ROW(I)
!                  CAS_OUT%COL(J) = CAS%COL(I)
!                  IF(CAS%HAS_VAL) THEN
!                      CALL CAS%SET_VAL(CAS_OUT,I,J)  !CAS_OUT%VAL(J) = CAS%VAL(I)
!                  END IF
!          END DO
!       ELSEIF(CAS%HAS_ID) THEN
!          DO CONCURRENT (I=ONE:CAS%DIM, CAS%ID(I).NE.NULL)
!                  J=J+1
!                  CAS_OUT%ID(J)  = CAS%ID(I)
!                  CAS_OUT%ROW(J) = CAS%ROW(I)
!                  CAS_OUT%COL(J) = CAS%COL(I)
!                  IF(CAS%HAS_VAL) THEN
!                        CALL CAS%SET_VAL(CAS_OUT,I,J)  !CAS_OUT%VAL(J) = CAS%VAL(I)
!                  END IF
!          END DO
!       ELSE
!          IF(CAS%HAS_ID ) CAS_OUT%ID  = CAS%ID
!          IF(CAS%HAS_RC ) CAS_OUT%ROW = CAS%ROW
!          IF(CAS%HAS_RC ) CAS_OUT%COL = CAS%COL
!          IF(CAS%HAS_VAL) THEN
!                CALL CAS%SET_VAL(CAS_OUT)  !CAS_OUT%VAL = CAS%VAL
!          END IF
!       END IF
!    ELSE
!          IF(CAS%HAS_ID ) CAS_OUT%ID  = CAS%ID
!          IF(CAS%HAS_RC ) CAS_OUT%ROW = CAS%ROW
!          IF(CAS%HAS_RC ) CAS_OUT%COL = CAS%COL
!          IF(CAS%HAS_VAL) THEN
!                CALL CAS%SET_VAL(CAS_OUT)  !CAS_OUT%VAL = CAS%VAL
!          END IF
!    END IF
!    !
!    IF(CAS%HAS_IDX .AND. INCLUDE_IDX) THEN
!            ALLOCATE(CAS_OUT%IDX, SOURCE = CAS%IDX)
!                    CAS_OUT%LOC = CAS%LOC
!                    CAS_OUT%HAS_IDX = TRUE
!    ELSE
!                    CAS_OUT%HAS_IDX = FALSE
!    END IF
!    !
!    CALL CAS%DESTROY()
!    !
!  END SUBROUTINE
!  !
!  PURE SUBROUTINE SETUP_IDX_LOC_COMPRESSED_ARRAY_STORAGE(CAS)
!    CLASS(COMPRESSED_ARRAY_STORAGE_BASE), INTENT(INOUT):: CAS
!    INTEGER, DIMENSION(CAS%DIM):: UNIQUE
!    INTEGER:: I,J,K,N, CNT
!    LOGICAL:: ADD_ZERO
!    !
!    IF(ALLOCATED(CAS%LOC)) DEALLOCATE(CAS%LOC)
!    CAS%NLOC = Z
!    CAS%HAS_IDX = FALSE
!    !
!    IF(CAS%DIM>Z .AND. CAS%HAS_ID) THEN
!        ADD_ZERO = TRUE
!        UNIQUE = Z
!        N = ONE
!        DO CONCURRENT (I=ONE:CAS%DIM, CAS%ID(I) .NE. inf_I)
!            IF    (CAS%ID(I)==Z) THEN
!                                    IF(ADD_ZERO) THEN
!                                        N = N + ONE
!                                        ADD_ZERO = FALSE
!                                    END IF
!            ELSEIF(ALL(CAS%ID(I) .NE. UNIQUE(:N))) THEN
!                UNIQUE(N)=CAS%ID(I)
!                N = N + ONE
!            END IF
!        END DO
!        !
!        N = N - ONE
!        !
!        CAS%NLOC = N
!        IF(N > Z) THEN
!              ALLOCATE(CAS%IDX, SOURCE=UNIQUE(:N))
!              CAS%HAS_IDX = TRUE
!              CALL SORT(N,CAS%IDX)
!              ALLOCATE(CAS%LOC(N))
!              DO I=ONE, N
!                  CNT = COUNT(CAS%IDX(I) == CAS%ID)
!                  !
!                  CALL CAS%LOC(I)%ALLOC(CNT)
!                  !
!                  K = ONE
!                  DO J=1, CAS%DIM
!                      IF(CAS%IDX(I) == CAS%ID(J)) THEN
!                          CAS%LOC(I)%VEC(K) = J
!                          K = K + ONE
!                          IF(K > CNT) EXIT
!                      END IF
!                  END DO
!              END DO
!        END IF
!    END IF
!    !
!  END SUBROUTINE
!  !
!  PURE FUNCTION FIND_IDX_ID_COMPRESSED_ARRAY_STORAGE(CAS, ID) RESULT (IDX)
!    CLASS(COMPRESSED_ARRAY_STORAGE_BASE), INTENT(IN):: CAS
!    INTEGER,                              INTENT(IN):: ID
!    INTEGER:: I, IDX
!    IDX = Z
!    DO I=ONE,CAS%NLOC
!        IF(CAS%IDX(I) == ID) THEN
!               IDX=I
!               EXIT
!        END IF
!    END DO
!  END FUNCTION
!  !
!  SUBROUTINE DUBLICATE_ROW_COL_CHECK_COMPRESSED_ARRAY_STORAGE(CAS, IOUT, OPT) !ASSUMES IDX AND LOC HAVE BEEN BUILT.
!    CLASS(COMPRESSED_ARRAY_STORAGE_BASE), INTENT(INOUT):: CAS
!    INTEGER, INTENT(IN):: IOUT
!    INTEGER, INTENT(IN):: OPT! = 1=SUM, 0=STOP
!    INTEGER:: A,I,J,K,JJ,ID,R,C
!    LOGICAL:: REBUILD
!    CHARACTER(:),ALLOCATABLE:: ERR
!    !
!    REBUILD=FALSE
!    ERR=NL
!    !
!    IF(CAS%HAS_ID .AND. CAS%HAS_RC) THEN
!       !
!       DO CONCURRENT (I=ONE:CAS%NLOC)
!           ID = CAS%IDX(I)
!           DO J=1, CAS%LOC(I)%N-1
!               A = CAS%LOC(I)%VEC(J)
!               IF(CAS%ID(A) .NE. inf_I) THEN
!                  R = CAS%ROW(A)
!                  C = CAS%COL(A)
!                  DO CONCURRENT(JJ=J+1:CAS%LOC(I)%N)
!                      K = CAS%LOC(I)%VEC(JJ)
!                      IF( CAS%ID(K).NE.inf_I .AND. R==CAS%ROW(K) .AND. C==CAS%COL(K)) THEN
!                          CAS%ID(K)  = inf_I
!                          CAS%ROW(K) = inf_I
!                          CAS%COL(K) = inf_I
!                          REBUILD    = TRUE
!                          ERR=ERR//NUM2STR(ID,-5)//' '//NUM2STR(R,-10)//' '//NUM2STR(C,-10)//NL
!                          IF(OPT==ONE .AND. CAS%HAS_VAL) THEN
!                              SELECT TYPE(CAS)
!                              CLASS IS (COMPRESSED_ARRAY_STORAGE    )
!                                                                      CAS%VAL(A) = CAS%VAL(A) + CAS%VAL(K)
!                                                                      CAS%VAL(K) = DZ
!                              CLASS IS (COMPRESSED_ARRAY_STORAGE_INT)
!                                                                      CAS%VAL(A) = CAS%VAL(A) + CAS%VAL(K)
!                                                                      CAS%VAL(K) =  Z
!                              END SELECT
!                          END IF
!                      END IF
!                  END DO
!               END IF
!           END DO
!       END DO
!       !
!    ELSEIF(CAS%HAS_RC) THEN ! NOT HAS_ID
!       !
!       DO I=ONE, CAS%DIM-1
!           IF(CAS%ROW(J).NE.inf_I) THEN
!              R = CAS%ROW(I)
!              C = CAS%COL(I)
!              DO CONCURRENT (J=I+ONE:CAS%DIM, R==CAS%ROW(J) .AND. C==CAS%COL(J))
!                      CAS%ROW(J) = inf_I
!                      CAS%COL(J) = inf_I
!                      REBUILD    = TRUE
!                      ERR=ERR//'   NA'//' '//NUM2STR(R,-10)//' '//NUM2STR(C,-10)//NL
!                      IF(OPT==ONE .AND. CAS%HAS_VAL) THEN
!                          SELECT TYPE(CAS)
!                          CLASS IS (COMPRESSED_ARRAY_STORAGE    )
!                                                                  CAS%VAL(I) = CAS%VAL(I) + CAS%VAL(J)
!                                                                  CAS%VAL(J) = DZ
!                          CLASS IS (COMPRESSED_ARRAY_STORAGE_INT)
!                                                                  CAS%VAL(I) = CAS%VAL(I) + CAS%VAL(J)
!                                                                  CAS%VAL(J) =  Z
!                          END SELECT
!                      END IF
!              END DO
!           END IF
!       END DO
!       !
!    END IF
!    !
!    IF(ERR.NE.NL) THEN
!        SELECT CASE(OPT)
!        CASE(Z);   CALL STOP_ERROR( OUTPUT=IOUT, MSG= 'DUBLICATE_ROW_COL_CHECK_COMPRESSED_ARRAY_STORAGE: FOUND THE DUBLICATE ROW AND COLUMNS FOR THE SAME ID. THE FOLLOWING IS A LIST OF ROW AND COLUMNS THAT WERE DUBLICATES:'//NL//'ID    ROW     COLUMN'//ERR)
!        CASE(ONE); CALL WARNING_MESSAGE(    OUTPUT=IOUT, MSG= 'DUBLICATE_ROW_COL_CHECK_COMPRESSED_ARRAY_STORAGE: FOUND THE DUBLICATE ROW AND COLUMNS FOR THE SAME ID. THE FOLLOWING IS A LIST OF IDs AND THEIR ROW AND COLUMNS THAT WERE DUBLICATE. THEIR VALUE IS SUMMED TOGETHER TO MAKE ONE UNIQUE (ID, ROW, COL):'//NL//'ID    ROW     COLUMN'//ERR)
!        END SELECT
!    END IF
!    !
!    IF(REBUILD) THEN
!      SELECT TYPE(CAS)
!      CLASS IS (COMPRESSED_ARRAY_STORAGE    )
!                                             BLOCK
!                                                  TYPE(COMPRESSED_ARRAY_STORAGE):: TMP
!                                                  CALL CAS%MOVE(TMP, inf_I)
!                                                  CALL TMP%MOVE(CAS)
!                                             END BLOCK
!      CLASS IS (COMPRESSED_ARRAY_STORAGE_INT)
!                                             BLOCK
!                                                  TYPE(COMPRESSED_ARRAY_STORAGE_INT):: TMP
!                                                  CALL CAS%MOVE(TMP, inf_I)
!                                                  CALL TMP%MOVE(CAS)
!                                             END BLOCK
!      TYPE IS (COMPRESSED_ARRAY_STORAGE_BASE)
!                                             BLOCK
!                                                  TYPE(COMPRESSED_ARRAY_STORAGE_BASE):: TMP
!                                                  CALL CAS%MOVE(TMP, inf_I)
!                                                  CALL TMP%MOVE(CAS)
!                                             END BLOCK
!      END SELECT
!    END IF
!    !
!    IF(REBUILD .AND. CAS%HAS_ID) CALL SETUP_IDX_LOC_COMPRESSED_ARRAY_STORAGE(CAS)
!    !
!  END SUBROUTINE
!  !
!  ELEMENTAL SUBROUTINE GET_COMPRESSED_VALUE(LAI, ID, DIM1, DIM2, LDIM, VAL)
!    CLASS(LIST_ARRAY_INPUT), INTENT(IN ):: LAI
!    INTEGER,                 INTENT(IN ):: ID, DIM1, DIM2, LDIM
!    REAL(REAL64),            INTENT(OUT):: VAL
!    INTEGER:: I, J, N
!    !
!    J = Z
!    N = Z
!    VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)
!    !
!    IF (ID>Z .AND. DIM1>Z) THEN
!         DO I = ONE, LAI%CAS%DIM
!               IF(LAI%CAS%ID(I)==ID .AND. LAI%CAS%ROW(I)==DIM1 .AND. LAI%CAS%COL(I)==DIM2) THEN
!                     N = N + ONE
!                     IF(N == LDIM .OR. LDIM < ONE) THEN
!                           VAL = LAI%CAS%VAL(I)
!                           J = I
!                           EXIT
!                     END IF
!               END IF
!         END DO
!    ELSEIF (ID<ONE .AND. DIM1>Z) THEN
!         DO I = ONE, LAI%CAS%DIM
!               IF(LAI%CAS%ROW(I)==DIM1 .AND. LAI%CAS%COL(I)==DIM2) THEN
!                     N = N + ONE
!                     IF(N == LDIM .OR. LDIM < ONE) THEN
!                           VAL = LAI%CAS%VAL(I)
!                           J = I
!                           EXIT
!                     END IF
!               END IF
!         END DO
!    ELSE
!         DO I = ONE, LAI%CAS%DIM
!               IF(LAI%CAS%ROW(I)==DIM1 .AND. LAI%CAS%COL(I)==DIM2) THEN
!                     N = N + ONE
!                     IF(N == LDIM .OR. LDIM < ONE) THEN
!                           VAL = LAI%CAS%VAL(I)
!                           J = I
!                           EXIT
!                     END IF
!               END IF
!         END DO
!    END IF
!    !
!  END SUBROUTINE
!
!  !
!  !SUBROUTINE READ_COMPRESSED_ARRAY (CAS, UNIT, IOTYPE, V_LIST, IOSTAT, IOMSG)
!  !  CLASS(COMPRESSED_ARRAY_STORAGE_BASE):: CAS
!  !  INTEGER,      INTENT(IN   ):: UNIT
!  !  CHARACTER(*), INTENT(IN   ):: IOTYPE
!  !  INTEGER,      INTENT(IN   ):: V_LIST (:)
!  !  INTEGER,      INTENT(OUT  ):: IOSTAT
!  !  CHARACTER(*), INTENT(INOUT):: IOMSG
!  !  !
!  !  IF(ALLOCATED(CAS%ID ))
!  !  IF(ALLOCATED(CAS%ROW))
!  !  IF(ALLOCATED(CAS%COL))
!  !  IF(ALLOCATED(CAS%VAL))
!  !  !
!  !  IF(PRESENT(ID)) THEN
!  !      IF(ID)  ALLOCATE(CAS%ID(N))
!  !  ELSE
!  !              ALLOCATE(CAS%ID(N))
!  !  END IF
!  !  !
!  !  IF(PRESENT(RC)) THEN
!  !      IF(RC)  ALLOCATE(CAS%ROW(N))
!  !      IF(RC)  ALLOCATE(CAS%COL(N))
!  !  ELSE
!  !              ALLOCATE(CAS%ROW(N))
!  !              ALLOCATE(CAS%COL(N))
!  !  END IF
!  !  !
!  !  IF(PRESENT(VAL)) THEN
!  !      IF(VAL) ALLOCATE(CAS%VAL(N))
!  !  ELSE
!  !              ALLOCATE(CAS%VAL(N))
!  !  END IF
!  !END SUBROUTINE
!  !
!  !SUBROUTINE SET_COMPRESSED_ARRAY_STORAGE(CAS,P,ID,ROW,COL,VAL)
!  !  CLASS(COMPRESSED_ARRAY_STORAGE_BASE):: CAS
!  !  INTEGER,                    INTENT(IN):: N
!  !  INTEGER, OPTIONAL,          INTENT(IN):: P,ID,ROW,COW
!  !  DOUBLE PRECISION, OPTIONAL, INTENT(IN):: VAL
!  !  !
!  !  IF(PRESENT(ID)) THEN
!  !      IF(ID)  ALLOCATE(CAS%ID(N))
!  !  ELSE
!  !              ALLOCATE(CAS%ID(N))
!  !  END IF
!  !  !
!  !  IF(PRESENT(RC)) THEN
!  !      IF(RC)  ALLOCATE(CAS%ROW(N))
!  !      IF(RC)  ALLOCATE(CAS%COL(N))
!  !  ELSE
!  !              ALLOCATE(CAS%ROW(N))
!  !              ALLOCATE(CAS%COL(N))
!  !  END IF
!  !  !
!  !  IF(PRESENT(VAL)) THEN
!  !      IF(VAL) ALLOCATE(CAS%VAL(N))
!  !  ELSE
!  !              ALLOCATE(CAS%VAL(N))
!  !  END IF
!  !
!  !  CAS%N=N
!  !  CAS%P=Z
!  !END SUBROUTINE
!  !
!  PURE SUBROUTINE FINAL_COMPRESSED_ARRAY_STORAGE_BASE(CAS)
!    TYPE(COMPRESSED_ARRAY_STORAGE_BASE), INTENT(INOUT):: CAS
!    CALL INITITIALIZE_COMPRESSED_ARRAY_STORAGE(CAS)
!  END SUBROUTINE
!  !
!  PURE SUBROUTINE FINAL_COMPRESSED_ARRAY_STORAGE(CAS)
!    TYPE(COMPRESSED_ARRAY_STORAGE), INTENT(INOUT):: CAS
!    CALL INITITIALIZE_COMPRESSED_ARRAY_STORAGE(CAS)
!  END SUBROUTINE
!  !
!  PURE SUBROUTINE FINAL_COMPRESSED_ARRAY_STORAGE_INT(CAS)
!    TYPE(COMPRESSED_ARRAY_STORAGE_INT), INTENT(INOUT):: CAS
!    CALL INITITIALIZE_COMPRESSED_ARRAY_STORAGE(CAS)
!  END SUBROUTINE
!END MODULE
!
!
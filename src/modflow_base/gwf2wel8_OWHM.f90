MODULE GWFWEL2MODULE
  USE PAK_PROP_INTERFACE
  USE TABLEFILE_INTERFACE,              ONLY: TABFILETYPE
  USE LINE_FEEDER,                      ONLY: LINE_FEED
  USE GENERIC_OUTPUT_FILE_INSTRUCTION,  ONLY: GENERIC_OUTPUT_FILE
  USE BUDGET_GROUP_INTERFACE,           ONLY: BUDGET_GROUP
  !
  PRIVATE:: ULSTRDSTRUCT, UPARLSTSUBSTRUC, LINE_FEED, GENERIC_OUTPUT_FILE, BUDGET_GROUP
  !
  INTEGER,SAVE,POINTER:: IOUT, LOUT
  !
  TYPE(TABFILETYPE),  POINTER,SAVE:: WELTABFILE
  TYPE(LINE_FEED),    POINTER,SAVE:: WELFEED
  TYPE(BUDGET_GROUP), POINTER,SAVE:: WELBUD
  TYPE(PAK_PROPTAB),DIMENSION(:),SAVE,POINTER,CONTIGUOUS:: WELDATA
  DOUBLE PRECISION,   SAVE,POINTER  ::PHIRAMP
  TYPE(GENERIC_OUTPUT_FILE),SAVE,POINTER  ::IUNITRAMP
  INTEGER,SAVE,POINTER  ::NWELLS,MXWELL,NWELVL,IWELCB,IPRWEL
  INTEGER,SAVE,POINTER  ::NPWEL,IWELPB,NNPWEL,IPRTWELTAB
  LOGICAL,SAVE,POINTER:: WELSMOOTHING, NWT_SOLVER
  LOGICAL,SAVE,POINTER:: EOF_WARNING_GIVEN
  !
  CHARACTER(LEN=16),SAVE,DIMENSION(:),  POINTER,CONTIGUOUS::WELAUX
  !
  TYPE GWFWELTYPE
    !
    INTEGER,POINTER:: IOUT, LOUT
    !
    TYPE(TABFILETYPE),  POINTER:: WELTABFILE
    TYPE(LINE_FEED),    POINTER:: WELFEED
    TYPE(BUDGET_GROUP), POINTER:: WELBUD
    TYPE(PAK_PROPTAB),DIMENSION(:),POINTER,CONTIGUOUS:: WELDATA
    DOUBLE PRECISION,   POINTER  ::PHIRAMP
    TYPE(GENERIC_OUTPUT_FILE),POINTER  ::IUNITRAMP
    INTEGER,POINTER  ::NWELLS,MXWELL,NWELVL,IWELCB,IPRWEL
    INTEGER,POINTER  ::NPWEL,IWELPB,NNPWEL,IPRTWELTAB
    LOGICAL,POINTER:: WELSMOOTHING, NWT_SOLVER
    LOGICAL,POINTER:: EOF_WARNING_GIVEN
    !
    CHARACTER(LEN=16),DIMENSION(:),  POINTER,CONTIGUOUS::WELAUX
  END TYPE
  TYPE(GWFWELTYPE), SAVE:: GWFWELDAT(10)
END MODULE GWFWEL2MODULE

MODULE WEL_SUBROUTINES
  USE CONSTANTS,         ONLY: TRUE, FALSE, Z, DZ, ONE, UNO, BLN, NL, inf_I, BLNK
  USE NUM2STR_INTERFACE, ONLY: NUM2STR
  USE PAK_PROP_INTERFACE
  IMPLICIT NONE
  !
  PRIVATE ! NUM2STR, ULSTRDSTRUCT, UPARLSTSUBSTRUC
  !
  PUBLIC:: GWF2WEL8AR, GWF2WEL8RP,   GWF2WEL8AD,   GWF2WEL8FM, GWF2WEL8BD,  &
           GWF2WEL8DA, SGWF2WEL8PNT, SGWF2WEL8PSV, WEL_SMOOTH, WEL_DERIV
  !
  CONTAINS
  !
SUBROUTINE GWF2WEL8AR(IN,IGRID)
!  ******************************************************************
!  ALLOCATE ARRAY STORAGE FOR WELL PACKAGE
!  ******************************************************************
!
!     SPECIFICATIONS:
!  ------------------------------------------------------------------
  USE GWFWEL2MODULE
  USE GLOBAL,                           ONLY: LIST_UNIT=>IOUT,NCOL,NROW,NLAY,IFREFM,IUNIT,NOCBC
  USE TABLEFILE_INTERFACE,              ONLY: TABFILEPARSE
  USE LINE_FEEDER,                      ONLY: LINE_FEED
  USE UTIL_INTERFACE,                   ONLY: READ_TO_DATA, FILE_IO_ERROR, STOP_ERROR, PARSE_WORD, PARSE_WORD_UP, GET_NUMBER, GET_INTEGER
  USE GENERIC_BLOCK_READER_INSTRUCTION, ONLY: GENERIC_BLOCK_READER
  USE CONSTANTS,                        ONLY: UNO, DNEG, DZ
  !
  INTEGER,INTENT(INOUT):: IN
  INTEGER,INTENT(IN   ):: IGRID
  !
  TYPE(GENERIC_BLOCK_READER):: BL
  !
  INTEGER:: I, J, K, LLOC, ISTART, ISTOP, IERR, IUNITNWT, NINLST
  INTEGER:: IP, MXPW, MXACTW, NAUX, NLST, LSTBEG, LSTSUM, NUMINST
  !
  INTEGER:: N
  REAL:: R
  DOUBLE PRECISION:: SGN
  !
  CHARACTER(700):: LINE    
  CHARACTER(75)::  LABEL
  CHARACTER(25):: VER
  CHARACTER(5):: ERROR
  LOGICAL:: FOUND_BEGIN, NO_LINEFEED, NO_CBC_READ
! ------------------------------------------------------------------
  VER='2.0.0, 2/05/2015'
  ERROR='ERROR'
  ALLOCATE(NWELLS,MXWELL,NWELVL,IWELCB,IPRWEL)
  ALLOCATE(NPWEL,IWELPB,NNPWEL,PHIRAMP,IUNITRAMP)
  ALLOCATE(WELSMOOTHING,NWT_SOLVER,IPRTWELTAB)
  ALLOCATE(EOF_WARNING_GIVEN, SOURCE=FALSE)
  ALLOCATE(WELFEED)
  !
  ALLOCATE(IOUT, LOUT)
  LOUT = LIST_UNIT
  CALL READ_TO_DATA(LINE,IN,LOUT,LOUT)
  IOUT = LIST_UNIT
  !
  ! SETUP PACKAGE UNITS:
  IUNITNWT=IUNIT(63)
  !
  PHIRAMP = 0.1D0
  IF(IUNITNWT.NE.Z) THEN
      WELSMOOTHING=TRUE
      NWT_SOLVER=TRUE
  ELSE
      WELSMOOTHING=FALSE
      NWT_SOLVER=FALSE
  END IF

!1------IDENTIFY PACKAGE AND INITIALIZE NWELLS.
  WRITE(IOUT,'(/A/)') 'WEL -- WELL PACKAGE, VERSION '//TRIM(VER)//' INPUT READ FROM UNIT '//NUM2STR(IN)
  NWELLS=Z
  NNPWEL=Z
  !
  LLOC = 1
  CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
  IF(LINE(ISTART:ISTOP).EQ.'SPECIFY') THEN
      !
      WELSMOOTHING = TRUE
      CALL GET_NUMBER(LINE,LLOC,ISTART,ISTOP,LOUT,IN,PHIRAMP,MSG='FOUND KEYWORD "SPECIFY" WHICH MUST FOLLOW WITH PHIRAMP VALUE, BUT FAILED TO CONVERT IT TO A FLOATING POINT NUMBER.')
      !
      IF(PHIRAMP.LT.1.0E-5) PHIRAMP=1.0D-5;  IF(PHIRAMP.GT.1.0D0 ) PHIRAMP=1.0D0
      !
      CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP,OLD_LOC=LLOC)  !NO UPPER CASE AND STOP AT #, HOLD LLOC AT OLD POSITION
      IF(ISTART >= ISTART) THEN
          !
          CALL IUNITRAMP%OPEN(LINE, LLOC, IOUT, IN, NOBINARY=TRUE)
          !
          IF(.NOT. IUNITRAMP%NULL_FILE) CALL IUNITRAMP%SET_FNAME()
      END IF
      !
      CALL READ_TO_DATA(LINE,IN,IOUT,IOUT)
  END IF
  !
!2------READ MAXIMUM NUMBER OF WELLS AND UNIT OR FLAG FOR
!2------CELL-BY-CELL FLOW TERMS.
  CALL UPARLSTAL(IN,IOUT,LINE,NPWEL,MXPW)
  !
!3------READ AUXILIARY VARIABLES AND PRINT FLAG.
  ALLOCATE(WELAUX(20))
  NAUX=Z
  IPRWEL=ONE
  IPRTWELTAB=Z
  NO_LINEFEED = TRUE
  NO_CBC_READ = TRUE
  !
  ALLOCATE(WELBUD)
      CALL WELBUD%INIT('WELLS')
  !
  DO !BLOCK GROUPS
     !
     CALL BL%LOAD(IN,IOUT,LINE=LINE,FOUND_BEGIN=FOUND_BEGIN)
     !
     IF(BL%NAME == 'PARAMETER') THEN
         CALL UPARLSTAL(IN,IOUT,LINE,NPWEL,MXPW)
         CYCLE
     END IF
     !
     IF (.NOT. FOUND_BEGIN) EXIT
     !
     IF(BL%NAME == 'BUDGET_GROUP' .OR. BL%NAME == 'BUDGET_GROUPS') THEN
         !
         CALL WELBUD%LOAD(BL)
         !
     ELSEIF(BL%NAME == 'LINEFEED') THEN
         !
         !ALLOCATE WELFEED VARIABLE AND OPTIONALLY READ IN FEED FILE LOCATIONS
         IF(BL%NLINE>0) THEN
             CALL WELFEED%INIT(BL)    !=>FEED_ALLOCATE(IN,IOUT,LINE)
             NO_LINEFEED = FALSE
         END IF
     !
     ELSEIF((BL%NAME == 'OPTION' .OR. BL%NAME == 'OPTIONS') .AND. BL%NLINE>Z) THEN
         !
         CALL BL%START()
         DO I=1, BL%NLINE
             IF(  BL%LINE==ERROR ) CALL STOP_ERROR(LINE=LINE,INFILE=BL%IU, OUTPUT=BL%IOUT, MSG='UNFORTUNATELY UNKNOWN "'//BL%NAME//'" BLOCK ERROR. PLEASE DOUBLE CHECK BLOCK SET UP.')
             !
             LLOC=ONE
             CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP,TRUE)
             !
             SELECT CASE (BL%LINE(ISTART:ISTOP))
             CASE('NOPRINT')
                             WRITE(IOUT,'(1x A /)') 'LISTS OF WELL CELLS WILL NOT BE PRINTED'
                             IPRWEL = Z
             CASE('TABPRINT')
                             WRITE(IOUT,'(1x 2A /)') 'WEL RESULTS FROM TABFILE CALCULATIONS WILL BE PRINTED TO LIST'
                             IPRTWELTAB = ONE
             CASE('WEL_CBC','WELL_CBC','CBC')
                             NO_CBC_READ = FALSE
                             CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,IOUT,IN,IWELCB,MSG='WEL PACKAGE OPTIONS ERROR: FROUND KEYWORD "WELL_CBC" WHICH SHOULD BE FOLLOWED BY AN INTEGER REPRESENTING THE UNIT NUMBER TO WRITE THE CELL-BY-CELL FLOWS TOO.')
                             WRITE(IOUT,'(1x 2A /)') 'WELL PACKAGE CELL-BY-CELL FLOW IS WRITEN TO: '//NUM2STR(IWELCB)
             CASE('SMOOTHING')
                             WELSMOOTHING = TRUE
                             CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP,TRUE)
                             IF(  'BY_FRACTION' == BL%LINE(ISTART:ISTOP) .OR. 'BYFRACTION' == BL%LINE(ISTART:ISTOP)) THEN
                                                                   SGN = UNO
                             ELSEIF('BY_LENGTH' == BL%LINE(ISTART:ISTOP) .OR. 'BYLENGTH'   == BL%LINE(ISTART:ISTOP)) THEN
                                                                   SGN = DNEG
                             ELSE
                                 CALL STOP_ERROR(BL%LINE,IN,IOUT, 'FOUND OPTION "SMOOTHING" WHICH MUST BE FOLLOWED BY THE KEYWORD "BY_FRACTION" OR "BY_LENGTH" TO INDICATE WHAT PHIRAMP REPRESENTS.')
                             END IF
                             CALL GET_NUMBER(BL%LINE,LLOC,ISTART,ISTOP,LOUT,IN,PHIRAMP,MSG='FOUND OPTION "SMOOTHING" WHICH MUST FOLLOW WITH PHIRAMP VALUE, BUT FAILED TO CONVERT IT TO A FLOATING POINT NUMBER.')
                             !
                             IF(SGN > DZ) THEN
                                 IF(PHIRAMP.LT.1.0E-5) PHIRAMP=1.0D-5
                                 IF(PHIRAMP.GT.1.0D0 ) PHIRAMP=1.0D0
                             ELSE
                                 PHIRAMP = DNEG * PHIRAMP
                             END IF
                             !
                             !CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP,OLD_LOC=LLOC)  
                             CALL PARSE_WORD(BL%LINE,LLOC,ISTART,ISTOP, COM_STOP=TRUE) !NO UPPER CASE AND STOP AT #, HOLD LLOC AT OLD POSITION
                             IF(ISTART >= ISTART) THEN
                                 IF(BL%LINE(ISTART:ISTOP) .NE. BLNK) CALL IUNITRAMP%OPEN(BL%LINE, LLOC, IOUT, IN, NOSTOP=TRUE, NOBINARY=TRUE, SAVE_FNAME=TRUE)
                             END IF
             CASE('AUXILIARY', 'AUX')
                             CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP,TRUE)
                             IF(NAUX.LT.20) THEN
                                NAUX=NAUX+ONE
                                WELAUX(NAUX)=BL%LINE(ISTART:ISTOP)
                                WRITE(IOUT,'(1x 2A /)') 'AUXILIARY WELL VARIABLE: ', WELAUX(NAUX)
                             ELSE
                                WRITE(IOUT,'(/ A /)') 'WARNING: WELL PACKAGE CAN NOT HANDEL MORE THAN 20 AUX VARIABLES. ONLY FIRST 20 AUXILIARY VAIRABLES WILL BE USED.'
                             END IF
             END SELECT
             !
             CALL BL%NEXT()
         END DO
         !
        ELSE
           CALL STOP_ERROR(BLNK,IN,IOUT, 'WEL BLOCK ERROR. FOUND "BEGIN" KEYWORD, BUT IT WAS NOT FOLLOWED BY A KNOWN BLOCK NAME.'//BLN//'THE BLOCK NAME LOADED WAS: '//BL%NAME//BLN//'THE FOLLOWING ARE ACCEPTED BLOCK NAMES: "LINEFEED", "BUDGET_GROUP", "BUDGET_GROUPS", "OPTION", and "OPTIONS"' )
        END IF
        !
  END DO
  !
  ALLOCATE(WELTABFILE)
  CALL TABFILEPARSE(IN,IOUT,LINE,WELTABFILE)
  !CALL TABFILELINKS(IN,IOUT,LINE,WELTABFILE)  --NO LONGER SUPPORTED
  LLOC=ONE                
  CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP,TRUE)  !READ IN KEYWORD TABNOPRIRNT OR TABPRINT
  IF(LINE(ISTART:ISTOP).EQ.'TABPRINT' .OR. LINE(ISTART:ISTOP).EQ.'TABNOPRINT') THEN
     !
     CALL STOP_ERROR(LINE,IN,LOUT,                                                                                                   &
                               MSG=NL//'ERROR: WEL PACKAGE 2.0 NO LONGER READS IN TABFILE LINKS IN THE HEADER PART [PrintOption NLNK].'//NL//  &
                                   "TABFILES ARE LINED WHEN READING IN THE WELL'S INFORMATION AS FOLLOWS:"//NL//                               &
                                   'LAY, ROW, COL, Q, [xyz]  [TABNAM TSFAC]'//NL//NL//NL//                                                     &
                                   'IF YOU MUST USE THE OLD STYLE STRUCTURE CHANGE IN THE NAM FILE '//NL//                                     &
                                   'THE "WEL" PACKAGE TO "WEL1" TO ACTIVATE THE OWHM 1.0 WEL PACKAGE'                                          )
  END IF
  !
  !ALLOCATE WELFEED VARIABLE AND OPTIONALLY READ IN FEED FILE LOCATIONS
  IF(NO_LINEFEED) CALL WELFEED%INIT(IN,IOUT,LINE)    !=>FEED_ALLOCATE(IN,IOUT,LINE)
  !
  LLOC = ONE
  IF(IFREFM.EQ.Z) THEN
     !
     CALL GET_INTEGER(LINE( 1:10),LLOC,ISTART,ISTOP,IOUT,IN,MXACTW,MSG='NOSTOP')
     !
     IF(MXACTW == inf_I .AND. NO_LINEFEED) CALL STOP_ERROR(LINE,IN,LOUT, MSG=NL//'ERROR: WEL PACKAGE DOES NOT HAVE ANY LINEFEED FILES SPECIFIED, SO YOU MUST READ "MXACTW", BUT GET_INTEGER FAILED TO LOAD THAT NUMBER.')
     IF(MXACTW == inf_I) MXACTW = Z
     !
     LLOC = ONE
     IF(NO_CBC_READ) CALL GET_INTEGER(LINE(11:20),LLOC,ISTART,ISTOP,IOUT,IN,IWELCB,MSG='NOSTOP')
     IF(IWELCB == inf_I)  CALL STOP_ERROR(LINE,IN,LOUT, MSG=NL//'WEL PACKAGE OPTIONS ERROR: DID NOT FIND WITHIN THE OPTIONS BLOCK THE KEYWORD "WELL_CBC", SO INPUT EXPECTS TO LOAD AFTER MXACTW THE CBC UNIT NUMBER "IWELCB".')
  ELSE
     !
     CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IN,MXACTW,MSG='NOSTOP')
     !
     IF(MXACTW == inf_I .AND. NO_LINEFEED) CALL STOP_ERROR(LINE,IN,LOUT, MSG=NL//'ERROR: WEL PACKAGE DOES NOT HAVE ANY LINEFEED FILES SPECIFIED, SO YOU MUST READ "MXACTW", BUT GET_INTEGER FAILED TO LOAD THAT NUMBER.')
     IF(MXACTW == inf_I) MXACTW = Z
     !
     IF(NO_CBC_READ) CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IN,IWELCB,MSG='NOSTOP')
     IF(IWELCB == inf_I)  CALL STOP_ERROR(LINE,IN,LOUT, MSG=NL//'WEL PACKAGE OPTIONS ERROR: DID NOT FIND WITHIN THE OPTIONS BLOCK THE KEYWORD "WELL_CBC", SO INPUT EXPECTS TO LOAD AFTER MXACTW THE CBC UNIT NUMBER "IWELCB".')
  END IF
  !
  ! CHECK IF GLOBAL SHUTDOWN OF CBC IS IN EFFECT
  IF( NOCBC>Z ) IWELCB = Z
  !
  ! LOAD MODEL CELLS THAT WILL BE DESCRIBED BY THE LINE FEED
  CALL WELFEED%CELLS(3, Z, NAUX, IPRWEL, BUDGET_GROUPS=WELBUD%BUDGET_GROUPS)     !=>FEED_CELLS(LDIM,NPROP,NAUX,IPRT)
  !
  MXACTW = MXACTW + WELFEED%TOTDAT
  !
  WRITE(IOUT,'(/A /)')'MAXIMUM OF '//NUM2STR(MXACTW)//' ACTIVE WELLS AT ONE TIME'
  !
  IF(IWELCB.LT.Z) WRITE(IOUT,'(A /)') 'CELL-BY-CELL FLOWS WILL BE PRINTED WHEN ICBCFL NOT 0'
  !
  IF(IWELCB.GT.Z) WRITE(IOUT,'(A /)') 'CELL-BY-CELL FLOWS WILL BE SAVED ON UNIT '//NUM2STR(IWELCB)
!
!3A-----THERE ARE FOUR INPUT VALUES PLUS ONE LOCATION FOR
!3A-----CELL-BY-CELL FLOW.
  NWELVL=ONE !5+NAUX  UNDER NEW STRUCTURE ONLY NECESSARY INFORMATION IS READ IN...THAT IS ONLY THE RATE
!
!4------ALLOCATE SPACE FOR THE WELL DATA.
  IWELPB=MXACTW+ONE
  MXWELL=MXACTW+MXPW
  IF(MXACTW.LT.ONE) THEN
     WRITE(IOUT,'(/A)') 'WEL WARNING: Deactivating the Well Package because MXACTW=0'
     CLOSE(IN)
     IN=Z
     MXACTW=Z
     RETURN
  END IF
  !
  CALL READ_TO_DATA(LINE,IN,LOUT)
  LLOC = 1
  CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
  IF(LINE(ISTART:ISTOP).EQ.'SPECIFY') THEN  !NWT Support
         !
         WELSMOOTHING = TRUE
         CALL GET_NUMBER(LINE,LLOC,ISTART,ISTOP,LOUT,IN,PHIRAMP,MSG='FOUND KEYWORD "SPECIFY" WHICH MUST FOLLOW WITH PHIRAMP VALUE, BUT FAILED TO CONVERT IT TO A FLOATING POINT NUMBER.')
         !
         IF(PHIRAMP.LT.1.0E-5) PHIRAMP=1.0D-5;  IF(PHIRAMP.GT.1.0D0 ) PHIRAMP=1.0D0
         !
         CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP,OLD_LOC=LLOC)  !NO UPPER CASE AND STOP AT #, HOLD LLOC AT OLD POSITION
         IF(ISTART >= ISTART) THEN
             !
             CALL IUNITRAMP%OPEN(LINE, LLOC, IOUT, IN, NOBINARY=TRUE)
             !
             IF(.NOT. IUNITRAMP%NULL_FILE) CALL IUNITRAMP%SET_FNAME()
         END IF
  ELSEIF(LINE.NE.BLNK) THEN
      BACKSPACE(IN)
  END IF
  !
  IF(WELSMOOTHING) THEN
      WRITE(IOUT,'(/ 1x A)') 'NEGATIVE PUMPING RATES WILL BE REDUCED IF HEAD  FALLS WITHIN THE INTERVAL PHIRAMP TIMES THE CELL THICKNESS.'//NL//  &
                             'THE VALUE SPECIFIED FOR PHIRAMP IS '//NUM2STR(PHIRAMP)
      IF(IUNITRAMP%NULL_FILE) THEN
                                 WRITE(IOUT,'(A)') 'WELLS WITH REDUCED PUMPING WILL NOT BE REPORTED TO LIST FILE OR EXTERNAL FILE.'      
      ELSEIF(IUNITRAMP%IS_OPEN) THEN
                                WRITE(IOUT,'(/ 1x A /)')  'WELLS WITH REDUCED PUMPING WILL BE REPORTED TO UNIT NUMBER '//   &
                                                           NUM2STR(IUNITRAMP%IU)//' THAT IS ASSOCIATED WITH FILE '//TRIM(IUNITRAMP%FNAME)
      ELSE
         LLOC=1
         CALL IUNITRAMP%OPEN('LIST', LLOC, IOUT, IN) 
         WRITE(IOUT,'(A)') 'WELLS WITH REDUCED PUMPING WILL NOT BE REPORTED TO SEPARATE FILE, BUT INSTEAD WRITTEN TO LIST.'      
      END IF
  END IF
  !
  !ALLOCATE (WELL(NWELVL,MXWELL))
  ALLOCATE(WELDATA(MXWELL))
  DO I=1, MXWELL
                             ALLOCATE(WELDATA(I)%VAL(NWELVL))   !WELL(NWELVL,MXBND) <=> WELDATA(MXBND)%VAL(NWELVL)
    IF(NAUX.GT.Z)            ALLOCATE(WELDATA(I)%AUX(NAUX))
    IF(WELBUD%BUDGET_GROUPS) ALLOCATE(WELDATA(I)%BUDGET_GROUP)
    !
    IF(WELTABFILE%NTAB.GT.Z)THEN
                             ALLOCATE(WELDATA(I)%TABNAM   )
                             ALLOCATE(WELDATA(I)%TSFAC    )
                             !ALLOCATE(WELDATA(I)%TABIDX   )  !had to comment out cause the ANY function would not work on allocatable TABIDX
       IF(WELTABFILE%USE_TABEQN) THEN 
                             ALLOCATE( CHARACTER(100):: WELDATA(I)%TABEQN )
                             ALLOCATE(WELDATA(I)%TABEQNRES)
       ELSE
                             ALLOCATE( CHARACTER(1):: WELDATA(I)%TABEQN )
                             WELDATA(I)%TABEQN=''
       END IF
    END IF
  END DO
!
!5------READ NAMED PARAMETERS.
  WRITE(IOUT,'(/A)')NUM2STR(NPWEL)//' Well parameters'
  LABEL='WELL NO.  LAYER   ROW   COL   STRESS FACTOR'
  IF(NPWEL.GT.Z) THEN
    LSTSUM=IWELPB
    IF(IPRWEL.EQ.1) WRITE(IOUT,'(/ 2A)') ' WEL PACKAGE PARAMETER INFORMATION [BEFORE APPLICATION OF TABFILES]'
    DO K=1,NPWEL
      LSTBEG=LSTSUM
      CALL UPARLSTRP(LSTSUM,MXWELL,IN,IOUT,IP,'WEL','Q',1,NUMINST)
      NLST=LSTSUM-LSTBEG
      IF(NUMINST.EQ.Z) THEN
!5A-----READ PARAMETER WITHOUT INSTANCES.
        CALL ULSTRDSTRUCT(NLST,WELDATA,LSTBEG,NWELVL,MXWELL,IN,IOUT,TRIM(LABEL),WELAUX,20,NAUX,IFREFM,1,1,IPRWEL)
      ELSE
!5B-----READ INSTANCES.
        NINLST=NLST/NUMINST
        DO I=1,NUMINST
           CALL UINSRP(I,IN,IOUT,IP,IPRWEL)
           CALL ULSTRDSTRUCT(NLST,WELDATA,LSTBEG,NWELVL,MXWELL,IN,IOUT,TRIM(LABEL),WELAUX,20,NAUX,IFREFM,1,1,IPRWEL)
           LSTBEG=LSTBEG+NINLST
        END DO
      END IF
    END DO
    !
    IF(WELTABFILE%NTAB.GT.Z) THEN
       DO I=IWELPB, LSTSUM-1 !NNPWEL+IWELPB
           WELDATA(I)%TABIDX=Z
           IF(WELDATA(I)%TABNAM.NE.'     NO_TABFILE     ') THEN
               DO J=1,WELTABFILE%NTAB
                   IF(WELDATA(I)%TABNAM.EQ.WELTABFILE%TABNAM(J)) THEN
                      WELDATA(I)%TABIDX=J
                      EXIT
                   END IF
               END DO
               IF(WELDATA(I)%TABIDX.EQ.Z) WELDATA(I)%TABNAM=' TABFILE_NOT_FOUND  '
           END IF
       END DO
    END IF
  END IF
!
!6------RETURN
  CALL SGWF2WEL8PSV(IGRID)
  !
END SUBROUTINE
!
SUBROUTINE GWF2WEL8RP(IN,IGRID)
!     ******************************************************************
!     READ WELL DATA FOR A STRESS PERIOD
!     ******************************************************************
!
!        SPECIFICATIONS:
!     ------------------------------------------------------------------
  USE GLOBAL,        ONLY:NCOL,NROW,NLAY,IFREFM
  USE GWFWEL2MODULE, ONLY:NWELLS,MXWELL,NWELVL,IPRWEL,NPWEL,IWELPB,  &
                          NNPWEL,WELAUX,WELDATA,WELTABFILE,WELFEED, EOF_WARNING_GIVEN, WELBUD, IOUT, LOUT
  USE UTIL_INTERFACE,ONLY: READ_TO_DATA, STOP_ERROR, GET_NUMBER, GET_INTEGER

  INTEGER,INTENT(IN):: IN
  INTEGER,INTENT(IN):: IGRID

  INTEGER:: ITMP, NP, MXACTW, NAUX, IOUTU, NREAD
  INTEGER:: I, J, N, LLOC, ISTART,ISTOP
  CHARACTER(700):: LINE
  CHARACTER(75)::  LABEL
  CHARACTER(6):: CWELL
  REAL:: R
!  ------------------------------------------------------------------
  CALL SGWF2WEL8PNT(IGRID)

!1----READ NUMBER OF WELLS (OR FLAG SAYING REUSE WELL DATA).
!1----AND NUMBER OF PARAMETERS
  CALL READ_TO_DATA(LINE,IN,LOUT)
  IF (LINE .NE. '') THEN
   LLOC=ONE
   CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IN,ITMP,MSG='WEL PACKAGE FAILED TO LOAD "ITMP"')
   NP=Z
   IF(NPWEL.GT.Z) CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IN,NP,MSG='WEL PACKAGE FAILED TO LOAD "NP"')
  ELSE
   IF(.NOT. EOF_WARNING_GIVEN) THEN
       WRITE(LOUT,'(/A)')"WEL PACKAGE WARNING (don't panic): FAILED TO READ STRESS PERIOD INFORMATION."//NEW_LINE(' ')//  &
      'THIS MAY BE DUE TO THE END OF THE FILE BEING REACHED IN THE WELL PACKAGE FILE.'//NEW_LINE(' ')//                                         &
      'IF YOU ARE USING LINEFEED, THEN THOSE RATES ARE STILL APPLIED AND THE PACKAGE WILL OPERATE NORMALLY.' 
       EOF_WARNING_GIVEN=TRUE
   END IF
   ITMP=Z
   NP=Z
  END IF
  !IF(NPWEL.GT.Z) THEN
  !  IF(IFREFM.EQ.Z) THEN
  !     READ(IN,'(2I10)') ITMP,NP
  !  ELSE
  !     READ(IN,*) ITMP,NP
  !  END IF
  !ELSE
  !   NP=Z
  !   IF(IFREFM.EQ.Z) THEN
  !      READ(IN,'(I10)') ITMP
  !   ELSE
  !      READ(IN,*) ITMP
  !   END IF
  !END IF
!
!------Calculate some constants.
  NAUX=Z
  IF(ALLOCATED(WELDATA(1)%AUX)) NAUX=SIZE(WELDATA(1)%AUX,1)
  
  IOUTU = IOUT
  !IF (IPRWEL.EQ.Z) IOUTU=-IOUTU  seb changed to passing IPR
!
!1A-----IF ITMP LESS THAN ZERO REUSE NON-PARAMETER DATA. PRINT MESSAGE.
!1A-----IF ITMP=>Z, SET NUMBER OF NON-PARAMETER WELLS EQUAL TO ITMP.
  IF(ITMP.LT.Z) THEN
     WRITE(IOUT,'(/A)') 'REUSING NON-PARAMETER WELLS FROM LAST STRESS PERIOD'
  ELSE
     NNPWEL=ITMP
  END IF
  !
  !READ IN NEXT LINE IN LINE_FEED FILE WHICH CONTAINS THE CURRENT STRESS PERIODS DATA
  CALL WELFEED%NEXTLINE()
  !
  IF(NNPWEL==Z .AND. NP==Z .AND. WELFEED%NACT==Z) THEN
    WRITE(IOUT,'(/A/)') 'WEL PACKAGE WARNING: CURRENT STRESS PERIOD DOES NOT CONTAIN ANY WELLS'
  END IF
  !
!
!1B-----IF THERE ARE NEW NON-PARAMETER WELLS, READ THEM.
  MXACTW=IWELPB-ONE
  !
  IF(NNPWEL+WELFEED%NACT .GT. MXACTW) THEN
     CALL STOP_ERROR(LINE,IN,LOUT,                                                                                                                          &
                               MSG='THE NUMBER OF ACTIVE WELLS ('//NUM2STR(NNPWEL+WELFEED%NACT)//') IS GREATER THAN MXACTW ('//NUM2STR(MXACTW)//')'//NEW_LINE(' ')//  &
                                   'WHERE NNPWEL IS '//NUM2STR(NNPWEL)//' AND THE LINE FEED CURRENT ACTIVE COUNT IS '//NUM2STR(WELFEED%NACT)                          )
  END IF
  !
  LABEL='WELL NO.  LAYER   ROW   COL   STRESS RATE'
  IF(ITMP.GT.Z) THEN
     IF(IPRWEL.EQ.1) WRITE(IOUT,'(/ A)') ' WEL PACKAGE STRESS PERIOD INFORMATION [BEFORE APPLICATION OF TABFILES]'
     !
     CALL ULSTRDSTRUCT(NNPWEL,WELDATA,1,NWELVL,MXWELL,IN,IOUT,TRIM(LABEL),WELAUX,20,NAUX,IFREFM,1,1,IPRWEL)
     !
! IF A TABFILE HAS BEEN SPECIFIED BUILD INDEX FOR NONPARAMETER VARIABLES TO WHAT 
! TABFILE IS ASSOCIATED WITH THE PARAMETER
    IF(WELTABFILE%NTAB.GT.Z) THEN
     DO I=1, NNPWEL
       WELDATA(I)%TABIDX=Z
       IF(WELDATA(I)%TABNAM.NE.'     NO_TABFILE     ') THEN
         DO J=1,WELTABFILE%NTAB
           IF(WELDATA(I)%TABNAM.EQ.WELTABFILE%TABNAM(J)) THEN
              WELDATA(I)%TABIDX=J
              EXIT
           END IF
         END DO
         IF(WELDATA(I)%TABIDX.EQ.Z) WELDATA(I)%TABNAM=' TABFILE_NOT_FOUND  '
       END IF
     END DO
    END IF
  END IF
  NWELLS=NNPWEL
  !
  ! APPLY THE NEW DATA TO THE WELL PACKAGE ARRAY
  !
  CALL WELFEED%PAKPROP_APPLY(WELDATA,1,NWELLS,TRIM(LABEL),WELAUX,IPRWEL)
!
!1C-----IF THERE ARE ACTIVE WELL PARAMETERS, READ THEM AND SUBSTITUTE
  CALL PRESET('Q')
  NREAD=NWELVL-1
  IF(NP.GT.Z) THEN
     DO N=1,NP
      CALL UPARLSTSUBSTRUC(IN,'WEL',IOUTU,'Q',WELDATA,NWELVL,MXWELL,MXACTW,NWELLS,1,1,TRIM(LABEL),WELAUX,20,NAUX,IPRWEL)
     END DO
  END IF
  !
  IF (WELBUD%BUDGET_GROUPS) THEN
      CALL WELBUD%RESET()
      DO I=1, NWELLS
          CALL WELBUD%ADD( I, WELDATA(I)%BUDGET_GROUP )
      END DO
  ELSE
          CALL WELBUD%ADD( -NWELLS )
  END IF
!
!3------PRINT NUMBER OF WELLS IN CURRENT STRESS PERIOD.
  CWELL=' WELLS'
  IF(NWELLS.EQ.1) CWELL=' WELL '
  WRITE(IOUT,'(/A)') NUM2STR(NWELLS)//CWELL
  !
END SUBROUTINE
!
SUBROUTINE GWF2WEL8AD(KSTP,IGRID)
!     ******************************************************************
!     IF TABFILES ARE PRESENT APPLY THEM DEVELOPED BY SCOTT E. BOYCE
!     ******************************************************************
!
!        SPECIFICATIONS:
!     ------------------------------------------------------------------
  USE GWFWEL2MODULE, ONLY:NWELLS,WELDATA,WELTABFILE,IPRTWELTAB,IOUT
  USE TABLEFILE_INTERFACE,ONLY: PAK_PROP_TABINTERP
  INTEGER, INTENT(IN):: KSTP, IGRID
! ------------------------------------------------------------------ 
  INTEGER:: IPRT
  !INTEGER,PARAMETER::VLOC=1  --REPLACED WITH "ONE"
  !
  CALL SGWF2WEL8PNT(IGRID)
  !     
  IPRT=Z
  IF(IPRTWELTAB.NE.Z) IPRT=IOUT
  !
  CALL PAK_PROP_TABINTERP(WELDATA,WELTABFILE,NWELLS,ONE,'WEL',KSTP,IPRT)  !ONE = VLOC
  !
END SUBROUTINE
!
SUBROUTINE GWF2WEL8FM(IGRID)   !SCOTT IDEA MAKE SUBTRACTING FROM RHS VECTORIZABLE
!     ******************************************************************
!     SUBTRACT Q FROM RHS
!     ******************************************************************
!
!        SPECIFICATIONS:
!     ------------------------------------------------------------------
  USE GLOBAL,       ONLY:IBOUND,RHS,HCOF,LBOTM,BOTM,HNEW,LAYHDT
  USE GWFWEL2MODULE, ONLY:NWELLS, WELDATA, PHIRAMP,WELSMOOTHING, NWT_SOLVER
  USE GWFNWTMODULE, ONLY: A, IA, Icell
  !
  INTEGER, INTENT(IN):: IGRID
  !
  DOUBLE PRECISION Qp,Hh,Ttop,Bbot,dQp
  REAL:: Q, ZERO
  INTEGER:: IL, IR, IC, L, IJ
! ------------------------------------------------------------------
  CALL SGWF2WEL8PNT(IGRID)
  ZERO=0.0E0
  Qp = 0.0
!
!1------IF NUMBER OF WELLS <= 0 THEN RETURN.
  IF(NWELLS.LE.Z) RETURN
!
!2------PROCESS EACH WELL IN THE WELL LIST.
  WELL_PROCESS: DO L=1,NWELLS
!
!2A------GET WEL PROPERTIES.
    IL=WELDATA(L)%LAY
    IR=WELDATA(L)%ROW
    IC=WELDATA(L)%COL
!
!2B-----IF THE CELL IS INACTIVE THEN BYPASS PROCESSING.
    IF(IBOUND(IC,IR,IL).LE.Z) CYCLE
!
!2C-----PULL THE WELLS PUMPING RATE
    Q=WELDATA(L)%VAL(1)
!
!2B-----IF THE CELL IS VARIABLE HEAD THEN SUBTRACT Q FROM
!       THE RHS ACCUMULATOR.
    IF ( WELSMOOTHING .AND. Q.LT.ZERO) THEN  ! .AND. LAYHDT(IL).NE.Z
       Hh = HNEW(ic,ir,il)
       bbot = Botm(IC, IR, Lbotm(IL))
       ttop = Botm(IC, IR, Lbotm(IL)-1)
       !
       Q = Q*WEL_SMOOTH(PHIRAMP,Hh,Ttop,Bbot)  
       !
       RHS(IC,IR,IL)=RHS(IC,IR,IL)-Q
       !
       IF(NWT_SOLVER) THEN
          ! Derivative for RHS WHEN USING UPW/NWT
          IJ = Icell(IC,IR,IL)
          A(IA(IJ)) = A(IA(IJ)) + WEL_DERIV(PHIRAMP,Hh,Ttop,Bbot)*Q
       END IF
    ELSE
       RHS(IC,IR,IL)=RHS(IC,IR,IL)-Q
    END IF
    !
  END DO WELL_PROCESS
!
!3------RETURN
!
END SUBROUTINE
!
SUBROUTINE GWF2WEL8BD(KSTP,KPER,IGRID)
!     ******************************************************************
!     CALCULATE VOLUMETRIC BUDGET FOR WELLS
!     ******************************************************************
!
!        SPECIFICATIONS:
! ------------------------------------------------------------------
  USE GLOBAL,      ONLY:NCOL,NROW,NLAY,IBOUND,BUFF,BOTM,LBOTM,HNEW,LAYHDT
  USE GWFBASMODULE,ONLY:MSUM,ICBCFL,IAUXSV,DELT,PERTIM,TOTIM,VBVL,VBNM
  USE GWFWEL2MODULE,ONLY:NWELLS,IWELCB,WELDATA,NWELVL,WELAUX,PHIRAMP,IUNITRAMP,IPRWEL,WELSMOOTHING,WELBUD,IOUT
  !
  INTEGER,INTENT(IN)::KSTP, KPER, IGRID
  !
  CHARACTER(16):: TEXT
  DOUBLE PRECISION:: RATIN,RATOUT,QQ,QSAVE
  DOUBLE PRECISION:: Qp,Hh,Ttop,Bbot,dQp
  DOUBLE PRECISION:: DZERO
  REAL:: Q, RIN, ROUT, ZERO
  INTEGER:: IL, IR, IC, IG, IDX
  INTEGER:: IBD, IBDLBL, L, NAUX
  LOGICAL:: RED_Q_HEADER
! ------------------------------------------------------------------
  CALL SGWF2WEL8PNT(IGRID)
!
!1------CLEAR RATIN AND RATOUT ACCUMULATORS, AND SET CELL-BY-CELL
!1------BUDGET FLAG.
  ZERO=0E0
  DZERO=0D0
  !
  IBD=Z
  !TEXT = '           WELLS'
  !
  Qp = 1.0D0
  RED_Q_HEADER=TRUE
  !
  IF(IWELCB.LT.Z .AND. ICBCFL.NE.Z) IBD=-1
  IF(IWELCB.GT.Z) IBD=ICBCFL
  !
  IBDLBL=Z
  !
!
!2-----IF CELL-BY-CELL FLOWS WILL BE SAVED AS A LIST, WRITE HEADER.
  NAUX=Z
  IF(ALLOCATED(WELDATA(1)%AUX)) NAUX=SIZE(WELDATA(1)%AUX,1)
  !
  GROUPS: DO IG=1, WELBUD%NGRP
      RATIN =DZERO
      RATOUT=DZERO
      TEXT = WELBUD%GRP(IG)
      TEXT = ADJUSTR(TEXT)
      !
      IF(IBD.EQ.2) THEN
         IF(IAUXSV.EQ.Z) NAUX=Z
         CALL UBDSV4(KSTP,KPER,TEXT,NAUX,WELAUX,IWELCB,NCOL,NROW,NLAY,WELBUD%DIM(IG),IOUT,DELT,PERTIM,TOTIM,IBOUND)
      END IF
!
!3------IF THERE ARE NO WELLS, DO NOT ACCUMULATE FLOW.
      BUDGET: IF(WELBUD%DIM(IG).EQ.Z) THEN
         VBVL(1,MSUM)=VBVL(1,MSUM)
         VBVL(2,MSUM)=VBVL(2,MSUM)
         VBVL(3,MSUM)=DZERO
         VBVL(4,MSUM)=DZERO
         !
         VBNM(MSUM)=TEXT
         !
         MSUM=MSUM+1               !INCREMENT BUDGET TERM COUNTER(MSUM).
         !
      ELSE
!
!4------CLEAR THE BUFFER.
         BUFF=ZERO
!
!5------LOOP THROUGH EACH WELL CALCULATING FLOW.
         FLOW_CALC: DO IDX=1, WELBUD%DIM(IG)
           L = WELBUD%INDEX(IG,IDX)
!
!5A-----GET LAYER, ROW & COLUMN OF CELL CONTAINING WELL.
           IL=WELDATA(L)%LAY
           IR=WELDATA(L)%ROW
           IC=WELDATA(L)%COL
           !
           Q=ZERO
           QSAVE = DZERO
           bbot = Botm(IC, IR, Lbotm(IL))
           ttop = Botm(IC, IR, Lbotm(IL)-1)
           Hh = HNEW(ic,ir,il)
!
!5B-----IF THE CELL IS NO-FLOW OR CONSTANT HEAD, IGNORE IT.
           ACTIVE_CELL: IF(IBOUND(IC,IR,IL).GT.Z) THEN
!
!5C-----GET FLOW RATE FROM WELL LIST.
                Q=WELDATA(L)%VAL(1)
                !
                QSAVE = DBLE(Q)
                !
                IF ( WELSMOOTHING .AND. Q.LT.ZERO .AND. LAYHDT(IL).NE.Z) THEN
                   Hh = HNEW(ic,ir,il)
                   bbot = Botm(IC, IR, Lbotm(IL))
                   ttop = Botm(IC, IR, Lbotm(IL)-1)
                   !
                   Qp = WEL_SMOOTH(PHIRAMP,Hh,Ttop,Bbot)  
                   Q = REAL(Qp*QSAVE)
                   QQ = Qp*QSAVE
                ELSE
                   QQ = QSAVE
                END IF
!
!5D-----PRINT FLOW RATE IF REQUESTED.
                IF(IBD.LT.Z) THEN
                   IF(IBDLBL.EQ.Z) WRITE(IOUT,'(/ A)') TEXT//'   PERIOD '//NUM2STR(KPER)//'   STEP '//NUM2STR(KSTP)
                   !
                   WRITE(IOUT,'(4(A,I10),2A)') 'WELL ',L,'   LAYER ',IL,'   ROW ',IR,'   COL ',IC,'   RATE ', NUM2STR(Q)
                   !
                   IBDLBL=1
                END IF
!
!5E-----ADD FLOW RATE TO BUFFER.
                BUFF(IC,IR,IL)=BUFF(IC,IR,IL)+Q
!
!5F-----SEE IF FLOW IS POSITIVE OR NEGATIVE.
                IF(Q.GE.ZERO) THEN
!5G-----FLOW RATE IS POSITIVE (RECHARGE). ADD IT TO RATIN.
                  RATIN=RATIN+QQ
                ELSE
!5H-----FLOW RATE IS NEGATIVE (DISCHARGE). ADD IT TO RATOUT.
                  RATOUT=RATOUT-QQ
                END IF
           END IF ACTIVE_CELL
!
!5I-----IF SAVING CELL-BY-CELL FLOWS IN A LIST, WRITE FLOW.  ALSO
!5I-----COPY FLOW TO WELL LIST.
           IF(IBD.EQ.2.AND.NAUX.GT.Z) CALL UBDSVB(IWELCB,NCOL,NROW,IC,IR,IL,Q,REAL(WELDATA(L)%AUX),NAUX,NAUX,1,IBOUND,NLAY)
           !
           IF(IBD.EQ.2.AND.NAUX.EQ.Z) CALL UBDSVB(IWELCB,NCOL,NROW,IC,IR,IL,Q,WELDATA(L)%VAL,NWELVL,NAUX,1,IBOUND,NLAY)
           !
           WELDATA(L)%CBCFLOW=Q
! write wells with reduced pumping
           IF ( WELSMOOTHING .AND. Qp.LT.0.9999D0 .AND. IPRWEL.NE.Z .AND. .NOT. IUNITRAMP%NULL_FILE) THEN
              IF ( RED_Q_HEADER ) THEN
                 WRITE(IUNITRAMP%IU,'(/ A /)')' WELLS WITH REDUCED PUMPING FOR STRESS PERIOD '//NUM2STR(KPER)//' TIME STEP '//NUM2STR(KSTP)//NEW_LINE(' ')//  &
                                           '   LAY   ROW   COL         APPL.Q          ACT.Q        GW-HEAD       CELL-BOT'
                RED_Q_HEADER=FALSE
              END IF
              WRITE(IUNITRAMP%IU,'(3I6,4E15.6)') IL,IR,IC, QSAVE,Q, hh,bbot
           END IF
           !
         END DO FLOW_CALC
         !
         IF ( .NOT. RED_Q_HEADER .AND. .NOT. IUNITRAMP%NULL_FILE ) WRITE(IUNITRAMP%IU,*)  !THERE WAS REDUCED HEAD WRITTEN SO ADD CARRIAGE RETURN
!
!6------IF CELL-BY-CELL FLOWS WILL BE SAVED AS A 3-D ARRAY,
!6------CALL UBUDSV TO SAVE THEM.
         IF(IBD.EQ.1 .AND. WELBUD%DIM(IG).NE.Z) CALL UBUDSV(KSTP,KPER,TEXT,IWELCB,BUFF,NCOL,NROW,NLAY,IOUT)  !SKIPS CALL IF NWELLS=0, THIS IS HOW THE OLD WEL PACKAGE OPERATED TOO
!
!7------MOVE RATES, VOLUMES & LABELS INTO ARRAYS FOR PRINTING.
        RIN=REAL( RATIN)
        ROUT=REAL(RATOUT)
        VBVL(3,MSUM)=RIN
        VBVL(4,MSUM)=ROUT
        VBVL(1,MSUM)=VBVL(1,MSUM)+RIN*DELT
        VBVL(2,MSUM)=VBVL(2,MSUM)+ROUT*DELT
        VBNM(MSUM)=TEXT
!
!8------INCREMENT BUDGET TERM COUNTER(MSUM).
        MSUM=MSUM+ONE
      END IF BUDGET
  END DO GROUPS
  
      
!
!9------RETURN
!
END SUBROUTINE
!
!SUBROUTINE GWF2WEL8BD(KSTP,KPER,IGRID)
!!     ******************************************************************
!!     CALCULATE VOLUMETRIC BUDGET FOR WELLS
!!     ******************************************************************
!!
!!        SPECIFICATIONS:
!! ------------------------------------------------------------------
!  USE GLOBAL,      ONLY:IOUT,NCOL,NROW,NLAY,IBOUND,BUFF,BOTM,LBOTM,HNEW,LAYHDT
!  USE GWFBASMODULE,ONLY:MSUM,ICBCFL,IAUXSV,DELT,PERTIM,TOTIM,VBVL,VBNM
!  USE GWFWEL2MODULE,ONLY:NWELLS,IWELCB,WELDATA,NWELVL,WELAUX,PHIRAMP,IUNITRAMP,IPRWEL,WELSMOOTHING
!  !
!  INTEGER,INTENT(IN)::KSTP, KPER, IGRID
!  !
!  CHARACTER(16):: TEXT
!  DOUBLE PRECISION:: RATIN,RATOUT,QQ,QSAVE
!  DOUBLE PRECISION:: Qp,Hh,Ttop,Bbot,dQp
!  DOUBLE PRECISION:: DZERO
!  REAL:: Q, RIN, ROUT, ZERO
!  INTEGER:: IL, IR, IC
!  INTEGER:: IBD, IBDLBL, L, NAUX
!  LOGICAL:: RED_Q_HEADER
!! ------------------------------------------------------------------
!  CALL SGWF2WEL8PNT(IGRID)
!!
!!1------CLEAR RATIN AND RATOUT ACCUMULATORS, AND SET CELL-BY-CELL
!!1------BUDGET FLAG.
!  ZERO=0E0
!  DZERO=0D0
!  RATIN=DZERO
!  RATOUT=DZERO
!  !
!  IBD=0
!  !TEXT = '           WELLS'
!  !
!  Qp = 1.0D0
!  RED_Q_HEADER=TRUE
!  !
!  IF(IWELCB.LT.0 .AND. ICBCFL.NE.0) IBD=-1
!  IF(IWELCB.GT.0) IBD=ICBCFL
!  !
!  IBDLBL=0
!  !
!!
!!2-----IF CELL-BY-CELL FLOWS WILL BE SAVED AS A LIST, WRITE HEADER.
!  NAUX=0
!  IF(ALLOCATED(WELDATA(1)%AUX)) NAUX=SIZE(WELDATA(1)%AUX,1)
!  !
!  IF(IBD.EQ.2) THEN
!     IF(IAUXSV.EQ.0) NAUX=0
!     CALL UBDSV4(KSTP,KPER,TEXT,NAUX,WELAUX,IWELCB,NCOL,NROW,NLAY,NWELLS,IOUT,DELT,PERTIM,TOTIM,IBOUND)
!  END IF
!!
!!3------IF THERE ARE NO WELLS, DO NOT ACCUMULATE FLOW.
!  IF(NWELLS.EQ.0) THEN
!     VBVL(1,MSUM)=VBVL(1,MSUM)
!     VBVL(2,MSUM)=VBVL(2,MSUM)
!     VBVL(3,MSUM)=DZERO
!     VBVL(4,MSUM)=DZERO
!     !
!     VBNM(MSUM)=TEXT
!     !
!     MSUM=MSUM+1               !INCREMENT BUDGET TERM COUNTER(MSUM).
!     !
!     RETURN
!  END IF
!!
!!4------CLEAR THE BUFFER.
!  BUFF=ZERO
!!
!!5------LOOP THROUGH EACH WELL CALCULATING FLOW.
!  FLOW_CALC: DO L=1,NWELLS
!!
!!5A-----GET LAYER, ROW & COLUMN OF CELL CONTAINING WELL.
!     IL=WELDATA(L)%LAY
!     IR=WELDATA(L)%ROW
!     IC=WELDATA(L)%COL
!     !
!     Q=ZERO
!     QSAVE = DZERO
!     bbot = Botm(IC, IR, Lbotm(IL))
!     ttop = Botm(IC, IR, Lbotm(IL)-1)
!     Hh = HNEW(ic,ir,il)
!!
!!5B-----IF THE CELL IS NO-FLOW OR CONSTANT HEAD, IGNORE IT.
!     ACTIVE_CELL: IF(IBOUND(IC,IR,IL).GT.0) THEN
!!
!!5C-----GET FLOW RATE FROM WELL LIST.
!        Q=WELDATA(L)%VAL(1)
!        !
!        QSAVE = DBLE(Q)
!        !
!        IF ( WELSMOOTHING .AND. Q.LT.ZERO .AND. LAYHDT(IL).NE.0) THEN
!           Hh = HNEW(ic,ir,il)
!           bbot = Botm(IC, IR, Lbotm(IL))
!           ttop = Botm(IC, IR, Lbotm(IL)-1)
!           !
!           Qp = WEL_SMOOTH(PHIRAMP,Hh,Ttop,Bbot)  
!           Q = REAL(Qp)*QSAVE
!           QQ = Qp*QSAVE
!        ELSE
!           QQ = QSAVE
!        END IF
!!
!!5D-----PRINT FLOW RATE IF REQUESTED.
!        IF(IBD.LT.0) THEN
!           IF(IBDLBL.EQ.0) WRITE(IOUT,'(/ A)') TEXT//'   PERIOD '//NUM2STR(KPER)//'   STEP '//NUM2STR(KSTP)
!           !
!           WRITE(IOUT,'(4(A,I10),2A)') 'WELL ',L,'   LAYER ',IL,'   ROW ',IR,'   COL ',IC,'   RATE ', NUM2STR(Q)
!           !
!           IBDLBL=1
!        END IF
!!
!!5E-----ADD FLOW RATE TO BUFFER.
!        BUFF(IC,IR,IL)=BUFF(IC,IR,IL)+Q
!!
!!5F-----SEE IF FLOW IS POSITIVE OR NEGATIVE.
!        IF(Q.GE.ZERO) THEN
!!5G-----FLOW RATE IS POSITIVE (RECHARGE). ADD IT TO RATIN.
!          RATIN=RATIN+QQ
!        ELSE
!!5H-----FLOW RATE IS NEGATIVE (DISCHARGE). ADD IT TO RATOUT.
!          RATOUT=RATOUT-QQ
!        END IF
!     END IF ACTIVE_CELL
!!
!!5I-----IF SAVING CELL-BY-CELL FLOWS IN A LIST, WRITE FLOW.  ALSO33333333333333333333333333333333333333333333333333333333333333333333333333
!!5I-----COPY FLOW TO WELL LIST.
!     IF(IBD.EQ.2.AND.NAUX.GT.0) CALL UBDSVB(IWELCB,NCOL,NROW,IC,IR,IL,Q,REAL(WELDATA(L)%AUX),NAUX,NAUX,1,IBOUND,NLAY)
!     !
!     IF(IBD.EQ.2.AND.NAUX.EQ.0) CALL UBDSVB(IWELCB,NCOL,NROW,IC,IR,IL,Q,WELDATA(L)%VAL,NWELVL,NAUX,1,IBOUND,NLAY)
!     !
!     WELDATA(L)%CBCFLOW=Q
!! write wells with reduced pumping
!     IF ( WELSMOOTHING .AND. Qp.LT.0.9999D0 .AND. IPRWEL.NE.0 ) THEN
!        IF ( RED_Q_HEADER ) THEN
!           WRITE(IUNITRAMP%IU,'(/ A /)')' WELLS WITH REDUCED PUMPING FOR STRESS PERIOD '//NUM2STR(KPER)//' TIME STEP '//NUM2STR(KSTP)//NEW_LINE(' ')//  &
!                                     '   LAY   ROW   COL         APPL.Q          ACT.Q        GW-HEAD       CELL-BOT'
!          RED_Q_HEADER=FALSE
!        END IF
!        WRITE(IUNITRAMP%IU,'(3I6,4E15.6)') IL,IR,IC, QSAVE,Q, hh,bbot
!     END IF
!     !
!  END DO FLOW_CALC
!  !
!  IF ( .NOT. RED_Q_HEADER ) WRITE(IUNITRAMP%IU,*)  !THERE WAS REDUCED HEAD WRITTEN SO ADD CARRIAGE RETURN
!!
!!6------IF CELL-BY-CELL FLOWS WILL BE SAVED AS A 3-D ARRAY,
!!6------CALL UBUDSV TO SAVE THEM.
!  IF(IBD.EQ.1 .AND. NWELLS.NE.0) CALL UBUDSV(KSTP,KPER,TEXT,IWELCB,BUFF,NCOL,NROW,NLAY,IOUT)  !SKIPS CALL IF NWELLS=0, THIS IS HOW THE OLD WEL PACKAGE OPERATED TOO
!!
!!7------MOVE RATES, VOLUMES & LABELS INTO ARRAYS FOR PRINTING.
!  RIN=REAL( RATIN)
!  ROUT=REAL(RATOUT)
!  VBVL(3,MSUM)=RIN
!  VBVL(4,MSUM)=ROUT
!  VBVL(1,MSUM)=VBVL(1,MSUM)+RIN*DELT
!  VBVL(2,MSUM)=VBVL(2,MSUM)+ROUT*DELT
!  VBNM(MSUM)=TEXT
!!
!!8------INCREMENT BUDGET TERM COUNTER(MSUM).
!  MSUM=MSUM+1
!!
!!9------RETURN
!!
!END SUBROUTINE
!
PURE ELEMENTAL FUNCTION WEL_SMOOTH(PHIRAMP,H,T,B,SATTHK) RESULT(Qp)
!     ******************************************************************
!     SMOOTHLY REDUCES PUMPING TO ZERO FOR DEWATERED CONDITIONS
!     ******************************************************************
! PHIRAMP is the fraction of cell thickness for when smoothing occurs
! h is hydraulic head of cell
! T is the top of the cell
! B is the bottom of the cell
! SATTHK is an optional thickness that when present over rides the thickness defined by PHIRAMP*(T-B)
!
  USE CONSTANTS, ONLY: DZ, DNEG
  DOUBLE PRECISION, INTENT(IN) :: PHIRAMP
  DOUBLE PRECISION, INTENT(IN) :: H
  DOUBLE PRECISION, INTENT(IN) :: T
  DOUBLE PRECISION, INTENT(IN) :: B
  DOUBLE PRECISION, INTENT(IN),  OPTIONAL :: SATTHK
  DOUBLE PRECISION:: Qp
  !
  DOUBLE PRECISION s, x, y
  DOUBLE PRECISION cof1, cof2, cof3
  !
  x = (T-B)            !Temp storage of cell thickness
  IF(PHIRAMP > DZ) THEN
      s = PHIRAMP*x
  ELSE
      s = DNEG * PHIRAMP
      IF(s > x) s = x
  END IF
  !
  IF(PRESENT(SATTHK)) THEN
    IF(SATTHK.lt.s) s=SATTHK
  END IF
  !
  x = (H-B)
  IF ( x.LT.0.0D0 ) THEN
    Qp = 0.0D0
  ELSEIF ( x-s.GT.-1.0D-14 ) THEN
    Qp = 1.0D0
  ELSE
    cof1 = x**2.0D0
    cof2 = -(2.0D0*x)/(s**3.0D0)
    cof3 = 3.0D0/(s**2.0D0)
    Qp = cof1*(cof2+cof3)
  END IF
  !
END FUNCTION WEL_SMOOTH
!
PURE ELEMENTAL FUNCTION WEL_DERIV(PHIRAMP,H,T,B,SATTHK)  RESULT(dq) 
!     ******************************************************************
!     CALCULATES DERTIVATIVE FROM SMOOTHLY REDUCES PUMPING
!     TO ZERO FOR DEWATERED CONDITIONS
!     ******************************************************************
! PHIRAMP is the fraction of cell thickness for when smoothing occurs
! h is hydraulic head of cell
! T is the top of the cell
! B is the bottom of the cell
! SATTHK is an optional thickness that when present over rides the thickness defined by PHIRAMP*(T-B)
! RETURNS dq which is the derivative of well conductance with respect to well head
!
  DOUBLE PRECISION, INTENT(IN) :: PHIRAMP
  DOUBLE PRECISION, INTENT(IN) :: H
  DOUBLE PRECISION, INTENT(IN) :: T
  DOUBLE PRECISION, INTENT(IN) :: B
  DOUBLE PRECISION, INTENT(IN),  OPTIONAL :: SATTHK
  DOUBLE PRECISION:: dQ
  !
  DOUBLE PRECISION s, aa, bb, x, y
  !
  s = PHIRAMP*(T-B)
  !
  IF(PRESENT(SATTHK)) THEN
    IF(SATTHK.lt.s) s=SATTHK
  END IF
  !
  x = (H-B)
  IF ( x.LT.0.0D0 ) THEN
    dQ = 0.0D0
  ELSEIF ( x-s.GT.-1.0e-14 ) THEN
    dQ = 0.0D0
  ELSE
    aa = -6.0D0/(s**3.0D0)
    bb = -6.0D0/(s**2.0D0)
    dQ = aa*x**2.0D0-bb*x
  END IF
  !
END FUNCTION WEL_DERIV
!
SUBROUTINE GWF2WEL8DA(IGRID)
!  Deallocate WEL MEMORY
  USE GWFWEL2MODULE
  INTEGER, INTENT(IN):: IGRID
!
  DEALLOCATE(GWFWELDAT(IGRID)%PHIRAMP) 
  DEALLOCATE(GWFWELDAT(IGRID)%NWELLS)
  DEALLOCATE(GWFWELDAT(IGRID)%MXWELL)
  DEALLOCATE(GWFWELDAT(IGRID)%NWELVL)
  DEALLOCATE(GWFWELDAT(IGRID)%IWELCB)
  DEALLOCATE(GWFWELDAT(IGRID)%IPRWEL)
  DEALLOCATE(GWFWELDAT(IGRID)%NPWEL)
  DEALLOCATE(GWFWELDAT(IGRID)%IWELPB)
  DEALLOCATE(GWFWELDAT(IGRID)%NNPWEL)
  DEALLOCATE(GWFWELDAT(IGRID)%WELAUX)
  DEALLOCATE(GWFWELDAT(IGRID)%WELDATA)
  DEALLOCATE(GWFWELDAT(IGRID)%WELTABFILE)
  DEALLOCATE(GWFWELDAT(IGRID)%IPRTWELTAB)
  DEALLOCATE(GWFWELDAT(IGRID)%WELSMOOTHING)
  DEALLOCATE(GWFWELDAT(IGRID)%NWT_SOLVER) 
  DEALLOCATE(GWFWELDAT(IGRID)%EOF_WARNING_GIVEN)
  ! GFORTRAN compiler error work-around for pointer data type FINAL statement
  IUNITRAMP=>GWFWELDAT(IGRID)%IUNITRAMP
  GWFWELDAT(IGRID)%IUNITRAMP=>NULL()
  DEALLOCATE(IUNITRAMP)
  IUNITRAMP=>NULL()
  !
  WELFEED=>GWFWELDAT(IGRID)%WELFEED
  GWFWELDAT(IGRID)%WELFEED=>NULL()
  DEALLOCATE(WELFEED)
  WELFEED=>NULL()
  !
  WELBUD=>GWFWELDAT(IGRID)%WELBUD
  GWFWELDAT(IGRID)%WELBUD=>NULL()
  DEALLOCATE(WELBUD)
  WELBUD=>NULL()
  !DEALLOCATE(GWFWELDAT(IGRID)%IUNITRAMP) 
  !DEALLOCATE(GWFWELDAT(IGRID)%WELFEED)
  !DEALLOCATE(GWFWELDAT(IGRID)%WELBUD)
!
! NULLIFY THE LOCAL POINTERS
  IF(IGRID.EQ.1)THEN
      PHIRAMP     =>NULL()
      IUNITRAMP   =>NULL()
      NWELLS      =>NULL()
      MXWELL      =>NULL()
      NWELVL      =>NULL()
      IWELCB      =>NULL()
      IPRWEL      =>NULL()
      NPWEL       =>NULL()
      IWELPB      =>NULL()
      NNPWEL      =>NULL()
      WELAUX      =>NULL()
      WELDATA     =>NULL()
      WELTABFILE  =>NULL()
      WELFEED     =>NULL()
      IPRTWELTAB  =>NULL()
      WELSMOOTHING=>NULL()
      NWT_SOLVER  =>NULL() 
      EOF_WARNING_GIVEN=>NULL()
      WELBUD => NULL()
  END IF
!
END SUBROUTINE
!
SUBROUTINE SGWF2WEL8PNT(IGRID)
!  Change WEL data to a different grid.
  USE GWFWEL2MODULE
  INTEGER, INTENT(IN):: IGRID
!
  PHIRAMP=>GWFWELDAT(IGRID)%PHIRAMP
  IUNITRAMP=>GWFWELDAT(IGRID)%IUNITRAMP 
  NWELLS=>GWFWELDAT(IGRID)%NWELLS
  MXWELL=>GWFWELDAT(IGRID)%MXWELL
  NWELVL=>GWFWELDAT(IGRID)%NWELVL
  IWELCB=>GWFWELDAT(IGRID)%IWELCB
  IPRWEL=>GWFWELDAT(IGRID)%IPRWEL
  NPWEL=>GWFWELDAT(IGRID)%NPWEL
  IWELPB=>GWFWELDAT(IGRID)%IWELPB
  NNPWEL=>GWFWELDAT(IGRID)%NNPWEL
  WELAUX=>GWFWELDAT(IGRID)%WELAUX
  WELDATA=>GWFWELDAT(IGRID)%WELDATA
  WELTABFILE=>GWFWELDAT(IGRID)%WELTABFILE
  IPRTWELTAB=>GWFWELDAT(IGRID)%IPRTWELTAB
  WELSMOOTHING=>GWFWELDAT(IGRID)%WELSMOOTHING
  WELFEED=>GWFWELDAT(IGRID)%WELFEED
  NWT_SOLVER=>GWFWELDAT(IGRID)%NWT_SOLVER   
  EOF_WARNING_GIVEN=>GWFWELDAT(IGRID)%EOF_WARNING_GIVEN
  WELBUD => GWFWELDAT(IGRID)%WELBUD
!
END SUBROUTINE
!
SUBROUTINE SGWF2WEL8PSV(IGRID)
!  Save WEL data for a grid.
  USE GWFWEL2MODULE
  INTEGER, INTENT(IN):: IGRID
! 
  GWFWELDAT(IGRID)%PHIRAMP=>PHIRAMP
  GWFWELDAT(IGRID)%IUNITRAMP=>IUNITRAMP
  GWFWELDAT(IGRID)%NWELLS=>NWELLS
  GWFWELDAT(IGRID)%MXWELL=>MXWELL
  GWFWELDAT(IGRID)%NWELVL=>NWELVL
  GWFWELDAT(IGRID)%IWELCB=>IWELCB
  GWFWELDAT(IGRID)%IPRWEL=>IPRWEL
  GWFWELDAT(IGRID)%NPWEL=>NPWEL
  GWFWELDAT(IGRID)%IWELPB=>IWELPB
  GWFWELDAT(IGRID)%NNPWEL=>NNPWEL
  GWFWELDAT(IGRID)%WELAUX=>WELAUX
  GWFWELDAT(IGRID)%WELDATA=>WELDATA
  GWFWELDAT(IGRID)%WELTABFILE=>WELTABFILE
  GWFWELDAT(IGRID)%WELFEED=>WELFEED
  GWFWELDAT(IGRID)%IPRTWELTAB=>IPRTWELTAB
  GWFWELDAT(IGRID)%WELSMOOTHING=>WELSMOOTHING
  GWFWELDAT(IGRID)%NWT_SOLVER=>NWT_SOLVER
  GWFWELDAT(IGRID)%EOF_WARNING_GIVEN=>EOF_WARNING_GIVEN
  GWFWELDAT(IGRID)%WELBUD => WELBUD
!
END SUBROUTINE
! 
END MODULE

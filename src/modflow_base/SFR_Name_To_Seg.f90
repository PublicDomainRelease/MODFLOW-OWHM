!
MODULE SFR_INPUT_DATA_TYPES!, ONLY: SFR_NAMED_LOCATION, SFR_SEGRCH_TFR, SFR_SEG_TFR, FMP_FLOW_REMOVE_SFR
  !
  USE CONSTANTS,                        ONLY: DZ, DNEG, NEG, Z, ONE, TWO, NL, BLN, TRUE, FALSE, NEARZERO_29
  USE UTIL_INTERFACE,                   ONLY: STOP_ERROR, READ_TO_DATA, PARSE_WORD_UP, PARSE_WORD, GET_WORD, GET_INTEGER, GET_NUMBER, JOIN_TXT, STR_POS
  USE NUM2STR_INTERFACE,                ONLY: NUM2STR
  USE ALLOC_INTERFACE,                  ONLY: ALLOC
  USE GENERIC_BLOCK_READER_INSTRUCTION, ONLY: GENERIC_BLOCK_READER
  USE GENERIC_INPUT_FILE_INSTRUCTION,   ONLY: GENERIC_INPUT_FILE
  USE LIST_ARRAY_INPUT_INTERFACE,       ONLY: GENERIC_LINE_INPUT
  USE SORT_INTERFACE
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: SFR_NAMED_LOCATION, SFR_SEGRCH_TFR, SFR_SEG_TFR, WBS_SEG_RCH_WT_TFR, FMP_FLOW_REMOVE_SFR
  !
  TYPE SFR_NAMED_LOCATION
      INTEGER:: N = Z
      INTEGER:: IOUT = Z
      CHARACTER(20),DIMENSION(:),   ALLOCATABLE:: NAM
      INTEGER,      DIMENSION(:,:), ALLOCATABLE:: SEG_RCH  !([ISEG, IRCH], N)
      INTEGER,      DIMENSION(:),   ALLOCATABLE:: ISTRM    !(N)
      CONTAINS
      GENERIC::              LOAD          => LOAD_SFR_NAMED_LOCATION, LOAD_SFR_NAMED_LOCATION_BYLINE
      GENERIC::              GET           => SFR_NAMED_LOCATION_LINE_TO_WBSSEGRCH, & !(LINE, LLOC, ISTART, ISTOP, IOUT, IN, WBS, SEG, RCH, [NOID])
                                              SFR_NAMED_LOCATION_LINE_TO_SEGRCH,    & !(LINE, LLOC, ISTART, ISTOP, IOUT, IN,      SEG, RCH, [NOID])
                                              SFR_NAMED_LOCATION_LINE_TO_SEG          !(LINE, LLOC, ISTART, ISTOP, IOUT, IN,      SEG,      [NOID])
      PROCEDURE, PASS(SFR):: POS           => GET_SFR_NAMED_LOCATION_STOP             !(NAM, [ALLOW_ERROR])
      PROCEDURE, PASS(SFR):: GET_POS       => GET_SFR_NAMED_LOCATION                  !(NAM)
      PROCEDURE, PASS(SFR):: NAM2SEGRCH    => SFR_NAMED_LOCATION_TO_SEGRCH!(SFR, NAM, SEG, RCH)
      PROCEDURE, PASS(SFR):: POS_ISTRM     => GET_SFR_NAMED_LOCATION_ISTRM_STOP !( NAM, [ALLOW_ERROR]) 
      PROCEDURE, PASS(SFR):: GET_ISTRM     => GET_SFR_NAMED_LOCATION_ISTRM      !( NAM ) 
      PROCEDURE, PASS(SFR):: BUILD_ISTRM   => SFR_NAMED_LOCATION_BUILD_ISTRM
      PROCEDURE, PASS(SFR):: EXTEND        => EXTEND_SFR_NAMED_LOCATION  !(SFR_EXTEND)
      GENERIC::              ASSIGNMENT(=) => COPY_SFR_NAMED_LOCATION
      PROCEDURE, PASS(SFR):: DESTROY       => DEALLOCATE_SFR_NAMED_LOCATION
      !
      PROCEDURE, PASS(SFR), PRIVATE:: LOAD_SFR_NAMED_LOCATION
      PROCEDURE, PASS(SFR), PRIVATE:: LOAD_SFR_NAMED_LOCATION_BYLINE
      PROCEDURE,            PRIVATE:: COPY_SFR_NAMED_LOCATION
      PROCEDURE, PASS(SFR), PRIVATE:: SFR_NAMED_LOCATION_LINE_TO_WBSSEGRCH !(LINE, LLOC, ISTART, ISTOP, IOUT, IN, WBS, SEG, RCH, [NOID]) 
      PROCEDURE, PASS(SFR), PRIVATE:: SFR_NAMED_LOCATION_LINE_TO_SEGRCH    !(LINE, LLOC, ISTART, ISTOP, IOUT, IN, SEG, RCH, [NOID])
      PROCEDURE, PASS(SFR), PRIVATE:: SFR_NAMED_LOCATION_LINE_TO_SEG       !(LINE, LLOC, ISTART, ISTOP, IOUT, IN, SEG,      [NOID])
      FINAL:: FINAL_SFR_NAMED_LOCATION
  END TYPE
  !
  TYPE, EXTENDS(GENERIC_LINE_INPUT):: WBS_SEG_RCH_WT_TFR !%NEXT()
      INTEGER,          DIMENSION(  :), ALLOCATABLE:: WBS
      INTEGER,          DIMENSION(:,:), ALLOCATABLE:: SR
      DOUBLE PRECISION, DIMENSION(  :), ALLOCATABLE:: WT
  CONTAINS
      PROCEDURE, PASS(GIN):: ALLOC  => ALLOC_FMP_SRD_SEGRCH_TFR!(DIM, WILD_IN, WILD_OUT)
      PROCEDURE, PASS(GIN):: LOAD   => LOAD_FMP_SRD_SEGRCH_TFR !(LOC, LINE, IU, SFR_NAMED_LOCATION) 
      PROCEDURE, PASS(GIN):: DESTROY => DEALLOCATE_FMP_SRD_SEGRCH_TFR
      FINAL:: FINAL_FMP_SRD_SEGRCH_TFR
  END TYPE
  !
  TYPE, EXTENDS(GENERIC_LINE_INPUT):: SFR_SEGRCH_TFR !%NEXT()
      INTEGER, DIMENSION(:,:), ALLOCATABLE:: SEGRCH
  CONTAINS
      PROCEDURE, PASS(GIN):: ALLOC  => ALLOC_SFR_SEGRCH_TFR!(DIM, WILD_IN, WILD_OUT)
      PROCEDURE, PASS(GIN):: LOAD   => LOAD_SFR_SEGRCH_TFR !(LOC, LINE, IU, SFR_NAMED_LOCATION) 
      PROCEDURE, PASS(GIN):: DESTROY => DEALLOCATE_SFR_SEGRCH_TFR
      FINAL:: FINAL_SFR_SEGRCH_TFR
  END TYPE
  !
  TYPE, EXTENDS(GENERIC_LINE_INPUT):: SFR_SEG_TFR !%NEXT()
      INTEGER, DIMENSION(:), ALLOCATABLE:: SEG
  CONTAINS
      PROCEDURE, PASS(GIN):: ALLOC  => ALLOC_SFR_SEG_TFR!(DIM, WILD_IN, WILD_OUT)
      PROCEDURE, PASS(GIN):: LOAD   => LOAD_SFR_SEG_TFR !(LOC, LINE, IU, SFR_NAMED_LOCATION) DESTROY_BASE
      PROCEDURE, PASS(GIN):: DESTROY => DEALLOCATE_SFR_SEG_TFR
      FINAL:: FINAL_SFR_SEG_TFR
  END TYPE
  !
  TYPE FMP_FLOW_REMOVE_SFR !USED TO SET SFR RUNOFF WITH NEGATIVE VALUSE TO SIMULATE REMOVAL
      INTEGER:: N=0, DIM=0
      INTEGER,         DIMENSION(:),ALLOCATABLE:: ISTRM
      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE:: INFLOW
      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE:: REMOVE_INFLOW
      CONTAINS
      PROCEDURE, PASS(SFR):: ALLOC        => ALLOCATE_FMP_FLOW_REMOVE_SFR !(DIM)
      PROCEDURE, PASS(SFR):: RESET        => RESET_FMP_FLOW_REMOVE_SFR    !()
      PROCEDURE, PASS(SFR):: ADD_ISTRM    => ADD_ISTRM_FMP_FLOW_REMOVE_SFR!(ISTRM)
      PROCEDURE, PASS(SFR):: SORT_ISTRM   => SORT_ISTRM_FMP_FLOW_REMOVE_SFR!()
      PROCEDURE, PASS(SFR):: SET_INFLOW   => SET_SFR_INFLOW_FMP_FLOW_REMOVE_SFR!(STRM)
      PROCEDURE, PASS(SFR):: GET_INFLOW   => GET_SFR_INFLOW_FMP_FLOW_REMOVE_SFR!(ISTRM)
      PROCEDURE, PASS(SFR):: SET_TO_INFLOW=> SET_TO_SFR_INFLOW_FMP_FLOW_REMOVE_SFR!(ISTRM, FLOW, LOWER_LIM, UPPER_LIM)
      PROCEDURE, PASS(SFR):: APPLY_DMD    => REMOVE_DEMAND_FROM_SFR_INFLOW!(ISTRM, DMD, FLOW, LOWER_LIM, UPPER_LIM)
      PROCEDURE, PASS(SFR):: APPLY_TO_SFR => APPLY_TO_SFR_FMP_FLOW_REMOVE_SFR!(STRM)
      FINAL:: FINAL_DEALLOCATE_FMP_FLOW_REMOVE_SFR
  END TYPE
  !
  CONTAINS
  !
  SUBROUTINE LOAD_SFR_NAMED_LOCATION(SFR, BL, LLOC, ISTART, ISTOP)
    CLASS(SFR_NAMED_LOCATION),   INTENT(INOUT):: SFR
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    INTEGER,                     INTENT(INOUT):: LLOC, ISTART, ISTOP
    TYPE(GENERIC_INPUT_FILE):: FL
    INTEGER:: P, I, DUM
    LOGICAL:: HAS_ERROR, EOF
    !
    SFR%N = Z
    SFR%IOUT = BL%IOUT
    !
    CALL FL%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,DIM=SFR%N,NO_CONSTANT=TRUE)
    !
    IF(FL%IU==Z) THEN
        IF(SFR%N == Z) THEN
            P = BL%LINE_NUM()
            CALL BL%NEXT()
            DO I=BL%LINE_NUM(), BL%NLINE
                LLOC = ONE
                CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,DUM, HAS_ERROR=HAS_ERROR)
                !
                IF(HAS_ERROR) THEN
                                  EXIT
                ELSE
                                  SFR%N = SFR%N + ONE
                                  CALL BL%NEXT()
                END IF
            END DO
            !
            CALL BL%GOTO_LINE(P)
            CALL BL%DELETE_LINE()  !DELETE THE KEYWORD LINE SFR_NAMES -- MOVE POINTER TO NEXT LINE
            !
            IF(SFR%N == Z)  CALL STOP_ERROR(BL%LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG='WITHIN THE GLOBAL DIMENSION BLOCK FOUND "SFR_NAMES" KEYWORD'//NL//'THAT DID NOT SPECIFIY A DIMENSION (POST GENERIC_INPUT KEYWORD "DIM" FOLLOWED BY THE NUMBER OF NAMES THAT WILL BE LOADED WITH ULOAD).'//NL//'THIS INDICATES THAT FMP SHOULD AUTOCOUNT THE NUMBER OF NAMES, BUT THIS FAILE TO IDENTIFY THAT COUNT'//NL//'(EITHER IT IS EMPTY, END OF BLOCK, OR YOU DO NOT HAVE THE INPUT IN THE FORM OF "ID NAME SEG RCH").')
            !
        END IF
        !
        CALL ALLOC(SFR%NAM,          SFR%N, TRUE)
        CALL ALLOC(SFR%SEG_RCH, TWO, SFR%N)
        CALL ALLOC(SFR%ISTRM,        SFR%N)
        !
        DO I=ONE, SFR%N
            !CALL BL%NEXT()
            LLOC = ONE
            CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,DUM, MSG = 'FAILED TO LOAD "ID" FROM "SFR_NAMES" ULOAD LIST')
            CALL GET_WORD   (BL%LINE,LLOC,ISTART,ISTOP,SFR%NAM(I))
            CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,SFR%SEG_RCH(ONE,I), MSG = 'FAILED TO LOAD "ISEG" FROM "SFR_NAMES" ULOAD LIST')
            CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,SFR%SEG_RCH(TWO,I), MSG = 'FAILED TO LOAD "IRCH" FROM "SFR_NAMES" ULOAD LIST')
            !
            CALL BL%DELETE_LINE()  ! DELETE LINE THAT JUST WAS LOADED
        END DO
    ELSE
        IF(SFR%N == Z) THEN
            DO WHILE (.NOT. EOF)
                !
                CALL READ_TO_DATA(BL%LN, FL%IU, EOF = EOF)
                !
                IF(.NOT. EOF) THEN
                                  LLOC = ONE
                                  CALL GET_INTEGER(BL%LN,LLOC,ISTART,ISTOP,BL%IOUT,FL%IU,DUM, HAS_ERROR=HAS_ERROR)
                                  !
                                  IF(HAS_ERROR) THEN
                                                    EXIT
                                  ELSE
                                                    SFR%N = SFR%N + ONE
                                  END IF
                END IF
            END DO
            !
            CALL FL%REWIND()
            !
            IF(SFR%N == Z)  CALL STOP_ERROR(BL%LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG='WITHIN THE GLOBAL DIMENSION BLOCK FOUND "SFR_NAMES" KEYWORD'//NL//'THAT DID NOT SPECIFIY A DIMENSION (POST GENERIC_INPUT KEYWORD "DIM" FOLLOWED BY THE NUMBER OF NAMES THAT WILL BE LOADED WITH ULOAD).'//NL//'THIS INDICATES THAT FMP SHOULD AUTOCOUNT THE NUMBER OF NAMES, BUT THIS FAILE TO IDENTIFY THAT COUNT'//NL//'(EITHER IT IS EMPTY, END OF BLOCK, OR YOU DO NOT HAVE THE INPUT IN THE FORM OF "ID NAME SEG RCH").')
            !
        END IF
        !
        CALL BL%DELETE_LINE()  !DELETE THE KEYWORD LINE SFR_NAMES -- MOVE POINTER TO NEXT LINE
        !
        CALL ALLOC(SFR%NAM,          SFR%N, TRUE)
        CALL ALLOC(SFR%SEG_RCH, TWO, SFR%N)
        CALL ALLOC(SFR%ISTRM,        SFR%N)
        !
        DO I=ONE, SFR%N
            CALL READ_TO_DATA(BL%LN, FL%IU)
            LLOC = ONE
            CALL GET_INTEGER(BL%LN,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,DUM, MSG = 'FAILED TO LOAD "ID" FROM "SFR_NAMES" ULOAD LIST')
            CALL GET_WORD   (BL%LN,LLOC,ISTART,ISTOP,SFR%NAM(I))
            CALL GET_INTEGER(BL%LN,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,SFR%SEG_RCH(ONE,I), MSG = 'FAILED TO LOAD "ISEG" FROM "SFR_NAMES" ULOAD LIST')
            CALL GET_INTEGER(BL%LN,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,SFR%SEG_RCH(TWO,I), MSG = 'FAILED TO LOAD "IRCH" FROM "SFR_NAMES" ULOAD LIST')
        END DO
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_SFR_NAMED_LOCATION_BYLINE(SFR, IU, IOUT, LINE, LLOC, ISTART, ISTOP, INTERNAL_COUNT)
    CLASS(SFR_NAMED_LOCATION),   INTENT(INOUT):: SFR
    INTEGER,                     INTENT(IN   ):: IU, IOUT
    CHARACTER(*),                INTENT(INOUT):: LINE
    INTEGER,                     INTENT(INOUT):: LLOC, ISTART, ISTOP
    INTEGER,                     INTENT(INOUT):: INTERNAL_COUNT
    TYPE(GENERIC_INPUT_FILE):: FL
    INTEGER:: P, I, DUM, BS, IFIL
    LOGICAL:: HAS_ERROR, EOF
    !
    SFR%N = Z
    SFR%IOUT = IOUT
    !
    CALL FL%OPEN(LINE,LLOC,IOUT,IU,DIM=SFR%N,NO_CONSTANT=TRUE)
    !
    IF(FL%IU==Z) THEN
        IFIL = IU
    ELSE
        IFIL = FL%IU
    END IF
    !
    IF(SFR%N == Z) THEN
        BS = Z
        CALL READ_TO_DATA(LINE, IFIL, EOF = EOF); BS = BS + ONE
        DO WHILE (.NOT. EOF)
            LLOC = ONE
            CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IFIL,DUM, HAS_ERROR=HAS_ERROR)
            !
            IF(HAS_ERROR) THEN
                              EXIT
            ELSE
                              SFR%N = SFR%N + ONE
                              CALL READ_TO_DATA(LINE, IFIL, EOF = EOF); BS = BS + ONE
            END IF
        END DO
        !
        DO I=ONE, BS
                    BACKSPACE(IFIL)
        END DO
        !
        IF(SFR%N == Z)  CALL STOP_ERROR(LINE, INFILE=IFIL, OUTPUT=IOUT, MSG='WITHIN THE GLOBAL DIMENSION BLOCK FOUND "SFR_NAMES" KEYWORD'//NL//'THAT DID NOT SPECIFIY A DIMENSION (POST GENERIC_INPUT KEYWORD "DIM" FOLLOWED BY THE NUMBER OF NAMES THAT WILL BE LOADED WITH ULOAD).'//NL//'THIS INDICATES THAT FMP SHOULD AUTOCOUNT THE NUMBER OF NAMES, BUT THIS FAILE TO IDENTIFY THAT COUNT'//NL//'(EITHER IT IS EMPTY, END OF BLOCK, OR YOU DO NOT HAVE THE INPUT IN THE FORM OF "ID NAME SEG RCH").')
    END IF
    !
    IF(FL%IU==Z) THEN
        INTERNAL_COUNT = SFR%N
    ELSE
        INTERNAL_COUNT = Z
    END IF
    !
    CALL ALLOC(SFR%NAM,          SFR%N, TRUE)
    CALL ALLOC(SFR%SEG_RCH, TWO, SFR%N)
    CALL ALLOC(SFR%ISTRM,        SFR%N)
    !
    DO I=ONE, SFR%N
        !
        CALL READ_TO_DATA(LINE, IFIL, EOF = EOF)
        LLOC = ONE
        CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IFIL,DUM, MSG = 'FAILED TO LOAD "ID" FROM "SFR_NAMES" ULOAD LIST')
        CALL GET_WORD   (LINE,LLOC,ISTART,ISTOP,SFR%NAM(I))
        CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IFIL,SFR%SEG_RCH(ONE,I), MSG = 'FAILED TO LOAD "ISEG" FROM "SFR_NAMES" ULOAD LIST')
        CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IFIL,SFR%SEG_RCH(TWO,I), MSG = 'FAILED TO LOAD "IRCH" FROM "SFR_NAMES" ULOAD LIST')
        !
    END DO
    !
  END SUBROUTINE
  !
  FUNCTION GET_SFR_NAMED_LOCATION_STOP(SFR, NAM, ALLOW_ERROR) RESULT(POS)
    CLASS(SFR_NAMED_LOCATION), INTENT(IN):: SFR
    CHARACTER(*),              INTENT(IN):: NAM
    LOGICAL,     OPTIONAL,     INTENT(IN):: ALLOW_ERROR
    INTEGER:: POS
    INTEGER:: I
    !
    POS = Z
    DO I=ONE, SFR%N
        IF(NAM == SFR%NAM(I)) THEN
            POS = I
            EXIT
        END IF
    END DO
    !
    IF(POS == Z) THEN
        BLOCK
            LOGICAL:: ERR
            ERR = TRUE
            IF(PRESENT(ALLOW_ERROR)) ERR = ALLOW_ERROR
            !
            IF(ERR) CALL STOP_ERROR(OUTPUT=SFR%IOUT, MSG='"SFR_NAMES" FROM GLOBAL DIMENSION ATTEMED TO LOOK FOR THE FOLLOWING SFR NAME "'//TRIM(NAM)//'"'//NL//'BUT FAILED TO LOCATE IT WIHIN THE THE FOLLOWING LIST OF SPECIFIED NAMES (FROM THE GLOBAL DIMENSION BLOCK):'//NL//JOIN_TXT(SFR%NAM,NL,BLN)//'NOTE THAT THIS ERROR COULD HAVE BEEN TRIGGERED IF YOU MEANT TO LOAD A SPECIFIED SEGMENT AND REACH AND THAT FAILED TO LOAD.')
        END BLOCK
    END IF
    !
  END FUNCTION
  !
  PURE FUNCTION GET_SFR_NAMED_LOCATION(SFR, NAM) RESULT(POS)
    CLASS(SFR_NAMED_LOCATION), INTENT(IN):: SFR
    CHARACTER(*),              INTENT(IN):: NAM
    INTEGER:: POS
    INTEGER:: I
    !
    POS = Z
    DO I=ONE, SFR%N
        IF(NAM == SFR%NAM(I)) THEN
            POS = I
            EXIT
        END IF
    END DO
    !
  END FUNCTION
  !
  FUNCTION GET_SFR_NAMED_LOCATION_ISTRM_STOP(SFR, NAM, ALLOW_ERROR) RESULT(POS)
    CLASS(SFR_NAMED_LOCATION), INTENT(IN):: SFR
    CHARACTER(*),              INTENT(IN):: NAM
    LOGICAL,     OPTIONAL,     INTENT(IN):: ALLOW_ERROR
    INTEGER:: POS
    INTEGER:: I
    !
    POS = Z
    DO I=ONE, SFR%N
        IF(NAM == SFR%NAM(I)) THEN
            POS = I
            EXIT
        END IF
    END DO
    !
    IF(POS == Z) THEN
        BLOCK
            LOGICAL:: ERR
            ERR = TRUE
            IF(PRESENT(ALLOW_ERROR)) ERR = ALLOW_ERROR
            !
            IF(ERR) CALL STOP_ERROR(OUTPUT=SFR%IOUT, MSG='"SFR_NAMES" FROM GLOBAL DIMENSION ATTEMED TO LOOK FOR THE FOLLOWING SFR NAME "'//TRIM(NAM)//'"'//NL//'BUT FAILED TO LOCATE IT WIHIN THE THE FOLLOWING LIST OF SPECIFIED NAMES (FROM THE GLOBAL DIMENSION BLOCK):'//NL//JOIN_TXT(SFR%NAM,NL,BLN)//'NOTE THAT THIS ERROR COULD HAVE BEEN TRIGGERED IF YOU MEANT TO LOAD A SPECIFIED SEGMENT AND REACH AND THAT FAILED TO LOAD.')
        END BLOCK
    ELSE
        POS = SFR%ISTRM(POS)
    END IF
    !
  END FUNCTION
  !
  PURE FUNCTION GET_SFR_NAMED_LOCATION_ISTRM(SFR, NAM) RESULT(POS)
    CLASS(SFR_NAMED_LOCATION), INTENT(IN):: SFR
    CHARACTER(*),              INTENT(IN):: NAM
    INTEGER:: POS
    INTEGER:: I
    !
    POS = Z
    DO I=ONE, SFR%N
        IF(NAM == SFR%NAM(I)) THEN
            POS = I
            EXIT
        END IF
    END DO
    !
    IF(POS .NE. Z)  POS = SFR%ISTRM(POS)
    !
  END FUNCTION
  !
  PURE SUBROUTINE SFR_NAMED_LOCATION_TO_SEGRCH(SFR, NAM, SEG, RCH)
    !IF(SEG<Z) CALL STOP_ERROR(OUTPUT=IOUT, MSG='"SFR_NAMES" FROM GLOBAL DIMENSION ATTEMED TO LOOK FOR THE FOLLOWING SFR NAME "'//TRIM(NAM)//'"'//NL//'BUT FAILED TO LOCATE IT WIHIN THE THE FOLLOWING LIST OF SPECIFIED NAMES (FROM THE GLOBAL DIMENSION BLOCK):'//NL//JOIN_TXT(SFR%NAM,NL,BLN)//'NOTE THAT THIS ERROR COULD HAVE BEEN TRIGGERED IF YOU MEANT TO LOAD A SPECIFIED SEGMENT AND REACH AND THAT FAILED TO LOAD.')
    CLASS(SFR_NAMED_LOCATION), INTENT(IN   ):: SFR
    CHARACTER(*),              INTENT(IN   ):: NAM
    INTEGER,                   INTENT(  OUT):: SEG, RCH
    INTEGER:: I
    !
    SEG = NEG
    RCH = NEG
    DO I=ONE, SFR%N
        IF(NAM == SFR%NAM(I)) THEN
            SEG = SFR%SEG_RCH(ONE,I)
            RCH = SFR%SEG_RCH(TWO,I)
            EXIT
        END IF
    END DO
    !
    IF( SEG == NEG .AND. (NAM == 'FULLY' .OR. NAM == 'SKIP') ) THEN
          SEG = Z
          RCH = Z
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE SFR_NAMED_LOCATION_BUILD_ISTRM(SFR, NSEG, SEG_NSTRM)
    !IF(SEG<Z) CALL STOP_ERROR(OUTPUT=IOUT, MSG='"SFR_NAMES" FROM GLOBAL DIMENSION ATTEMED TO LOOK FOR THE FOLLOWING SFR NAME "'//TRIM(NAM)//'"'//NL//'BUT FAILED TO LOCATE IT WIHIN THE THE FOLLOWING LIST OF SPECIFIED NAMES (FROM THE GLOBAL DIMENSION BLOCK):'//NL//JOIN_TXT(SFR%NAM,NL,BLN)//'NOTE THAT THIS ERROR COULD HAVE BEEN TRIGGERED IF YOU MEANT TO LOAD A SPECIFIED SEGMENT AND REACH AND THAT FAILED TO LOAD.')
    CLASS(SFR_NAMED_LOCATION),        INTENT(INOUT):: SFR
    INTEGER,                          INTENT(IN   ):: NSEG
    INTEGER, DIMENSION(:),CONTIGUOUS, INTENT(IN   ):: SEG_NSTRM
    INTEGER:: I, SEG, RCH
    !
    IF(NSEG > Z) THEN  ! NSEG = SIZE(SEG_NSTRM) - ONE
       !         
       DO I=ONE, SFR%N
           SEG = SFR%SEG_RCH(ONE,I)
           RCH = SFR%SEG_RCH(TWO,I)
           !
           IF (NSEG < SEG) CALL STOP_ERROR(OUTPUT=SFR%IOUT, MSG='"SFR_NAMES" FROM GLOBAL DIMENSION HAD THE SFR NAME "'//TRIM(SFR%NAM(I))//'"'//NL//'BUT THE SEGMENT IT IS ASSOCIATED WITH, "'//NUM2STR(SEG)//'" IS GREATER THEN SFR NSEG: '//NUM2STR(NSEG))
           !
           IF (RCH  > SEG_NSTRM(SEG+1)-SEG_NSTRM(SEG)) CALL STOP_ERROR(OUTPUT=SFR%IOUT, MSG='"SFR_NAMES" FROM GLOBAL DIMENSION HAD THE SFR NAME "'//TRIM(SFR%NAM(I))//'"'//NL//'BUT THE SEGMENT IT IS ASSOCIATED WITH, "'//NUM2STR(SEG)//'" HAS A REACH, "'//NUM2STR(RCH)//'" THAT IS GREATER THEN THE NUMBER OF REACHES FOR THAT SEGMENT: '//NUM2STR(SEG_NSTRM(SEG+1)-SEG_NSTRM(SEG)))
           !
       END DO
       !
       DO I=ONE, SFR%N
           SEG = SFR%SEG_RCH(ONE,I)
           RCH = SFR%SEG_RCH(TWO,I)
           !
           IF (RCH < ONE) RCH = ONE
           !
           SFR%ISTRM(I) = SEG_NSTRM(SEG) + RCH
       END DO
       !
    ELSE
        CALL DEALLOCATE_SFR_NAMED_LOCATION(SFR)
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE SFR_NAMED_LOCATION_LINE_TO_WBSSEGRCH(SFR, LINE, LLOC, ISTART, ISTOP, IOUT, IN, WBS, SEG, RCH, NOID)
    !IF(SEG<Z) CALL STOP_ERROR(OUTPUT=IOUT, MSG='"SFR_NAMES" FROM GLOBAL DIMENSION ATTEMED TO LOOK FOR THE FOLLOWING SFR NAME "'//TRIM(NAM)//'"'//NL//'BUT FAILED TO LOCATE IT WIHIN THE THE FOLLOWING LIST OF SPECIFIED NAMES (FROM THE GLOBAL DIMENSION BLOCK):'//NL//JOIN_TXT(SFR%NAM,NL,BLN)//'NOTE THAT THIS ERROR COULD HAVE BEEN TRIGGERED IF YOU MEANT TO LOAD A SPECIFIED SEGMENT AND REACH AND THAT FAILED TO LOAD.')
    CLASS(SFR_NAMED_LOCATION), INTENT(IN   ):: SFR
    CHARACTER(*),              INTENT(INOUT):: LINE
    INTEGER,                   INTENT(INOUT):: LLOC, ISTART, ISTOP
    INTEGER,                   INTENT(IN   ):: IOUT, IN
    INTEGER,                   INTENT(  OUT):: WBS, SEG, RCH
    LOGICAL,  OPTIONAL,        INTENT(IN   ):: NOID
    INTEGER:: I
    !
    !TO BY PASS READING ID OR TO READ IT (JUST MOVE PAST IT)
    IF(PRESENT(NOID)) THEN; IF(.NOT. NOID) CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP)  !BYPASS INTEGER ID
    ELSE;                                  CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP)
    END IF
    !
    CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IN,WBS, MSG = 'FAILED TO THE WBS/FID NUMBER ON LINE')
    !
    IF(WBS > Z) THEN
        !
        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)   !LOAD SFR_NAME OR ISEG --PARSE_WORD ALLOWS FOR UPCASE
        !
        SEG = NEG
        RCH = NEG
        DO I=ONE, SFR%N
            IF(LINE(ISTART:ISTOP) == SFR%NAM(I)) THEN
                SEG = SFR%SEG_RCH(ONE,I)
                RCH = SFR%SEG_RCH(TWO,I)
                EXIT
            END IF
        END DO
        !
        IF(SEG == NEG) THEN
                IF(LINE(ISTART:ISTOP) == 'FULLY' .OR. LINE(ISTART:ISTOP) == 'SKIP') THEN
                    SEG = Z
                    RCH = Z
                ELSEIF(SFR%N > Z) THEN
                    CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IN,SEG, NO_PARSE_WORD=TRUE, MSG = 'FAILED TO EITHER LOCATE THE SFR_NAME AMONG THE SFR_NAMES LIST OR LOAD THE SFR "SEGMENT" NUMBER FROM LINE')
                    CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IN,RCH,                     MSG = 'FAILED TO EITHER LOCATE THE SFR_NAME AMONG THE SFR_NAMES LIST OR LOAD THE SFR "REACH" NUMBER FROM LINE')
                ELSE
                    CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IN,SEG, NO_PARSE_WORD=TRUE, MSG = 'FAILED TO LOAD THE SFR "SEGMENT" NUMBER FROM LINE')
                    CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IN,RCH,                     MSG = 'FAILED TO LOAD THE SFR "REACH" NUMBER FROM LINE')
                END IF
        END IF
        !
        IF(SEG == Z) THEN
            WBS = Z
            RCH = Z
        END IF
    ELSE
        SEG = Z
        RCH = Z
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE SFR_NAMED_LOCATION_LINE_TO_SEGRCH(SFR, LINE, LLOC, ISTART, ISTOP, IOUT, IN, SEG, RCH, NOID)
    !IF(SEG<Z) CALL STOP_ERROR(OUTPUT=IOUT, MSG='"SFR_NAMES" FROM GLOBAL DIMENSION ATTEMED TO LOOK FOR THE FOLLOWING SFR NAME "'//TRIM(NAM)//'"'//NL//'BUT FAILED TO LOCATE IT WIHIN THE THE FOLLOWING LIST OF SPECIFIED NAMES (FROM THE GLOBAL DIMENSION BLOCK):'//NL//JOIN_TXT(SFR%NAM,NL,BLN)//'NOTE THAT THIS ERROR COULD HAVE BEEN TRIGGERED IF YOU MEANT TO LOAD A SPECIFIED SEGMENT AND REACH AND THAT FAILED TO LOAD.')
    CLASS(SFR_NAMED_LOCATION), INTENT(IN   ):: SFR
    CHARACTER(*),              INTENT(INOUT):: LINE
    INTEGER,                   INTENT(INOUT):: LLOC, ISTART, ISTOP
    INTEGER,                   INTENT(IN   ):: IOUT, IN
    INTEGER,                   INTENT(  OUT):: SEG, RCH
    LOGICAL,  OPTIONAL,        INTENT(IN   ):: NOID
    INTEGER:: I
    !
    !TO BY PASS READING ID OR TO READ IT (JUST MOVE PAST IT)
    IF(PRESENT(NOID)) THEN; IF(.NOT. NOID) CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP)  !BYPASS INTEGER ID
    ELSE;                                  CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP)
    END IF
    !
    CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)   !LOAD SFR_NAME OR ISEG -- PARSE_WORD ALLOWS FOR UPCASE
    !
    SEG = NEG
    RCH = NEG
    DO I=ONE, SFR%N
        IF(LINE(ISTART:ISTOP) == SFR%NAM(I)) THEN
            SEG = SFR%SEG_RCH(ONE,I)
            RCH = SFR%SEG_RCH(TWO,I)
            EXIT
        END IF
    END DO
    !
    IF(SEG == NEG) THEN
            IF(LINE(ISTART:ISTOP) == 'FULLY' .OR. LINE(ISTART:ISTOP) == 'SKIP') THEN
                SEG = Z
                RCH = Z
            ELSEIF(SFR%N > Z) THEN
                CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IN,SEG, NO_PARSE_WORD=TRUE, MSG = 'FAILED TO EITHER LOCATE THE SFR_NAME AMONG THE SFR_NAMES LIST OR LOAD THE SFR "SEGMENT" NUMBER FROM LINE')
                CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IN,RCH,                     MSG = 'FAILED TO EITHER LOCATE THE SFR_NAME AMONG THE SFR_NAMES LIST OR LOAD THE SFR "REACH" NUMBER FROM LINE')
            ELSE
                CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IN,SEG, NO_PARSE_WORD=TRUE, MSG = 'FAILED TO LOAD THE SFR "SEGMENT" NUMBER FROM LINE')
                CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IN,RCH,                     MSG = 'FAILED TO LOAD THE SFR "REACH" NUMBER FROM LINE')
            END IF
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE SFR_NAMED_LOCATION_LINE_TO_SEG(SFR, LINE, LLOC, ISTART, ISTOP, IOUT, IN, SEG, NOID)
    !IF(SEG<Z) CALL STOP_ERROR(OUTPUT=IOUT, MSG='"SFR_NAMES" FROM GLOBAL DIMENSION ATTEMED TO LOOK FOR THE FOLLOWING SFR NAME "'//TRIM(NAM)//'"'//NL//'BUT FAILED TO LOCATE IT WIHIN THE THE FOLLOWING LIST OF SPECIFIED NAMES (FROM THE GLOBAL DIMENSION BLOCK):'//NL//JOIN_TXT(SFR%NAM,NL,BLN)//'NOTE THAT THIS ERROR COULD HAVE BEEN TRIGGERED IF YOU MEANT TO LOAD A SPECIFIED SEGMENT AND REACH AND THAT FAILED TO LOAD.')
    CLASS(SFR_NAMED_LOCATION), INTENT(IN   ):: SFR
    CHARACTER(*),              INTENT(INOUT):: LINE
    INTEGER,                   INTENT(INOUT):: LLOC, ISTART, ISTOP
    INTEGER,                   INTENT(IN   ):: IOUT, IN
    INTEGER,                   INTENT(  OUT):: SEG
    LOGICAL,  OPTIONAL,        INTENT(IN   ):: NOID
    INTEGER:: I
    !
    !TO BY PASS READING ID OR TO READ IT (JUST MOVE PAST IT)
    IF(PRESENT(NOID)) THEN; IF(.NOT. NOID) CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP)  !BYPASS INTEGER ID
    ELSE;                                  CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP)
    END IF
    !
    CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)   !LOAD SFR_NAME OR ISEG -- PARSE_WORD ALLOWS FOR UPCASE
    !
    SEG = NEG
    DO I=ONE, SFR%N
        IF(LINE(ISTART:ISTOP) == SFR%NAM(I)) THEN
            SEG = SFR%SEG_RCH(ONE,I)
            EXIT
        END IF
    END DO
    !
    IF(SEG == NEG) THEN
            IF(LINE(ISTART:ISTOP) == 'FULLY' .OR. LINE(ISTART:ISTOP) == 'SKIP') THEN
                SEG = Z
            ELSEIF(SFR%N > Z) THEN
                CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IN,SEG, NO_PARSE_WORD=TRUE, MSG = 'FAILED TO EITHER LOCATE THE SFR_NAME AMONG THE SFR_NAMES LIST OR LOAD THE SFR "SEGMENT" NUMBER FROM LINE')
            ELSE
                CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IN,SEG, NO_PARSE_WORD=TRUE, MSG = 'FAILED TO LOAD THE SFR "SEGMENT" NUMBER FROM LINE')
            END IF
    END IF
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_SFR_NAMED_LOCATION(SFR_OUT, SFR_IN)
    CLASS(SFR_NAMED_LOCATION),INTENT(INOUT)::SFR_OUT
    CLASS(SFR_NAMED_LOCATION),INTENT(IN   )::SFR_IN
    !
    SFR_OUT%N = SFR_IN%N
    IF(SFR_OUT%N > Z) THEN
        !
        CALL ALLOC(SFR_OUT%NAM,          SFR_IN%N, SRC = SFR_IN%NAM)
        CALL ALLOC(SFR_OUT%SEG_RCH, TWO, SFR_IN%N, SRC = SFR_IN%SEG_RCH)
        CALL ALLOC(SFR_OUT%ISTRM,        SFR_IN%N, SRC = SFR_IN%ISTRM)
        !
    END IF
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE EXTEND_SFR_NAMED_LOCATION(SFR, SFR_IN)
    CLASS(SFR_NAMED_LOCATION),INTENT(INOUT)::SFR
    CLASS(SFR_NAMED_LOCATION),INTENT(IN   )::SFR_IN
    !
    CHARACTER(20),DIMENSION(:),   ALLOCATABLE:: NAM
    INTEGER,      DIMENSION(:,:), ALLOCATABLE:: SEG_RCH
    INTEGER,      DIMENSION(:),   ALLOCATABLE:: ISTRM  
    INTEGER:: I, INEW
    !
    IF(SFR_IN%N > Z) THEN
       !
       IF(SFR%N == Z) THEN
           !
           CALL COPY_SFR_NAMED_LOCATION(SFR, SFR_IN)
       ELSE
           INEW = SFR_IN%N
           DO I=ONE, SFR_IN%N
              !
              IF(STR_POS(SFR_IN%NAM(I), SFR%NAM) > Z)  INEW = INEW - ONE !FOUND STRING
           END DO
           !
           IF(INEW > Z) THEN
               !
               INEW = SFR%N + INEW  !New Dimension
               !
               CALL ALLOC(NAM,          INEW)
               CALL ALLOC(SEG_RCH, TWO, INEW)
               CALL ALLOC(ISTRM,        INEW)
               !
               NAM                  = SFR%NAM     
               SEG_RCH(:,:SFR%N) = SFR%SEG_RCH
               ISTRM                = SFR%ISTRM  
               !
               DO I=ONE, SFR_IN%N
                   !
                   IF(STR_POS(SFR_IN%NAM(I), SFR%NAM) == Z) THEN
                       !
                       SFR%N = SFR%N + ONE
                       !
                       NAM    (  SFR%N) = SFR_IN%NAM    (  I) 
                       SEG_RCH(:,SFR%N) = SFR_IN%SEG_RCH(:,I)
                       ISTRM  (  SFR%N) = SFR_IN%ISTRM  (  I)
                   END IF
               END DO
               !
               CALL MOVE_ALLOC(NAM    , SFR%NAM    )
               CALL MOVE_ALLOC(SEG_RCH, SFR%SEG_RCH)
               CALL MOVE_ALLOC(ISTRM  , SFR%ISTRM  )
           END IF
       END IF
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_SFR_NAMED_LOCATION(SFR)
    CLASS(SFR_NAMED_LOCATION), INTENT(INOUT):: SFR
    !
    SFR%N = Z
    SFR%IOUT = Z
    IF(ALLOCATED(SFR%NAM    )) DEALLOCATE(SFR%NAM    )
    IF(ALLOCATED(SFR%SEG_RCH)) DEALLOCATE(SFR%SEG_RCH)
    !
  END SUBROUTINE
  !
  SUBROUTINE FINAL_SFR_NAMED_LOCATION(SFR)
    TYPE(SFR_NAMED_LOCATION), INTENT(INOUT):: SFR
    !
    CALL DEALLOCATE_SFR_NAMED_LOCATION(SFR)
    !
  END SUBROUTINE
  !
  !-------------------------------------------------------------------
  !
  SUBROUTINE ALLOC_SFR_SEGRCH_TFR(GIN, DIM, WILD_IN, WILD_OUT, WILD_1D_IN, WILD_1D_OUT)
    CLASS(SFR_SEGRCH_TFR),                           INTENT(INOUT):: GIN
    INTEGER,     DIMENSION(:),           CONTIGUOUS, INTENT(IN   ):: DIM
    CLASS(*),    OPTIONAL,                           INTENT(IN   ):: WILD_IN  !ANY OPTIONAL DATA TYPE THAT MAYBE SET OR NECESSARY TO PASS IN (WILD CARD)
    CLASS(*),    OPTIONAL,                           INTENT(INOUT):: WILD_OUT
    CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(IN   ):: WILD_1D_IN
    CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(INOUT):: WILD_1D_OUT
    !
    ALLOCATE(GIN%SEGRCH(DIM(ONE),DIM(TWO)), SOURCE=Z)
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_SFR_SEGRCH_TFR(GIN, LLOC, LINE, IU, WILD_IN, WILD_OUT, WILD_1D_IN, WILD_1D_OUT) !WILD_IN ==> SFR_NAMED_LOCATION
    CLASS(SFR_SEGRCH_TFR),                           INTENT(INOUT):: GIN
    INTEGER,                                         INTENT(INOUT):: LLOC
    CHARACTER(*),                                    INTENT(INOUT):: LINE
    INTEGER,                                         INTENT(IN   ):: IU
    CLASS(*),    OPTIONAL,                           INTENT(IN   ):: WILD_IN  !ANY OPTIONAL DATA TYPE THAT MAYBE SET OR NECESSARY TO PASS IN (WILD CARD)
    CLASS(*),    OPTIONAL,                           INTENT(INOUT):: WILD_OUT
    CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(IN   ):: WILD_1D_IN
    CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(INOUT):: WILD_1D_OUT
    INTEGER:: ISTART, ISTOP, I
    !
    IF(IU == Z) THEN
        CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP) !NO NEED TO UPCASE CAUSE IT WILL ALREADY BE SO
        SELECT CASE(LINE(ISTART:ISTOP))
        CASE('REPEAT'  ); CONTINUE  !DO NOTHING
        CASE('SKIP'    ); GIN%SEGRCH = Z
        CASE('CONSTANT'); 
                          CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,GIN%IOUT,IU,GIN%SEGRCH(ONE,ONE),  MSG='FOUND KEYWORD "CONSTANT", WHICH MUST BE FOLLOWED BY AN INTEGER. FAILED TO LOAD THE INTEGER.')
                          ISTART = GIN%SEGRCH(ONE,ONE)
                          GIN%SEGRCH = ISTART
                          !CALL STOP_ERROR( LINE=LINE, OUTPUT=GIN%IOUT, MSG= 'LOAD SFR SEGMENT AND REACH ERROR: THIS INPUT DOES NOT ALLOW FOR THE KEYWORD "CONSTANT". PLEASE USE A KEYWORD TO INDICATE WHERE DATA IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)')
        CASE DEFAULT
                          CALL STOP_ERROR( LINE=LINE, OUTPUT=GIN%IOUT, INFILE=IU, MSG= 'LOAD SFR SEGMENT AND REACH ERROR: THIS INPUT DOES NOT ALLOW FOR IMPLIED INTERNAL LOADING. PLEASE USE A KEYWORD TO INDICATE WHERE DATA IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)')
        END SELECT
    ELSE
        SELECT TYPE(SFR=>WILD_IN)
        TYPE IS(SFR_NAMED_LOCATION)
                              DO I=ONE, SIZE(GIN%SEGRCH,TWO)
                                                 CALL READ_TO_DATA(LINE, IU)
                                                 LLOC = ONE                                               !          ISEG               IRCH
                                                 CALL SFR%GET(LINE, LLOC, ISTART, ISTOP, GIN%IOUT, IU, GIN%SEGRCH(ONE,I), GIN%SEGRCH(TWO,I))
                              END DO
        END SELECT
    END IF
   ! 
  END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_SFR_SEGRCH_TFR(GIN)
    CLASS(SFR_SEGRCH_TFR), INTENT(INOUT):: GIN
    !
    CALL GIN%DESTROY_BASE()
    !
    IF(ALLOCATED(GIN%SEGRCH)) DEALLOCATE(GIN%SEGRCH)
    !
  END SUBROUTINE
  !
  SUBROUTINE FINAL_SFR_SEGRCH_TFR(GIN)
    TYPE(SFR_SEGRCH_TFR), INTENT(INOUT):: GIN
    !
    CALL DEALLOCATE_SFR_SEGRCH_TFR(GIN)
    !
  END SUBROUTINE
  !
  SUBROUTINE ALLOC_SFR_SEG_TFR(GIN, DIM, WILD_IN, WILD_OUT, WILD_1D_IN, WILD_1D_OUT)
    CLASS(SFR_SEG_TFR),                              INTENT(INOUT):: GIN
    INTEGER,     DIMENSION(:),           CONTIGUOUS, INTENT(IN   ):: DIM
    CLASS(*),    OPTIONAL,                           INTENT(IN   ):: WILD_IN  !ANY OPTIONAL DATA TYPE THAT MAYBE SET OR NECESSARY TO PASS IN (WILD CARD)
    CLASS(*),    OPTIONAL,                           INTENT(INOUT):: WILD_OUT
    CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(IN   ):: WILD_1D_IN
    CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(INOUT):: WILD_1D_OUT
    !
    ALLOCATE(GIN%SEG(DIM(ONE)), SOURCE=Z)
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_SFR_SEG_TFR(GIN, LLOC, LINE, IU, WILD_IN, WILD_OUT, WILD_1D_IN, WILD_1D_OUT) !WILD_IN ==> SFR_NAMED_LOCATION
    CLASS(SFR_SEG_TFR),                              INTENT(INOUT):: GIN
    INTEGER,                                         INTENT(INOUT):: LLOC
    CHARACTER(*),                                    INTENT(INOUT):: LINE
    INTEGER,                                         INTENT(IN   ):: IU
    CLASS(*),    OPTIONAL,                           INTENT(IN   ):: WILD_IN  !ANY OPTIONAL DATA TYPE THAT MAYBE SET OR NECESSARY TO PASS IN (WILD CARD)
    CLASS(*),    OPTIONAL,                           INTENT(INOUT):: WILD_OUT
    CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(IN   ):: WILD_1D_IN
    CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(INOUT):: WILD_1D_OUT
    INTEGER:: ISTART, ISTOP, I
    !
    IF(IU == Z) THEN
        CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP) !NO NEED TO UPCASE CAUSE IT WILL ALREADY BE SO
        SELECT CASE(LINE(ISTART:ISTOP))
        CASE('REPEAT'  ); CONTINUE  !DO NOTHING
        CASE('SKIP','NUL','NULL','NAN');     GIN%SEG = Z
        CASE('CONSTANT'); 
                          CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,GIN%IOUT,IU,I,  MSG='FOUND KEYWORD "CONSTANT", WHICH MUST BE FOLLOWED BY AN INTEGER. FAILED TO LOAD THE INTEGER.')
                          GIN%SEG = I
                          !CALL STOP_ERROR( LINE=LINE, OUTPUT=GIN%IOUT, MSG= 'LOAD SFR SEGMENT AND REACH ERROR: THIS INPUT DOES NOT ALLOW FOR THE KEYWORD "CONSTANT". PLEASE USE A KEYWORD TO INDICATE WHERE DATA IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)')
        CASE DEFAULT
                          CALL STOP_ERROR( LINE=LINE, OUTPUT=GIN%IOUT, INFILE=IU, MSG= 'LOAD SFR SEGMENT AND REACH ERROR: THIS INPUT DOES NOT ALLOW FOR IMPLIED INTERNAL LOADING. PLEASE USE A KEYWORD TO INDICATE WHERE DATA IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)')
        END SELECT
    ELSE
        SELECT TYPE(SFR=>WILD_IN)
        TYPE IS(SFR_NAMED_LOCATION)
                              DO I=ONE, SIZE(GIN%SEG)
                                                 CALL READ_TO_DATA(LINE, IU)
                                                 LLOC = ONE                                       !       ISEG
                                                 CALL SFR%GET(LINE, LLOC, ISTART, ISTOP, GIN%IOUT, IU, GIN%SEG(I))
                              END DO
        END SELECT
    END IF
    ! 
  END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_SFR_SEG_TFR(GIN)
    CLASS(SFR_SEG_TFR), INTENT(INOUT):: GIN
    !
    CALL GIN%DESTROY_BASE()
    !
    IF(ALLOCATED(GIN%SEG)) DEALLOCATE(GIN%SEG)
    !
  END SUBROUTINE
  !
  SUBROUTINE FINAL_SFR_SEG_TFR(GIN)
    TYPE(SFR_SEG_TFR), INTENT(INOUT):: GIN
    !
    CALL DEALLOCATE_SFR_SEG_TFR(GIN)
    !
  END SUBROUTINE
  !
  !-------------------------------------------------------------------
  !
  SUBROUTINE ALLOC_FMP_SRD_SEGRCH_TFR(GIN, DIM, WILD_IN, WILD_OUT, WILD_1D_IN, WILD_1D_OUT)
    CLASS(WBS_SEG_RCH_WT_TFR),                       INTENT(INOUT):: GIN
    INTEGER,               DIMENSION(:), CONTIGUOUS, INTENT(IN   ):: DIM
    CLASS(*),    OPTIONAL,                           INTENT(IN   ):: WILD_IN    !ANY OPTIONAL DATA TYPE THAT MAYBE SET OR NECESSARY TO PASS IN (WILD CARD)
    CLASS(*),    OPTIONAL,                           INTENT(INOUT):: WILD_OUT
    CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(IN   ):: WILD_1D_IN
    CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(INOUT):: WILD_1D_OUT
    !
    ALLOCATE(GIN%WBS(     DIM(ONE)), SOURCE=Z)
    ALLOCATE(GIN%SR (TWO, DIM(ONE)), SOURCE=Z)
    ALLOCATE(GIN%WT(      DIM(ONE)), SOURCE=DZ)
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_FMP_SRD_SEGRCH_TFR(GIN, LLOC, LINE, IU, WILD_IN, WILD_OUT, WILD_1D_IN, WILD_1D_OUT) !WILD_IN ==> SFR_NAMED_LOCATION
    CLASS(WBS_SEG_RCH_WT_TFR),                       INTENT(INOUT):: GIN
    INTEGER,                                         INTENT(INOUT):: LLOC
    CHARACTER(*),                                    INTENT(INOUT):: LINE
    INTEGER,                                         INTENT(IN   ):: IU
    CLASS(*),    OPTIONAL,                           INTENT(IN   ):: WILD_IN  !ANY OPTIONAL DATA TYPE THAT MAYBE SET OR NECESSARY TO PASS IN (WILD CARD)
    CLASS(*),    OPTIONAL,                           INTENT(INOUT):: WILD_OUT
    CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(IN   ):: WILD_1D_IN
    CLASS(*),    OPTIONAL, DIMENSION(:), CONTIGUOUS, INTENT(INOUT):: WILD_1D_OUT
    INTEGER:: ISTART, ISTOP, I
    !
    IF(IU == Z) THEN
        CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP) !NO NEED TO UPCASE CAUSE IT WILL ALREADY BE SO
        !
        SELECT CASE(LINE(ISTART:ISTOP))
        CASE('REPEAT'  ); CONTINUE  !DO NOTHING
        CASE('SKIP'    )
                          GIN%WBS = Z
                          GIN%SR  = Z
                          GIN%WT  = DZ
        CASE('CONSTANT')
                          CALL STOP_ERROR( LINE=LINE, OUTPUT=GIN%IOUT, MSG= 'LOAD FMP SFR SEMI-ROUTED DELIVERY SEGMENT AND REACH ERROR: THIS INPUT DOES NOT ALLOW FOR THE KEYWORD "CONSTANT". PLEASE USE A KEYWORD TO INDICATE WHERE DATA IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)')
        CASE DEFAULT
                          CALL STOP_ERROR( LINE=LINE, OUTPUT=GIN%IOUT, INFILE=IU, MSG= 'LOAD FMP SFR SEMI-ROUTED DELIVERY SEGMENT AND REACH ERROR: THIS INPUT DOES NOT ALLOW FOR IMPLIED INTERNAL LOADING. PLEASE USE A KEYWORD TO INDICATE WHERE DATA IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)')
        END SELECT
    ELSE
        SELECT TYPE(SFR=>WILD_IN)
        TYPE IS(SFR_NAMED_LOCATION)
                              DO I=ONE, SIZE(GIN%WBS,ONE)
                                                 CALL READ_TO_DATA(LINE, IU)
                                                 LLOC = ONE                                            !           ISEG           IRCH
                                                 CALL SFR%GET(LINE, LLOC, ISTART, ISTOP, GIN%IOUT, IU, GIN%WBS(I), GIN%SR(ONE,I), GIN%SR(TWO,I))
                                                 !
                                                 IF(GIN%WBS(I) > Z) THEN
                                                     CALL GET_NUMBER(LINE,LLOC,ISTART,ISTOP, GIN%IOUT, IU, GIN%WT(I),  ERROR_VAL = DNEG) !MSG='LOAD FMP SFR SEMI-ROUTED DELIVERY (SRD) ERROR: FAILED TO LOAD THE FRACTION OF TOTAL DEMAND/RANK PART OF SRD. THIS FRACTION IS THE PORTION OF TOTAL DEMAND EACH SRD ATTEMPTS TO PROVIDE WITH SUPPLY.'
                                                 ELSE
                                                     GIN%WT(I) = DZ
                                                 END IF
                              END DO
        END SELECT
    END IF
    ! 
  END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_FMP_SRD_SEGRCH_TFR(GIN)
    CLASS(WBS_SEG_RCH_WT_TFR), INTENT(INOUT):: GIN
    !
    CALL GIN%DESTROY_BASE()
    !
    IF(ALLOCATED(GIN%WBS)) DEALLOCATE(GIN%WBS)
    IF(ALLOCATED(GIN%SR )) DEALLOCATE(GIN%SR )
    IF(ALLOCATED(GIN%WT )) DEALLOCATE(GIN%WT )
    !
  END SUBROUTINE
  !
  SUBROUTINE FINAL_FMP_SRD_SEGRCH_TFR(GIN)
    TYPE(WBS_SEG_RCH_WT_TFR), INTENT(INOUT):: GIN
    !
    CALL DEALLOCATE_FMP_SRD_SEGRCH_TFR(GIN)
    !
  END SUBROUTINE
  !
  !-------------------------------------------------------------------
  !
  SUBROUTINE ALLOCATE_FMP_FLOW_REMOVE_SFR(SFR,DIM)
    CLASS(FMP_FLOW_REMOVE_SFR),  INTENT(INOUT):: SFR
    INTEGER,                     INTENT(IN   ):: DIM
    !
    SFR%DIM = DIM
    SFR%N   = Z
    !
    ALLOCATE(SFR%ISTRM(DIM))
    ALLOCATE(SFR%INFLOW(DIM))
    ALLOCATE(SFR%REMOVE_INFLOW(DIM))
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE RESET_FMP_FLOW_REMOVE_SFR(SFR)
    CLASS(FMP_FLOW_REMOVE_SFR),  INTENT(INOUT):: SFR
    INTEGER:: I
    !
    DO CONCURRENT(I=ONE:SFR%DIM); SFR%ISTRM(I) = Z
    END DO
    !
    SFR%N = Z
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ADD_ISTRM_FMP_FLOW_REMOVE_SFR(SFR, ISTRM)
    CLASS(FMP_FLOW_REMOVE_SFR),  INTENT(INOUT):: SFR
    INTEGER,                     INTENT(IN   ):: ISTRM
    INTEGER:: I
    LOGICAL:: NOT_FOUND
    !
    IF(ISTRM > Z) THEN
        NOT_FOUND = TRUE
        DO CONCURRENT(I=ONE:SFR%N, ISTRM == SFR%ISTRM(I)); NOT_FOUND = FALSE
        END DO
        !
        IF(NOT_FOUND) THEN
            SFR%N = SFR%N + ONE
            SFR%ISTRM(SFR%N) = ISTRM
        END IF
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SORT_ISTRM_FMP_FLOW_REMOVE_SFR(SFR)
    CLASS(FMP_FLOW_REMOVE_SFR),  INTENT(INOUT):: SFR
    !
    IF(SFR%N>ONE) CALL SORT( SFR%N, SFR%ISTRM(1:SFR%N) )
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_SFR_INFLOW_FMP_FLOW_REMOVE_SFR(SFR, STRM)
    CLASS(FMP_FLOW_REMOVE_SFR),          INTENT(INOUT):: SFR
    REAL,    DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: STRM
    INTEGER:: I
    !
    DO CONCURRENT(I=ONE:SFR%N)
        SFR%INFLOW(I) = STRM(10, SFR%ISTRM(I)) !INFLOW TO CURRENT REACH
    END DO
    !
    DO CONCURRENT(I=ONE:SFR%N, SFR%INFLOW(I) < NEARZERO_29)
        SFR%INFLOW(I) = DZ
    END DO
    !
    DO CONCURRENT(I=ONE:SFR%N)
        SFR%REMOVE_INFLOW(I) = DZ !RESET
    END DO
    !
  END SUBROUTINE
  !
  PURE FUNCTION GET_SFR_INFLOW_FMP_FLOW_REMOVE_SFR(SFR, ISTRM) RESULT(FLOW)
    CLASS(FMP_FLOW_REMOVE_SFR),  INTENT(IN):: SFR
    INTEGER,                     INTENT(IN):: ISTRM
    DOUBLE PRECISION::  FLOW
    INTEGER:: I
    !
    FLOW = DZ
    IF(SFR%N > Z) THEN
       DO CONCURRENT(I=ONE:SFR%N, ISTRM == SFR%ISTRM(I)); FLOW = SFR%INFLOW(I)
       END DO
    END IF
    !
    IF(FLOW < DZ) FLOW = DZ
    !
  END FUNCTION
  !
  PURE SUBROUTINE SET_TO_SFR_INFLOW_FMP_FLOW_REMOVE_SFR(SFR, ISTRM, FLOW, LOWER_LIM, UPPER_LIM)
    CLASS(FMP_FLOW_REMOVE_SFR),  INTENT(IN):: SFR
    INTEGER,                     INTENT(IN):: ISTRM
    DOUBLE PRECISION,            INTENT(INOUT):: FLOW
    DOUBLE PRECISION,            INTENT(IN   ):: LOWER_LIM, UPPER_LIM
    INTEGER:: I
    !
    FLOW = DZ
    IF(SFR%N > Z) THEN
       DO CONCURRENT(I=ONE:SFR%N, ISTRM == SFR%ISTRM(I)); FLOW = SFR%INFLOW(I)
       END DO
    END IF
    !
    IF    (FLOW <= LOWER_LIM) THEN
                                 FLOW = DZ
    ELSEIF(FLOW >  UPPER_LIM) THEN
                                 FLOW = UPPER_LIM
    ELSEIF(FLOW < DZ) THEN
                                 FLOW = DZ
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE REMOVE_DEMAND_FROM_SFR_INFLOW(SFR, ISTRM, DMD, FLOW, LOWER_LIM, UPPER_LIM, MAXDEL) !DMD IS POSTITIVE TO INDICATE REMOVING
    CLASS(FMP_FLOW_REMOVE_SFR),  INTENT(INOUT):: SFR
    INTEGER,                     INTENT(IN   ):: ISTRM
    DOUBLE PRECISION,            INTENT(IN   ):: DMD
    DOUBLE PRECISION,            INTENT(INOUT):: FLOW
    DOUBLE PRECISION,            INTENT(IN   ):: LOWER_LIM, UPPER_LIM
    DOUBLE PRECISION, OPTIONAL,  INTENT(INOUT):: MAXDEL
    INTEGER:: I, P
    DOUBLE PRECISION:: INFLOW
    !
    DO I=ONE, SFR%N
        IF(ISTRM == SFR%ISTRM(I)) THEN
            P = I
            EXIT
        END IF
    END DO
    !
    IF(SFR%INFLOW(P) > UPPER_LIM) THEN  !CHECK UPPER BOUND FLOW
        INFLOW =  UPPER_LIM
    ELSE
        INFLOW = SFR%INFLOW(P)
    END IF
    !
    IF(INFLOW <= LOWER_LIM) THEN
        INFLOW = DZ
    ELSE
        INFLOW = INFLOW - LOWER_LIM
    END IF
    !
    IF(PRESENT(MAXDEL)) THEN
                        MAXDEL = INFLOW
                        IF(MAXDEL < DZ) MAXDEL = DZ
    END IF
    !
    IF    (INFLOW <= DZ) THEN
                                FLOW = DZ
    ELSEIF(INFLOW <= DMD) THEN
                                FLOW = INFLOW
    ELSE
                                FLOW = DMD
    END IF
    !
    IF(FLOW > DZ) THEN
        SFR%INFLOW(P)        = SFR%INFLOW(P)        - FLOW
        SFR%REMOVE_INFLOW(P) = SFR%REMOVE_INFLOW(P) + FLOW
    END IF
    !
  END SUBROUTINE
  !
  !!!PURE SUBROUTINE REMOVE_DEMAND_FROM_SFR_INFLOW(SFR, ISTRM, DMD, FLOW) !DMD IS POSTITIVE TO INDICATE REMOVING
  !!!  CLASS(FMP_FLOW_REMOVE_SFR),  INTENT(INOUT):: SFR
  !!!  INTEGER,                     INTENT(IN   ):: ISTRM
  !!!  DOUBLE PRECISION,            INTENT(IN   ):: DMD
  !!!  DOUBLE PRECISION,            INTENT(INOUT):: FLOW
  !!!  INTEGER:: I, P
  !!!  !
  !!!  DO I=ONE, SFR%N
  !!!      IF(ISTRM == SFR%ISTRM(I)) THEN
  !!!          P = I
  !!!          EXIT
  !!!      END IF
  !!!  END DO
  !!!  !
  !!!  IF    (SFR%INFLOW(P) <= DZ) THEN
  !!!                              FLOW = DZ
  !!!  ELSEIF(SFR%INFLOW(P) - DMD < DZ) THEN
  !!!                              FLOW = SFR%INFLOW(P)
  !!!                              SFR%INFLOW(P) = DZ
  !!!  ELSE
  !!!      FLOW = DMD
  !!!      SFR%INFLOW(P) = SFR%INFLOW(P) - DMD
  !!!  END IF
  !!!  !
  !!!  IF(FLOW > DZ) SFR%REMOVE_INFLOW(P) = SFR%REMOVE_INFLOW(P) + FLOW
  !!!  !
  !!!END SUBROUTINE
  !
  PURE SUBROUTINE APPLY_TO_SFR_FMP_FLOW_REMOVE_SFR(SFR, STRM)
    CLASS(FMP_FLOW_REMOVE_SFR),          INTENT(IN   ):: SFR
    REAL,    DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: STRM
    INTEGER:: I
    !
    IF(SFR%N > Z) THEN
        DO CONCURRENT(I=ONE:SFR%N)
            !
            STRM(12,SFR%ISTRM(I)) = STRM(12,SFR%ISTRM(I)) - SFR%REMOVE_INFLOW(I)
            !
        END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE FINAL_DEALLOCATE_FMP_FLOW_REMOVE_SFR(SFR)
    TYPE(FMP_FLOW_REMOVE_SFR),  INTENT(INOUT):: SFR
    !
    IF(ALLOCATED(SFR%ISTRM )) DEALLOCATE(SFR%ISTRM )
    IF(ALLOCATED(SFR%INFLOW)) DEALLOCATE(SFR%INFLOW)
    !
    SFR%DIM = Z
    SFR%N   = Z
    !
  END SUBROUTINE
  !
END MODULE
! CODE DEVELOPED BY SCOTT E BOYCE
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
! MODULE TABLEFILE_INTERFACE
!  DESIGNED TO TAKE IN A LIST OF VARIABLE VALUES AND EVALUTE
!  VERSION 1.1 [5/30/2014] ADDED THE ABILITY TO EITHER READ ENTIRE TABFILE IN OR (NEW PART)
!                          ONLY THE PORTION THAT PERTAINS TO THE CURRENT TIME STEP VIA FILEIO FLAG
!  VERSION 1.0 [8/01/2013] ORIGINAL VERSION THAT RETURNS A TABFILE DATATYPE, READS TABFILE INFORMATION,
!                          RETURNS TO APPROPIATE LOCATION A DATA VALUE
!
C DATA TREE
      !TABIDX,PACIDX,CHARID,LRCIDX,TSFAC ARE ALL ONE TO ONE, WHERE EACH ROW RELATES THE SAME INFORMATION.
      !THE NUMBER OR ROWS EQUALS TO THE NUMBER OF FEATURES THAT ARE LINKED TO A TABFILE (e.g. ONE FEATURE WOUDL BE A SINGLE SFR SEGMENT LINKED TO A TABFILE)
      !THE TOTAL NUMBER OF THE ROWS IS REFEREND AS "NLNK" IN CODE
      !TABIDX IS A POINTER OF TO THE TABFILE THAT IS ASSOCITED WITH THE FEATURE
      !
      !TABNAM, TAB  ARE ALL ONE TO ONE, WHERE EACH ROW RELATES THE SAME INFORMATION.
      !EACH ROW REPRESENTS A SEPARATE TABFILE THAT IS POITNED TO BY TABIDX
      !THE TOTAL NUMBER OF THE ROWS IS REFEREND AS "NTAB" IN CODE
      !
      !TIM, DAT ARE ALL ONE TO ONE. EACH ROW REPRESENTS A SEPARATE ENTRY POINTED TO BY POS FOR A SPECIFIC TABFILE POITNED TO BY TABIDX
      !THE TOTAL NUMBER OF THE ROWS IS REFEREND AS "NVAL" IN CODE

      MODULE TABLEFILE_INTERFACE
      !
      USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: REAL32, REAL64
      !
      USE CONSTANTS,                 ONLY: Z, ONE, TRUE, FALSE, NL
      USE DATE_OPERATOR_INSTRUCTION, ONLY: DATE_OPERATOR
      USE NUM2STR_INTERFACE,         ONLY: NUM2STR
      USE UTIL_INTERFACE,            ONLY: GET, PARSE_WORD,
     +                               WARNING_MESSAGE, READ_TO_DATA,
     +                               FILE_IO_ERROR, STOP_ERROR
      USE GENERIC_OPEN_INTERFACE,    ONLY: UTF8_BOM_OFFSET_REWIND
      IMPLICIT NONE
      !
      PRIVATE:: Z, ONE, TRUE, FALSE, NL, DATE_OPERATOR
      PRIVATE:: FILE_IO_ERROR,STOP_ERROR,UTF8_BOM_OFFSET_REWIND,
     +                       WARNING_MESSAGE, READ_TO_DATA,
     +                       NUM2STR, GET, PARSE_WORD
      PRIVATE:: REAL32, REAL64
      !
      TYPE TABARRAY
        INTEGER::POS                                                    !HOLDS CURRENT POSITION IN TABFILE. THIS PREVENTS SEARCHING THROUGH SIMULATION TIMES THAT HAVE PASSED
        LOGICAL::USEVAL                                                 !FLAG TO TELL IF TABFILE HAS ALREADY BEEN INTERPOLATED TO CURRENT TIME STEP. THIS PREVENTS UNNECESSARY
        INTEGER::FILEIO                                                 !FLAG TO TELL IF TABFILE IS TREATED AS OPEN FILE OR ENTIRELY READ, IF ZERO ALL DATA IS READ IN. IF NONZERO THEN IS UNIT NUMBER OF TABFILE
        DOUBLE PRECISION::VAL                                           !HOLDS CURRENT INTERPOLATED TABFILE VALUE IF USEVAL=.TRUE.
        DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE::TIM,DAT              !TABFILE INFORMATION WHERE TIM HOLDS THE TIME AND DAT HOLDS THE VALUES/DATA
      END TYPE
      !
      TYPE TABFILETYPE                                                  !ALL ARRAYS HERE ARE DIMENSION NTAB. ARRAYS TABNAM AND TAB ARE ONE TO ONE AND ARE POINTED TO BY TABIDX
        INTEGER::NTAB=Z                                                 !NUMBER OF TABFILES HELD IN TABFILETYPE
        CHARACTER(20), DIMENSION(:),ALLOCATABLE::TABNAM                 !NAME/ID ASSOCIATED WITH EACH TABFILE. HAS DIM OF TABNAM(NTAB)
        TYPE(TABARRAY),DIMENSION(:),ALLOCATABLE::TAB                    !DATA TYPE THAT HOLDS ALLTABFILE INFORMATION. HAS DIM OF TABFILE%TAB(NTAB) AND A REFERENCE WOULD BE AS TABFILE%TAB(ITAB)%DAT(IVAL)
        LOGICAL::SIMTIME                                                !FLAG TO INDICATE THAT THE SIMULATED TIME AND DIS SPECIFIED UNITS ARE USED. IF FALSE THEN CODE WILL USE THE STARTTIME VALUE AND DECIMAL YEAR
        LOGICAL::TABPRINT                                               !FLAG TO INDICATE THAT DETAILED PRINTOUT IS REQUESTED
        LOGICAL::USE_TABEQN                                             !FLAG TO INDICATE THAT AN EQUATION WILL BE READ AFTER THE TSFAC THAT USES THE EXPRESSION PARSER TO CALCULATE THE RESULT FROM THE TAB.
        LOGICAL::IGNORE_TIME                                            !FLAG THAT WHEN TRUE CAUSES THE TABFILE TIMES TO BE IGNORED AND ASSUMES A ONE TO ONE RELATIONSHIP
        LOGICAL::SPBASIS                                                 !FLAG TO INDICATE THAT TABFILE TIMES WILL BE INTERPOLTED BASED ON A STRESS PERIOD RATHER THAN THE TIME STEP
        LOGICAL::STEP_FUNCTION
      END TYPE
      !
      TYPE, EXTENDS (TABFILETYPE):: TABFILETYPELINKS                    !ALL ARRAYS HERE ARE DIMENSION NLNK (NUMBER OF LINKED FEATURES TO TABS). THEY ALL HAVE A ONE TO ONE MAPPING OF THEIR ROWS.
        CHARACTER(:),    DIMENSION(:),ALLOCATABLE:: TABEQN
        DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE:: TABEQNRES
        DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE:: TSFAC               !SCALE FACTOR THAT IS APPLIED TO INTERPOLATED TABFILE RESULT
        INTEGER,         DIMENSION(:),ALLOCATABLE:: TABIDX              !LOCATION IN TABFILETYPE OF CORRECT TABFILE. FOR EXAMPLE TABFILE%TAB( TABFILE%TABIDX(1) ) WOULD GET THE TABFILE FOR THE FIRST REFERENCED TABLINK. THE TABLINK IS THE FEATURE OF THE PACKAGE THAT IS LINKED TO A TABFILE (e.g. THE FIRST SFR SEGMENT THAT IS LINKED TO A TABFILE)
        INTEGER,         DIMENSION(:),ALLOCATABLE:: PACIDX              !INDEX OF THE LOCATION OF THE FEATURE FROM A PACKAGE. SET TO ZERO WHEN FEATURE IS NOT USED
        !
!        CONTAINS
!        FINAL:: DEALLOCATE=>TABFILE_DEALLOCATE
      END TYPE
      !
      TYPE, EXTENDS (TABFILETYPELINKS):: TABFILETYPE1IDX                !TABFILE DEFINED BY 1 INTEGER INDEX. HAS ONE TO ONE MATCHING WITH TABFILETYPELINKS
        INTEGER,      DIMENSION(:),ALLOCATABLE:: ONEIDX                 !ARRAY THAT HOLDS UNIQUE ID FOR PACKAGE THAT IS USED TO LINK THE PACKAGE FEATURE TO A ROW IN STORAGE. MOST PACKAGES USE THE ROW NUMBER AS THE SAME AS THE UNIQUE ID, LIKE IN SFR ISEG IS THE SEGMENT NUMBER AND COLUMN IN THE MATRIX
      END TYPE
      !
      TYPE, EXTENDS (TABFILETYPELINKS):: TABFILETYPECHARIDX             !TABFILE DEFINED BY A CHARACTER VARIABLE AND NEEDS TO MATCH AN INTEGER INDEX. HAS ONE TO ONE MATCHING WITH TABFILETYPELINKS
        CHARACTER(20),DIMENSION(:),ALLOCATABLE:: CHARID                 !CHARACTER THAT HOLDS THE ID OF THE FEATURE OF THE PACKAGE THAT IS BEING LINKED TO A TABFILE
      END TYPE
      !
      TYPE, EXTENDS (TABFILETYPELINKS):: TABFILETYPE3IDX                !TABFILE DEFINED BY 3 INTEGER INDEX (LAY,ROW,COL) AND IS CONVERTED TO A UNIQUE NUMBER. HAS ONE TO ONE MATCHING WITH TABFILETYPELINKS
        INTEGER,      DIMENSION(:),ALLOCATABLE:: LRCIDX                 !ARRAY THAT HOLDS UNIQUE ID FOR LAY, ROW, AND COL AS DEFINED AS LRCIDX = COL + NCOL*(ROW-1) + NCOL*NROW*(LAY-1)
      END TYPE
      !
      INTERFACE TABFILEUPDATE                                           !CALL TABFILEUPDATE(TABFILE,PACK, [S/D]RESULT )
C       MODULE PROCEDURES ARE DUMMY ROUTINES THAT LINK TO SUBROUTINE TABFILEUPDATER
C       SUBROUTINE TABFILEUPDATE ASSUMES THAT PACIDX HAS BEEN CONTRUCTED.
C       LOOK THROUGH ALL LINKS AND INTERPOLATE THEIR APPROPIATE TABFILES
C       IF TABFILE PRINTING IS REQUESTED THEN PRINTS TABFILE RESULTS
C       VARIABLE LIST:
C       TABFILE: TABFILE THAT WILL BE UPDATED FOR TIMESTEP
C       PACK   : STRING THAT IS PASSED IN THAT IDENTIFIES THE CALLING PACKAGE. FOR EXAMPE PACK='WEL' OR 'SFR'
C       SRESULT: IS A SINGLE PRECISION ARRAY THAT IF PRESENT WILL HAVE THE TABFILE VALUE AND SCALE FACTORE APPLIED TO ITS PACKIDX LOCATION
C       DRESULT: IS A DOUBLE PRECISION ARRAY THAT IF PRESENT WILL HAVE THE TABFILE VALUE AND SCALE FACTORE APPLIED TO ITS PACKIDX LOCATION
        MODULE PROCEDURE TABFILEUPDATE_S!(TABFILE,PACK, SRESULT )
        MODULE PROCEDURE TABFILEUPDATE_D!(TABFILE,PACK, DRESULT )
      END INTERFACE
      !
      CONTAINS
      !
      SUBROUTINE TABFILEPARSE(IN,IOUT,LINE,TABFILE,IGNORE_TAB_FLAG_IN)
C     ******************************************************************
C     GENERIC TABFILE INTERFACE AND READIN DEVELOPED BY SCOTT E. BOYCE
C     ALLOCATE AND READ TABEFILE INFORMATION IF TABFILE FLAG IS FOUND
C     IF TABFILE IS **NOT** PRESENT THEN THE DERIVED DATA TYPE, TABFILE,
C     IS ALLOCATED AND TABFILE%NTAB IS SET TO 0
C
C     ******************************************************************
C
C        SPECIFICATIONS:
C     ------------------------------------------------------------------
      USE GLOBAL,            ONLY:IUNIT,CUNIT
      USE GWFBASMODULE,      ONLY:REALTIM
      CLASS(TABFILETYPE)::TABFILE
      INTEGER:: IN,IOUT
      LOGICAL,OPTIONAL::IGNORE_TAB_FLAG_IN
      CHARACTER(*) LINE
C     LOCAL VARIABLES
      CHARACTER(250)::FNAME
      CHARACTER(20)::TABNAM
      CHARACTER(8) :: EXT
      INTEGER::LLOC,ISTART,ISTOP
      INTEGER::I,J,N,FN,NVAL,NTAB,PACKID,FILEIO
      REAL:: R
      DOUBLE PRECISION::VAL,T
      LOGICAL:: LVAL,IGNORE_TAB_FLAG, EOF
      TYPE(DATE_OPERATOR):: DATE
C     ------------------------------------------------------------------
C     SET FLAG CHECK FLAG (WHEN PRESENT AND TRUE THE KEYWORD 'TABFILE' IS READ BUT IGNORED THIS ADDS FLEXIBILITY SO THAT THE KEYWORD CAN BE ANYTHING)
      IGNORE_TAB_FLAG=FALSE
      IF(PRESENT(IGNORE_TAB_FLAG_IN))
     +                      IGNORE_TAB_FLAG = IGNORE_TAB_FLAG_IN
C
C     FIND CALLING PACKAGE
      N=Z
      DO I=ONE,UBOUND(IUNIT,1)
        N=N+ONE
        IF(IUNIT(I).EQ.IN) EXIT
      END DO
      IF(N.EQ.Z)THEN
          PACKID=UBOUND(IUNIT,1)
      ELSE
          PACKID=N
      END IF
      !
C     CHECK IF TABFILE IS SPECIFIED FOR SPECIFIC PACKAGE
C     IF NOT SPECIFIED ALLOCATE AND RETURN
      LLOC=ONE
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,IN)
      NTAB=Z
      IF(LINE(ISTART:ISTOP).EQ.'TABFILE' .OR. IGNORE_TAB_FLAG) THEN
        CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NTAB,R,IOUT,IN)
        CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,FILEIO,R,IOUT,IN)
        !
        TABFILE%SIMTIME    =TRUE
        TABFILE%USE_TABEQN =FALSE
        TABFILE%IGNORE_TIME=FALSE
        TABFILE%SPBASIS    =FALSE
        TABFILE%STEP_FUNCTION = FALSE
        DO
          CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,IN)
          !
          IF    (LINE(ISTART:ISTOP).EQ.'REALTIME')THEN
              TABFILE%SIMTIME=FALSE
          ELSEIF(LINE(ISTART:ISTOP).EQ.'SIMTIME')THEN
              TABFILE%SIMTIME=TRUE
          ELSEIF(LINE(ISTART:ISTOP).EQ.'TABEQN')THEN                     !KEYWORD TO TRIGGER TABFILE EXPRESSION PARSING AKA "TABFILE EQUATIONS"
              TABFILE%USE_TABEQN=TRUE
          ELSEIF(LINE(ISTART:ISTOP).EQ.'IGNORE_TIME')THEN               !KEYWORD TO TRIGGER INORING TIMES AND ASSUMES ONE TO ONE RELATIONSHIP
              TABFILE%IGNORE_TIME=TRUE
          ELSEIF(LINE(ISTART:ISTOP).EQ.'SPBASIS')THEN                   !KEYWORD TO TRIGGER COMPUTATION BASED ON THE STRESS PERIOD
              TABFILE%SPBASIS    =TRUE
          ELSEIF(LINE(ISTART:ISTOP).EQ.'STEP'
     +      .OR. LINE(ISTART:ISTOP).EQ.'STEP_FUNCTION')THEN             !KEYWORD TO TRIGGER STEP FUNCTION
              TABFILE%STEP_FUNCTION=TRUE
          ELSE
              EXIT
          END IF
        END DO
        !
        IF(REALTIM.LT.0D0 .AND. .NOT. TABFILE%SIMTIME)THEN
            CALL STOP_ERROR(OUTPUT=IOUT, MSG='TABFILE '//
     +      'ERROR: SPECIFIED THAT TABFILE TIME '//
     +      'WILL USE REALTIME (NOT SIMTIME) FOR PACKAGE '//
     +      TRIM(CUNIT(PACKID))//', BUT A "STARTTIME" '//
     +      'OR "STARTDATE" WAS NOT SPECIFIED IN THE DIS.')
        END IF
        !
        CALL READ_TO_DATA(LINE,IN,IOUT,EOF=EOF)
      END IF
      !
      TABFILE%NTAB=NTAB
      !
      IF(TABFILE%NTAB.LE.Z)THEN
       IF(IOUT.NE.Z) WRITE(IOUT,'(/ 2A /)')
     +              ' NO TABFILE SPECIFIED FOR PACKAGE ',CUNIT(PACKID)
       TABFILE%NTAB=Z
       RETURN
      END IF
C
C     TABLEFILE IS SPECIFIED READ IN NAMELIST
      IF(IOUT.NE.Z) WRITE(IOUT,'(/3A,/A,/)')'"TABFILE" FLAG SPECIFIED ',
     + 'IN PACKAGE ',CUNIT(PACKID),
     + 'NOW READING LIST OF TABFILE NAMES AND THEIR LOCATION'
C
C     ALLOCATE TABFILE DATATYPE SPACE
      ALLOCATE( TABFILE%TAB   (TABFILE%NTAB) )
      ALLOCATE( TABFILE%TABNAM(TABFILE%NTAB) )
C     TWO STRUCTION OPTIONS
C     TABGROUPNAME FILELOCATION
C     TABGROUPNAME EXTERNAL FILENUMBER
      DO I=ONE,TABFILE%NTAB
        LLOC=ONE
        CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,IN)
        TABNAM=LINE(ISTART:ISTOP)
        TABNAM=ADJUSTL(TABNAM)
        !
        TABFILE%TABNAM(I)=TABNAM
        !
        CALL URWORD(LINE,LLOC,ISTART,ISTOP,Z,N,R,IOUT,IN)
        IF(ISTOP-ISTART+1.EQ.8) THEN
          EXT=LINE(ISTART:ISTOP)                                        !COULD CONTAIN EXTERNAL KEY WORD
          CALL UPCASE(EXT)
        ELSE
          EXT=' '
        END IF
        !
        FNAME=' '
        IF (EXT.EQ.'EXTERNAL')THEN
           CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,FN,R,IOUT,IN)           !EXTERNAL FILE, READ UNIT NUMBER
           INQUIRE(FN, NAME=FNAME )
           LVAL=FALSE                                                 !FLAG TO INDICATE THAT FILE IS EXTERNAL
        ELSE                                                            !FILE LOCATION SPECIFIED OPEN FILE NUMBER
           FNAME=LINE(ISTART:ISTOP)
           INQUIRE(FILE=FNAME, EXIST=LVAL )
           IF ( .NOT.LVAL ) THEN
         CALL FILE_IO_ERROR(FNAME=FNAME,LINE=LINE,INFILE=IN,OUTPUT=IOUT,
     +       MSG='SPECIFIED TABFILE DOES NOT EXIST. PLEASE CHECK PATH')
           END IF
           !
           OPEN(NEWUNIT=FN,FILE=FNAME,ACTION='READ')
        END IF
        !
        !FIRST PASS TO CALCULATE SIZE
        CALL UTF8_BOM_OFFSET_REWIND(FN)
        !
        IF(FILEIO.EQ.Z) THEN
          TABFILE%TAB(I)%FILEIO=Z
          NVAL=Z
          DO
            CALL READ_TO_DATA(LINE,FN,EOF=EOF)
            IF(EOF) EXIT
            LLOC = ONE
            CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP)          !JUST TO MOVE PASS THE FIRST WORD
            CALL GET(LINE,LLOC,ISTART,ISTOP,IOUT,FN,VAL,MSG='NOSTOP')
            IF (VAL.NE.VAL) EXIT
            NVAL=NVAL+ONE
          END DO
          IF(NVAL<ONE) CALL STOP_ERROR(INFILE=FN,OUTPUT=IOUT,
     +           MSG='SPECIFIED TABFILE DATA COUNT RETURNE ZER0. '//NL//
     +           'FILE MAYBE EMPTY OR NOT FORMATTED CORRECTLY TO GET '//
     +           'AN ACCURATE COUNT OF THE NUMBER OF ROWS.')
          ALLOCATE(TABFILE%TAB(I)%TIM(NVAL))
          ALLOCATE(TABFILE%TAB(I)%DAT(NVAL))
          TABFILE%TAB(I)%POS=ONE                                        !INITIAL POSITION IN TABFILE TO IMPROVE SPEED ON TIME SEARCH
          !
          !SECOND PASS TO READ IN DATA
          CALL UTF8_BOM_OFFSET_REWIND(FN)
          !
          DO J=ONE,NVAL
            CALL READ_TO_DATA(LINE,FN)
            LLOC=ONE
            IF(TABFILE%IGNORE_TIME) THEN
                CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP)          !JUST TO MOVE PASS THE FIRST WORD
                T = DBLE(J)
            ELSE
                CALL GET(LINE,LLOC,ISTART,ISTOP,IOUT,FILEIO,T,DATE,
     +              MSG='TABFILE FAILED TO LOAD THE FIRST VALUE AS '//
     +              'EITHER A VALUE OR CALENDAR DATE PLEASE CHECK IF '//
     +              'IT IS FORMATTED CORRECTLY.', ONLY_DYEAR=TRUE)          !ONLY WANT TO GET T AS A DECIMAL YEAR.
            END IF
            !
            CALL GET(LINE,LLOC,ISTART,ISTOP,IOUT,FN,VAL,MSG=
     +         'TABFILE LOADED SUCESSIFULLY THE FIRST VALUE,'//NL//
     +         'BUT FAILED TO LOAD THE SECOND VALUE.'//NL//
     +         'EITHER REMOVE THE FIRST VALUE TO INDICATE THAT THE '//
     +         'TIME SERIES IS COMPLETE (AND THUS KEEP REUSING THE '//
     +         'LAST VALUE),'//NL//
     +      'OR FIX THE DATA SET SO THAT THE FIRST VALUE IS THE TIME '//
     +         'AND SECOND IS THE VALUE TO ASSIGN.')
            !CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,N,T,IOUT,FN)
            !CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,N,R,IOUT,FN)
            TABFILE%TAB(I)%TIM(J)=T
            TABFILE%TAB(I)%DAT(J)=VAL
          END DO
          !
          IF(IOUT.NE.Z)WRITE(IOUT,'(5A)')'CONTENTS OF TABFILE "',
     +     TRIM(FNAME),'" HAVE BEEN LOADED TO TABNAM "',TRIM(TABNAM),'"'
          !
          IF(LVAL) CLOSE(FN)
          !
        ELSE
          ALLOCATE(TABFILE%TAB(I)%TIM(2))
          ALLOCATE(TABFILE%TAB(I)%DAT(2))
          !
          TABFILE%TAB(I)%FILEIO=FN
          TABFILE%TAB(I)%POS=ONE                                        !INITIAL POSITION IN TABFILE TO IMPROVE SPEED ON TIME SEARCH
          !
          CALL READ_TO_DATA(LINE,FN,EOF=EOF)
          IF(EOF) CALL STOP_ERROR(INFILE=FN,OUTPUT=IOUT,
     +            MSG='SPECIFIED TABFILE DATA REACHED END OF FILE ON '//
     +                                   'LOADING THE FIRST LINE.'//NL//
     +           'FILE MAYBE EMPTY OR NOT FORMATTED CORRECTLY.')
          LLOC=ONE
          CALL GET(LINE,LLOC,ISTART,ISTOP,IOUT,FILEIO,T,DATE,
     +              MSG='TABFILE FAILED TO LOAD THE FIRST VALUE AS '//
     +              'EITHER A VALUE OR CALENDAR DATE PLEASE CHECK IF '//
     +              'IT IS FORMATTED CORRECTLY.', ONLY_DYEAR=TRUE)          !ONLY WANT TO GET T AS A DECIMAL YEAR.
          !
          CALL GET(LINE,LLOC,ISTART,ISTOP,IOUT,FN,VAL,MSG=
     +       'TABFILE LOADED SUCESSIFULLY THE FIRST VALUE,'//NL//
     +       'BUT FAILED TO LOAD THE SECOND VALUE.'//NL//
     +       'EITHER REMOVE THE FIRST VALUE TO INDICATE THAT THE '//
     +       'TIME SERIES IS COMPLETE (AND THUS KEEP REUSING THE '//
     +       'LAST VALUE),'//NL//
     +    'OR FIX THE DATA SET SO THAT THE FIRST VALUE IS THE TIME '//
     +       'AND SECOND IS THE VALUE TO ASSIGN.')
          !CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,N,T,IOUT,FN)
          !CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,N,R,IOUT,FN)
          TABFILE%TAB(I)%TIM(1)=T
          TABFILE%TAB(I)%TIM(2)=1D99                                    !REQUIRES INITIAL VALUE THAT IS NEVER TRUE
          TABFILE%TAB(I)%DAT(1)=VAL
          !
          CALL UTF8_BOM_OFFSET_REWIND(FN)
          !
          IF(IOUT.NE.Z)WRITE(IOUT,'(6A)')'CONTENTS OF TABFILE "',
     +    TRIM(FNAME),'" WILL BE READ DURING SIMULATION TO SAVE MEMORY',
     +    ' FOR TABNAM "',TRIM(TABNAM),'"'
        END IF
        CALL READ_TO_DATA(LINE,IN)
      END DO
      !

      IF (TABFILE%IGNORE_TIME) THEN
        IF(IOUT.NE.Z) WRITE(IOUT,'(/2A/,A)') 'TABFILE "IGNORE_TIME" ',
     +   'KEYWORD FOUND. TABFILE TIMES ARE IGNORED AND ',
     +   'EACH TABFILE VALUE IS ASSUMED TO BE ONE TO ONE WITH MODEL'
      END IF
      IF (TABFILE%SPBASIS) THEN
        IF(IOUT.NE.Z) WRITE(IOUT,'(/A/,A)')
     +  'TABFILE "SPBASIS" KEYWORD FOUND.',
     +  'TABFILE WILL PROCESS INFORMATION RELATIVE TO STRESS PERIOD.'
      END IF
      IF (TABFILE%STEP_FUNCTION) THEN
        IF(IOUT.NE.Z) WRITE(IOUT,'(/A/,A)')
     +  'TABFILE "STEP_FUNCTION" KEYWORD FOUND.',
     +  'TABFILE WILL ONLY MOST RECENT EXCEDED TIME VALUE.'
      END IF
      IF (TABFILE%USE_TABEQN) THEN
        IF(IOUT.NE.Z) WRITE(IOUT,'(/2A/ 3A/,3A/)') 'TABFILE "TABEQN" ',
     +   'KEYWORD FOUND.','TABFILE WILL CHECK FOR OPTIONAL EQUATION ',
     +   'AFTER THE TABFILE SCALE FACTOR. IT MUST BE ENCLOSED WITHIN ',
     +    "'SINGLE QUOTES'.",
     +    'AND HAS THE RESERVED WORDS "TAB","SIM", AND "REL" THAT ',
     +    'REPRESENT THE TABfile VALUE, THE SIMulated TIME, ',
     +    'AND THE DECIMAL YEAR (REL).'
      END IF
      !
      IF(IOUT.NE.Z) WRITE(IOUT,*)                                       !BLANK SPACE AFTER WRITING OUT TABFILE INFO
      !
      END SUBROUTINE
      !
      SUBROUTINE TABFILELINKS(IN,IOUT,LINE,TABFILE)
C     ******************************************************************
C     GENERIC TABFILE INDEX BUILDER DEVELOPED BY SCOTT E. BOYCE
C     THIS FEATURE USES SELECT TYPE TO DISTINGUISH BETWEEN DIFFERNET PACKAGES
C     IT WILL READ IN THE FEATURE THAT A TABFILE IS LINKED TO AND THE TABNAM
C     WITH THIS INFORMATION A SET OF INDEXES ARE MADE
C
C     VARIABLE LIST:
C     IN      : INPUT FILE THAT THE TABINDEX IS READ FROM
C     IOUT    : OUTPUT FILE TO WRITE ERROR (i.e. THE LST FILE)
C     LINE    : STRING THAT CONTAINS A LINE OF OF THE INPUT FILE TO BE
C               ANALYZED AND THEN USED TO READ IN SUBSEQUENT LINES
C     TABFILE : DATATYPE THAT WILL BE ALLOCATED AND POPULATED WITH TAB DATA
C     ******************************************************************
      CLASS(TABFILETYPELINKS),                   INTENT(INOUT)::TABFILE
      INTEGER,                                   INTENT(IN)   :: IN,IOUT
      CHARACTER(*),                              INTENT(INOUT):: LINE
C     LOCAL VARIABLES
      CHARACTER(20),DIMENSION(:),ALLOCATABLE::TABNAM
      CHARACTER(20)::TEXTID
      CHARACTER(75)::TABEQN
      INTEGER::LLOC,ISTART,ISTOP
      INTEGER::I,K,NTAB,NLNK,LAY,ROW,COL
      REAL::R
C     ------------------------------------------------------------------
C
      TABFILE%TABPRINT=FALSE                                          !INITIALIZE TABPRINTING TO FALSE
C     CHECK IF TABFILES ARE SPECIFIED, IF NOT USED THEN RETURN
      IF ( TABFILE%NTAB.EQ.Z) RETURN
      !
C     THERE ARE TABFILES SO READ IN THE FEATURES TO LINK TOO
      LLOC=ONE
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,I,R,IOUT,IN)                 !READ IN KEYWORD TABNOPRIRNT OR TABPRINT
      ! IMF
      ! IF(LINE(ISTART:ISTOP).EQ.'TABPRINT') TABFILE%TABPRINT=TRUE
      IF(LINE(ISTART:ISTOP).EQ.'TABPRINT') THEN
          TABFILE%TABPRINT=TRUE
          LLOC = ISTOP + ONE
      END IF
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NLNK,R,IOUT,IN)              !NUMBER OF SEGEMENTS (NLNK) ASSOCIATED WITH A TABFILE
      ALLOCATE( TABNAM(NLNK) )                                          !TEMPORARY VARIABLE TO HOLD TABNAMES
      ALLOCATE( TABFILE%TSFAC(NLNK)  )
      ALLOCATE( TABFILE%TABIDX(NLNK) )
      ALLOCATE( TABFILE%PACIDX(NLNK) )
      IF( TABFILE%USE_TABEQN ) THEN
          ALLOCATE( CHARACTER(100):: TABFILE%TABEQN(NLNK) )
          ALLOCATE( TABFILE%TABEQNRES(NLNK))
      ELSE
          ALLOCATE( CHARACTER(1):: TABFILE%TABEQN(NLNK) )
           TABFILE%TABEQN=''
      END IF
      TABFILE%TABIDX=Z                                                  !INITIALIZE INDEX TO ZERO
      TABFILE%PACIDX=Z
      !READ(IN,'(A)') LINE                                               !READ IN NEXT LINE
      CALL READ_TO_DATA(LINE,IN, IOUT)
      !
      SELECT TYPE (TABFILE)
        CLASS IS (TABFILETYPE1IDX)                                      !READ IN SFR SPECIFIC PORTIONS
          ALLOCATE(TABFILE%ONEIDX(NLNK))
          DO I=ONE,NLNK
             LLOC=ONE
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,K,R,IOUT,IN)          !READ SEGMENT THAT IS LINKED TO TABNAM
             TABFILE%ONEIDX(I)=K                                        !UNIQUE NUMBER AS IDENTIFIER (SFR WOULD BE ISEG)
             !
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,K,R,IOUT,IN)          !READ TABNAM THAT SEGMENT IS LINKED THIS WILL MATCH TO A TABFILE
             TEXTID=LINE(ISTART:ISTOP);   TEXTID=ADJUSTL(TEXTID)
             TABNAM(I)=TEXTID
             !
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,K,R,IOUT,IN)
             TABFILE%TSFAC(I) =R
             !
             IF( TABFILE%USE_TABEQN ) THEN
                CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,K,R,IOUT,IN)
                TABEQN=LINE(ISTART:ISTOP);   TABEQN=ADJUSTL(TABEQN)
                TABFILE%TABEQN(I)=TABEQN
             END IF
             !
             !READ(IN,'(A)') LINE
             CALL READ_TO_DATA(LINE,IN,IOUT)
          END DO
          !
        CLASS IS (TABFILETYPECHARIDX)                                   !READ IN MNW2SPECIFIC PORTIONS
          ALLOCATE( TABFILE%CHARID(NLNK) )
          TABFILE%CHARID=''
          DO I=ONE,NLNK
             LLOC=ONE
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,K,R,IOUT,IN)          !READ MWN2 WELL NAME
             TEXTID=LINE(ISTART:ISTOP);    TEXTID=ADJUSTL(TEXTID)       !MNW2 WEL NAME
             TABFILE%CHARID(I)=TEXTID
             !
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,K,R,IOUT,IN)          !READ TABNAM THAT SEGMENT IS LINKED THIS WILL MATCH TO A TABFILE
             TEXTID=LINE(ISTART:ISTOP);    TEXTID=ADJUSTL(TEXTID)
             TABNAM(I)=TEXTID
             !
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,K,R,IOUT,IN)
             TABFILE%TSFAC(I) =R
             !
             IF( TABFILE%USE_TABEQN ) THEN
                CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,K,R,IOUT,IN)
                TABEQN=LINE(ISTART:ISTOP);   TABEQN=ADJUSTL(TABEQN)
                TABFILE%TABEQN(I)=TABEQN
             END IF
             !
             !READ(IN,'(A)') LINE
             CALL READ_TO_DATA(LINE,IN,IOUT)
          END DO
        CLASS IS (TABFILETYPE3IDX)
          ALLOCATE( TABFILE%LRCIDX(NLNK) )
          DO I=ONE,NLNK
             LLOC=ONE
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,LAY,R,IOUT,IN)
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,ROW,R,IOUT,IN)
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,COL,R,IOUT,IN)
             TABFILE%LRCIDX(I) = LRC2ID(LAY,ROW,COL)                    !=COL + NCOL*(ROW-1) + NCOL*NROW*(LAY-1)
             !
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,K,R,IOUT,IN)          !READ TABNAM THAT SEGMENT IS LINKED THIS WILL MATCH TO A TABFILE
             TEXTID=LINE(ISTART:ISTOP);   TEXTID=ADJUSTL(TEXTID)
             TABNAM(I)=TEXTID
             !
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,K,R,IOUT,IN)
             TABFILE%TSFAC(I) =R
             !
             IF( TABFILE%USE_TABEQN ) THEN
                CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,K,R,IOUT,IN)
                TABEQN=LINE(ISTART:ISTOP);   TABEQN=ADJUSTL(TABEQN)
                TABFILE%TABEQN(I)=TABEQN
             END IF
             !
             !READ(IN,'(A)') LINE
             CALL READ_TO_DATA(LINE,IN,IOUT)
          END DO
        !
      END SELECT
      !
      NTAB=TABFILE%NTAB
      DO I=ONE,NLNK                                                       !BUILD INDEX OF TABFILE LOCATIONS
          DO K=ONE, NTAB                                                  !SEARCH FOR LOCATION OF TABFILE
            IF(TABNAM(I).EQ.TABFILE%TABNAM(K)) THEN
               TABFILE%TABIDX(I)=K
               EXIT
            END IF
          END DO
          IF(TABFILE%TABIDX(I).EQ.Z) THEN
          CALL STOP_ERROR(INFILE=IN,OUTPUT=IOUT,
     +    MSG='FAILED TO LOCATE TABFILE WITH TABNAM "'//
     +                                       TRIM(TABNAM(I))//'"'//NL//
     + 'MAYBE THE TABNAM IS WRONG OR IT WAS NEVER ORIGINALLY DECLAIRED')
          END IF
      END DO
      DEALLOCATE(TABNAM)
      !
      !READ(IN,'(A)') LINE                                               !READ IN NEXT LINE ALREADY DONE IN SELECT TYPE
      END SUBROUTINE
      !
      SUBROUTINE TABFILEPACKINDEX(TABFILE,NAMELST,INDEXLST,
     +                            INDEX3LST)
C     ******************************************************************
C     GENERIC TABFILE INDEX BUILDER DEVELOPED BY SCOTT E. BOYCE
C     THIS FEATURE USES SELECT TYPE TO DISTINGUISH BETWEEN DIFFERNET PACKAGES
C     ITS PURPOSE IS TO BUILD THE LINKE TO THE PACKAGE INDEX THAT EACH TABFILE/TABNAM REFERS
C     SOME PACKAGES (e.g. SFR) DO NOT NEED THIS BECAUSE THEY HAVE A ONE TO ONE RELATIONSHIP
C     WITH THE INDEX ID AND THE ACTUAL INDEX IN THE STORAGE ARRAY
C
C     VARIABLE LIST:
C     IOUT    :  OUTPUT FILE TO WRITE ERROR (i.e. THE LST FILE)
C     TABFILE :  DATATYPE THAT WILL BE ALLOCATED AND POPULATED WITH TAB DATA
C     NAMELST :  OPTIONAL VARIABLE THAT CONTAINS A 1D ARRAY OF CHARACTER
C                NAMES THAT REPRESENT THE ID USED BY PACKAGE (e.g MNW2 WELLID)
C                THIS VARIABLE IS REQUIRED WHEN THERE IS A NAME ID BEING
C                MATCHED FOR A TABFILE
C     INDEXLST:  OPTIONAL VARIABLE THAT CONTAINS A 1D ARRAY OF INTEGER
C                VALUES THAT REPRESENT THE ID USED BY PACKAGE
C                (e.g SFR WHEN SEG ARE NOT IN NUMERICAL ORDER WELLID)
C                THIS VARIABLE IS REQUIRED IF YOU WANT TO SEARCH FOR LOCATION OF INTEGER ID
C                OTHERWISE IT IS ASSUMED THAT THE INTEGER READ IS ALSO THE INDEX
C     INDEX3LST: OPTIONAL VARIABLE THAT CONTAINS A 2D ARRAY OF INTEGER
C                VALUES THAT REPRESENT THE LAY, ROW, AND COL USED BY PACKAGE
C                THE SHAPE OF THE ARRAY MUST BE (3,:) WHERE THE FIRST DIMENSION IS
C                DEFINED AS ([LAY,ROW,COL],:)
C     ******************************************************************
      CLASS(TABFILETYPELINKS),                   INTENT(INOUT)::TABFILE
      CHARACTER(*),DIMENSION(:),OPTIONAL,        INTENT(IN)   :: NAMELST
      INTEGER,     DIMENSION(:),OPTIONAL,        INTENT(IN) :: INDEXLST
      INTEGER,     DIMENSION(:,:),OPTIONAL,      INTENT(IN) :: INDEX3LST
      !CONTIGUOUS:: NAMELST, INDEXLST, INDEX3LST
C     LOCAL VARIABLES
      CHARACTER(20)::TEXTID
      INTEGER::LAY,ROW,COL
      INTEGER::I,K,NLST,NLNK,ID
C     ------------------------------------------------------------------
C
C     CHECK IF TABFILES ARE SPECIFIED, IF NOT USED THEN RETURN
      IF ( TABFILE%NTAB.EQ.Z) RETURN
      !
      NLST=Z
      IF(PRESENT(NAMELST ))  NLST=SIZE(NAMELST, 1)                    !GET SIZE OF PACKAGE ARRAY OF INDICIES
      IF(PRESENT(INDEXLST))  NLST=SIZE(INDEXLST,1)
      IF(PRESENT(INDEX3LST)) NLST=SIZE(INDEX3LST,2)
      NLNK=UBOUND(TABFILE%PACIDX,1)
      !
C     THERE ARE TABFILES SO PROCESS THE FEATURES TO LINK TOO
      !
      TABFILE%PACIDX=Z                                                  !INITIALIZE THE PACKAGE LOACTION, IF LEFT Z THEN TABFILE FOR THAT ROW IS IGNORED
      !
      SELECT TYPE (TABFILE)
        CLASS IS (TABFILETYPE1IDX)
          IF(PRESENT(INDEXLST))THEN                                     !IF INDEXLST IS PASSED THEN SEARCH FOR THE ROW THAT CONTAINS THE ID (K IS ID NOT INDEX LOCATION) [IN SFR THE ID, ISEG, IS ALSO THE INDEX LOCATION]
            DO I=ONE,NLNK
             DO K=ONE, NLST
               IF(TABFILE%PACIDX(I).NE.Z) CYCLE                         !LINK PREVIOUSLY DEFINED, SO THERE MUST BE MULTIPLE REFERENCES TO THE SAME CELL, SKIP AND FIND NEW LOCATION
               IF(TABFILE%ONEIDX(I).EQ.INDEXLST(K))THEN                 !ON ENTRANCE TABFILE%PACIDX(I) HOLDS THE UNIQUE ID FOR THAT TABFILE. IT IS OVERWRITTEN WITH THE ROW LOCATION IN INDEXLST OF THAT UNIQUE ID
                   TABFILE%PACIDX(I)=K
                   EXIT
               END IF
               IF(K.EQ.NLST) THEN
               CALL STOP_ERROR(MSG='ERROR IN TABFILEINDEX. '//
     +                       'UNABLE TO FIND INDEX MATCH IN TABFILE "'//
     +        TRIM(TABFILE%TABNAM(TABFILE%TABIDX(I)))//'" TO PACKAGE '//
     +        'WITH INDEX '//NUM2STR(TABFILE%ONEIDX(I)))
               END IF
             END DO
            END DO
          ELSE
            CALL STOP_ERROR(MSG='ERROR IN CODE. SUBROUTINE '//
     +'TABFILEPACKINDEX MUST PASS IN VARIABLE "INDEXLST" TO FORM LINKS')
          END IF
          !
        CLASS IS (TABFILETYPECHARIDX)
          IF(PRESENT(NAMELST))THEN
            DO I=ONE,NLNK
             TEXTID=TABFILE%CHARID(I)
             DO K=ONE, NLST
               IF(TEXTID.EQ.NAMELST(K))THEN
                   TABFILE%PACIDX(I)=K
                   EXIT
               END IF
               IF(K.EQ.NLST) THEN
               CALL STOP_ERROR(MSG='ERROR IN TABFILEINDEX. '//
     +   'UNABABLE TO FIND NAME MATCH IN TABFILE TO PACKAGE FOR NAME '//
     +             TRIM(TEXTID))
               END IF
             END DO
            END DO
          ELSE
            CALL STOP_ERROR(MSG='ERROR IN CODE. SUBROUTINE '//
     +               'TABFILEPACKINDEX MUST PASS IN VARIABLE "NAMELST"')
          END IF
          !
        CLASS IS (TABFILETYPE3IDX)
          IF(PRESENT(INDEX3LST))THEN
            DO K=ONE, NLST
             LAY=INDEX3LST(1,K)
             ROW=INDEX3LST(2,K)
             COL=INDEX3LST(3,K)
             ID = LRC2ID(LAY,ROW,COL)                                   !=COL + NCOL*(ROW-1) + NCOL*NROW*(LAY-1)
             DO I=ONE,NLNK                                                !CAN NOT HANDEL MORE THAN 1 DATA POINT FOR 1 ROW,COL,LAY
               IF(TABFILE%PACIDX(I).NE.Z) CYCLE                         !LINK PREVIOUSLY DEFINED, SO THERE MUST BE MULTIPLE REFERENCES TO THE SAME CELL, SKIP AND FIND NEW LOCATION
               IF(TABFILE%LRCIDX(I).EQ.ID)THEN
                   TABFILE%PACIDX(I)=K
                   EXIT
               END IF
               IF(I.EQ.NLNK) THEN
               CALL STOP_ERROR(MSG='ERROR IN TABFILEINDEX. '//
     +        'UNABABLE TO FIND INDEX MATCH (Layer, Row, Column) '//NL//
     +        'IN TABFILE "'//TRIM(TABFILE%TABNAM(TABFILE%TABIDX(I)))//
     +         '" TO PACKAGE WITH Layer, Row, Column: '//
     +         NUM2STR(LAY)//', '//NUM2STR(ROW)//', '//NUM2STR(COL))
               END IF
             END DO
            END DO
          ELSE
            CALL STOP_ERROR(MSG=
     +       'ERROR IN CODE. SUBROUTINE TABFILEPACKINDEX MUST PASS '//
     +       'IN VARIABLE "INDEX3LST" TO FORM LINKS')
          END IF
          !
        CLASS DEFAULT
            CALL WARNING_MESSAGE(MSG='TABFILEPACKINDEX CODE ERROR: '//
     + 'SUBROUTINE RECIEVED AN UNIDEFIED CLASS, PROGRAM WILL '//
     + 'CONTINUE, BUT WILL NOT PROCESS THE TABFILE', CMD_PRINT=TRUE)
            RETURN
        !
      END SELECT
      !
      END SUBROUTINE
      !
      SUBROUTINE TABFILEUPDATE_S( TABFILE,PACK,KSTP,SRESULT )
        CLASS(TABFILETYPELINKS),  INTENT(INOUT):: TABFILE
        CHARACTER(*)           ,  INTENT(IN   ):: PACK
        INTEGER                ,  INTENT(IN   ):: KSTP
        REAL(REAL32),DIMENSION(:),INTENT(INOUT):: SRESULT
        !CONTIGUOUS:: SRESULT
        !
        CALL TABFILEUPDATER( TABFILE,PACK,KSTP,SRESULT=SRESULT )
        !
      END SUBROUTINE
      !
      SUBROUTINE TABFILEUPDATE_D( TABFILE,PACK,KSTP,DRESULT )
        CLASS(TABFILETYPELINKS)      ,INTENT(INOUT):: TABFILE
        CHARACTER(*)                 ,INTENT(IN   ):: PACK
        INTEGER                      ,INTENT(IN   ):: KSTP
        DOUBLE PRECISION,DIMENSION(:),INTENT(INOUT):: DRESULT
        !CONTIGUOUS:: DRESULT
        !
        CALL TABFILEUPDATER( TABFILE,PACK,KSTP,DRESULT=DRESULT )
        !
      END SUBROUTINE
      !
      SUBROUTINE TABFILEUPDATER( TABFILE,PACK,KSTP,SRESULT,DRESULT )
C SUBROUTINE ASSUMES THAT PACIDX HAS BEEN CONTRUCTED.
C LOOK THROUGH ALL LINKS AND INTERPOLATE THEIR APPROPIATE TABFILES
C IF TABFILE PRINTING IS REQUESTED THEN PRINTS TABFILE RESULTS
C VARIABLE LIST:
C TABFILE: TABFILE THAT WILL BE UPDATED FOR TIMESTEP
C PACK   : STRING THAT IS PASSED IN THAT IDENTIFIES THE CALLING PACKAGE. FOR EXAMPE PACK='WEL' OR 'SFR'
C SRESULT: IS A SINGLE PRECISION ARRAY THAT IF PRESENT WILL HAVE THE TABFILE VALUE AND SCALE FACTORE APPLIED TO ITS PACKIDX LOCATION
C DRESULT: IS A DOUBLE PRECISION ARRAY THAT IF PRESENT WILL HAVE THE TABFILE VALUE AND SCALE FACTORE APPLIED TO ITS PACKIDX LOCATION
      USE GLOBAL,       ONLY:IOUT
      USE GWFBASMODULE, ONLY:TOTIM,REALTIM
      USE ExpressionParser  !ONLY PROVIDES ACCESS TO ExpEVAL
      CLASS(TABFILETYPELINKS),           INTENT(INOUT)::TABFILE
      CHARACTER(*)           ,           INTENT(IN):: PACK
      INTEGER,                           INTENT(IN):: KSTP
      REAL(REAL32),OPTIONAL,DIMENSION(:),INTENT(INOUT)::SRESULT
      REAL(REAL64),OPTIONAL,DIMENSION(:),INTENT(INOUT)::DRESULT
      !CONTIGUOUS:: SRESULT, DRESULT
C LOCAL
      DOUBLE PRECISION::VAL,TSFAC,RES
      INTEGER::I,NLNK,PACIDX,TABIDX
      INTEGER::ID,LAY,ROW,COL
      CHARACTER(20)::CHARID
      !CHARACTER(75)::TABEQN
      CHARACTER(3),DIMENSION(3)::NML
      DOUBLE PRECISION,DIMENSION(3)::NMV
      !
C     CHECK IF TABFILES ARE SPECIFIED, IF NOT USED THEN RETURN
      IF ( TABFILE%NTAB.EQ.Z) RETURN
      !
      IF (KSTP.EQ.ONE .OR. .NOT. TABFILE%SPBASIS) THEN
          TABFILE%TAB%USEVAL=FALSE                                    !TELL TABFILEINTERP TO SEARCH FOR NEW TIME AND THEN START REUSING VALUES
      END IF
      NML=['TAB','SIM','REL']
      NMV=[1D0, DBLE(TOTIM), REALTIM]
      NLNK=SIZE(TABFILE%PACIDX,1)
      !
      IF(TABFILE%IGNORE_TIME) THEN
        DO TABIDX=ONE, TABFILE%NTAB
        CALL TABFILEINTERP( TABFILE%TAB(TABIDX),TABFILE%SIMTIME,
     +      TABFILE%IGNORE_TIME, TABFILE%SPBASIS, TABFILE%STEP_FUNCTION)
        END DO
      ELSE
        DO I=ONE,NLNK                                                       !LOOP THROUGH TABFILES AND UPDATE THEIR VALUES TO CURRENT TIME
          PACIDX=TABFILE%PACIDX(I)
          IF(PACIDX.EQ.Z) CYCLE
          !
          TABIDX=TABFILE%TABIDX(I)
          !
          CALL TABFILEINTERP( TABFILE%TAB(TABIDX), TABFILE%SIMTIME,
     +      TABFILE%IGNORE_TIME, TABFILE%SPBASIS, TABFILE%STEP_FUNCTION)!CALCULATE CURRENT TABFILE VALUE AND STORE IT IN TABFILE%TAB(TABIDX)%VAL
          !
          IF( TABFILE%USE_TABEQN ) THEN
            IF(TABFILE%TABEQN(I)=='')THEN
                TABFILE%TABEQNRES(I)=TABFILE%TAB(TABIDX)%VAL
            ELSE
               NMV(1)=TABFILE%TAB(TABIDX)%VAL
               TABFILE%TABEQNRES(I)=ExpEVAL(TABFILE%TABEQN(I), NML, NMV)
            END IF
          END IF
          !
        END DO
      END IF
      !
      IF(TABFILE%TABPRINT)THEN                                          !IF TABPRINT IS REQUEST WRITE TO LIST FILE TABTABLE
        WRITE(CHARID,'(ES20.9)') TOTIM;    CHARID=ADJUSTL(CHARID)
        IF(TABFILE%SIMTIME)THEN
          WRITE(IOUT,'(/ 2A)') PACK//
     +      ' PACKAGE TABFILE PRINT OUT AT SIMULTED TIME ',TRIM(CHARID)
        ELSE
          WRITE(IOUT,'(/ 3A,F11.5)') PACK//
     +      ' PACKAGE TABFILE PRINT OUT AT SIMULTED TIME ',TRIM(CHARID),
     +      ' AND DECIMAL YEAR (REALTIME) ',REALTIM
        END IF
        !
        SELECT TYPE (TABFILE)
          CLASS IS (TABFILETYPE1IDX)
          !

          IF(TABFILE%USE_TABEQN) THEN
             WRITE(IOUT,'(3A)')'      ID              RESULT',
     +       '          TSFAC              TABVAL  TABNAM',
     +       '              TABEQN'
          ELSE
             WRITE(IOUT,'(2A)')'      ID              RESULT',
     +       '          TSFAC              TABVAL  TABNAM '
          END IF
          !
          DO I=ONE,NLNK
            PACIDX=TABFILE%PACIDX(I)
            IF(PACIDX.EQ.Z) CYCLE
            !
            TSFAC =TABFILE%TSFAC(I)
            TABIDX=TABFILE%TABIDX(I)
            ID    =TABFILE%ONEIDX(I)
            !
            VAL=TABFILE%TAB(TABIDX)%VAL
            !
            IF(TABFILE%USE_TABEQN) THEN
              WRITE(IOUT,'(I8,2x,A18,A15,2x,A18,2x,A,2x,A)')
     +           ID,NUM2STR(TSFAC*TABFILE%TABEQNRES(I)),
     +           NUM2STR(TSFAC),NUM2STR(VAL),
     +           TABFILE%TABNAM(TABIDX),TRIM(TABFILE%TABEQN(I))
            ELSE
              WRITE(IOUT,'(I8,2x,A18,A15,2x,A18,2x,A,2x,A)')
     +           ID,NUM2STR(TSFAC*VAL),
     +           NUM2STR(TSFAC),NUM2STR(VAL),
     +           TABFILE%TABNAM(TABIDX)
            END IF
            !
          END DO
          !
          CLASS IS (TABFILETYPECHARIDX)
          !
          IF(TABFILE%USE_TABEQN) THEN
             WRITE(IOUT,'(3A)')'  ID                          RESULT',
     +       '          TSFAC              TABVAL  TABNAM',
     +       '              TABEQN'
          ELSE
             WRITE(IOUT,'(2A)')'  ID                          RESULT',
     +       '          TSFAC              TABVAL  TABNAM'
          END IF
          DO I=ONE,NLNK
            PACIDX=TABFILE%PACIDX(I)
            IF(PACIDX.EQ.Z) CYCLE
            !
            TSFAC =TABFILE%TSFAC(I)
            TABIDX=TABFILE%TABIDX(I)
            CHARID=TABFILE%CHARID(I)
            !
            VAL=TABFILE%TAB(TABIDX)%VAL
            !
            IF(TABFILE%USE_TABEQN) THEN
              WRITE(IOUT,'(A,2x,A18,A15,2x,A18,2x,A,2x,A)')
     +         ID,NUM2STR(TSFAC*TABFILE%TABEQNRES(I)),
     +         NUM2STR(TSFAC),NUM2STR(VAL),
     +         TABFILE%TABNAM(TABIDX),TRIM(TABFILE%TABEQN(I))
            ELSE
              WRITE(IOUT,'(A,2x,A18,A15,2x,A18,2x,A)')
     +         ID,NUM2STR(TSFAC*VAL),
     +         NUM2STR(TSFAC),NUM2STR(VAL),
     +         TABFILE%TABNAM(TABIDX)
            END IF
            !
          END DO
          !
        CLASS IS (TABFILETYPE3IDX)
          !
          IF(TABFILE%USE_TABEQN) THEN
           WRITE(IOUT,'(3A)')'   ID      LAY   ROW   COL        RESULT',
     +       '          TSFAC              TABVAL  TABNAM',
     +       '              TABEQN'
          ELSE
           WRITE(IOUT,'(2A)')'   ID      LAY   ROW   COL        RESULT',
     +       '          TSFAC              TABVAL  TABNAM'
          END IF
          DO I=ONE,NLNK
            PACIDX=TABFILE%PACIDX(I)
            IF(PACIDX.EQ.Z) CYCLE
            !
            TSFAC =TABFILE%TSFAC(I)
            TABIDX=TABFILE%TABIDX(I)
            ID    =TABFILE%LRCIDX(I)
            CALL ID2LRC(ID,LAY,ROW,COL)
            !
            VAL=TABFILE%TAB(TABIDX)%VAL
            !
            IF(TABFILE%USE_TABEQN) THEN
              WRITE(IOUT,'(I8,3I6,2x,A18,A15,2x A18,2x,A,2x,A)')
     +         ID,LAY,ROW,COL,NUM2STR(TSFAC*TABFILE%TABEQNRES(I)),
     +         NUM2STR(TSFAC),NUM2STR(VAL),
     +         TABFILE%TABNAM(TABIDX),TRIM(TABFILE%TABEQN(I))
            ELSE
              WRITE(IOUT,'(I8,3I6,2x,A18,A15,2x A18,2x,A)')
     +         ID,LAY,ROW,COL,NUM2STR(TSFAC*VAL),
     +         NUM2STR(TSFAC),NUM2STR(VAL),
     +         TABFILE%TABNAM(TABIDX)
            END IF
            !
          END DO
          !
        END SELECT
      END IF
      !
      IF(PRESENT(SRESULT)) THEN
        DO I=ONE,NLNK
          PACIDX=TABFILE%PACIDX(I)
          IF(PACIDX.EQ.Z) CYCLE
          !
          TABIDX=TABFILE%TABIDX(I)
          TSFAC =TABFILE%TSFAC(I)
          !
          IF(TABFILE%USE_TABEQN) THEN
            RES=TSFAC*TABFILE%TABEQNRES(I)
          ELSE
            RES=TSFAC*TABFILE%TAB(TABIDX)%VAL
          END IF
          !
          SRESULT(PACIDX) = REAL(RES,REAL32)
        END DO
      END IF
      IF(PRESENT(DRESULT)) THEN
        DO I=ONE,NLNK
          PACIDX=TABFILE%PACIDX(I)
          IF(PACIDX.EQ.Z) CYCLE
          !
          TABIDX=TABFILE%TABIDX(I)
          TSFAC =TABFILE%TSFAC(I)
          !
          IF(TABFILE%USE_TABEQN) THEN
            RES=TSFAC*TABFILE%TABEQNRES(I)
          ELSE
            RES=TSFAC*TABFILE%TAB(TABIDX)%VAL
          END IF
          !
          DRESULT(PACIDX) = RES
        END DO
      END IF
      !
      END SUBROUTINE
      !
      SUBROUTINE TABFILEINTERP( TABFILE, SIMTIM, IGNORE_TIME, SPBASIS,
     +                                                  STEP_FUNCTION )
C FUNCTION SOLVES FOR TABFILE VALUE FOR CURRENT TIMESTEP
C NOTE THAT FUNCTION EXPECTS TO RECIEVE A SINGLE TABFILE, NOT A VECTOR CONTAINING MULTIPLE TAB FILES
C IT IS ASSUMED THAT THE CORRECT TABFILE IS BEING REQUESTED.
C
C FUNCTION EITHER PASSES TO PURE SUBROUTINE OF FILEIO SUBROUTIEOND TIME STEP
      TYPE(TABARRAY),  INTENT(INOUT)::TABFILE
      LOGICAL,         INTENT(IN   )::SIMTIM, IGNORE_TIME, SPBASIS
      LOGICAL,         INTENT(IN   )::STEP_FUNCTION
      !
      IF(TABFILE%USEVAL) RETURN                                         !FLAG THAT INDICATES THAT THE TABFILE HAS ALREADY BEEN INTERPOLATED TO CURRENT TIME
      !
      IF(TABFILE%FILEIO.EQ.Z)THEN
          CALL TABFILEINTERPFAST( TABFILE, SIMTIM, IGNORE_TIME, SPBASIS,
     +                                                   STEP_FUNCTION )
      ELSE
          CALL TABFILEINTERPFILE( TABFILE, SIMTIM, IGNORE_TIME, SPBASIS,
     +                                                   STEP_FUNCTION )
      END IF
      !
      END SUBROUTINE
      !
      PURE SUBROUTINE TABFILEINTERPFAST( TABFILE, SIMTIM,
     +                                   IGNORE_TIME, SPBASIS, STEP )
C FUNCTION SOLVES FOR TABFILE VALUE FOR CURRENT TIMESTEP
C NOTE THAT FUNCTION EXPECTS TO RECIEVE A SINGLE TABFILE, NOT A VECTOR CONTAINING MULTIPLE TAB FILES
C THIS FUNCTION ALSO PROCESSES TABFILES THAT HAVE BEEN READ IN ENTIRELY INTO THE MODULE
C IT IS ASSUMED THAT THE CORRECT TABFILE IS BEING REQUESTED.
C
C FUNCTION SEARCHES THROUGH A TABFILE DATA TYPE FOR A MATCHING TABNAM IF TABIDX<=0
C IF TABIDX>0 THEN THE INDEX IS ASSUMED TO BE THE LOCATION OF THE MATCHING TABFILE
C 3 CASES
C SINGLE VALUE IN TIME STEP, USE ONLY 1 VALUE
C MULTIPLE VALUES IN TIME STEP, TIME WEIGHTED AVERAGE
C NO VALUES IN TIME STEP, LINEAR INTERPOLATE CLOSEST VALUES BEYOND TIME STEP
      USE GLOBAL,       ONLY: ITMUNI
      USE GWFBASMODULE, ONLY: DELT,TOTIM,REALTIM,USE_LEAP_YR,
     +                        TOTPERTIM, SIMTIM_PER, REALTIM_PER
      USE BAS_UTIL, ONLY: DECIMAL_YEAR, CVRT2DYEAR
      TYPE(TABARRAY),  INTENT(INOUT)::TABFILE
      LOGICAL,         INTENT(IN   )::SIMTIM,IGNORE_TIME,SPBASIS,STEP
C LOCAL
      REAL::RES                                                         !TEMP VARIABLE TO HOLD RESULT
      DOUBLE PRECISION::B,ErrFrac                                       !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR
      DOUBLE PRECISION::TIMOLD,TIMNEW,SUMTAB,SUMTIM,TW
      INTEGER::I,NTIM,ISTR,ISTP,IPOS
      !
      IF(TABFILE%USEVAL) RETURN                                         !FLAG THAT INDICATES THAT THE TABFILE HAS ALREADY BEEN INTERPOLATED TO CURRENT TIME
      !
      RES=-9.9E30 !SET TO EXTREME VALUE IN CASE OF ERROR
      IPOS=TABFILE%POS
      ISTR=Z
      ISTP=Z
      TIMOLD=0D0
      TIMNEW=0D0
      !
      NTIM=UBOUND(TABFILE%TIM,1)
      !
      ErrFrac=0.000001D0
      B=ErrFrac*DBLE(DELT)                                              !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR IN COMPARING TIMES
      IF (SPBASIS .AND. .NOT. IGNORE_TIME)THEN
        IF(SIMTIM)THEN
          TIMOLD = SIMTIM_PER - TOTPERTIM
          TIMNEW = SIMTIM_PER
        ELSE
           TIMOLD=REALTIM_PER
           CALL DECIMAL_YEAR(TIMOLD,-TOTPERTIM,ITMUNI,USE_LEAP_YR)      !GOING BACK IN TIME
           TIMNEW=REALTIM_PER
           B = ErrFrac * TOTPERTIM * CVRT2DYEAR(ITMUNI,Z)               !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR IN COMPARING TIMES
        END IF
      ELSEIF(.NOT. IGNORE_TIME) THEN
        IF(SIMTIM)THEN
          TIMOLD=DBLE(TOTIM-DELT)
          TIMNEW=DBLE(TOTIM)
        ELSE
           TIMOLD=REALTIM
           CALL DECIMAL_YEAR(TIMOLD,DBLE(-DELT),ITMUNI,USE_LEAP_YR)
           TIMNEW=REALTIM
           B = ErrFrac * DBLE(DELT) * CVRT2DYEAR(ITMUNI,Z)             !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR IN COMPARING TIMES
        END IF
      END IF
      !
      IF (IGNORE_TIME) THEN
          RES=TABFILE%DAT(IPOS)
          IPOS=IPOS+ONE
          TABFILE%POS=IPOS
      ELSEIF    ( REAL(TIMNEW) < REAL(TABFILE%TIM(1)   ) ) THEN         !FIRST TABFILE TIME IS GREATER THEN CURRENT TOTAL TIME, SO THERE IS NO POSSIBLILITY OF FINDING A TIME
                                               RES=TABFILE%DAT(1)
      ELSEIF( REAL(TIMOLD) >  REAL(TABFILE%TIM(NTIM)) ) THEN
                                               RES=TABFILE%DAT(NTIM)    !LAST TABFILE TIME IS LESS THAN PREVIOUS TIMESTEP TIME, SO THERE IS NO POSSIBLILITY OF FINDING A TIME
      ELSE
         ISTR=NTIM
         !
         IF(STEP) THEN
             DO I=IPOS,NTIM                                             !SEARCH FOR LOCATION AT BEGINING OF TIMESTEP
               IF( TIMOLD <=TABFILE%TIM(I) ) THEN
                  ISTR=I
                  ISTP=ISTR
                  EXIT
               END IF
             END DO
         ELSE
             DO I=IPOS,NTIM                                             !SEARCH FOR LOCATION AT BEGINING OF TIMESTEP
               IF( TIMOLD - TABFILE%TIM(I)  <  -B ) THEN
                  ISTR=I
                  EXIT
               END IF
             END DO
             DO I=ISTR,NTIM                                             !SEARCH FOR LOCATION AT END OF TIMESTEP
               IF( TIMNEW - TABFILE%TIM(I)  <   -B ) THEN
                  ISTP=I
                  EXIT
               END IF
             END DO
         END IF
         !
         IF (ISTP.EQ.Z.AND.ISTR.GT.Z) ISTP=ISTR
         IF (ISTP > ISTR) ISTP=ISTP-ONE                                   !ONLY WANT TABFILE TIMES WITHIN CURRENT TIMESTEP
         !
         IF     (REAL(TABFILE%TIM(ISTR)) > REAL(TIMNEW) ) THEN          !NO VALUE WITHIN TIME STEP, INTERPOATE TO TIME STEP BETWEEN ISTR-1 AND ISTR
             RES= REAL(
     +                 TABFILE%DAT(ISTR-1) +
     +                 (TABFILE%DAT(ISTR)-TABFILE%DAT(ISTR-1)) *
     +                     (
     +                      (TIMNEW            - TABFILE%TIM(ISTR-1)) /
     +                      (TABFILE%TIM(ISTR) - TABFILE%TIM(ISTR-1))
     +                     )
     +                )
         ELSEIF (ISTR == ISTP) THEN                                     !ONLY 1 VALUE WITHIN TIME STEP SO USE THAT
           RES=TABFILE%DAT(ISTR)
         ELSE                                                           !MULTIPLE VALUES WITHIN TIME STEP, TIME AVERAGE VALUES
           SUMTAB=0D0
           SUMTIM=0D0
           DO I=ISTR,ISTP
             IF    (I.EQ.ISTR) THEN
                TW=(TABFILE%TIM(I)-TIMOLD) +
     +                             (TABFILE%TIM(I+1)-TABFILE%TIM(I))/2D0
                SUMTAB=SUMTAB + TW*TABFILE%DAT(I)
                SUMTIM=SUMTIM + TW
             ELSEIF(I.EQ.ISTP) THEN
                TW=(TIMNEW-TABFILE%TIM(I)) +
     +                             (TABFILE%TIM(I)-TABFILE%TIM(I-1))/2D0
                SUMTAB=SUMTAB + TW*TABFILE%DAT(I)
                SUMTIM=SUMTIM + TW
             ELSE
                TW=(TABFILE%TIM(I+1)-TABFILE%TIM(I))/2D0 +
     +                             (TABFILE%TIM(I)-TABFILE%TIM(I-1))/2D0
                SUMTAB=SUMTAB + TW*TABFILE%DAT(I)
                SUMTIM=SUMTIM + TW
             END IF
           END DO
           RES=REAL(SUMTAB/SUMTIM)
         END IF
      END IF
      !
      IF(ISTR>ONE) TABFILE%POS=ISTR-ONE                                     !RECORD CURRENT POSITION IN TABFILE TO IMPROVE SEARCH SPEED
      !
      TABFILE%USEVAL=TRUE                                             !TABFILE VALUE HAS BEEN RECORDED
      TABFILE%VAL=RES
      !
      END SUBROUTINE
      !
      SUBROUTINE TABFILEINTERPFILE(TABFILE,SIMTIM,
     +                                       IGNORE_TIME, SPBASIS, STEP)
C FUNCTION SOLVES FOR TABFILE VALUE FOR CURRENT TIMESTEP
C NOTE THAT FUNCTION EXPECTS TO RECIEVE A SINGLE TABFILE, NOT A VECTOR CONTAINING MULTIPLE TAB FILES
C ALSO TABFILE IS NOT ENTIRELY READ IN AND INSTEAD ONLY THE PORTION OF THE FILE WITHIN THE TIME STEP
C   IS READ IN VIA A LINKED-LIST
C IT IS ASSUMED THAT THE CORRECT TABFILE IS BEING REQUESTED.
C
C FUNCTION SEARCHES THROUGH A TABFILE DATA TYPE FOR A MATCHING TABNAM IF TABIDX<=0
C IF TABIDX>0 THEN THE INDEX IS ASSUMED TO BE THE LOCATION OF THE MATCHING TABFILE
C 3 CASES
C SINGLE VALUE IN TIME STEP, USE ONLY 1 VALUE
C MULTIPLE VALUES IN TIME STEP, TIME WEIGHTED AVERAGE
C NO VALUES IN TIME STEP, LINEAR INTERPOLATE CLOSEST VALUES BEYOND TIME STEP
C
C NEW DEFINITION OF TABFILE%DAT and TABFILE%TIM
C TABFILE%TIM(1) and TABFILE%DAT(1) HOLD LAST VALUE FROM PREVIOUS TIMESTEP
C TABFILE%TIM(2) and TABFILE%DAT(2) HOLD FIRST VALUE THAT IS JUST BEYOND THE TIMESTEP
      USE GLOBAL,       ONLY: ITMUNI,IOUT
      USE GWFBASMODULE, ONLY: DELT,TOTIM,REALTIM,TOTPERTIM,USE_LEAP_YR,
     +                        TOTPERTIM, SIMTIM_PER, REALTIM_PER
      USE BAS_UTIL,     ONLY: DECIMAL_YEAR,CVRT2DYEAR
      TYPE(TABARRAY),  INTENT(INOUT)::TABFILE
      LOGICAL,         INTENT(IN   )::SIMTIM, IGNORE_TIME, SPBASIS, STEP
C LOCAL
      REAL::RES
      !DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE::TIM                    !TEMP VARIABLE TO HOLD TIM RESULT
      DOUBLE PRECISION::B,ErrFrac                                       !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR
      DOUBLE PRECISION::TIMOLD,TIMNEW,SUMTAB,SUMTIM,TW
      INTEGER::I,J,ISTP,FILEIO
      LOGICAL:: FAILED
      INTEGER::LLOC,ISTART,ISTOP,NLST
      DOUBLE PRECISION:: T,R,TOLD
      CHARACTER(200)::LINE
      CHARACTER(6):: NOSTOP
      TYPE(DATE_OPERATOR):: DATE
      TYPE LINKEDLIST
        DOUBLE PRECISION:: T,R
        TYPE (LINKEDLIST),POINTER:: NXT=>NULL()
      END TYPE
      TYPE (LINKEDLIST),POINTER:: DATASTR=>NULL()
      TYPE (LINKEDLIST),POINTER:: DATAPNT=>NULL()
      !
      IF(TABFILE%USEVAL) RETURN                                         !FLAG THAT INDICATES THAT THE TABFILE HAS ALREADY BEEN INTERPOLATED TO CURRENT TIME
      !
      IF(TABFILE%TIM(2)<0D0) THEN                                       !END OF TABFILE AND IT HAS NOW BEEN CLOSED
        TABFILE%USEVAL=TRUE
        TABFILE%VAL=TABFILE%DAT(2)
        RETURN
      END IF
      !
      RES=-9.9E30 !SET TO EXTREME VALUE IN CASE OF ERROR
      FILEIO=TABFILE%FILEIO
      ISTP=Z
      NLST=Z
      NOSTOP='NOSTOP'
      !
      ErrFrac=0.000001D0
      B=ErrFrac*DBLE(DELT)                                              !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR IN COMPARING TIMES
      IF (SPBASIS .AND. .NOT. IGNORE_TIME)THEN
        IF(SIMTIM)THEN
          TIMOLD = SIMTIM_PER - TOTPERTIM
          TIMNEW = SIMTIM_PER
        ELSE
           TIMOLD=REALTIM_PER
           CALL DECIMAL_YEAR(TIMOLD,-TOTPERTIM,ITMUNI,USE_LEAP_YR)      !GOING BACK IN TIME
           TIMNEW=REALTIM_PER
           B = ErrFrac * TOTPERTIM * CVRT2DYEAR(ITMUNI,Z)               !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR IN COMPARING TIMES
        END IF
      ELSEIF(.NOT. IGNORE_TIME) THEN
        IF(SIMTIM)THEN
          TIMOLD=DBLE(TOTIM-DELT)
          TIMNEW=DBLE(TOTIM)
        ELSE
           TIMOLD=REALTIM
           CALL DECIMAL_YEAR(TIMOLD,DBLE(-DELT),ITMUNI,USE_LEAP_YR)
           TIMNEW=REALTIM
           B = ErrFrac * DBLE(DELT) * CVRT2DYEAR(ITMUNI,Z)             !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR IN COMPARING TIMES
        END IF
      END IF
      !
      IF (IGNORE_TIME) THEN
         !READ(FILEIO,'(A)',IOSTAT=ERR) LINE                             !READ NEXT VALUE
         CALL READ_TO_DATA(LINE,FILEIO, EOF=FAILED)
         IF(FAILED) THEN
            CALL STOP_ERROR(INFILE=FILEIO,OUTPUT=IOUT,
     +         MSG='TABFILE ERROR: END OF TABFILE REACHED WHEN USING '//
     +    'IGNORE_TIME OPTION. THIS REQUIRES THE NUMBER OF LINES TO '//
     +    'BE EQUAL TO EITHER THE # OF TIME STEPS OR STRESS PERIODS')
         END IF
         LLOC=ONE
         CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP)  !JUST TO MOVE PASS THE FIRST WORD
         CALL GET(LINE,LLOC,ISTART,ISTOP,IOUT,FILEIO,R,MSG=
     +      'TABFILE LOADED SUCESSIFULLY THE FIRST VALUE,'//NL//
     +      'BUT FAILED TO LOAD THE SECOND VALUE.'//NL//
     +      'EITHER REMOVE THE FIRST VALUE TO INDICATE THAT THE '//
     +      'TIME SERIES IS COMPLETE (AND THUS KEEP REUSING THE '//
     +      'LAST VALUE),'//NL//
     +      'OR FIX THE DATA SET SO THAT THE FIRST VALUE IS THE TIME '//
     +      'AND SECOND IS THE VALUE TO ASSIGN.')
         !
         RES=R
      ELSEIF( TIMNEW < TABFILE%TIM(1) ) THEN                            !FIRST TABFILE TIME IS GREATER THEN CURRENT TOTAL TIME, SO THERE IS NO POSSIBLILITY OF FINDING A TIME
                                               RES=TABFILE%DAT(1)
      ELSEIF( TIMOLD > TABFILE%TIM(2) ) THEN
                                               RES=TABFILE%DAT(2)       !LAST TABFILE TIME IS LESS THAN PREVIOUS TIMESTEP TIME, SO THERE IS NO POSSIBLILITY OF FINDING A TIME
      ELSEIF( TIMOLD <=TABFILE%TIM(1) .AND. STEP) THEN                            !FIRST TABFILE TIME IS GREATER THEN CURRENT TOTAL TIME, SO THERE IS NO POSSIBLILITY OF FINDING A TIME
                                               RES=TABFILE%DAT(1)
      ELSE
       ALLOCATE(DATASTR)
       DATAPNT=>DATASTR
       NLST=Z
       DO                                                               !INFINITE LOOP THAT BUILDS A LINKED LIST THAT HOLDS ALL VALUES READ IN THAT PERTAIN TO THE CURRENT TIME STEP
         !READ(FILEIO,'(A)',IOSTAT=ERR) LINE                             !READ NEXT VALUE
         !FAILED=ERR.NE.Z                                                !FAILED=TRUE IF REACHED END OF PAGE OR FAILED URWORD READ
         CALL READ_TO_DATA(LINE,FILEIO,EOF=FAILED)
         !
         IF(.NOT. FAILED) THEN !TRUE IF AT EOF
              LLOC=ONE
              CALL GET(LINE,LLOC,ISTART,ISTOP,IOUT,FILEIO,T,DATE,
     +                                       MSG=NOSTOP,ONLY_DYEAR=TRUE)!ONLY WANT TO GET T AS A DECIMAL YEAR.
              IF (T.NE.T) THEN
                  FAILED = TRUE
              ELSE
                 CALL GET(LINE,LLOC,ISTART,ISTOP,IOUT,FILEIO,R,MSG=
     +           'TABFILE LOADED SUCESSIFULLY THE FIRST VALUE,'//NL//
     +           'BUT FAILED TO LOAD THE SECOND VALUE.'//NL//
     +           'EITHER REMOVE THE FIRST VALUE TO INDICATE THAT THE '//
     +           'TIME SERIES IS COMPLETE (REPEATIDLY USE LAST VALUE),'
     +                                                            //NL//
     +           'OR FIX THE DATA SET SO THAT THE FIRST VALUE IS THE '
     +           //'TIME AND SECOND IS THE VALUE TO ASSIGN.')
              END IF
         END IF
         !CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,N,T,0,FILEIO)
         !FAILED = FAILED .OR. (LINE(LEN(LINE):LEN(LINE)).EQ.'E')
         !CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,N,R,0,FILEIO)
         !FAILED = FAILED .OR. (LINE(LEN(LINE):LEN(LINE)).EQ.'E')
         !
         IF(FAILED)THEN                                                 !IF FAILED THEN IT IS ASSUMED THE END OF THE FILE HAS BEEN REACHED SET UP POINTERS ACCORDINGLY SO THAT FUTURE CALLS TO SUBROUTINE WILL ONLY RETURN LAST READ ENTRY
            CALL WARNING_MESSAGE(INFILE=FILEIO,OUTPUT=IOUT,
     +                   MSG='TABFILE REACHED THE END OF THE FILE'//NL//
     +               'NOW USING LAST VALUE FOR REMAINDER OF SIMULATION',
     +                                                    INLINE=TRUE)
            DATAPNT%NXT=>NULL()
            CLOSE(FILEIO)
            !
            IF(NLST.EQ.Z)THEN                                           !IF NLST=0 THEN NO VALUES WERE READ IN BEFORE THE BOTTOM OF THE FILE. TO COMPLETE CURRENT CALL FORCE ROUTINE TO USE LAST READ ENTRY FROM PRIOR CALL
              NLST=ONE
              DATASTR%T=1D99
              DATASTR%R=TABFILE%DAT(1)
              TABFILE%TIM(2)=-1D99
              TABFILE%DAT(2)=TABFILE%DAT(1)                             !ONE ENTRY IS READ IN SO USE THAT AND SET IT TO BE USED IN FUTURE CALLS
            ELSEIF(NLST.EQ.ONE)THEN
              DATASTR%T=1D99
              TABFILE%TIM(2)=-1D99
              TABFILE%DAT(2)=DATASTR%R
            ELSEIF(NLST.GT.ONE)THEN                                       !MULTIPLE ENTRIES WERE READ BEFORE END OF FILE. PROCESS AS NORMAL BUT STORE LAST VALUE FOR RESUSE IN FUTURE CALLS TO SUBROUTINE
              DATAPNT=>DATASTR
              DO I=ONE,NLST
                DATAPNT=>DATAPNT%NXT
              END DO
              TABFILE%TIM(2)=-1D99
              TABFILE%DAT(2)=DATAPNT%R
            END IF
            EXIT
         END IF
         !                                                              !IF THIS POINT IS REACHED THEN THERE WAS A SUCCESSFUL READ OF NEW TAB INFORAMTION DATA
         IF( TIMNEW - T  <  -B ) THEN                                   !CHECK IF TAB TIME EXCEDES CURRENT TIME STEP. IF TRUE THEN STOP READING IN NEW TAB INFORMATION
            TABFILE%TIM(2)=DBLE(T)                                      !STORE TIME  OF TABFILE ENTRY THAT IS 1 BEYOND THE CURRENT TIME STEP
            TABFILE%DAT(2)=DBLE(R)                                      !STORE VALUE OF TABFILE ENTRY THAT IS 1 BEYOND THE CURRENT TIME STEP
            BACKSPACE(FILEIO)                                           !CURRENT IO POSITION IS 1 PAST THE TIME STEP ENDING, MOVE BACK TO READ IN VALUE DURING NEXT CALL
            DATAPNT%NXT=>NULL()
            EXIT
         END IF
         !
         IF(STEP) THEN
             IF(TIMOLD <= T) THEN
                NLST=ONE
                DATAPNT%T=T
                DATAPNT%R=R
                ALLOCATE(DATAPNT%NXT)                                        !ALLOCATE SPACE IN NEXT LINKED LIST ENTRY
                DATAPNT=>DATAPNT%NXT                                         !SET UP LOCAL POINTER TO NEW LINKED LIST ENTRY
                EXIT
             END IF
         ELSEIF( TIMOLD - T  <  -B ) THEN                                   !CHECK IF TABFILE ENTRY IS WITHIN CURRENT TIMESTEP. IF IT IS INCLUDE IT IN LINKED LIST
                NLST=NLST+ONE
                DATAPNT%T=T
                DATAPNT%R=R
                ALLOCATE(DATAPNT%NXT)                                        !ALLOCATE SPACE IN NEXT LINKED LIST ENTRY
                DATAPNT=>DATAPNT%NXT                                         !SET UP LOCAL POINTER TO NEW LINKED LIST ENTRY
         END IF
       END DO
       !
       IF     (NLST.EQ.Z) THEN                                          !NO VALUE WITHIN TIME STEP, INTERPOATE TO TIME STEP BETWEEN ISTR-1 AND ISTR
           RES= REAL(
     +               TABFILE%DAT(1) +
     +               (TABFILE%DAT(2)-TABFILE%DAT(1)) *
     +                   (
     +                    (TIMNEW            - TABFILE%TIM(1)) /
     +                    (TABFILE%TIM(2) - TABFILE%TIM(1))
     +                   )
     +              )
       ELSEIF (NLST.EQ.ONE) THEN                                          !ONLY 1 VALUE WITHIN TIME STEP SO USE THAT
         TABFILE%TIM(1)=DATASTR%T
         TABFILE%DAT(1)=DATASTR%R
         RES=DATASTR%R
       ELSE                                                             !MULTIPLE VALUES WITHIN TIME STEP, TIME AVERAGE VALUES
         DATAPNT=>DATASTR
         SUMTAB=0D0
         SUMTIM=0D0
         DO I=ONE, NLST
           IF    (I.EQ.ONE) THEN
             TW=(DATAPNT%T-TIMOLD)
             TW=TW+ (DATAPNT%NXT%T-DATAPNT%T)/2D0
             SUMTAB=SUMTAB + TW*DATAPNT%R
             SUMTIM=SUMTIM + TW
             TOLD=DATAPNT%T
             DATAPNT=>DATAPNT%NXT
           ELSEIF(I.EQ.NLST) THEN
             TW=(TIMNEW-DATAPNT%T) + (DATAPNT%T-TOLD)/2D0
             SUMTAB=SUMTAB + TW*DATAPNT%R
             SUMTIM=SUMTIM + TW
             TABFILE%TIM(1)=DATASTR%T
             TABFILE%DAT(1)=DATASTR%R
           ELSE
             TW=(DATAPNT%NXT%T-DATAPNT%T)/2D0 + (DATAPNT%T-TOLD)/2D0
             SUMTAB=SUMTAB + TW*DATAPNT%R
             SUMTIM=SUMTIM + TW
             TOLD=DATAPNT%T
             DATAPNT=>DATAPNT%NXT
           END IF
         END DO
         RES=REAL(SUMTAB/SUMTIM)
       END IF
      END IF
      !
      TABFILE%USEVAL=TRUE                                             !TABFILE VALUE HAS BEEN RECORDED
      TABFILE%VAL=RES
      !
      !CLEANUP
      DO I=NLST,ONE,-1                                                    !NULLIFY THE LINKED LIST START WITH THE END AND WORKING TO THE BEGINING
        DATAPNT=>DATASTR                                                !SET SET POINT TO START AND CYCLE TO END OF LINKED LIST TO DEALLOCATE EACH POINTER IN THE LINKED LIST
        DO J=ONE,I
          DATAPNT=>DATAPNT%NXT
        END DO
        DEALLOCATE(DATAPNT)
      END DO
      DEALLOCATE(DATASTR)                                               !DEALLOCATE THE FINAL POINTER TO FREE ANY REMAINIGN MEMORY
         NULLIFY(DATAPNT)                                               !NULLIFY    THE FINAL POINTER TO FREE ANY REMAINIGN MEMORY HOLDS
      !
      END SUBROUTINE
      !
      SUBROUTINE MNW2TABFILE2QDES(TABFILE,WELLOC,QDES,FOUND)
C      IF THERE ARE TABFILES AVAILIBLE SET QDES TO ITS TABFILE
C      THIS SUBROUTINE IS WRITTEN TO MINIMIZE IMPACT ON MNW2 CODE BECAUSE
C      OF MULTIPLE CONDITIONAL READS OF QDES THIS SUBROUTINE WILL BE
C      REMOVED WITH UPDATE OF MNW2 RP AND AR SOURCE CODE
C
C     VARIABLE LIST:
C     TABFILE :  DATATYPE THAT CONTAINS APPROPIATE TABFILE INFORMATION
C     FOUND   :  RETURNS THE LOCATION OF THE WELL. SET TO 0 IF NOT FOUND
C
C
C
C     ******************************************************************
      TYPE(TABFILETYPECHARIDX),                 INTENT(INOUT):: TABFILE
      INTEGER,                                  INTENT(IN)   :: WELLOC
      DOUBLE PRECISION,                         INTENT(INOUT):: QDES   !LEFT ALONE IF NOT FOUND
      INTEGER,OPTIONAL,                         INTENT(OUT)  :: FOUND
C     LOCAL VARIABLES
      DOUBLE PRECISION::TSFAC
      INTEGER::I,NTAB,NLNK,TABIDX
      !
      IF(TABFILE%NTAB.LE.Z) RETURN                                      !REDUNDANT CHECK, BUT INCLUDED TO BE SAFE INCASE OF ACIDENTAL CALL
      !
      NTAB=TABFILE%NTAB
!      NLST=UBOUND(WELLNAME,1)
      NLNK=UBOUND(TABFILE%PACIDX,1)
      !
      IF(PRESENT(FOUND)) FOUND=Z
      DO I=ONE,NLNK
        IF(WELLOC.EQ.TABFILE%PACIDX(I)) THEN
            IF(PRESENT(FOUND)) FOUND=I
            TABIDX=TABFILE%TABIDX(I)
            TSFAC =TABFILE%TSFAC(I)
            !
            CALL TABFILEINTERP( TABFILE%TAB(TABIDX),TABFILE%SIMTIME,
     +      TABFILE%IGNORE_TIME, TABFILE%SPBASIS, TABFILE%STEP_FUNCTION)!CALCULATE CURRENT TABFILE VALUE AND STORE IT IN TABFILE%TAB(TABIDX)%VAL
            !
            QDES = DBLE( TSFAC * TABFILE%TAB(TABIDX)%VAL )
            !
            EXIT
         END IF
      END DO
      !
      END SUBROUTINE
      !
      ELEMENTAL FUNCTION LRC2ID(LAY,ROW,COL) RESULT(ID)                 !CALCULATES: ID = COL + NCOL*(ROW-1) + NCOL*NROW*(LAY-1)
        USE GLOBAL,ONLY: NROW,NCOL
        INTEGER,INTENT(IN) ::LAY,ROW,COL
        INTEGER::ID
        !
        ID = COL + NCOL*(ROW-1) + NCOL*NROW*(LAY-1)
        !
      END FUNCTION
      !
      ELEMENTAL SUBROUTINE ID2LRC(ID,LAY,ROW,COL)                       !CALCULATES: ID = COL + NCOL*(ROW-1) + NCOL*NROW*(LAY-1)
        USE GLOBAL,ONLY: NROW,NCOL
        INTEGER,INTENT(IN) ::ID
        INTEGER,INTENT(OUT)::LAY,ROW,COL
        INTEGER::IDX
        !
        IDX = ID
        IF(MODULO( IDX, (NCOL*NROW) ).EQ.Z) THEN
          LAY = ( IDX / (NCOL*NROW) )
        ELSE
          LAY = ( IDX / (NCOL*NROW) ) + 1
        END IF
        !
        IDX = IDX - NCOL*NROW*(LAY-1)
        IF(MODULO( IDX, NCOL ).EQ.Z) THEN
          ROW = ( IDX / NCOL)
        ELSE
          ROW = ( IDX / NCOL) + 1
        END IF
        !
        COL = IDX - NCOL*(ROW-1)
        !
      END SUBROUTINE
      !
      SUBROUTINE TABFILE_DEALLOCATE(TABFILE)
      CLASS(TABFILETYPELINKS),INTENT(INOUT)::TABFILE
      !
      INTEGER::I
      !
      IF(TABFILE%NTAB.EQ.Z) RETURN
      !
      DO I=ONE, TABFILE%NTAB
        DEALLOCATE( TABFILE%TAB(I)%TIM    )
        DEALLOCATE( TABFILE%TAB(I)%DAT    )
      END DO
      !
      DEALLOCATE( TABFILE%TAB    )
      DEALLOCATE( TABFILE%TABNAM )
      !
      DEALLOCATE( TABFILE%TSFAC  )
      DEALLOCATE( TABFILE%TABIDX )
      DEALLOCATE( TABFILE%PACIDX )
      !
      SELECT TYPE(TABFILE)
      CLASS IS (TABFILETYPE1IDX)
                                   DEALLOCATE( TABFILE%ONEIDX )
      CLASS IS (TABFILETYPECHARIDX)
                                   DEALLOCATE( TABFILE%CHARID )
      CLASS IS (TABFILETYPE3IDX)
                                   DEALLOCATE( TABFILE%LRCIDX )
      END SELECT
      !
      !
      END SUBROUTINE
      !
      SUBROUTINE  PAK_PROP_TABINTERP(PAKDATA, TABFILE,NLST,
     +                               VLOC,PAK,KSTP,IOUT)
      USE PAK_PROP_INTERFACE, ONLY: PAK_PROPTAB
      USE GWFBASMODULE, ONLY:TOTIM,REALTIM
      USE ExpressionParser  !ONLY PROVIDES ACCESS TO ExpEVAL
      !
      TYPE(PAK_PROPTAB), DIMENSION(:):: PAKDATA
      TYPE(TABFILETYPE)              :: TABFILE
      INTEGER,INTENT(IN)             :: VLOC,NLST,KSTP,IOUT
      CHARACTER(*),INTENT(IN)        :: PAK
      !CONTIGUOUS:: PAKDATA
      !
      INTEGER:: TABIDX, I, IL, IR, IC
      DOUBLE PRECISION:: TABVAL
      CHARACTER(3),DIMENSION(3)::NML
      DOUBLE PRECISION,DIMENSION(3)::NMV
      !
      CHARACTER(100)::LABEL

      LABEL='   ID   LAY   ROW   COL              TABVAL'//
     +      '          TSFAC  TABNAM'
      !
      NML=['TAB','SIM','REL']
      NMV=[1D0, DBLE(TOTIM), REALTIM]

C
      IF(TABFILE%NTAB.EQ.Z) RETURN   ! PROCESS TABFILES
      !
      IF (KSTP.EQ.ONE .OR. .NOT. TABFILE%SPBASIS) THEN
          TABFILE%TAB%USEVAL=FALSE                                   !TELL TABFILEINTERP TO SEARCH FOR NEW TIME AND THEN START REUSING VALUES
      END IF
      !
      IF(TABFILE%IGNORE_TIME) THEN
        !
        DO TABIDX=ONE, TABFILE%NTAB
        CALL TABFILEINTERP( TABFILE%TAB(TABIDX),TABFILE%SIMTIME,
     +      TABFILE%IGNORE_TIME, TABFILE%SPBASIS, TABFILE%STEP_FUNCTION)
        END DO
      END IF
        !
      IF(NLST>Z) THEN
      IF(ANY(PAKDATA(1:NLST)%TABIDX.GT.Z)) THEN
C 3 CASES
C SINGLE VALUE IN TIME STEP, USE ONLY 1 VALUE
C MULTIPLE VALUES IN TIME STEP, TIME WEIGHTED AVERAGE
C NO VALUES IN TIME STEP, LINEAR INTERPOLATE CLOSEST VALUES BEYOND TIME STEP
       !
       DO I=ONE,NLST
        IF (PAKDATA(I)%TABIDX.EQ.Z) CYCLE
        !
        TABIDX=PAKDATA(I)%TABIDX
        !
        CALL TABFILEINTERP( TABFILE%TAB(TABIDX), TABFILE%SIMTIME,
     +      TABFILE%IGNORE_TIME, TABFILE%SPBASIS, TABFILE%STEP_FUNCTION) !CALCULATE CURRENT TABFILE VALUE AND STORE IT IN TABFILE%TAB(TABIDX)%VAL
        !
        TABVAL=REAL(TABFILE%TAB(TABIDX)%VAL)
        !
        IF( TABFILE%USE_TABEQN ) THEN
         IF(PAKDATA(I)%TABEQN=='')THEN
           PAKDATA(I)%TABEQNRES=TABFILE%TAB(TABIDX)%VAL
         ELSE
           NMV(1)=TABFILE%TAB(TABIDX)%VAL  !SET FIRST VALUE IF EQUATION
           PAKDATA(I)%TABEQNRES=ExpEVAL(PAKDATA(I)%TABEQN,NML,NMV)
           TABVAL=REAL(PAKDATA(I)%TABEQNRES)
         END IF
        END IF

        PAKDATA(I)%VAL(VLOC)= PAKDATA(I)%TSFAC * TABVAL
        !
       END DO
C PRINT OUT TABFILE OUTPUT HEAD
        IF(IOUT.NE.Z)THEN
         IF(TABFILE%SIMTIME)THEN
           WRITE(IOUT,'(/ 2A /)') PAK//
     +  ' PACKAGE TABFILE PRINT OUT AT SIMULTED TIME ',NUM2STR(TOTIM)
         ELSE
           WRITE(IOUT,'(/ A,A,A,F11.5 /)')  PAK//
     + ' PACKAGE TABFILE PRINT OUT AT SIMULTED TIME ',NUM2STR(TOTIM),
     +     ' AND DECIMAL YEAR (REALTIME) ',REALTIM
         END IF
         !
         IF(TABFILE%USE_TABEQN)
     +                       LABEL=TRIM(LABEL)//'                TABEQN'
         WRITE(IOUT,'(A)')TRIM(LABEL)
         !
C PRINT OUT TABFILE OUTPUT
         DO I=ONE,NLST
           IL=PAKDATA(I)%LAY;  IR=PAKDATA(I)%ROW;  IC=PAKDATA(I)%COL
           TABIDX=PAKDATA(I)%TABIDX
           IF(TABIDX.GT.Z)THEN
             WRITE(IOUT,'(I5,3I6,2x,A18,A15,2x A,2x A)')
     +               I,IL,IR,IC,NUM2STR(PAKDATA(I)%VAL(VLOC)),
     +               NUM2STR(PAKDATA(I)%TSFAC),
     +               PAKDATA(I)%TABNAM,TRIM(PAKDATA(I)%TABEQN)
           ELSE
             WRITE(IOUT,'(I5,3I6,2x,A18,A15,A)')
     +                   I,IL,IR,IC,NUM2STR(PAKDATA(I)%VAL(VLOC)),
     +                   '0.0',PAKDATA(I)%TABNAM
           END IF
         END DO
         !
        END IF
        !
      ELSEIF(IOUT.NE.Z)THEN !NOT ANY(PAKDATA(1:NLST)%TABIDX.GT.0)
        WRITE(IOUT,'(/ A)') PAK//' TABFILE:'
        WRITE(IOUT,'(  A)')'NO TABFILES SPECIFIED THIS STRESS PERIOD'
        WRITE(IOUT,'(  A)')'IF YOU DID SPECIFY A TABNAM FOR A '//
     +                                                    PAK//' CELL,'
        WRITE(IOUT,'(A /)')'IT WAS NOT MATCHED TO A TABFILE AND IGNORED'
      END IF !ANY(PAKDATA(1:NLST)%TABIDX.GT.0)
      END IF
      !
      END SUBROUTINE
      !
      END MODULE  TABLEFILE_INTERFACE



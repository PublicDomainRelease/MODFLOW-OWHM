      MODULE CFPMODULE                                                  !TR: 2011 10 24 REFORMATTED
C
C     ******************************************************************
C     DEFINE DATA NEEDED FOR CONDUIT FLOW PROCESS
C     VERSION 1.0 MARCH 2007
C     UPDATED NOVEMBER 2007
C
C     **MODE=1, ONLY PIPES;
C     **MODE=2, ONLY LAYERS; **ONLY NEED TO MODIFY CONDUCTANCES AFTER 
C               BCF, LPF OR HUF FOR MODE 2;
C     **MODE=3, PIPES AND LAYERS
C
C     ******************************************************************
      IMPLICIT NONE
      INTEGER, PARAMETER :: NNOD = 6
      !DOUBLE PRECISION, PARAMETER :: PII = 3.141592654D0
      !DOUBLE PRECISION, PARAMETER :: TWOPII = 2.0D0*3.141592654D0
      DOUBLE PRECISION, PARAMETER :: ONE8TH = 1.0D0/8.0D0!, DOS = 2.0D0
      !DOUBLE PRECISION, PARAMETER :: NEARZERO = 1.0D-30, DZ = 0.0D0
      DOUBLE PRECISION, PARAMETER :: CM2INCH = 3.2804D0
C
C--VARIABLES NEEDED FOR MODE 1:
      INTEGER, SAVE, POINTER :: MODE, MXNODE, MXTUBE, NBR_LAY, ITERS
      INTEGER, SAVE, POINTER :: ACTIVENODE, ITERA_MAX, LSURFACEDEP, P_NR
      INTEGER, SAVE, POINTER, DIMENSION(:, :) :: NBR
      INTEGER, SAVE, POINTER, DIMENSION(:, :, :) :: NCOND
C
C--FOR TIME SERIES OUTPUT**
      INTEGER, SAVE, POINTER :: NOTSNO,NOTSTU,NNODES,NTUBES,TSNO,TSTU,  
     & NTSAN,NOTSTSAN,TSA_FUNIT,NCOUNT,TCOUNT,NTSAT,NOTSTSAT,           !TR: 2013 08 12 TSAN; NTSAN = NUMBER OF NODES FOR TIME SERIES DATA ALONG NODES (TSAN) // TSA_OUT = FILE NUMBER FOR TSA OUTPUT // 2013 05 17 NCOUNT / TCOUNT GLOBAL // !TR: 2013 08 13 TSAN // 2013 08 13 TSAT (TIME SERIES ALONG TUBES) //
     & L_NTS, NO_L_NTS                                                  !TR: 2018 05 22 LISTING OUTPUT
      INTEGER, SAVE, POINTER, DIMENSION(:) :: TSNODE, TSTUBE, TSAN,     !TR: 2013 08 13 TSAN
     & TSAN_FUNIT, TSAT, TSAT_FUNIT                                     !TR: 2013 08 12 TSAN / TSAT
      LOGICAL, SAVE, POINTER :: TSA_FLG, TSAN_FLG, TSAT_FLG             !TR: 2013 05 13 FLAG TO CONSIDER TIME SERIES ANALYSIS OUTPUT // 2013 08 12 TSAN OUTPUT // TSAT
C
C--WATER TEMP, VISCOSITIES
      DOUBLE PRECISION, SAVE, POINTER :: NU, TC, VISCTC, VNUTC, EPSILON
      DOUBLE PRECISION, SAVE, POINTER :: G, CFPRELAX, L_ABS             !TR: 2014 11 18 L_TOT IS ABSOLUTE LENGTH OF CONDUITS
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: GEOHIGHT, NODETOP
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: NODEBOT
!     DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: LAY_THICK
C
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: BEGHEAD, TORTUOS
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: ROUGHNESS
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: B, B_MAT, B_MAT_O
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: B_MAT_P,B_MAT_OTR!TR: 2012 07 16 PFPS / B_MAT_P TO STORE RESULTS FROM PREVIOUS ITERATION // 2014 02 28 B_MAT_OTR = OLD HEAD FOR TRANSPORT COMPUTATION
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: MOD2, MODD
C
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:,:) :: CON_DATA
C
C--FOR CFP1PC
      INTEGER, SAVE, POINTER, DIMENSION(:,:) :: ITUBE
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:,:) :: DTUBE
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:,:) :: NODE_LOCA
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:,:,:) :: TOP
C
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: HC
C
C--FOR MODE 1 DIRECT CONDUIT RECHARGE
      INTEGER, SAVE, POINTER :: IFLAG_RECH
!     DOUBLE PRECISION, SAVE, POINTER :: RECH_FACT
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: QCONDIR 
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: QCONDIROLD
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: QBDIR, QBDIROLD
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: QBDIRSAVE
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: QCDSDIR          !TR: 2014 02 19 CADS RECHARGE // QCDSDIR = PARTICIAN COEFFICIENT TO CALCULATE CADS RECHARGE FROM RCH
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: QCDSDIROLD       !TR: 2014 02 19 CADS RECHARGE
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: QSDIR, QSDIROLD  !TR: 2014 02 20 CADS RECHARGE // QSDIR = AMOUNT OF RECHARGE THAT GOES INTO CADS
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: QSDIRSAVE        !TR: 2014 02 20 CADS RECHARGE
C
C--NEEDED IN FORMULATE SUBROUTINE
      INTEGER, SAVE, POINTER :: KONV, FTURB
C
!     DOUBLE PRECISION, SAVE, POINTER :: TTIME, TMYPCG, TLUBSK, TGLLAM
!     DOUBLE PRECISION, SAVE, POINTER :: TITERNEW, TOLDTIME, CLOCK
C
      INTEGER, SAVE, POINTER, DIMENSION(:) :: TURB
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: FX0, TUB_REYNOLD,
     +TAUI
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: HEAD_SAVE, INDEX1
C
      !RSR CHANGED MAT TO EQ_MAT
!     DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:,:) :: QWD
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:,:) :: EQ_MAT
C
C--FOR CFP OUTPUT CONTROL AND BUDGET
      INTEGER, SAVE, POINTER :: KTSNO, KTSTU, KTSTSAN, KTSTSAT          !TR: 2013 08 13 TSAN / TSAT
!     INTEGER, SAVE, POINTER :: NOFLOW, NOCWB, KCWB, KFLOW
C
      DOUBLE PRECISION, SAVE, POINTER :: BUD_SOURCE, BUD_SINK, BUD_MATIN
      DOUBLE PRECISION, SAVE, POINTER :: BUD_MATOUT, DIFF_TOT           !TR: 2012 04 24 BUD_QBDIR REMOVED
      DOUBLE PRECISION, SAVE, POINTER :: BUD_QBDIRIN, BUD_QBDIROUT      !TR: 2012 04 24 BUD_QBDIRIN AND BUD_QBDIROUT TO DISTIGUISH RECHARGE IN- AND OUT
      DOUBLE PRECISION, SAVE, POINTER :: BUD_QSDIRIN, BUD_QSDIROUT      !TR: 2014 02 20 CADS RECHARGE
      DOUBLE PRECISION, SAVE, POINTER :: BUD_CADSIN, BUD_CADSOUT        !TR: 2012 04 26 CADS
      DOUBLE PRECISION, SAVE, POINTER :: BUD_CDSCONIN, BUD_CDSCONOUT    !TR: 2014 04 16 CADS RCH
      DOUBLE PRECISION, SAVE, POINTER :: BUD_FHLQIN, BUD_FHLQOUT        !TR: 2012 05 11 FHLQ
      DOUBLE PRECISION, SAVE, POINTER :: BUD_WELLIN, BUD_WELLOUT        !TR: 2012 06 08 WELL
      DOUBLE PRECISION, SAVE, POINTER :: BUD_CYIN, BUD_CYOUT            !TR: 2013 03 14 CAUCHY
      DOUBLE PRECISION, SAVE, POINTER :: BUD_CYLQIN, BUD_CYLQOUT        !TR: 2013 03 14 CAUCHY LQ
      DOUBLE PRECISION, SAVE, POINTER :: BUD_LHIN, BUD_LHOUT            !TR: 2013 03 22 LH
      DOUBLE PRECISION, SAVE, POINTER :: BUD_STORAGE_IN, BUD_STORAGE_OUT
      DOUBLE PRECISION, SAVE, POINTER :: TOTAL_BUDGET, BUD_TOTAL_STEP
      DOUBLE PRECISION, SAVE, POINTER :: TS_IN_MAT, TS_OUT_MAT
      DOUBLE PRECISION, SAVE, POINTER :: TS_BUD_SINK, TS_BUD_SOURCE
      DOUBLE PRECISION, SAVE, POINTER :: TS_IN, TS_OUT                  !TR: 2012 04 24 TS_QBDIR REMOVED
      DOUBLE PRECISION, SAVE, POINTER :: KU_IN, KU_OUT                  !TR: 2012 07 17 TOTAL KUMULATIVE TERMS
      DOUBLE PRECISION, SAVE, POINTER :: TS_IN_QBDIR, TS_OUT_QBDIR      !TR: 2012 04 24 TS_IN_QBDIR AND TS_OUT_QBDIR TO DISTIGUISH RECHARGE IN- AND OUT
      DOUBLE PRECISION, SAVE, POINTER :: TS_IN_QSDIR, TS_OUT_QSDIR      !TR: 2014 02 20 CADS RECHARGE
      DOUBLE PRECISION, SAVE, POINTER :: TS_IN_CADS, TS_OUT_CADS        !TR: 2012 04 26 CADS
      DOUBLE PRECISION, SAVE, POINTER :: TS_IN_CDSCON, TS_OUT_CDSCON    !TR: 2014 04 16 CADS RCH
      DOUBLE PRECISION, SAVE, POINTER :: TS_IN_FHLQ, TS_OUT_FHLQ        !TR: 2012 05 11 FHLQ
      DOUBLE PRECISION, SAVE, POINTER :: TS_IN_WELL, TS_OUT_WELL        !TR: 2012 06 08 WELL
      DOUBLE PRECISION, SAVE, POINTER :: TS_IN_CY, TS_OUT_CY            !TR: 2013 03 14 CAUCHY
      DOUBLE PRECISION, SAVE, POINTER :: TS_IN_CYLQ, TS_OUT_CYLQ        !TR: 2013 03 14 CAUCHY LQ
      DOUBLE PRECISION, SAVE, POINTER :: TS_IN_LH, TS_OUT_LH            !TR: 2013 03 23 LH
      DOUBLE PRECISION, SAVE, POINTER :: TS_IN_PFPS, TS_OUT_PFPS        !TR: 2012 07 16 PFPS / RENAMED TS_BUD_STORAGE_OUT/IN AS TS_OUT/IN_PFPS (PARTIALLY FILLED PIPE STORAGE)      
      DOUBLE PRECISION, SAVE, POINTER :: DIFF_TS, TOT_FLOW, TS_TOT_FLOW
C
C--STORAGE (PFPS = PARTIALLY FILLED PIPES STORAGE) AND MATRIX EXCHANGE
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: PFPSFLOW, PFPS2  !TR: 2012 07 12 PFPS / PFPSFLOW =  ;PFPS2 = RESULTING PFPS COEFFICIENT (SIMILAR TO MOD2);      
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: NSTOR            !TR: 2012 07 16 REPLACED QSTOR BY PFPSFLOW
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: QMAT, MATFLOW  
C
C--FOR NODE BUDGET
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: QDIR, QFIX       !TR: 2011 10 24 QDIR NECESSARY? = QBDIR
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: NODIN, NODOUT
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: QTUBIN, QTUBOUT
C
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:,:) :: QTUB
C
C--GSFLOW
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: ROF
C
C--VARIABLES NEEDED FOR MODE 2:
      INTEGER, SAVE, POINTER :: NCL,ICFPCNVG,IRADFLAG,IRADWELCOL
      INTEGER, SAVE, POINTER, DIMENSION(:) :: CL
C
C--FOR RADIAL FLOW MODELS
      DOUBLE PRECISION, SAVE, POINTER,DIMENSION(:) :: R_LENGTH
      DOUBLE PRECISION, SAVE, POINTER :: TWATER, DENSWA, VISCWA
C      
C--ADD SPATIAL VARIABILITY
      DOUBLE PRECISION, SAVE, POINTER,DIMENSION(:,:,:) :: TWATER2, 
     +DENSWA2, VISCWA2,VOID2,LCRITREY2,TCRITREY2,FEEXP                  !TR: 2010 03 22 FEEXP AS FLOW EQUATION EXPONENT 
C
C--BARC**ADD THESE
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:,:,:) :: KLAM_CR,
     +KLAM_CC,KLAM_CV
!     DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:)::NEFF
      INTEGER, SAVE, POINTER, DIMENSION(:,:,:) :: TURB_FR, TURB_FF,
     +TURB_FV
      INTEGER, SAVE, POINTER, DIMENSION(:,:,:) :: TL_OUT
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:,:,:) :: CRT, CCT,CVT
C
C--FOR CAD STORAGE
      INTEGER, SAVE, POINTER :: CADS_FLG, CADSML_FLG                    !TR: 2012 04 25 CADS / CADS_FLG = DEFINES WHETHER CADS IS ACTIVE (1) OR NOT (0) // 2013 06 28 CADSML_FLG
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: W_CADS, L_NODE   !TR: 2012 04 25 CADS / W_CADS = WIDTH OF CAD STORAGE; L_NODE = LENGTH OF TUBES ASSOCIATED TO A NODE      
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: CADSFLOW, CADS2  !TR: 2012 04 26 CADS / CADSFLOW =  ;CADS2 = RESULTING CADS COEFFICIENT (SIMILAR TO MOD2); 
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: CADSML2,CADSML2_P!TR: 2013 06 27 CADSML; CADSML2 = RESULTING CADSML COEFFICIENT (SIMILAR TO MOD2);CADSML2_P = PREVIOUS SAVE VALUE FOR FIRST ITERATION
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:,:,:) :: CADSMLDAT    !TR: 2013 06 28 CADSML; DATA FILE; POS.1 = NODE#, POS.2 = 2 (1 = Z, 2 = W), POS.3 = NUMBER OF ML DATASETS (SO FAR FIXED AS 4)
C
C--FOR FURTHER BC CONSIDERATION
      INTEGER, SAVE, POINTER :: FBC_FLG                                 !TR: 2012 06 08 FLAG TO CONSIDER FURTHER BOUNDARIES 
C
C--FOR FHLQ BOUNDARY                                                    !TR: 2012 05 09       
      LOGICAL, SAVE, POINTER :: FHLQ_FLG, FHLQTD_FLG                    !TR: 2012 05 09 FHLQ / FHLQ_FLG = FLAG INDICATING FHLQ IS ACTIVE / FHLQTD_FLG = FLAG INDICATING FHLQ TIME DEPENDENT INPUT IS ACTIVE
      INTEGER, SAVE, POINTER :: FHLQTD_LINESMAX, FHLQTD_COUNT           !TR: 2013 04 03 WELL TD; MAX NUMBER OF LINES IN INPUT FILES, WELLTD_COUNT = NUMBER OF TD WELLS (BOTH NECESSARY FOR ALLOCATION)
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: Q_FH_LQ, QFHLQ   !TR: 2012 05 09 FHLQ / Q_FH_LQ = FLOW IN FHLQ BC (QFIX OR QFHLQ) QFHLQ = FLOW IN FHLQ BC IF LQ ACTIVE
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:,:) :: DFHLQ          !TR: 2012 05 09 FHLQ / DFHLQ = BOUBLE PRECISION DATA FOR FHLQ BC
      INTEGER, SAVE, POINTER, DIMENSION(:,:) :: IFHLQ                   !TR: 2012 05 09 FHLQ / IFHLQ = INTEGER DATA FOR FHLQ BC
      INTEGER, SAVE, POINTER, DIMENSION(:) :: FHLQ_FLIP, FHLQTD_IN      !TR: 2012 11 01 FHLQ / FHLQ_FLIP COUNTER TO PREVENT OSCILLATIONS; FHLQTD_IN = INPUT FILE NUMBER
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:,:,:) :: FHLQTD_DAT   !TR: 2013 04 04 FHLQ TD
C
C--FOR WELL BOUNDARY                                                    2012 06 08      
      LOGICAL, SAVE, POINTER :: WELL_FLG, WELLTD_FLG                    !TR: 2012 06 08 WELL / WELL_FLG = FLAG INDICATING WELL IS ACTIVE; WELLTD_FLG = FLAG INDICATING THAT TD WELLS ARE ACTIVE
      INTEGER, SAVE, POINTER :: WELLTD_LINESMAX, WELLTD_COUNT           !TR: 2013 04 03 WELL TD; MAX NUMBER OF LINES IN INPUT FILES, WELLTD_COUNT = NUMBER OF TD WELLS (BOTH NECESSARY FOR ALLOCATION)      
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: QWELL            !TR: 2012 06 08 WELL / QWELL = FLOW IN WELL
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:) :: CWC_WELL         !TR: 2016 10 11 WELL / CASING SKIN (CONDUCTANCE); CORRECT NODE HEAD FOR OUTPUT OF WELL HEAD (Q_WELL/CWC+H_NODE)
      INTEGER, SAVE, POINTER, DIMENSION(:) :: IWELL, WELLTD_IN          !TR: 2012 05 09 WELL / IWELL = INTEGER DATA FOR WELL BC = FLAG INDICATING ACTIVE WELL (1) RESPECTIVELY ACTIVE TD WELL (2); WELLTD_IN = INPUT FILE NUMBER
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:,:,:) :: WELLTD_DAT   !TR: 2013 04 03 WELL TD 
C
C--FOR CAUCHY BOUNDARY
      LOGICAL, SAVE, POINTER :: CY_FLG, CYTD_FLG                        !TR: 2013 03 13 CAUCHY / CY_FLG = FLAG INDICATION CAUCHY IS ACTIVE (TRUE) / 2013 04 03 CYTD_FLG = FLAG FOR CAUCHY TD
      INTEGER, SAVE, POINTER :: CYTD_LINESMAX, CYTD_COUNT               !TR: 2013 04 03 CAUCHY TD; MAX NUMBER OF LINES IN INPUT FILES, CYTD_COUNT = NUMBER OF TD CAUCHY BCS (BOTH NECESSARY FOR ALLOCATION)
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:)::HCY,CONDCY,CONDCYS !TR: 2013 03 13 CAUCHY / HCY = CAUCHY HEAD, CONDCY = CAUCHY CONDUCTANCE, CONDCYS = SAVED CAUCHY CONDUCTANCE FOR LQ SITUATIONS
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:)::CYLQ,CYFLOW,QCYLQ  !TR: 2013 03 15 CAUCHY / CYLQ = LIMITED INFLOW FOR CAUCHY BC, QCYLQ = CAUCHY FLOW LQ; CY_FLOW CAUCHY FLOW
      INTEGER, SAVE, POINTER, DIMENSION(:) :: CY_FLIP, CYTD_IN          !TR: 2013 03 14 CAUCHY / CY_FLIP COUNTER TO PREVENT OSCILLATIONS / CYTD_IN = INPUT FILE NUMBER
      INTEGER, SAVE, POINTER, DIMENSION(:,:) :: ICY                     !TR: 2012 05 09 CAUCHY / ICY = INTEGER DATA FOR FHLQ BC      
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:,:,:)::CYTD_DAT       !TR: 2013 04 03 CAUCHY TD      
C      
C--FOR LIMITED HEAD (LH) BOUNDARY
      LOGICAL, SAVE, POINTER :: LH_FLG                                  !TR: 2013 03 13 LH / LH_FLG = FLAG INDICATION LH BOUNDARY IS ACTIVE (TRUE)
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:)::HLH                !TR: 2013 03 13 LH / HLH = LIMITED HEAD
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:)::QLH                !TR: 2013 03 15 LH / CYLQ = LIMITED INFLOW FOR CAUCHY BC, QCYLQ = CAUCHY FLOW
      INTEGER, SAVE, POINTER, DIMENSION(:) :: LH_FLIP                   !TR: 2013 03 14 LH / LH_FLIP COUNTER TO PREVENT OSCILLATIONS
      INTEGER, SAVE, POINTER, DIMENSION(:,:) :: ILH                     !TR: 2012 05 09 LH / ICY = INTEGER DATA FOR FHLQ BC      
C
C--FOR FIXED HEAD TD BOUNDARY
      LOGICAL, SAVE, POINTER :: FHTD_FLG                                !TR: 2013 04 04 FHTD FHTD_FLG = FLAG FOR CAUCHY TD
      INTEGER, SAVE, POINTER :: FHTD_LINESMAX, FHTD_COUNT               !TR: 2013 04 04 FHTD FHTD_LINESMAX = MAX NUMBER OF LINES IN INPUT FILES, FHTD_COUNT = NUMBER OF TD CAUCHY BCS (BOTH NECESSARY FOR ALLOCATION)
      INTEGER, SAVE, POINTER, DIMENSION(:) :: FHTD_IN                   !TR: 2013 04 04 FHTD FHTD_IN = INPUT FILE NUMBER
      DOUBLE PRECISION, SAVE, POINTER, DIMENSION(:,:,:)::FHTD_DAT       !TR: 2013 04 04 FHTD FHTD_DAT = TIME DEPENDENT FIXED HEAD      
C      
      END MODULE CFPMODULE
C
C
C
C
C
      SUBROUTINE GWF2CFP1AR(INUNIT, INCFPOC, INCFPRCH,CFPMODE)
C
C     ******************************************************************
C     ALLOCATE AND READ DATA FOR CONDUIT FLOW PROCESS
C     MARCH 2007 VERSION 1.0
C     ******************************************************************
C
      USE CONSTANTS, ONLY: TRUE,FALSE,Z,ONE,NEG,NINER,DZ,DOS,NEARZERO_30
      USE GLOBAL, ONLY:IOUT, NCOL, NROW, NLAY, LENUNI, ITMUNI,BOTM,DELR
      USE CFPMODULE
      IMPLICIT NONE
      INTRINSIC DINT
C
C--BARC**NEED THESE FUNCTIONS
      DOUBLE PRECISION, EXTERNAL :: DYNVISC, KINVISC
      EXTERNAL CFP1PC, CALC_DENS_VISC, CFPM1OCAR, INITDDATA, READTD     !, GWF2CFP1PSV         !TR: 2011 10 13 U2DREL MISSING HERE? / 2013 04 04 TIME DEPENDENT BC
      EXTERNAL EINTRD_MULTI                                             !TR: 2018 05 22 LISTING OUTPUT
C--ARGUMENTS
      INTEGER, INTENT(IN) :: INUNIT, INCFPOC, INCFPRCH
      INTEGER   CFPMODE, READIN(8)                                      !TR: 2018 05 22 LISTING OUTPUT
C
C--LOCAL VARIABLES
      INTEGER I, IC, II, IL, IR, J, IDUMMY,K,KK, JJ, JJJ,NUM            !TR: 2016 10 11 NUM FOR COUNT_LINE_NUMBERS ROUTINE
      CHARACTER(LEN=80) CDUMMY
      DOUBLE PRECISION DUMMY2, DUMMY3, DUMMY4, DUMMY5, DUMMY6
      CHARACTER (LEN=8) BC_TYPE,  NAME_MULTI(8)                         !TR: 2012 05 09 FHLQ / TO CONSIDER FURTHER BC DATA; READ IN N_HEAD DATA (LINE 27 OF CFPM1 INPUT) // 2018 05 22 LISTING OUTPUT
      DOUBLE PRECISION BC_DUMMY1, BC_DUMMY2                             !TR: 2012 05 09 FHLQ / DUMMYS FOR BC_DATA
      INTEGER FHLQ_COUNT, WELL_COUNT, CY_COUNT, LH_COUNT                !TR: 2012 05 09 FHLQ / WELL / FHLQ_COUNT / WELL_COUNT = COUNTER TO CHECK FHLQ /WELL BC INPUT / 2013 03 13 CAUCHY / 2013 03 22 LH / 2013 04 03  WELL TD
      REAL,DIMENSION(:,:),ALLOCATABLE:: ARR
C
C--BARC**FOR CFPMODE 2 U2DREL
      CHARACTER*24 ANAME(5)
CB      CHARACTER*12 AVGNAM(4)
CB      DATA AVGNAM/'HARMONIC    ','ARITHMETIC  ',
CB     1            'LOGARITHMIC ','*UNCONFINED*'/
C
      DATA ANAME(1) /'                 GW TEMP'/
      DATA ANAME(2) /'      MEAN VOID DIAMETER'/
      DATA ANAME(3) /'   LOWER CRIT REY NUMBER'/
      DATA ANAME(4) /'   UPPER CRIT REY NUMBER'/
      DATA ANAME(5) /'            TURB EXP (M)'/     
C      
C--ALLOCATE SCALAR DATA.
      ALLOCATE (MODE, MXNODE, MXTUBE, NBR_LAY, KONV, FTURB, ITERS)
      ALLOCATE (FBC_FLG, FHLQ_FLG, CADS_FLG, WELL_FLG, CY_FLG, LH_FLG,  !TR: 2012 05 09 FHLQ / CADS / WELL / 2012 11 01 FHLQ_FLIP / 2013 03 13 CAUCHY / 2013 03 22 LH
     +  WELLTD_FLG, WELLTD_LINESMAX, WELLTD_COUNT, CYTD_FLG, CYTD_COUNT,
     +  CYTD_LINESMAX, FHTD_FLG, FHTD_LINESMAX, FHTD_COUNT,FHLQTD_FLG,
     +  FHLQTD_LINESMAX, FHLQTD_COUNT, CADSML_FLG)                      !TR: 2013 04 03 WELL TD / CY TD / FHTD / FHLQTD // 2013 06 28 CADSML
      ALLOCATE (ACTIVENODE, ITERA_MAX, LSURFACEDEP, P_NR)
      ALLOCATE (L_NTS, NO_L_NTS)                                        !TR: 2018 05 22 LISTING OUTPUT
      ALLOCATE (G, EPSILON, CFPRELAX, TC, IFLAG_RECH)
      ALLOCATE (NCL,ICFPCNVG,TWATER,DENSWA,VISCWA,KTSNO,KTSTU,KTSTSAN,  !TR: 2013 08 13 TSAN
     + KTSTSAT,L_ABS)                                                   !TR: 2013 08 13 TSAT, !TR: 2014 11 18 L_ABS
      !
      ALLOCATE(ARR(NCOL,NROW))                                          !seb TMP space for U2DREL
C
C--INITIALIZE
      CADS_FLG = Z                                                      !TR: 2012 05 09 CADS / INI CADS_FLG
      CADSML_FLG = Z                                                    !TR: 2013 06 28 CADSML / INI CADSML_FLG
      FHLQ_FLG = FALSE                                                !TR: 2012 05 09 FHLQ / INI FHLQ_FLG
      FHLQTD_FLG = FALSE                                              !TR: 2012 05 09 FHLQ / INI FHLQTD_FLG
      WELL_FLG = FALSE                                                !TR: 2012 06 08 WELL / INI WELL_FLG
      WELLTD_FLG = FALSE                                              !TR: 2013 04 03 WELL TD / INI WELLTD_FLG
      CY_FLG   = FALSE                                                !TR: 2013 03 13 CAUCHY / INI CY_FLG
      CYTD_FLG = FALSE                                                !TR: 2013 04 03 CAUCHY TD
      LH_FLG   = FALSE                                                !TR: 2013 03 22 LH / INI LH_FLG
      FHTD_FLG = FALSE                                                !TR: 2013 04 04 FHTD
      FBC_FLG  = Z                                                      !TR: 2012 06 08 INI FBC_FLG
      WELLTD_LINESMAX = Z                                               !TR: 2013 04 03 WELL TD
      WELLTD_COUNT = Z                                                  !TR: 2013 04 03 WELL TD
      CYTD_LINESMAX = Z                                                 !TR: 2013 04 03 WELL TD
      CYTD_COUNT = Z                                                    !TR: 2013 04 03 WELL TD
      FHTD_LINESMAX = Z                                                 !TR: 2013 04 04 FHTD
      FHTD_COUNT = Z                                                    !TR: 2013 04 04 FHTD
      FHLQTD_LINESMAX = Z                                               !TR: 2013 04 04 FHLQTD
      FHLQTD_COUNT = Z                                                  !TR: 2013 04 04 FHLQTD
      L_ABS = DZ                                                       !TR: 2014 11 18 L_ABS
      NO_L_NTS = Z                                                     !TR: 2018 05 22 COUNTER FOR LISTING OUTPUT
      L_NTS = ONE                                                      !TR: 2018 05 22 NUMBER OF TIME STEPS FOR LISTING OUTPUT (CALL FREQUENCY OF NWBOUT AND FLOW_OUTPUT)
C
C--CBARC**FOR BUDGETS AND OUTPUT CONTROL
      ALLOCATE (BUD_SOURCE, BUD_SINK, BUD_MATIN, BUD_MATOUT,            !TR: 2012 04 24 BUD_QBDIR REMOVED
     +          TOTAL_BUDGET, BUD_TOTAL_STEP, TS_IN_MAT, TS_OUT_MAT,    
     +          TS_BUD_SINK, TS_BUD_SOURCE, TS_IN, TS_OUT,              !TR: 2012 04 24 TS_QBDIR REMOVED
     +          DIFF_TOT, DIFF_TS, TOT_FLOW, TS_TOT_FLOW,               
     +          BUD_QBDIRIN, BUD_QBDIROUT, TS_IN_QBDIR, TS_OUT_QBDIR,   !TR: 2012 04 24 VARIABLES ADDED TO DISTIGUISH RECHARGE IN- AND OUT
     +          BUD_CADSIN, BUD_CADSOUT, TS_IN_CADS, TS_OUT_CADS,       !TR: 2012 04 26 CADS /
     +          BUD_FHLQIN, BUD_FHLQOUT, TS_IN_FHLQ, TS_OUT_FHLQ,       !TR: 2012 05 11 FHLQ /
     +          BUD_WELLIN, BUD_WELLOUT, TS_IN_WELL, TS_OUT_WELL,       !TR: 2012 06 08 WELL /
     +          BUD_CYIN, BUD_CYOUT, TS_IN_CY, TS_OUT_CY, TS_IN_CYLQ,   !TR: 2012 06 08 CAUCHY
     +          TS_OUT_CYLQ, BUD_CYLQIN, BUD_CYLQOUT, BUD_LHIN, 
     +          BUD_LHOUT, TS_IN_LH, TS_OUT_LH, KU_IN, KU_OUT,          !TR: 2012 07 17 CUMULATIVE TERMS / 2013 03 22 LH
     +          BUD_QSDIRIN, BUD_QSDIROUT, TS_IN_QSDIR, TS_OUT_QSDIR,   !TR: 2014 02 20 CADS RECHARGE
     +          BUD_CDSCONIN,BUD_CDSCONOUT,TS_IN_CDSCON,TS_OUT_CDSCON)  !TR: 2014 04 16 CADS RCH
      BUD_SOURCE = DZ
      BUD_SINK = DZ
      BUD_MATIN = DZ
      BUD_MATOUT = DZ
      BUD_QBDIRIN = DZ                                                !TR: 2012 04 24 TO DISTIGUISH RECHARGE IN- AND OUT
      BUD_QBDIROUT = DZ                                               !TR: 2012 04 24 TO DISTIGUISH RECHARGE IN- AND OUT
      BUD_QSDIRIN = DZ                                                !TR: 2014 02 20 CADS RECHARGE
      BUD_QSDIROUT = DZ                                               !TR: 2014 02 20 CADS RECHARGE
      BUD_CADSIN = DZ                                                 !TR: 2012 04 26 CADS /
      BUD_CADSOUT = DZ                                                !TR: 2012 04 26 CADS /
      BUD_CDSCONIN = DZ                                               !TR: 2014 04 16 CADS RCH
      BUD_CDSCONOUT = DZ                                              !TR: 2014 04 16 CADS RCH
      BUD_FHLQIN = DZ                                                 !TR: 2012 05 11 FHLQ /
      BUD_FHLQOUT = DZ                                                !TR: 2012 05 11 FHLQ /
      BUD_WELLIN = DZ                                                 !TR: 2012 06 08 WELL /
      BUD_WELLOUT = DZ                                                !TR: 2012 06 08 WELL /
      BUD_CYIN = DZ                                                   !TR: 2013 03 14 CAUCHY
      BUD_CYOUT = DZ                                                  !TR: 2013 03 14 CAUCHY
      BUD_CYLQIN = DZ                                                 !TR: 2013 03 14 CAUCHY LQ
      BUD_CYLQOUT = DZ                                                !TR: 2013 03 14 CAUCHY LQ
      BUD_LHIN = DZ                                                   !TR: 2013 03 22 LH
      BUD_LHOUT = DZ                                                  !TR: 2013 03 22 LH
      TOTAL_BUDGET = DZ
      BUD_TOTAL_STEP = DZ
      KU_IN = DZ
      KU_OUT = DZ
C 
C--BARC**STORAGE AND MATRIX EXCHANGE
      ALLOCATE (TS_IN_PFPS, TS_OUT_PFPS)
      ALLOCATE (BUD_STORAGE_IN, BUD_STORAGE_OUT)                        !TR: 2012 07 16 REMOVED TS_BUD_STORAGE
      BUD_STORAGE_IN = DZ
      BUD_STORAGE_OUT = DZ
C 
C--BARC**WRITE MESSAGE TO OUTPUT IOUT
      WRITE (IOUT, *)
      WRITE (IOUT, *) 'CFP1AR READING FROM UNIT', INUNIT
C 
C--BARC**READ MODE TO DETERMINE WHAT IS READ FROM CFP FILE.
C--ELK**READ CFP INPUT FILE CDUMMY REQUIRED COMMENT LINE FOR SIMULATION
      READ (INUNIT, *) CDUMMY
C
C--ELK**READ CFP INPUT DATA TYPE 0 IN REPORT DOCUMENTATION
      READ (INUNIT, *) MODE
      CFPMODE = MODE                                                    !TR: 2009 11 10 CFPMODE
C
C--BARC**SKIP PIPE ALLOCATES AND READS IF MODE=2
      IF ( MODE.NE.2 ) THEN
C
C--BARC**READ WHAT IS NEEDED FOR PIPES
        WRITE (IOUT, *) '---------------------------------'
        WRITE (IOUT, *) 'CFP MODE 1 IS ACTIVE (PIPES) '
        WRITE (IOUT, *) '---------------------------------'
C
C--ELK**READ CFP INPUT FILE DATA TYPE 1 AND 2 REQUIRED COMMENT LINES
        READ (INUNIT,'(A)') CDUMMY
C
C--CHECK IF FURTHER BOUNDARY DATA ARE ACTIVE - HERE THE FIRST COMMENT 
C  LINE IS USED; CHECK FOR FBC PARAMETERS AND SET FLAGS        
        CALL CHECKPARA(CDUMMY,"FBC",IOUT,FBC_FLG)        
        CALL CHECKPARA(CDUMMY,"CADS",IOUT,CADS_FLG)    
        CALL CHECKPARA(CDUMMY,"CADSML",IOUT,CADSML_FLG)                 !TR: 2013 06 28 CADSML
        IF (CADS_FLG.EQ.1.AND.CADSML_FLG.EQ.1) CALL USTOP('BOTH CADS AND!TR: 2013 06 28 CADSML
     + CADSML ARE ACTIVE - DEACTIVATE ONE - STOP')
C 
C--BARC&ELK**READ CFP INPUT FILE DATA TYPE 3 MXNODE,MXTUBE,NBR_LAY
C--BARC**SET NNOD, THIS IS THE MAXIMUM # OF CONNECTING NODES (3-D)
        READ (INUNIT, *) CDUMMY    
        READ (INUNIT, *) MXNODE, MXTUBE, NBR_LAY     
        WRITE (IOUT, 9001) MXNODE
        WRITE (IOUT, 9009) MXTUBE
        WRITE (IOUT, 9002) NBR_LAY
C 
C--SEBA--TEST IF # OF LAYERS IN MODFLOW AND CONDUIT IS THE SAME
        IF ( NLAY.NE.NBR_LAY ) THEN
          PRINT *,                                                      
     +    'THE NUMBER OF LAYERS IN MODFLOW AND CFP FILE IS NOT THE SAME'
          PRINT *, '  PROGRAM STOPS'
          STOP
        ENDIF
C        
C--BARC**ALLOCATE MODE 1 ARRAYS AND VARIABLES THAT NEED MXNODE,MXTUBE,
C  NBR_LAY
        ALLOCATE (NBR(MXNODE,4+2*NNOD))
        ALLOCATE (NODETOP(MXNODE), NODEBOT(MXNODE))
!       ALLOCATE (LAY_THICK(NBR_LAY))
C 
C--BARC**ALLOCATE CFP MODE 1 STRESS PERIOD DATA
        ALLOCATE (CON_DATA(MXTUBE,6))
        ALLOCATE (BEGHEAD(MXNODE), MODD(MXNODE), TORTUOS(MXTUBE),       
     +            ROUGHNESS(MXTUBE))
C
C--DATA FOR FHLQ AND WELL BC
        ALLOCATE (Q_FH_LQ(MXNODE), QFHLQ(MXNODE),QWELL(MXNODE), 
     +   HCY(MXNODE),CONDCY(MXNODE),CONDCYS(MXNODE),FHLQ_FLIP(MXNODE),  
     +   CY_FLIP(MXNODE),QCYLQ(MXNODE),CYLQ(MXNODE),CYFLOW(MXNODE),
     +   IWELL(MXNODE),QLH(MXNODE),LH_FLIP(MXNODE),HLH(MXNODE),
     +   WELLTD_IN(MXNODE), CYTD_IN(MXNODE), FHTD_IN(MXNODE),
     +   FHLQTD_IN(MXNODE),CWC_WELL(MXNODE))                            !TR: 2012 05 11 FHLQ / 2012 06 08 WELL / 2013 03 13 CAUCHY / 2012 11 01 FHLQ / 2013 03 22 LH / 2013 04 03 WELL TD / 2013 04 04 FHTD / 2013 04 04 FHLQTD / 2016 10 11 CWC_WELL
        ALLOCATE (DFHLQ(MXNODE,2),IFHLQ(MXNODE,2),ICY(MXNODE,2),
     +   ILH(MXNODE,2))                                                 !TR: 2012 05 09 FHLQ / 2013 03 14 CAUCHY / 2013 03 22 LH
C
C--INITIALIZE     
        DO I = 1, MXNODE                                                !TR: 2012 05 09 FHLQ /
          DO J = 1, 2                                                   !TR: 2012 05 09 FHLQ /
            IFHLQ(I,J) = Z                                              !TR: 2012 05 09 FHLQ /
            DFHLQ(I,J) = DZ                                             !TR: 2012 05 09 FHLQ /
            ICY(I,J) = Z                                                !TR: 2013 03 14 CAUCHY
            ILH(I,J) = Z                                                !TR: 2013 03 22 LH
          ENDDO                                                         !TR: 2012 05 09 FHLQ /
          IWELL(I) = Z                                                  !TR: 2013 03 18 WELL
          QFHLQ(I) = DZ                                                 !TR: 2012 05 11 FHLQ /
          Q_FH_LQ(I) = DZ                                               !TR: 2012 05 16 FHLQ /
          QWELL(I) = DZ                                                 !TR: 2012 06 08 WELL /
          CWC_WELL(I) = DZ                                              !TR: 2016 10 11 WELL / INTERNAL SKIN
          HCY(I) = DZ                                                   !TR: 2013 03 13 CAUCHY
          CONDCY(I) = DZ                                                !TR: 2013 03 13 CAUCHY
          CONDCYS(I) = DZ                                               !TR: 2013 03 13 CAUCHY
          QCYLQ(I) = DZ                                                 !TR: 2013 03 14 CAUCHY
          CYLQ(I) = DZ                                                  !TR: 2013 03 14 CAUCHY
          CYFLOW(I) = DZ                                                !TR: 2013 03 18 CAUCHY
          QLH(I) = DZ                                                   !TR: 2013 03 22 LH
          HLH(I) = DZ                                                   !TR: 2013 03 22 LH
          WELLTD_IN(I) = Z                                              !TR: 2013 04 03 WELL TD
          CYTD_IN(I) = Z                                                !TR: 2013 04 03 CAUCHY TD
          FHTD_IN(I) = Z                                                !TR: 2013 04 04 FHTD
          FHLQTD_IN(I) = Z                                              !TR: 2013 04 04 FHLQTD
        ENDDO               
C 
C--BARC**SET ACTIVENODE
        ACTIVENODE = MXNODE                                             !TR: 2013 03 22 TODO: SET ACTIVENODE TO NUMBER OF USED NODES
C 
C--BARC**FOR RECHARGE
        ALLOCATE (QCONDIR(MXNODE), QCONDIROLD(MXNODE))
        QCONDIR = DZ                                                  !TR: 2014 04 09 
        QCONDIROLD = DZ                                               !TR: 2014 04 09 
C
C--FOR CADS RECHARGE
        ALLOCATE (QCDSDIR(MXNODE), QCDSDIROLD(MXNODE),QSDIR(MXNODE),    !TR: 2014 02 19 CADS RECHARGE
     +   QSDIROLD(MXNODE), QSDIRSAVE(MXNODE))                           !TR: 2014 02 19 CADS RECHARGE
          QCDSDIR = DZ                                                !TR: 2014 02 19 CADS RECHARGE
          QCDSDIROLD = DZ                                             !TR: 2014 02 19 CADS RECHARGE
          QSDIR = DZ                                                  !TR: 2014 02 19 CADS RECHARGE
          QSDIROLD = DZ                                               !TR: 2014 02 19 CADS RECHARGE
          QSDIRSAVE = DZ                                              !TR: 2014 02 19 CADS RECHARGE
C 
C--BARC**ALOCATE THESE FOR PIPE FLOW FORMULATE SUBROUTINES
        ALLOCATE (MOD2(MXNODE), HC(MXNODE), B_MAT(MXNODE), B(MXNODE),   
     +            B_MAT_O(MXNODE), B_MAT_P(MXNODE), B_MAT_OTR(MXNODE))  !TR: 2012 07 16 PFPS / ADDED B_MAT_P (= RESULTS FROM PREVIOUS ITERATION) // 2014 02 28  B_MAT_OTR
        B_MAT = DZ
        B_MAT_O = DZ
        B_MAT_P = DZ                                                  !TR: 2012 07 16 PFPS
        B_MAT_OTR = DZ                                                !TR: 2014 02 28 
C 
C--BARC**FOR CFP1PC
        ALLOCATE (ITUBE(MXTUBE,4), DTUBE(MXTUBE,3), NODE_LOCA(MXNODE,4))!TR: 2011 10 24 CHANGED ITUBE FROM MXTUBE,3 TO MXTUBE,4; NO#4 REPRESENTS FLAG INDICATING WHETHER THE TUBE IS DRY (-1) OR NOT (1) // 2014 07 31 DTUBE INDEX INCREASED TO 3; #3 IS DEQV (EQUIV. DIAM. FOR PARTIALLY FILLED PIPES)
        ITUBE = Z
        DTUBE = DZ
        ALLOCATE (TOP(NCOL,NROW,NLAY))
        ALLOCATE (QBDIR(MXNODE), TURB(MXTUBE), FX0(MXNODE),             
     +            QBDIROLD(MXNODE), QBDIRSAVE(MXNODE))
        TURB = Z
C
C--BARC**ADD TAUI
        ALLOCATE (TUB_REYNOLD(MXTUBE), HEAD_SAVE(MXNODE),TAUI(MXTUBE))
        TUB_REYNOLD = DZ
        ALLOCATE (INDEX1(ACTIVENODE), EQ_MAT(ACTIVENODE,ACTIVENODE))
C 
C--BARC**FOR BUDGETS AND OUTPUT CONTROL
        ALLOCATE (QTUB(MXNODE,NNOD))
        ALLOCATE (MATFLOW(MXNODE),QMAT(MXNODE),NSTOR(MXNODE),
     +   QDIR(MXNODE),NODIN(MXNODE),NODOUT(MXNODE),QFIX(MXNODE),
     +   QTUBIN(MXNODE),QTUBOUT(MXNODE))
C
C--BARC**ADD THIS FOR GSFLOW
        ALLOCATE (ROF(MXNODE))
C
C--BARC**MAKE SURE LENGTH AND TIME UNITS ARE NOT UNDEFINED, SO THAT G
C  CAN BE DEFINED
        IF ( ITMUNI.EQ.Z .OR. LENUNI.EQ.Z ) THEN
          PRINT *, 'ERROR IN DIS FILE, ITMUNI AND LENUNIT CANNOT BE',   
     +          ' UNDEFINED WHEN CFP IS ACTIVE'
          STOP
        ENDIF
C 
C--BARC**SET G
        IF ( ITMUNI.EQ.1 .AND. LENUNI.EQ.2 ) G = 9.80665D0              !C--BARC**UNITS ARE M SEC-2
        IF ( ITMUNI.EQ.2 .AND. LENUNI.EQ.2 ) G = 9.80665D0*60.D0**DOS   !C--BARC**UNITS ARE M MIN-2
        IF ( ITMUNI.EQ.3 .AND. LENUNI.EQ.2 )                            !C--BARC**UNITS ARE M HOURS-2
     +       G = 9.80665D0*60.D0**DOS*60.D0**DOS
        IF ( ITMUNI.EQ.4 .AND. LENUNI.EQ.2 )                            !C--BARC**UNITS ARE M DAYS-2
     +       G = 9.80665D0*60.D0**DOS*60.D0**DOS*24.D0**DOS
        IF ( ITMUNI.EQ.5 .AND. LENUNI.EQ.2 )                            !C--BARC**UNITS ARE M YEAR-2
     +       G = 9.80665D0*60.D0**DOS*60.D0**DOS*24.D0**DOS*365.D0**DOS
        IF ( ITMUNI.EQ.1 .AND. LENUNI.EQ.1 ) G = 9.80665D0*CM2INCH      !C--BARC**UNITS ARE FT SEC-2
        IF ( ITMUNI.EQ.2 .AND. LENUNI.EQ.1 )                            !C--BARC**UNITS ARE FT MIN-2
     +       G = 9.80665D0*CM2INCH*60.D0**DOS
        IF ( ITMUNI.EQ.3 .AND. LENUNI.EQ.1 )                            !C--BARC**UNITS ARE FT HOURS-2
     +       G = 9.80665D0*CM2INCH*60.D0**DOS*60.D0**DOS
        IF ( ITMUNI.EQ.4 .AND. LENUNI.EQ.1 )                            !C--BARC**UNITS ARE FT DAYS-2
     +       G = 9.80665D0*CM2INCH*60.D0**DOS*60.D0**DOS*24.D0**DOS
        IF ( ITMUNI.EQ.5 .AND. LENUNI.EQ.1 )                            !C--BARC**UNITS ARE FT YEAR-2
     +       G = 9.80665D0*CM2INCH*60.D0**DOS*60.D0**DOS*24.D0**DOS     
     +           *365.D0**DOS
        IF ( ITMUNI.EQ.1 .AND. LENUNI.EQ.3 ) G = 9.80665D0*100.D0       !C--BARC**UNITS ARE CM SEC-2
        IF ( ITMUNI.EQ.2 .AND. LENUNI.EQ.3 )                            !C--BARC**UNITS ARE CM MIN-2
     +       G = 9.80665D0*100.D0*60.D0**DOS
        IF ( ITMUNI.EQ.3 .AND. LENUNI.EQ.3 )                            !C--BARC**UNITS ARE CM HOURS-2
     +       G = 9.80665D0*100.D0*60.D0**DOS*60.D0**DOS
        IF ( ITMUNI.EQ.4 .AND. LENUNI.EQ.3 )                            !C--BARC**UNITS ARE CM DAYS-2
     +       G = 9.80665D0*100*60**DOS*60**DOS*24**DOS
        IF ( ITMUNI.EQ.5 .AND. LENUNI.EQ.3 )                            !C--BARC**UNITS ARE CM YEAR-2
     +       G = 9.80665D0*100.D0*60.D0**DOS*60.D0**DOS*24.D0**DOS      
     +           *365.D0**DOS
C 
        WRITE (IOUT, *) 'GRAVITATIONAL CONSTANT (G) COMPUTED '
C
C--BARC**ALLOCATE AND INITIALIZE NCOND
        ALLOCATE (NCOND(NCOL,NROW,NLAY))
        DO IL = 1, NLAY
          DO IR = 1, NROW
            DO IC = 1, NCOL
              NCOND(IC, IR, IL) = Z
            ENDDO
          ENDDO
        ENDDO
C 
C--BARC&ELK**READ COMMENT CFC INPUT FILE DATA TYPE 4 AND TEMPERATURE IN
C  C DATA TYPE 5
        READ (INUNIT, '(A)') CDUMMY
        READ (INUNIT, *) TC
        WRITE (IOUT, *) 'WATER TEMPERATURE, IN DEGREES CELCIUS, IS ', TC
C 
C--BARC**CALCULATE DYNAMIC VISCOSITY
        ALLOCATE (NU, VISCTC, VNUTC)
C
C--BARC**COMING OUT OF HERE IN PA S                                     !TR: 2015 01 20 TODO TEMPERATURE DEPENDENCE (COUPLING WITH HEAT TRANSPORT)
        VISCTC = DYNVISC(TC) 
C
C--CALCULATE KINEMATIC VISCOSITY (COMES OUT WITH UNITS OF M2/SEC)
        VNUTC = KINVISC(TC, VISCTC)                                     !TR: 2015 01 20 TODO TEMPERATURE DEPENDENCE (COUPLING WITH HEAT TRANSPORT)
C
        IF ( ITMUNI.EQ.1 .AND. LENUNI.EQ.2 ) VNUTC = VNUTC*1.D0         !C--BARC**UNITS ARE M2/S
        IF ( ITMUNI.EQ.2 .AND. LENUNI.EQ.2 ) VNUTC = VNUTC*60.D0        !C--BARC**UNITS ARE M2 / MIN
        IF ( ITMUNI.EQ.3 .AND. LENUNI.EQ.2 ) VNUTC = VNUTC*60.D0**DOS   !C--BARC**UNITS ARE M2/HOUR
        IF ( ITMUNI.EQ.4 .AND. LENUNI.EQ.2 )                            !C--BARC**UNITS ARE M2/DAY
     +       VNUTC = VNUTC*60.D0**DOS*24.D0
        IF ( ITMUNI.EQ.5 .AND. LENUNI.EQ.2 )                            !C--BARC**UNITS ARE M2/YEAR
     +       VNUTC = VNUTC*60.D0**DOS*24.D0*365.D0
        IF ( ITMUNI.EQ.1 .AND. LENUNI.EQ.1 )                            !C--BARC**UNITS ARE FT2 /SEC
     +       VNUTC = VNUTC*CM2INCH**DOS
        IF ( ITMUNI.EQ.2 .AND. LENUNI.EQ.1 )                            !C--BARC**UNITS ARE FT2/MIN
     +       VNUTC = VNUTC*CM2INCH**DOS*60.D0
        IF ( ITMUNI.EQ.3 .AND. LENUNI.EQ.1 )                            !C--BARC**UNITS ARE FT2/HR
     +       VNUTC = VNUTC*CM2INCH**DOS*60.D0**DOS
        IF ( ITMUNI.EQ.4 .AND. LENUNI.EQ.1 )                            !C--BARC**UNITS ARE FT2/DAY
     +       VNUTC = VNUTC*CM2INCH**DOS*60.D0**DOS*24.D0
        IF ( ITMUNI.EQ.5 .AND. LENUNI.EQ.1 )                            !C--BARC**UNITS ARE FT2/YR
     +       VNUTC = VNUTC*CM2INCH**DOS*60.D0**DOS*24.D0*365.D0
        IF ( ITMUNI.EQ.1 .AND. LENUNI.EQ.3 ) VNUTC = VNUTC*100.D0**DOS  !C--BARC**UNITS ARE CM2/SEC
        IF ( ITMUNI.EQ.2 .AND. LENUNI.EQ.3 )                            !C--BARC**UNITS ARE CM2/MIN
     +       VNUTC = VNUTC*100.D0**DOS*60.D0
        IF ( ITMUNI.EQ.3 .AND. LENUNI.EQ.3 )                            !C--BARC**UNITS ARE CM2/HR
     +       VNUTC = VNUTC*100.D0**DOS*60.D0**DOS
        IF ( ITMUNI.EQ.4 .AND. LENUNI.EQ.3 )                            !C--BARC**UNITS ARE CM2/DAY
     +       VNUTC = VNUTC*100.D0**DOS*60.D0**DOS*24.D0
        IF ( ITMUNI.EQ.5 .AND. LENUNI.EQ.3 )                            !C--BARC**UNITS ARE CM2/YR
     +       VNUTC = VNUTC*100.D0**DOS*60.D0**DOS*24.D0*365.D0
C 
        WRITE (IOUT, *) ' KINEMATIC VISCOSITY [L^2/T]=', VNUTC
C
C--BARC**SET NU
        NU = VNUTC
C
C--READ IN NODES, TUBES AND THEIR RELATION => NBR-ARRAY
C--ELK READ CFP INPUT DATA TYPE 6 REQUIRED COMMENT LINE
        READ (INUNIT, '(A)') CDUMMY
        WRITE (IOUT, *)
        WRITE (IOUT, *) ' NBR-ARRAY: '
C
C--ELK READ CFP INPUT DATA TYPE 7
C--ELK READ NO_N  MC  MR  ML  NB1  NB2  NB3  NB4  NB5  NB6  PB1  PB2  
C  PB3  PB4  PB5  PB6
        DO I = 1, MXNODE
          READ (INUNIT, *) (NBR(I,J), J=1, (4+2*NNOD))
          WRITE (IOUT, 9003) (NBR(I,J), J=1, (4+2*NNOD))
        ENDDO
        WRITE (IOUT, *) 'NBR ARRAY READ'
C 
C--BIRK---WRITE NODE NUMBERS TO NCOND
        DO I = 1, MXNODE
          IC = NBR(I, 2)
          IR = NBR(I, 3)
          IL = NBR(I, 4)
C
          IF(NCOND(IC,IR,IL).EQ.Z) THEN
            NCOND(IC, IR, IL) = I
          ELSE
            WRITE(IOUT,'(A34,3I5)') 
     +                 'ERROR, DOS NODES WITHIN CELL JIK =',IC,IR,IL
            STOP
          ENDIF
        ENDDO
C
C--BARC**STOP IF MULTIPLE NODES IN A SINGLE MODEL CELL
C 
C--BARC**ALLOCATE AND READ DATA TO DETERMINE ELEVATION OF NODES
        ALLOCATE (GEOHIGHT(MXNODE))
C
C--ELK READ CFP INPUT FILE DATA TYPE 8-10 3 REQUIRED COMMENT LINES 
        READ (INUNIT, '(A)') CDUMMY
        READ (INUNIT, '(A)') CDUMMY
        READ (INUNIT, '(A)') CDUMMY
C
C--ELK READ CFP INPUT FILE DATA TYPE 11 NOTE READ DUMMY FIRST BECAUSE 
C  ELK OF 2 OPTIONS FOR THE ELEVATION OF THE NODE HEIGHT
C  ELK      OPTION 1 USER MUST ENTER ABSOLUTE NODE HEIGHT 
C  !TR:     ADDED OPTION TO DEFINE A UNIFORM VALUE FOR ABSOLUTE NODE HEIGHT
C  !TR:     THIS OPTION IS ACTIVE IF NUMBER IS -1 
        READ (INUNIT, *) IDUMMY, DUMMY2
        IF ( IDUMMY.EQ.-1) THEN                                         !TR: 2017 07 25 GEOHIGHT UNIFORM
          DO I = 1,MXNODE                                               !TR: 2017 07 25 GEOHIGHT UNIFORM
            GEOHIGHT(I) = DUMMY2                                        !TR: 2017 07 25 GEOHIGHT UNIFORM
          ENDDO                                                         !TR: 2017 07 25 GEOHIGHT UNIFORM
        ELSEIF( IDUMMY.EQ.1 ) THEN
          GEOHIGHT(IDUMMY) = DUMMY2
          DO I = 2, MXNODE
            READ (INUNIT, *) II, GEOHIGHT(I)
            IF ( II.NE.I ) WRITE (IOUT, *)                              
     +                     'ERROR READING NODE ELEVATIONS, LIST NODES', 
     +            ' AND ELEVATIONS IN SEQUENTIAL ORDER FROM 1 TO MXNODE'
          ENDDO
        ELSEIF ( IDUMMY.EQ.MXNODE ) THEN
          DO I = 1, MXNODE
C
C--BARC&ELK OPTION 2 MAKE THE NODE ELEVATION THE CENTER OF THE MODFLOW 
C  CELL.
            GEOHIGHT(I) = DUMMY2 + BOTM(NBR(I,2), NBR(I,3), NBR(I,4))
     +                    + (BOTM(NBR(I,2),NBR(I,3),NBR(I,4)-1)         
     +                    -BOTM(NBR(I,2),NBR(I,3),NBR(I,4)))/2
          ENDDO
        ELSEIF ( IDUMMY.EQ.-MXNODE ) THEN                               !TR: 2017 07 26 GEOHIGHT RELATIVE TO CELL BOTTOM
          DO I = 1, MXNODE                                              !TR: 2017 07 26 GEOHIGHT RELATIVE TO CELL BOTTOM
C
C--BARC&ELK OPTION 2 MAKE THE NODE ELEVATION THE BOTTOM + DUMMY2 OF THE MODFLOW 
C  CELL.
            GEOHIGHT(I) = DUMMY2 + BOTM(NBR(I,2), NBR(I,3), NBR(I,4))   !TR: 2017 07 26 GEOHIGHT RELATIVE TO CELL BOTTOM
          ENDDO                                                         !TR: 2017 07 26 GEOHIGHT RELATIVE TO CELL BOTTOM
        ENDIF
        WRITE (IOUT, *) ' NODE ELEVATIONS:'
        DO I = 1, MXNODE
          WRITE (IOUT, *) I, GEOHIGHT(I)
        ENDDO
C 
C--BARC**READ MODE 1 CONTROLS
C 
C--READ FLAG OF SURFACE-AREA DEPENDENT OR CONSTANT EXCHANGE PIPE 
C  CONCUCTANCE
C  ELK CPF INPUT FILE DATA TYPE 12 REQUIRED COMMENT STATEMENT
        READ (INUNIT, '(A)') CDUMMY
C
C--ELK CPF INPUT FILE DATA TYPE 13 SA_EXCHANGE IN REPORT THIS IS
C  A 0 OR 1
        READ (INUNIT, *) LSURFACEDEP
C 
C--READ CRITERION OF CONVERGENCE
C--ELK CPF INPUT FILE DATA TYPE 14 REQUIRED COMMENT STATEMENT
        READ (INUNIT, '(A)') CDUMMY
C--ELK CPF INPUT FILE DATA TYPE 15 EPSILON IN REPORT THE CONVERGENCE
C  CRITERIA
        READ (INUNIT, *) EPSILON
C 
C--READ MAXIMUM FOR ITERATION
C--ELK CPF INPUT FILE DATA TYPE 16 REQUIRED COMMENT STATEMENT
        READ (INUNIT, '(A)') CDUMMY
C
C--ELK CPF INPUT FILE DATA TYPE 17 NITER IN REPORT-THE MAXIMUM NUMBER
C  OF ITERATIONS
        READ (INUNIT, *) ITERA_MAX
C 
C--READ IN RELAXATION PARAMETER
C  ELK CPF INPUT FILE DATA TYPE 18 REQUIRED COMMENT STATEMENT
        READ (INUNIT, '(A)') CDUMMY
C
C--ELK CPF INPUT FILE DATA TYPE 19 RELAX IN REPORT-THE RELAXATION
C  PERAMETER
        READ (INUNIT, *) CFPRELAX
C 
C--READ NEWTON RAPHSON PRINT FLAG
C  ELK CPF INPUT FILE DATA TYPE 20 REQUIRED COMMENT STATEMENT
        READ (INUNIT, '(A)') CDUMMY
C        
C--ELK CPF INPUT FILE DATA TYPE 21 P_NR IN REPORT-A PRINT FLAG 0 OR 1
C       READ (INUNIT, *) P_NR
        NAME_MULTI(1) = 'P_NR    '                                      !TR: 2018 05 22 LISTING OUTPUT
        NAME_MULTI(2) = 'L_NTS   '                                      !TR: 2018 05 22 LISTING OUTPUT
        CALL EINTRD_MULTI(READIN,INUNIT,IOUT,NAME_MULTI)                     !TR: 2018 05 22 LISTING OUTPUT
        P_NR = READIN(1)                                                !TR: 2018 05 22 LISTING OUTPUT
        L_NTS = READIN(2)                                               !TR: 2018 05 22 LISTING OUTPUT
        IF (L_NTS.EQ.0) L_NTS = 1                                      !TR: 2018 05 22 LISTING OUTPUT
C
C--BARC**WRITE THIS:
        WRITE (IOUT, *)                                                 
     +              'FINISHED READING NEWTON RAPHSON ITERATION CONTROLS'
C 
C--BARC**READ NODE AND TUBE DATA NEXT
        WRITE (IOUT, *) 'READING NODE AND TUBE DATA'
C
C--ELK CPF INPUT FILE DATA TYPE 22 ABD 23 REQUIRED COMMENT STATEMENTS
        READ (INUNIT, '(A)') CDUMMY
        READ (INUNIT, '(A)') CDUMMY
C
C--READ TUBEDATA
C  ELK CPF INPUT FILE DATA TYPE 24  ONE LINE FOR EACH PIPE NUMBER OR SET 
C  ELK ALL PIPES CONSTANT    NO_P  DIAMETER  TORTUOSITY  ROUGHNESS  
C  ELK LCRITREY_P  TCRITREY_P LCRITREY_P THE LOWER CRITICAL REYNOLDS 
C  ELK NUMBER (TURBULENT TO LAMINAR) TCRITREY_P THE UPPER CRITICAL 
C  ELK REYNOLDS NUMBER (LAMINAR TO TURBULENT) 
C  !TR: ADDED MESSAGES FOR OUTPUT
        WRITE (IOUT,*) 'NO_P  DIAMETER  TORTUOSITY  RHEIGHT  LCRITREY_P'
     +                ,' TCRITREY_P'                                    !TR: 2012 12 11 WRITE OUTPUT HEADER TO LISTING FILE
        DO I = 1, MXTUBE
          READ (INUNIT, *) (CON_DATA(I,J), J=1, 6)
          IF ( I.NE.DINT(CON_DATA(I,1)) ) PRINT *,                      
     +         '      ERROR IN CONDUIT INPUT FILE: TUBE DATA'
          WRITE (IOUT, 9020)(CON_DATA(I,J), J=1, 6)                     !TR: 2012 12 11 WRITE OUTPUT TO LISTING FILE
        ENDDO
C
C--BARC**ASSIGN THESE FOR LATER
        DO I = 1, MXTUBE
          TORTUOS(I) = CON_DATA(I, 3)
          ROUGHNESS(I) = CON_DATA(I, 4)
        ENDDO
C
C--BARC**READ HEADS
C  ELK CFP INPUT FILE DATA TYPE 25 REQUIRED COMMENT STATEMENT
        READ (INUNIT, '(A)') CDUMMY
        WRITE (IOUT, *) 'READING NODE BOUNDARY CONDITIONS (FIXED HEADS, 
     +IBOUNDS, AND FBCs)'
        WRITE (IOUT, *) ' NODE  HEAD AND/OR IBOUND'
C
C--ELK CFP INPUT FILE DATA TYPE 26 NO_N N_HEAD IN REPORT
C  IF NO FURTHER BC DATA NEED TO BE CONSIDERED                          !TR: 2012 05 09 THIS IS THE ORIGINAL FORMULATION
        IF (FBC_FLG.EQ.Z) THEN                                          !TR: 2012 05 09 FHLQ
          DO I = 1, MXNODE
            READ (INUNIT, *) IDUMMY, BEGHEAD(I)
            WRITE (IOUT, *) I, BEGHEAD(I)
            IF ( I.NE.IDUMMY ) PRINT *,                                 
     +             '      ERROR IN CONDUIT INPUT FILE: STARTING HEADS'
          ENDDO
C
C--IF FBC DATA ARE CONSIDERED
        ELSE                                                            !TR: 2012 05 09
          FHLQ_COUNT = Z                                                !TR: 2012 05 09 INI COUNTER FOR FHLQ BC'S
          WELL_COUNT = Z                                                !TR: 2012 06 08 WELL / INI COUNTER FOR WELL BC'S
          WELLTD_COUNT = Z                                              !TR: 2013 04 03 WELL TD
          CY_COUNT = Z                                                  !TR: 2013 03 14 CAUCHY
          LH_COUNT = Z                                                  !TR: 2013 03 22 LH
          BC_DUMMY2 = 999999                                            !TR: 2013 03 15 INI BCDUMMY2 FOR CAUCHY; LARGE NUMBER MEANS LQ IS QUITE HIGH
          DO I = 1, MXNODE
            READ (INUNIT, *) IDUMMY, BEGHEAD(I), BC_TYPE                !TR: 2012 05 09 ADDED BC_TYPE, BC_DUMMY1 / 2013 03 15 BCDUMMY2
            IF ( I.NE.IDUMMY ) PRINT *,                                 
     +             '      ERROR IN CONDUIT INPUT FILE: STARTING HEADS'
C
C--PROCESS BOUNDARY CONDITION DATA - FHLQ
            IF (BC_TYPE.EQ."FHLQ    ") THEN                             !TR: 2012 05 09 
              BACKSPACE (INUNIT)                                        !TR: 2013 03 15 READ AGAIN WITH ADEQUATE PARAMETERS
              READ (INUNIT, *) IDUMMY, BEGHEAD(I), BC_TYPE, BC_DUMMY1   !TR: 2012 05 09 ADDED BC_TYPE, BC_DUMMY1 / 2013 03 15 BCDUMMY2            
              WRITE (IOUT,9030) I, BEGHEAD(I), BC_DUMMY1                !TR: 2012 05 09 
              FHLQ_COUNT = FHLQ_COUNT + 1                               !TR: 2012 05 09 
C                                                                       
C--ASSIGN FHLQ DATA                                                     
              IFHLQ(FHLQ_COUNT,1) = I                                   !TR: 2012 05 09 
              IFHLQ(FHLQ_COUNT,2) = Z                                   !TR: 2012 05 09 
              DFHLQ(FHLQ_COUNT,1) = BEGHEAD(I)                          !TR: 2012 05 09 
              DFHLQ(FHLQ_COUNT,2) = BC_DUMMY1                           !TR: 2012 05 09 
C
C--PROCESS BOUNDARY CONDITION DATA - FHLQ
            ELSEIF (BC_TYPE.EQ."FHLQTD  ") THEN                         !TR: 2013 04 04 FHLQTD
              BACKSPACE (INUNIT)                                        !TR: 2013 03 15 READ AGAIN WITH ADEQUATE PARAMETERS
              READ (INUNIT, *) IDUMMY, BEGHEAD(I), BC_TYPE, BC_DUMMY1   !TR: 2012 05 09 ADDED BC_TYPE, BC_DUMMY1 / 2013 03 15 BCDUMMY2
              WRITE (IOUT,9035) I, INT(BEGHEAD(I)), BC_DUMMY1           !TR: 2013 04 04 FHLQTD
              FHLQ_COUNT = FHLQ_COUNT + 1                               !TR: 2013 04 04 FHLQTD
              FHLQTD_COUNT = FHLQTD_COUNT + 1                           !TR: 2013 04 04 FHLQTD
              FHLQTD_FLG = TRUE                                       !TR: 2013 04 04 FHLQTD
              CALL ASSIGNTDDATA(I,BEGHEAD(I),FHLQTD_IN,FHLQTD_LINESMAX) !TR: 2013 04 04 FHLQTD
C                                                                       
C--ASSIGN FHLQ DATA                                                     
              IFHLQ(FHLQ_COUNT,1) = I                                   !TR: 2012 05 09 
              IFHLQ(FHLQ_COUNT,2) = Z                                   !TR: 2012 05 09 
              DFHLQ(FHLQ_COUNT,1) = NINER                                !TR: 2012 05 09 
              DFHLQ(FHLQ_COUNT,2) = BC_DUMMY1                           !TR: 2012 05 09 
            ELSEIF (BC_TYPE.EQ."WELL    ") THEN                         !TR: 2012 05 09 
C
C--ASSIGN WELL DATA            
              WELL_COUNT = WELL_COUNT + 1                               !TR: 2012 06 08 WELL /
              IWELL(I) = 1                                              !TR: 2013 03 18 WELL / SET FLAG TO MARK ACTIVE WELL
              BACKSPACE (INUNIT)                                        !TR: 2016 10 11 CWC REWIND TO READ AGAIN FOR EVENTUALLY CWC DATA
              CALL COUNT_LINE_NUMBERS(INUNIT, IOUT, NUM)                !TR: 2016 10 11 CWC
              IF (NUM .EQ. 4) THEN                                      !TR: 2016 10 11 CWC
                BACKSPACE (INUNIT)                                      !TR: 2016 10 11 CWC REWIND TO READ AGAIN FOR EVENTUALLY CWC DATA 
                READ (INUNIT, *) IDUMMY, BEGHEAD(I), BC_TYPE, BC_DUMMY1 !TR: 2012 05 09 ADDED BC_TYPE, BC_DUMMY1 / 2013 03 15 BCDUMMY2
                CWC_WELL(I) = BC_DUMMY1                                 !TR: 2016 10 11 
              ENDIF                                                     !TR: 2016 10 11 
              IF(CWC_WELL(I).EQ.Z)THEN                                  !TR: 2016 10 11 THIS IS THE INITIAL VALUE, I.E. NO DATA ASSIGNED OR DZ IS ASSIGNED IN INPUT
                WRITE (IOUT,9040) I, BEGHEAD(I)                         !TR: 2012 05 09 
              ELSE
                WRITE (IOUT,9042) I, BEGHEAD(I), CWC_WELL(I)            !TR: 2016 10 11  
              ENDIF
            ELSEIF (BC_TYPE.EQ."WELLTD  ") THEN                         !TR: 2013 04 03 WELL TD
C
C--ASSIGN WELL DATA FOR TIME DEPENDENT WELLS         
              BACKSPACE (INUNIT)                                        !TR: 2013 04 03 WELL TD
              CALL COUNT_LINE_NUMBERS(INUNIT, IOUT, NUM)                !TR: 2016 10 21 CWC
              BACKSPACE (INUNIT)                                        !TR: 2018 05 02 REWIND HERE
              IF (NUM .EQ. 5) THEN                                      !TR: 2016 10 21 CWC
C               BACKSPACE (INUNIT)                                      !TR: 2016 10 11 CWC REWIND TO READ AGAIN FOR EVENTUALLY CWC DATA 
                READ (INUNIT,*) IDUMMY, BEGHEAD(I), BC_TYPE, BC_DUMMY1, !TR: 2013 04 03 WELL TD
     +                          BC_DUMMY2                               !TR: 2016 10 21 CWC
                CWC_WELL(I) = BC_DUMMY2                                 !TR: 2016 10 21 
              ELSE                                                      !TR: 2016 10 21 CWC
                READ (INUNIT,*) IDUMMY, BEGHEAD(I), BC_TYPE, BC_DUMMY1  !TR: 2013 04 03 WELL TD
              ENDIF                                                     !TR: 2016 10 21 CWC
                WELLTD_FLG = TRUE                                       !TR: 2013 04 03 WELL TD
              WELLTD_COUNT = WELLTD_COUNT + 1                           !TR: 2013 04 03 WELL TD
              IWELL(I) = 2                                              !TR: 2013 04 03 WELL TD/ SET FLAG TO MARK ACTIVE WELL (FLAG AS 2 MEANS TD WELL)
              CALL ASSIGNTDDATA(I,BC_DUMMY1,WELLTD_IN,WELLTD_LINESMAX)  !TR: 2013 04 04 FHLQTD 
              IF(CWC_WELL(I).EQ.Z)THEN                                  !TR: 2016 10 11 THIS IS THE INITIAL VALUE, I.E. NO DATA ASSIGNED OR DZ IS ASSIGNED IN INPUT
                WRITE (IOUT,9045) I, BEGHEAD(I)                         !TR: 2013 04 03 WELL TD
              ELSE
                WRITE (IOUT,9047) I, BEGHEAD(I), CWC_WELL(I)            !TR: 2016 10 21  
              ENDIF
            ELSEIF (BC_TYPE.EQ."CAUCHY  ") THEN                         !TR: 2013 03 13 CAUCHY
C
C--ASSIGN CAUCHY DATA                                       
              BACKSPACE (INUNIT)                                        !TR: 2013 03 13 CAUCHY
              READ (INUNIT, *) IDUMMY, BEGHEAD(I), BC_TYPE, BC_DUMMY1,  !TR: 2013 03 13 CAUCHY
     +                         BC_DUMMY2                                !TR: 2012 05 09 ADDED BC_TYPE, BC_DUMMY1 / 2013 03 15 BCDUMMY2
              WRITE (IOUT,9050)I, BEGHEAD(I),BC_DUMMY1,BC_DUMMY2        !TR: 2012 05 09      
              CY_COUNT = CY_COUNT + 1                                   !TR: 2013 03 13 CAUCHY
              ICY(CY_COUNT,1) = I                                       !TR: 2013 03 13 CAUCHY
              ICY(CY_COUNT,2) = Z                                       !TR: 2013 03 13 CAUCHY
              HCY(CY_COUNT) = BEGHEAD(I)                                !TR: 2013 03 13 CAUCHY
              CONDCY(CY_COUNT) = BC_DUMMY1                              !TR: 2013 03 13 CAUCHY
              CYLQ(CY_COUNT) = BC_DUMMY2                                !TR: 2013 03 13 CAUCHY
              BEGHEAD(I)=-1                                             !TR: 2013 03 13 CAUCHY
            ELSEIF (BC_TYPE.EQ."CAUCHYTD")THEN                          !TR: 2013 04 03 CAUCHY TD
C
C--ASSIGN CAUCHY DATA                                       
              BACKSPACE (INUNIT)                                        !TR: 2013 04 03 CAUCHY TD
              READ (INUNIT, *) IDUMMY, BEGHEAD(I), BC_TYPE, BC_DUMMY1,  !TR: 2013 04 03 CAUCHY TD
     +                         BC_DUMMY2                                !TR: 2012 05 09 ADDED BC_TYPE, BC_DUMMY1 / 2013 03 15 BCDUMMY2
              CYTD_FLG = TRUE                                         !TR: 2013 04 03 CAUCHY TD
              CALL ASSIGNTDDATA(I,BEGHEAD(I),CYTD_IN,CYTD_LINESMAX)     !TR: 2013 04 04 CAUCHY TD
              WRITE (IOUT,9055)I, CYTD_IN(I),BC_DUMMY1,BC_DUMMY2        !TR: 2012 05 09      
              CYTD_COUNT = CYTD_COUNT + 1                               !TR: 2013 04 03 CAUCHY TD
              CY_COUNT = CY_COUNT + 1                                   !TR: 2013 03 13 CAUCHY
              ICY(CY_COUNT,1) = I                                       !TR: 2013 03 13 CAUCHY
              ICY(CY_COUNT,2) = Z                                       !TR: 2013 03 13 CAUCHY
              HCY(CY_COUNT) = NINER                                      !TR: 2013 04 03 CAUCHY TD
              CONDCY(CY_COUNT) = BC_DUMMY1                              !TR: 2013 03 13 CAUCHY
              CYLQ(CY_COUNT) = BC_DUMMY2
              BEGHEAD(I)=-1              
            ELSEIF (BC_TYPE.EQ."LH      ")THEN
C
C--ASSIGN LH DATA
              BACKSPACE (INUNIT)                                        !TR: 2013 03 15 READ AGAIN WITH ADEQUATE PARAMETERS
              READ (INUNIT, *) IDUMMY, BEGHEAD(I), BC_TYPE              !TR: 2013 03 22 LH
              WRITE (IOUT,9070) I, BEGHEAD(I)                           !TR: 2013 03 22 LH
              LH_COUNT = LH_COUNT + 1                                   !TR: 2013 03 22 LH
              ILH(LH_COUNT,1) = I                                       !TR: 2013 03 22 LH
              ILH(LH_COUNT,2) = Z                                       !TR: 2013 03 22 LH
              HLH(LH_COUNT) = BEGHEAD(I)                                !TR: 2013 03 22 LH
              BEGHEAD(I)=-1                                             !TR: 2013 03 22 LH
            ELSEIF (BC_TYPE.EQ."TD      ")THEN              
C
C--ASSIGN FIXED HEAD TD DATA     
              FHTD_FLG = TRUE                                         !TR: 2013 04 04 FH TD
              CALL ASSIGNTDDATA(I,BEGHEAD(I),FHTD_IN,FHTD_LINESMAX)     !TR: 2013 04 04 FH TD
              WRITE (IOUT,9065)I, INT(BEGHEAD(I))                       !TR: 2013 04 04 FH TD
              FHTD_COUNT = FHTD_COUNT + 1                               !TR: 2013 04 04 FH TD
              BEGHEAD(I) = NINER                                         !TR: 2013 04 04 FH TD
            ELSE
              WRITE (IOUT,9060) I, BEGHEAD(I)
              IF ((BC_TYPE(1:1).NE.'X').AND.(BC_TYPE(1:1).NE.'x')) 
     +            WRITE(IOUT,*)'BOUNDARY DENOTATION FOR NODE',I,
     +           'MISSED - BCTYPE OR X IS EXPECTED - PLEASE CHECK!'  
            ENDIF                                                       !TR: 2013 03 13 CAUCHY
          ENDDO                                                         !TR: 2012 05 09 
C
C--SET FLAG FOR EXISTENT BOUNDARY CONDITIONS AND WRITE OUTPUT MESSAGE         
          IF (FHLQ_COUNT.GE.1) FHLQ_FLG = TRUE                        !TR: 2012 06 08 SET FHLQ FLG
          IF (WELL_COUNT.GE.1) WELL_FLG = TRUE
          IF (WELLTD_COUNT.GE.1) WELL_FLG = TRUE                      !TR: 2013 04 03 WELL TD
          IF (CY_COUNT.GE.1) CY_FLG = TRUE                            !TR: 2013 03 14 SET CAUCHY FLG
          IF (CYTD_COUNT.GE.1) CY_FLG = TRUE                          !TR: 2013 04 03 CAUCHY TD
          IF (LH_COUNT.GE.1) LH_FLG = TRUE                            !TR: 2013 03 22 SET LH FLAG          
          WRITE (IOUT, 9004) FHLQ_COUNT                                 !TR: 2012 06 08 
          WRITE (IOUT, 9007) (WELL_COUNT+WELLTD_COUNT), WELLTD_COUNT    !TR: 2012 06 08 / 2013 04 03 WELL TD
          WRITE (IOUT, 9008) CY_COUNT, CYTD_COUNT                       !TR: 2013 03 14 CAUCHY / 2013 04 03 CAUCHY TD
          WRITE (IOUT, 9015) LH_COUNT                                   !TR: 2013 03 22 LH
C
C--PROCESS TIME DEPENDENT DATA
C  FHLQ TD // ALLOCATE, INITIALIZE, AND READ IN DATA
          IF (FHLQTD_FLG) THEN                                          !TR: 2013 04 04 FHLQ TD
            ALLOCATE (FHLQTD_DAT(FHLQTD_LINESMAX,3,FHLQTD_COUNT))       !TR: 2013 04 04 FHLQ TD
            CALL INITDDATA(FHLQTD_DAT,FHLQTD_LINESMAX,FHLQTD_COUNT)     !TR: 2013 04 04 FHLQ TD
            CALL READTD (FHLQTD_IN,FHLQTD_DAT,FHLQTD_LINESMAX,
     +                   FHLQTD_COUNT)                                  !TR: 2013 04 04 FHLQ TD
          ENDIF                                                         !TR: 2013 04 04 FHLQ TD
C
C--TD WELLS // ALLOCATE, INITIALIZE, AND READ IN DATA
          IF (WELLTD_FLG) THEN                                          !TR: 2013 04 03 WELL TD
            ALLOCATE (WELLTD_DAT(WELLTD_LINESMAX,3,WELLTD_COUNT))       !TR: 2013 04 03 WELL TD
            CALL INITDDATA(WELLTD_DAT,WELLTD_LINESMAX,WELLTD_COUNT)     !TR: 2013 04 04 WELL TD
            CALL READTD (WELLTD_IN,WELLTD_DAT,WELLTD_LINESMAX,
     +                   WELLTD_COUNT)                                  !TR: 2013 04 03 WELL TD
          ENDIF                                                         !TR: 2013 04 03 WELL TD
C
C--CAUCHY TD DATA // ALLOCATE, INITIALIZE, AND READ IN DATA
          IF (CYTD_FLG) THEN                                            !TR: 2013 04 03 CAUCHY TD
            ALLOCATE (CYTD_DAT(CYTD_LINESMAX,3,CYTD_COUNT))             !TR: 2013 04 03 CAUCHY TD
            CALL INITDDATA(CYTD_DAT,CYTD_LINESMAX,CYTD_COUNT)           !TR: 2013 04 04 CAUCHY TD
            CALL READTD (CYTD_IN,CYTD_DAT,CYTD_LINESMAX,CYTD_COUNT)     !TR: 2013 04 03 CAUCHY TD
          ENDIF                                                         !TR: 2013 04 03 CAUCHY TD
C          
C--TD FIXED HEAD // ALLOCATE, INITIALIZE, AND READ IN DATA
          IF (FHTD_FLG) THEN                                            !TR: 2013 04 04 FH TD
            ALLOCATE (FHTD_DAT(FHTD_LINESMAX,3,FHTD_COUNT))             !TR: 2013 04 04 FH TD
            CALL INITDDATA(FHTD_DAT,FHTD_LINESMAX,FHTD_COUNT)           !TR: 2013 04 04 FH TD
            CALL READTD (FHTD_IN,FHTD_DAT,FHTD_LINESMAX,FHTD_COUNT)     !TR: 2013 04 04 FH TD
          ENDIF                                                         !TR: 2013 04 04 FH TD
C          
        ENDIF        
C
C--MESSAGE SURFACE DEPENDENT EXCHANGE
        IF (LSURFACEDEP.EQ.Z) THEN
          WRITE (IOUT,*)'SURFACE-AREA DEPENDENT EXCHANGE IS NOT ACTIVE' !TR: 2012 12 11 WRITE MESSAGE FOR SURFACE DEPENDENT EXCHANGE
        ELSEIF (LSURFACEDEP.EQ.1) THEN                                  !TR: 2012 12 11 WRITE MESSAGE FOR SURFACE DEPENDENT EXCHANGE
          WRITE (IOUT,*)'SURFACE-AREA DEPENDENT EXCHANGE IS ACTIVE'     !TR: 2012 12 11 WRITE MESSAGE FOR SURFACE DEPENDENT EXCHANGE
        ELSEIF (LSURFACEDEP.EQ.2) THEN                                  !TR: 2013 07 26 LENGHT DEPENDENT EXCHANGE
          WRITE (IOUT,*)'LENGTH DEPENDENT EXCHANGE ACTIVE, INPUT A_EX/L'!TR: 2013 07 26 LENGHT DEPENDENT EXCHANGE
        ELSE                                                            !TR: 2012 12 11 WRITE MESSAGE FOR SURFACE DEPENDENT EXCHANGE
          WRITE (IOUT,*)'SA_EXCHANGE IS NOT ADEQUATE - CHECK INPUT'     !TR: 2012 12 11 WRITE MESSAGE FOR SURFACE DEPENDENT EXCHANGE
        ENDIF                                                           !TR: 2012 12 11 WRITE MESSAGE FOR SURFACE DEPENDENT EXCHANGE
C
C--BARC**READ 'MODD' EXCHANGE COEFFICIENTS
        WRITE (IOUT, *) 'READING EXCHANGE COEFFICIENTS'
!       WRITE (IOUT, *) 'NODE          EXCHANGE COEFFICIENT'            !TR: 2012 05 25 NOTE COMES LATER
C
C--ELK CFP INPUT FILE DATA TYPE 27 REQUIRED COMMENT STATEMENT
        READ (INUNIT, '(A)') CDUMMY
C
C--DATA FOR CADS
        ALLOCATE (L_NODE(MXNODE),CADSFLOW(MXNODE))                      !TR: 2012 04 25 CADS /
        L_NODE = DZ                                                   !TR: 2012 04 25 CADS /
        CADSFLOW = DZ                                                 !TR: 2012 04 25 CADS /
        IF (CADS_FLG.EQ.1) THEN
          ALLOCATE (CADS2(MXNODE),W_CADS(MXNODE))
          CADS2 = DZ                                                  !TR: 2012 04 25 CADS / 
          W_CADS = DZ                                                 !TR: 2012 04 25 CADS / 
        ENDIF
        IF (CADSML_FLG.EQ.1) THEN
          ALLOCATE (CADSMLDAT(MXNODE,2,5),CADSML2(MXNODE),
     +              CADSML2_P(MXNODE))                                  !TR: 2013 06 28 CADSML //2013 07 26 CADSML_P
          CADSMLDAT = DZ                                              !TR: 2013 06 28 CADSML 
          CADSML2 = DZ                                                !TR: 2012 04 25 CADS / 
          CADSML2_P = DZ                                              !TR: 2013 07 26 CADSML_P /
        ENDIF
C
C--DATA FOR PFPS
        ALLOCATE (PFPS2(MXNODE),PFPSFLOW(MXNODE))                       !TR: 2012 07 12 PFPS /
        DO I = 1, MXNODE                                                !TR: 2012 07 12 PFPS /
          PFPSFLOW(I) = DZ                                            !TR: 2012 07 12 PFPS /
          PFPS2(I) = DZ                                               !TR: 2012 07 12 PFPS /
        ENDDO                                                           !TR: 2012 07 12 PFPS /
C
C--ELK CFP INPUT FILE DATA TYPE 28 NO_N K_EXCHANGE IN REPORT
C  TR MODIFIED TO CONSIDER OPTIONALLY CADS
        IF (CADS_FLG.EQ.Z.AND.CADSML_FLG.EQ.Z) THEN                     !TR: 2012 05 25 NO CADS THEN ORIGINAL CODE // 2013 06 28 CADSML
          WRITE (IOUT, *) 'NODE I  K_EXCHANGE(I)'                       !TR: 2012 05 25 NOTE FOR OUTPUT
          DO I = 1, MXNODE
            READ (INUNIT, *) IDUMMY, MODD(I)
            WRITE (IOUT, 9005) I, MODD(I)                               !TR: 2012 05 25 ADDED FORMAT
            IF ( I.NE.IDUMMY ) PRINT *,                                 
     +             '      ERROR IN CONDUIT INPUT FILE: EXCHANGE TERMS'
          ENDDO
        ELSEIF (CADS_FLG.EQ.1.OR.CADS_FLG.EQ.-1) THEN                   !TR: 2012 05 25 CADS / !TR: 2013 06 28 CADSML
          WRITE (IOUT, *) 'NODE I  K_EXCHANGE(I)  W_CADS(I)'            !TR: 2012 05 25 NOTE FOR OUTPUT        
          DO I = 1, MXNODE
            READ (INUNIT, *) IDUMMY, MODD(I), W_CADS(I)                 !TR: 2012 05 25 CADS / READ W_CADS
            WRITE (IOUT, 9006) I, MODD(I), W_CADS(I)                    !TR: 2012 05 25 CADS /
            IF ( I.NE.IDUMMY ) PRINT *,                                 
     +             '      ERROR IN CONDUIT INPUT FILE: EXCHANGE TERMS'
          ENDDO        
        ELSE                                                            !TR: 2013 06 28 CADSML
          WRITE (IOUT, *) 'NODE I  K_EXCHANGE(I) Z_CADSML(I) W_CADSML(I)
     + ...'                                                             !TR: 2013 06 28 CADSML
          DO I = 1, MXNODE                                              
            READ (INUNIT, *) IDUMMY, MODD(I), (CADSMLDAT(I,1,II), 
     +                       CADSMLDAT(I,2,II),II = 1, 4)               !TR: 2013 06 28 CADSML
            WRITE (IOUT, 9016) I, MODD(I), (CADSMLDAT(I,1,II), 
     +             CADSMLDAT(I,2,II),II = 1, 4)                         !TR: 2013 06 28 CADSML
            IF ( I.NE.IDUMMY ) PRINT *,                                 
     +             '      ERROR IN CONDUIT INPUT FILE: EXCHANGE TERMS'
          ENDDO         
        ENDIF                                                           !TR: 2012 05 25 CADS /
C
C--ELK--END OF INPUT FOR MODE EQUAL 1 OR 3  -------------------           
      ENDIF
C
C--BARC**JUMP TO HERE IF MODE=2      
      IF ( MODE.NE.1 ) THEN
!TR: 2018 05 04 RE-ACTIVATE MODE 2 HERE          
!   WRITE (IOUT, *) '                                             ',
!&                  'CFP MODE 2 / 3 IS CURRENTLY NOT SUPPORTED BY ',!TR: 2013 05 17 NOTE
!&                  'THIS RESEARCH VERSION OF CFP. PLEASE REFER TO',!TR: 2013 05 17 NOTE
!&                  'THE OFFICIALLY RELEASED USGS VERSION OF CFP.'  !TR: 2013 05 17 NOTE
!   STOP                                                             !TR: 2013 05 17 CFP MODE 2 DEACTIVATED HERE
        WRITE (IOUT, *) '---------------------------------'
        WRITE (IOUT, *) 'CFP MODE 2 IS ACTIVE (LAYERS) '
        WRITE (IOUT, *) '---------------------------------'
C 
C--BARC**READ WHAT IS NEEDED FOR PREFERENTIAL FLOW LAYERS MODE 2
        ALLOCATE (TURB_FR(NCOL,NROW,NLAY), TURB_FF(NCOL,NROW,NLAY),     
     +            TL_OUT(NCOL,NROW,NLAY),TURB_FV(NCOL,NROW,NLAY))
C
C--BARC**
        ALLOCATE  (KLAM_CR(NCOL,NROW,NLAY),KLAM_CC(NCOL,NROW,NLAY),
     +             KLAM_CV(NCOL,NROW,NLAY))
CB        ALLOCATE  (CRT(NCOL,NROW,NLAY),CCT(NCOL,NROW,NLAY),
CB     +             CVT(NCOL,NROW,NLAY))
C
C--ELK CFP INPUT FILE DATA TYPES 29 AND 30 COMMENT LINES 
        READ (INUNIT, *) CDUMMY
        READ (INUNIT, *) CDUMMY
C
C--ELK CFP INPUT FILE DATA TYPES 31 NCL NUMBER OF PREFERENTIAL FLOW LAYERS
C--BARC**IRADFLAG=1 INDICATES RADIAL FLOW MODEL. 
        READ (INUNIT, *) NCL
        IF(NCL.GT.NLAY) THEN
          PRINT*, 'NUMBER OF CONDUIT LAYERS (NCL) CANNOT'
          PRINT*, 'BE GREATER THAN THE NUMBER OF MODEL'
          PRINT*, 'LAYERS (NLAY). RESET THE NUMBER OF CONDUIT LAYERS'
          PRINT*, 'IN THE CFP INPUT FILE.'
          STOP
        ENDIF
C
        ALLOCATE (CL(NCL))
C
C--BARC**ALLOCATE TWATER2 AND OTHERS
        ALLOCATE  (TWATER2(NCOL,NROW,NCL),DENSWA2(NCOL,NROW,NCL), 
     +         VISCWA2(NCOL,NROW,NCL),VOID2(NCOL,NROW,NCL),
     +         LCRITREY2(NCOL,NROW,NCL),TCRITREY2(NCOL,NROW,NCL),
     +         FEEXP(NCOL,NROW,NCL))
C     
C--ELK CFP INPUT FILE DATA TYPE 32 COMMENT LINE
        READ (INUNIT, *) CDUMMY
C
C--ELK CFP INPUT FILE DATA TYPE 33 THIS IS THE ACTUAL MODEL LAYER NUMBERS CL(NCL)
        READ (INUNIT, *) (CL(I), I=1, NCL)
        WRITE (IOUT, '(A10,I3,A27)') 'THERE ARE ', NCL,                 
     +                               ' PREFERENTIAL FLOW LAYER(S)'
        WRITE (IOUT, '(A34)') 'PREFERENTIAL FLOW LAYER NUMBER(S):'
        WRITE (IOUT, *) (CL(I), I=1, NCL)
C
C--BARC**ALLOCATE AND READ WATER TEMPERATURE TO CALCULATE DENSITY AND VISCOSITY
C--ELK CFP INPUT FILE DATA TYPE 34 COMMENT LINE
C--BARC**READ IRADFLAG FOR RADIAL FLOW MODELS
        ALLOCATE(IRADFLAG,IRADWELCOL)
        READ (INUNIT, *) CDUMMY
        READ (INUNIT, *) IRADFLAG
        ALLOCATE(R_LENGTH(NCOL))
C--BARC**FOR RADIAL FLOW MODELS
        IF(IRADFLAG.EQ.Z) THEN
          DO J=1,NCOL
            R_LENGTH(J)=1.0
          ENDDO
        ENDIF
        IF(IRADFLAG.EQ.1) THEN
C
C--BARC**CDUMMY FOR #IRADWELCOL COMMENT
          READ (INUNIT, *) CDUMMY
          READ (INUNIT, *) IRADWELCOL
C
C--BARC**CALCULATE R_LENGTH, BASED ON WEL COLUMN
          IF(IRADWELCOL.EQ.1) THEN
            DO J=1,NCOL
              IF(J.EQ.1) THEN 
                 R_LENGTH(J) = (DELR(1)*0.5)
              ELSEIF(J.EQ.2) THEN
                 R_LENGTH(J) = (DELR(1)*0.5)+DELR(J)*0.5
              ELSE
                 R_LENGTH(J) = R_LENGTH(J-1)+((DELR(J-1)*0.5)+
     +                        (DELR(J)*0.5))
              ENDIF
CB            PRINT*,R_LENGTH(J)
CB            PAUSE
            ENDDO
C
C--BARC**ELSE FOR  IF(IRADWELCOL.EQ.1) THEN
          ELSEIF(IRADWELCOL.EQ.NCOL) THEN
            DO J=NCOL,1,-1
              IF(J.EQ.NCOL) THEN 
                R_LENGTH(J) = (DELR(NCOL)*0.5) 
              ELSEIF(J.EQ.NCOL-1) THEN 
                R_LENGTH(J) = (DELR(NCOL)*0.5)+DELR(J)*0.5
              ELSE
                R_LENGTH(J) = R_LENGTH(J+1)+((DELR(J+1)*0.5)
     +                        +(DELR(J)*0.5))
              ENDIF
            ENDDO
C
C--BARC**ELSE FOR  IF(IRADWELCOL.EQ.1) THEN
          ENDIF
C
C--BARC**ENDIF FOR IF IRADFLAG****
        ENDIF
C
C--BARC**CDUMMY FOR #TURBULENT FLOW PARAMETER ARRAYS COMMENT
        READ (INUNIT, *) CDUMMY
C
C--ELK CFP INPUT FILE DATA TYPE 35 LTEMP IN REPORT ONE TEMPERATURE FOR ALL LAYERS
CB        READ (INUNIT, *) TWATER
        DO I=1,NCL
          K=I
          KK=K
          READ (INUNIT, *) CDUMMY
          CALL U2DREL(ARR,ANAME(1),NROW,NCOL,KK,INUNIT,IOUT)
          TWATER2(:,:,K) = DBLE(ARR)
          READ (INUNIT, *) CDUMMY
          CALL U2DREL(ARR,ANAME(2),NROW,NCOL,KK,INUNIT,IOUT)
          VOID2(:,:,K) = DBLE(ARR)
          READ (INUNIT, *) CDUMMY
          CALL U2DREL(ARR,ANAME(3),NROW,NCOL,KK,INUNIT,IOUT)
          LCRITREY2(:,:,K) = DBLE(ARR)
          READ (INUNIT, *) CDUMMY
          CALL U2DREL(ARR,ANAME(4),NROW,NCOL,KK,INUNIT,IOUT)
          TCRITREY2(:,:,K) = DBLE(ARR)
          READ (INUNIT, *) CDUMMY
          CALL U2DREL(ARR,ANAME(5),NROW,NCOL,KK,INUNIT,IOUT)
          FEEXP(:,:,K) = DBLE(ARR)
        ENDDO 
CB    WRITE (IOUT,' (A21,F6.3,A16)') 'WATER TEMPERATURE IS ', TWATER,   
CB   + ' DEGREES CELCIUS'
CB        CALL CALC_DENS_VISC
        CALL CALC_DENS_VISC2
C
C--BARC**ALLOCATE AND READ MEAN VOID DIAMETERS AND CRITICAL REYNOLDS #'S FOR CONDUIT LAYERS
CB        ALLOCATE (VOID(NCL), LCRITREY(NCL), TCRITREY(NCL),FEEXP(NCL))
C     ALLOCATE (NEFF(NCL))
C
C--ELK CFP INPUT FILE DATA TYPE 36 COMMENT LINES
C--ELK CFP INPUT FILE DATA TYPE FOR READING IN A COMMENT AND CONSTANTS FOR EACH LAYER
CB        READ (INUNIT, *) CDUMMY
CB       DO I = 1, NCL
CB          READ (INUNIT, *) CDUMMY
CB          READ (INUNIT, *) VOID(I), LCRITREY(I), TCRITREY(I),FEEXP(I)
CB       WRITE (IOUT, *) 'READ MEAN VOID DIA, LOWER & UPPER CRIT REYN
CB     + NO. FOR CONDUIT LAYER AND TURB EXP', CL(I)
CB    WRITE (IOUT, *) VOID(I), LCRITREY(I), TCRITREY(I),FEEXP(I)
CB        ENDDO
        ENDIF
CELK**ENDIF FOR READING DATA FOR MODE EQUAL 2 OR 3 

CBARC**JUMP TO HERE IF MODE=1,3
        IF ( MODE.NE.2 ) THEN
          IF ( INCFPOC.NE.Z ) CALL CFPM1OCAR(INCFPOC)
          CALL CFP1PC
        ENDIF
C
        IF ( MODE.EQ.2 ) THEN
        IF ( INCFPRCH.GT.Z ) THEN
          PRINT *, 'CRCH PACKAGE NOT NEEDED WHEN CFP MODE 2 IS ACTIVE'
          PRINT *, 'REMOVE OR COMMENT OUT CRCH IN NAME FILE'
          PRINT *, '                     '
        ENDIF
C
        IF( INCFPOC.NE.Z ) THEN
          PRINT *, 'COC PACKAGE NOT NEEDED WHEN CFP MODE 2 IS ACTIVE'
          PRINT *, 'REMOVE OR COMMENT OUT COC IN NAME FILE'
        ENDIF
      ENDIF
C 
 9001 FORMAT (4X, 'NUMBER OF NODES IS ', I5)
 9009 FORMAT (4X, 'NUMBER OF TUBES IS ', I5) 
 9002 FORMAT (4X, 'NUMBER OF LAYERS IS', I5)
 9003 FORMAT (4X, I6, 1X, 3I6, 1X, 6I6, 1X, 6I6)
 9004 FORMAT (4X, 'NUMBER OF FHLQ BCS IS ', I5) 
 9005 FORMAT (I4, 4X, G11.4)                                             !TR: 2012 05 25 
 9006 FORMAT (I4, 4X, G11.4, 5X, F7.3)      
 9016 FORMAT (I4, 4X, G11.4, 5X, 4(F7.2,X,F7.3))                         !TR: 2013 06 28 CADSML
 9007 FORMAT (4X, 'NUMBER OF WELL BCS IS ', I5,'; THEREOF TD WELLS:',I5)!TR: 2013 04 03 
 9008 FORMAT (4X, 'NUMBER OF CAUCHY BCS IS ', I3,'; THEREOF TD BCS:',I5)!TR: 2013 03 14 CAUCHY / 2013 04 03 CAUCHY TD
 9015 FORMAT (4X, 'NUMBER OF LH BCS IS ', I7)                           !TR: 2013 03 22 LH 
 9020 FORMAT (F5.0, 3X, F7.3, 7X, F5.2, 2X, F7.4, 4X, F8.2, 3X, F8.2)   !TR: 2012 12 11 FORMAT FOR TUBE DATA OUTPUT
 9030 FORMAT (I5,2X,F8.4,x,'FHLQ, LQ:',F8.4)                            !TR: 2013 03 19 FORMAT FHLQ BC OUTPUT
 9035 FORMAT (I5,4X,'FHLQ WITH FH DATA READ FROM UNIT:',I3,' FHLQ, LQ:',
     +        F8.4)                                                     !TR: 2013 03 19 FORMAT FHLQ BC OUTPUT 
 9040 FORMAT (I5,3X,F8.4,X,'WELL (NO INTERNAL SKIN)')                   !TR: 2013 03 19 FORMAT WELL BC OUTPUT // 2016 10 11 ADD NO SKIN MESSAGE
 9042 FORMAT (I5,3X,F8.4,X,'WELL (INTERNAL SKIN WITH CWC_WELL: ',F10.6,
     +        ')')                                                      !TR: 2013 03 19 FORMAT WELL BC OUTPUT  
 9045 FORMAT (I5,2X,F8.4,X,'WELL TD (NO INTERNAL SKIN)')                !TR: 2013 04 03 FORMAT WELL TD BC OUTPUT   
 9047 FORMAT (I5,2X,F8.4,X,'WELL TD (INTERNAL SKIN WITH CWC_WELL: ',
     +        F10.6,')')                                                !TR: 2016 10 21 FORMAT WELL BC OUTPUT       
 9050 FORMAT (I5,4X,'CAUCHY, HCY:',F8.4,2X,'CCY:',F8.4,2X,'CYLQ:',F8.4) !TR: 2013 03 19 FORMAT CAUCHY BC OUTPUT
 9055 FORMAT (I5,4X,'CAUCHY, HCY AS TD DATA FROM UNIT:',I3,2X,
     +        'CCY:',F8.4,2X,'CYLQ:',F8.4)                              !TR: 2013 04 03 CAUCHY TD
 9060 FORMAT (I5,2X,F9.4)                                               !TR: 2013 03 19 FORMAT NO BC OUTPUT 
 9065 FORMAT (I5,4X,'FIXED HEAD TD DATA READ FROM UNIT:',I3)            !TR: 2013 04 04 FH TD
 9070 FORMAT (I5,4X,'LH BC, LH:',F8.4)                                  !TR: 2013 03 19 FORMAT LH OUTPUT 
C 
      END SUBROUTINE GWF2CFP1AR
C
C
C
C
C
      SUBROUTINE CFPM1OCAR(INUNIT)
C***********************************************************************
C--BARC**READ AND PREPARE FOR MODE 1 (PIPES) OUTPUT CONTROL
C***********************************************************************
C
C        SPECIFICATIONS:
C     ------------------------------------------------------------------
C     NOTSNO    FREQUENCY OF TIME SERIES OUTPUT OF NODE DATA
C     NOTSTU    FREQUENCY OF TIME SERIES OUTPUT OF TUBE DATA
C     NOTSTSAN  FREQUENCY OF TIME SERIES ALONG NODES OUTPUT
C     NOTSTSAT  FREQUENCY OF TIME SERIES ALONG TUBES OUTPUT
C     NNODES    NUMBER OF NODES TO WRITE TIME SERIES OUTPUT
C     NTUBES    NUMBER OF TUBES TO WRITE TIME SERIES OUTPUT
C     NTSAN     NUMBER OF NODES FOR TSAN
C     NTSAT     NUMBER OF NODES FOR TSAT
C     TSNO    NODE NUMBER FOR WHICH TSO IS REQUESTED
C     TSNODE  ARRAY DETERMING IF TSO IS WRITTEN FOR A NODE (NOT 0)
C             OR NOT (0), DIMENSION(MXNODE)
C     TSTU    TUBE NUMBER FOR WHICH TSO IS REQUESTED
C     TSTUBE  ARRAY DETERMING IF TSO IS WRITTEN FOR A TUBE (NOT 0)
C             OR NOT (0), DIMENSION(MXTUBE)
C
      USE CONSTANTS, ONLY: TRUE,FALSE,Z,ONE,NEG,NINER,DZ,DOS,NEARZERO_30
      USE GLOBAL, ONLY:IOUT
C
      USE CFPMODULE, ONLY:NOTSNO, NOTSTU, NNODES, NTUBES, TSNO, TSNODE, 
     +    TSTU, TSTUBE, MXTUBE, MXNODE, TSA_FLG, TSA_FUNIT, NCOUNT,     !TR: 2013 05 13 TSA OUTPUT
     +    TCOUNT, TSAN_FUNIT, TSAN_FLG, NTSAN, TSAN, NOTSTSAN,          !TR: 2013 05 17 NCOUNT / TCOUNT GLOBAL // 2013 08 12 TSAN OUTPUT
     +    TSAT_FUNIT, TSAT_FLG, NTSAT, TSAT, NOTSTSAT                   !TR: 2013 08 13 TSAT
      IMPLICIT NONE
      EXTERNAL EINTRD, EINTRD_MULTI                                     !TR: 2013 08 12 TSAN
C
C--ARGUMENTS
      INTEGER, INTENT(IN) :: INUNIT
      INTEGER :: READIN(8)                                              !TR: 2013 08 12 TSAN
C
C--LOCAL VARIABLES
      INTEGER I, N, T, IDUMMY
      CHARACTER*8 NAME, NAME_MULTI(8)                                   !TR: 2013 08 12 TSAN
C
C--BARC**ALLOCATE
      ALLOCATE (NOTSNO, NOTSTU, NNODES, NTUBES, TSNO, TSTU, TSA_FLG,
     + TSA_FUNIT,NCOUNT,TCOUNT,TSAN_FLG,NTSAN,NOTSTSAN,TSAT_FLG,NTSAT,  !TR: 2013 05 13 TSA OUTPUT // 2013 05 17 NCOUNT/TCOUNT GLOBAL // 2013 08 12 TSAN OUTPUT
     + NOTSTSAT)
      ALLOCATE (TSNODE(MXNODE),TSTUBE(MXTUBE),TSAN(MXNODE),
     + TSAN_FUNIT(5),TSAT(MXNODE),TSAT_FUNIT(5))                        !TR: 2013 08 13 TSAN // TSAT
C
C--BARC**READ AND WRITE
C--WRITE MESSAGE
      WRITE (IOUT, *) 'READING CONDUIT OUTPUT CONTROL FROM UNIT', INUNIT
C
C--INITIALIZE TSNODE AND TSTUBE
      DO I = 1, MXNODE
        TSNODE(I) = Z
        TSAN(I) = Z                                                     !TR: 2013 08 13 TSAN
        TSAT(I) = Z
      ENDDO
      DO I = 1, MXTUBE
        TSTUBE(I) = Z
      ENDDO
      TSA_FLG = FALSE                                                 !TR: 2013 05 13 TSA OUTPUT
      TSAN_FLG = FALSE                                                !TR: 2013 08 13 TSAN
      TSAT_FLG = FALSE                                                !TR: 2013 08 13 TSAT
      TSA_FUNIT = -1                                                    !TR: 2013 05 13 TSA OUTPUT
      TSAN_FUNIT = -1                                                   !TR: 2013 08 12 TSAN OUTPUT
      TSAT_FUNIT = -1                                                   !TR: 2013 08 13 TSAT
      NCOUNT = Z                                                        !TR: 2013 05 17 NCOUNT / TCOUNT GLOBAL
      TCOUNT = Z                                                        !TR: 2013 05 17 NCOUNT / TCOUNT GLOBAL
      NOTSTSAN = 1                                                      !TR: 2013 08 13 TSAN
      NOTSTSAT = 1                                                      !TR: 2013 08 13 TSAT
C      
C--READ NNODES
      NAME_MULTI(1) = 'NNODES  '
      NAME_MULTI(2) = 'NTSAN   '                                        !TR: 2013 08 12 TSAN
      CALL EINTRD_MULTI(READIN, INUNIT, IOUT, NAME_MULTI)  
      NNODES = READIN(1)                                                !TR: 2013 08 12 TSAN
      NTSAN = READIN(2)                                                 !TR: 2013 08 13 TSAN
      IF (NNODES.LT.Z) THEN                                             !TR: 2013 05 13 TSA OUTPUT
        NNODES = NNODES * -1                                            !TR: 2013 05 13 TSA OUTPUT
        TSA_FLG = TRUE                                                !TR: 2013 05 13 TSA OUTPUT
      ENDIF                                                             !TR: 2013 05 13 TSA OUTPUT
      NCOUNT = NNODES                                                   !TR: 2013 05 17 SET NCOUNT FOR THE FIRST TIME
      IF (NTSAN.NE.Z) TSAN_FLG = TRUE                                 !TR: 2013 08 12 TSAN
C
C--READ TSNO
      DO N = 1, NNODES
        NAME = 'TSNO    '
        CALL EINTRD(TSNO, INUNIT, IOUT, NAME)
        TSNODE(TSNO) = 1
      ENDDO
C
C--READ NOTSNO
      NAME = 'NOTSNO  '
      CALL EINTRD(NOTSNO, INUNIT, IOUT, NAME)
C
C--READ NTUBES
      NAME_MULTI(1) = 'NTUBES  '
      NAME_MULTI(2) = 'NTSAT   '                                        !TR: 2013 08 12 TSAT
      CALL EINTRD_MULTI(READIN, INUNIT, IOUT, NAME_MULTI)       
      NTUBES = READIN(1)                                                !TR: 2013 08 12 TSAT
      NTSAT = READIN(2)                                                 !TR: 2013 08 13 TSAT
      TCOUNT = NTUBES                                                   !TR: 2013 05 17 SET TCOUNT FOR THE FIRST TIME
      IF (NTSAT.NE.Z) TSAT_FLG = TRUE                                 !TR: 2013 08 13 TSAT
C
C--READ TSTU
      DO T = 1, NTUBES
        NAME = 'TSTU    '
        CALL EINTRD(TSTU, INUNIT, IOUT, NAME)
        TSTUBE(TSTU) = 1
      ENDDO
C
C--READ NOTSTU
      NAME = 'NOTSTU  '
      CALL EINTRD(NOTSTU, INUNIT, IOUT, NAME)
C
C--READ TSAN NODES
      IF(TSAN_FLG) THEN
        DO N = 1, NTSAN
          NAME = 'NTSAN   '
          CALL EINTRD(IDUMMY, INUNIT, IOUT, NAME)       
          TSAN(N) = IDUMMY
        ENDDO
C
C--READ NOTSTSAN
        NAME = 'NOTSTSAN'
        CALL EINTRD(NOTSTSAN, INUNIT, IOUT, NAME)       
      ENDIF
C
C--READ TSAT TUBES
      IF(TSAT_FLG) THEN
        DO N = 1, NTSAT
          NAME = 'NTSAT   '
          CALL EINTRD(IDUMMY, INUNIT, IOUT, NAME)       
          TSAT(N) = IDUMMY
        ENDDO
C
C--READ NOTSTSAT
        NAME = 'NOTSTSAT'
        CALL EINTRD(NOTSTSAT, INUNIT, IOUT, NAME)                  
      ENDIF

      END SUBROUTINE CFPM1OCAR
C
C
C
C
C
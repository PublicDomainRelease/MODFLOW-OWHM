C
C
C
C
C
      SUBROUTINE NODINEX(SIDIR,SIWEL,SIFXH,SIMAT,SICY,CEQ,MINEX,
     +                   MDIR,MWEL,MFXH,MFHLQ,MMAT,MCY,MCYLQ,CMDIR,
     +                   CMWEL,CMFXH,CMFHLQ,CMMAT,CMCY,CMCYLQ,N)        !TR: 2012 08 13 WELL BOUNDARY // FHLQ // 2013 03 04 CADS (SICDS)/2013 03 18 CAUCHY
C
C**********************************************************************
C     CALCULATE EXTERNAL MASS FLOW TO THE NODES
C
C     STORE MASS FLOW RATES AND CUMULATIVE MASS FLOW FROM 
C     DIRECT RECHARGE, EXCHANGE WITH MATRIX AND FIXED HEAD TO NODES 
C     STORE SUM OF EXTERNAL MASS INFLOW RATE IN MINEX   
C**********************************************************************
C     
      USE CONSTANTS, ONLY: TRUE,FALSE,Z,ONE,NEG,NINER,DZ,DOS,NEARZERO_30
      USE CFPMODULE, ONLY: MXNODE,QBDIR,QMAT,QFIX,QWELL,QFHLQ,CADSFLOW, !TR: 2012 08 13 WELL BOUNDARY, 2012 08 17 FHLQ (QFHLQ IS FLOW WHILE LQ CONDITION IS ACTIVE) // 2013 03 04 CADSFLOW
     + CYFLOW,QCYLQ                                                     !TR: 2013 03 18 CYFLOW = CAUCHY FLOW; QCYLQ = CAUCHY LQ FLOW
      USE GWFBASMODULE, ONLY: DELT          
C
      IMPLICIT NONE
C
      INTEGER N
      DOUBLE PRECISION CEQ,SIDIR(MXNODE),SIMAT(MXNODE),
     +   SICY(MXNODE),MINEX(MXNODE),MDIR(MXNODE),MMAT(MXNODE),
     +   MFXH(MXNODE),MCY(MXNODE),MCYLQ(MXNODE),
     +   CMDIR(MXNODE),CMMAT(MXNODE),CMFXH(MXNODE),
     +   CMCY(MXNODE),CMCYLQ(MXNODE),SIWEL(MXNODE),MWEL(MXNODE),
     +   CMWEL(MXNODE),SIFXH(MXNODE),MFHLQ(MXNODE),CMFHLQ(MXNODE)       !TR: 2012 08 13 WELL BOUNDARY // 2012 08 15 FIXED HEAD CONCENTRATION / TEMPERATURE // 2012 08 17 FHLQ // 2013 03 04 CADS
C                
C--CLEAR MINEX(N): ACCUMULATOR FOR MASS INFLOW RATE TO NODE
      MINEX(N)=Z
C         
C--EXTERNAL INFLOW OF MASS TO NODE         
C  DIRECT RECHARGE: MASS FLOW RATE // ACCUMULATE IN MINEX(N) // 
C  CUMULATIV MASS FLOW
      IF(QBDIR(N).GE.Z)THEN
        MDIR(N)=QBDIR(N)*SIDIR(N)*CEQ
        MINEX(N)=MINEX(N)+MDIR(N)
        CMDIR(N)=CMDIR(N)+MDIR(N)*DELT            
      ENDIF          
C
C--EXCHANGE WITH MATRIX: MASS FLOW RATE // ACCUMULATE IN MINEX(N) //
C  CUMULATIV MASS FLOW
      IF(QMAT(N).LE.Z)THEN
        MMAT(N)=-QMAT(N)*SIMAT(N)*CEQ
        MINEX(N)=MINEX(N)+MMAT(N)
        CMMAT(N)=CMMAT(N)+MMAT(N)*DELT
      ENDIF     
C
C--CAUCHY: MASS FLOW RATE // ACCUMULATE IN MINEX(N) //
C  CUMULATIV MASS FLOW
      IF(CYFLOW(N).LE.Z)THEN
        MCY(N)=-CYFLOW(N)*SICY(N)*CEQ
        MINEX(N)=MINEX(N)+MCY(N)
        CMCY(N)=CMCY(N)+MCY(N)*DELT
      ENDIF                   
C
C--FIXED HEAD: MASS FLOW RATE // ACCUMULATE IN MINEX(N //
C  CUMULATIV MASS FLOW
      IF(QFIX(N).GE.Z)THEN
        MFXH(N)=QFIX(N)*SIFXH(N)*CEQ                                    !TR: 2012 08 15 FIXED HEAD CONCENTRATION / TEMPERATURE
        MINEX(N)=MINEX(N)+MFXH(N)
        CMFXH(N)=CMFXH(N)+MFXH(N)*DELT            
      ENDIF
C
C--FHLQ: MASS FLOW RATE // ACCUMULATE IN MINEX(N // CUMULATIV MASS FLOW
      IF(QFHLQ(N).GE.Z)THEN                                             !TR: 2012 08 17 FHLQ
        MFHLQ(N)=QFHLQ(N)*SIFXH(N)*CEQ                                  !TR: 2012 08 17 FHLQ
        MINEX(N)=MINEX(N)+MFHLQ(N)                                      !TR: 2012 08 17 FHLQ
        CMFHLQ(N)=CMFHLQ(N)+MFHLQ(N)*DELT                               !TR: 2012 08 17 FHLQ
      ENDIF   
C
C--CAUCHY LQ: MASS FLOW RATE // ACCUMULATE IN MINEX(N // CUMULATIV MASS FLOW
      IF(QCYLQ(N).GE.Z)THEN                                             !TR: 2013 03 18 CAUCHY LQ
        MCYLQ(N)=QCYLQ(N)*SICY(N)*CEQ                                   !TR: 2013 03 18 CAUCHY LQ
        MINEX(N)=MINEX(N)+MCYLQ(N)                                      !TR: 2013 03 18 CAUCHY LQ
        CMCYLQ(N)=CMCYLQ(N)+MCYLQ(N)*DELT                               !TR: 2013 03 18 CAUCHY LQ
      ENDIF               
C
C--WELL: MASS FLOW RATE // ACCUMULATE IN MINEX(N // CUMULATIV MASS FLOW
      IF(QWELL(N).GE.Z)THEN                                             !TR: 2012 08 13 WELL BOUNDARY
        MWEL(N)=QWELL(N)*SIWEL(N)*CEQ                                   !TR: 2012 08 13 WELL BOUNDARY
        MINEX(N)=MINEX(N)+MWEL(N)                                       !TR: 2012 08 13 WELL BOUNDARY
        CMWEL(N)=CMWEL(N)+MWEL(N)*DELT                                  !TR: 2012 08 13 WELL BOUNDARY
      ENDIF                            
C
      RETURN
      END
C
C
C
C
C
      SUBROUTINE FLOWDIR(T,QFLAG,QOLD)
C
C**********************************************************************
C        CHECK THE TUBE FOR CHANGES OF FLOW DIRECTION  
C**********************************************************************
C      
      USE CONSTANTS, ONLY: TRUE,FALSE,Z,ONE,NEG,NINER,DZ,DOS,NEARZERO_30
      USE CFPMODULE, ONLY: DTUBE,MXTUBE
      USE GLOBAL, ONLY: IOUT
C
      IMPLICIT NONE
C
      INTEGER T
      DOUBLE PRECISION QFLAG(MXTUBE), QOLD(MXTUBE)
C
C---SET QFLAG=1 FOR THE FIRST TIME STEP      
         IF(QFLAG(T).EQ.Z)THEN
            QFLAG(T)=1
C
C--IF FLOW DIRECTION OF THE PREVIOUS TIME STEP WAS THE SAME AS IN THE FIRST         
         ELSE IF(QFLAG(T).GT.Z)THEN
C
C---IF FLOW DIRECTION CHANGED: FLOW DIRECTION IS NOT THE SAME AS IN THE FIRST TIME STEP
           IF((DTUBE(T,1).GE.Z.AND.QOLD(T).LT.Z)
     1       .OR.(DTUBE(T,1).LT.Z.AND.QOLD(T).GE.Z))THEN
             WRITE(IOUT,*)'FLOW DIRECTION CHANGED IN TUBE',T         
             QFLAG(T)=-1
C
C---IF FLOW DIRECTION DID NOT CHANGE: FLOW DIRECTION IS THE SAME AS IN THE FIRST TIME STEP
           ELSE
             QFLAG(T)=1
           ENDIF
C
C--IF FLOW DIRECTION OF THE PREVIOUS TIME STEP WAS NOT THE SAME AS IN THE FIRST         
         ELSE IF(QFLAG(T).LT.Z)THEN
C
C---IF FLOW DIRECTION CHANGED: FLOW DIRECTION IS THE SAME AS IN THE FIRST TIME STEP
           IF((DTUBE(T,1).GE.Z.AND.QOLD(T).LT.Z)
     1       .OR.(DTUBE(T,1).LT.Z.AND.QOLD(T).GE.Z))THEN
           WRITE(IOUT,*)'FLOW DIRECTION CHANGED IN TUBE',T
             QFLAG(T)=1
C
C---IF FLOW DIRECTION DID NOT CHANGE: FLOW DIRECTION IS NOT THE SAME AS IN THE FIRST TIME STEP
           ELSE
             QFLAG(T)=-1
           ENDIF
        ENDIF
C
C--STORE FLOW RATE IN QOLD
        QOLD(T)=DTUBE(T,1)
C      
      RETURN
      END
C
C
C
C
C
      DOUBLE PRECISION FUNCTION LAMTURB(RE,RADIUS,T)
C
C*******************************************************************
C    CALCULATION OF FRICTION FACTOR FOR TURBULENT FLOW
C*******************************************************************
C
      USE CFPMODULE, ONLY: CON_DATA
C
      IMPLICIT NONE
C
      INTEGER I,ITMAX,T
      DOUBLE PRECISION RE,RADIUS,LAMBDA,LAMNEW,EPSIL
C
C--ITERATION FOR LAMBDA
      LAMBDA=0.04D0
      EPSIL=0.0000001D0
      ITMAX=40
      DO 100 I=1,ITMAX
        LAMNEW=(1D0/(-2D0*DLOG10(2.51D0/(RE*DSQRT(LAMBDA))
     +    +CON_DATA(T,4)/(3.71D0*RADIUS*2D0))))**2D0
        IF(DABS(LAMNEW-LAMBDA).LT.EPSIL) GOTO 10
        LAMBDA=LAMNEW
 100  CONTINUE
      WRITE (*,*) 'ITERATION FOR LAMBDA FAILED!'
C
C--IF NOT CONVERGED SET LAMBDA=0.04
      LAMBDA=0.04D0
 10   LAMTURB=LAMBDA
C
      RETURN
      END          
C
C
C
C
C
      SUBROUTINE EDPRRD(DPRNO,IN,IOUT,NAME)
C
C***********************************************************************
C          READ LINE AND CONVERT TO A DOUBLE PRECISION NUMBER  22JAN1999
C***********************************************************************
C
C DPRNO     DOUBLE PRECISION NUMBER
C IN  		UNIT NUMBER FROM WHICH INPUT FOR THIS PACKAGE WILL BE READ
C IOUT  	UNIT NUMBER FOR ALL PRINTED OUTPUT
C ISTART    LOCATION FOR THE START OF THE NUMBER
C IEND      LOCATION FOR THE END OF THE NUMBER
C LINE		LINE FROM INPUT FILE
C NAME		NAME OF THE VARIABLE
C      
      USE CONSTANTS, ONLY: TRUE,FALSE,Z,ONE,NEG,NINER,DZ,DOS,NEARZERO_30
      CHARACTER*80 LINE
      CHARACTER*8 NAME
      INTEGER IN,IOUT,I,ISTART,IEND
      DOUBLE PRECISION DPRNO
C
C--READ A LINE; IGNORE BLANK LINES AND COMMENT LINES
  10  READ(IN,'(A)',ERR=900) LINE
      IF(LINE.EQ.' ') GO TO 10
      IF(LINE(1:1).EQ.'#') GO TO 10
C      
C--FIND START AND END OF NUMBER: CHARACTER THAT IS NOT A BLANK OR A COMMA
      ISTART=Z
      IEND=80
      DO 20 I=1,80
        IF(LINE(I:I).NE.' '.AND.LINE(I:I).NE.','.AND.ISTART.EQ.Z)
     1    ISTART=I
        IF((LINE(I:I).EQ.' '.OR.LINE(I:I).EQ.',').AND.ISTART.NE.Z)THEN
          IEND=I
          GOTO 30
        ENDIF
  20  CONTINUE
C
C--CONVERT LINE TO A DOUBLE PRECISION NUMBER            
  30  READ(LINE(ISTART:IEND),'(F20.0)',ERR=900) DPRNO
      WRITE(IOUT,1000)NAME,DPRNO
      RETURN
C      
C--IF AN ERROR OCCURED      
 900  WRITE(IOUT,*) 'READ ERROR UNIT',IN
      WRITE(IOUT,*)'PARAMETER ',NAME
C 
1000  FORMAT(X,A8,4X,G13.6)      
      RETURN     
      END         
C
C
C
C
C
      SUBROUTINE EDPRRD_MULTI(DPRNO,IN,IOUT,NAME)
C
C***********************************************************************
C     READ LINE & CONVERT TO SEVERAL DOUBLE PRECISION NUMBERS  22JAN1999
C***********************************************************************
C
C DPRNO   DOUBLE PRECISION NUMBER
C IN  	UNIT NUMBER FROM WHICH INPUT FOR THIS PACKAGE WILL BE READ
C IOUT  	UNIT NUMBER FOR ALL PRINTED OUTPUT
C ISTART  LOCATION FOR THE START OF THE NUMBER
C IEND    LOCATION FOR THE END OF THE NUMBER
C LINE	LINE FROM INPUT FILE
C NAME	NAME OF THE VARIABLE
C      
      USE CONSTANTS, ONLY: TRUE,FALSE,Z,ONE,NEG,NINER,DZ,DOS,NEARZERO_30
      CHARACTER*80 LINE
      CHARACTER*11 NAME(8)
      INTEGER IN,IOUT,I,ISTART,IEND,II,N
      DOUBLE PRECISION DPRNO(8)
C      
      DO      
C
C--READ A LINE; IGNORE BLANK LINES AND COMMENT LINES
  10    READ(IN,'(A)',ERR=900) LINE
        IF(LINE.EQ.' ') GO TO 10
        IF(LINE(1:1).EQ.'#') GO TO 10
C      
C--FIND START AND END OF NUMBER: CHARACTER THAT IS NOT A BLANK OR A COMMA
        ISTART=Z
        IEND=80
        II=1
        N=1
        DO
C
C--SEARCH START
          DO I=II,80
            IF(LINE(I:I).NE.' '.AND.LINE(I:I).NE.',')THEN
              IF(LINE(I:I).EQ.'#')GOTO 50
              ISTART=I
              EXIT
            ENDIF
          ENDDO
          IF(I.EQ.81) GOTO 50
C
C--SEARCH END   
          II = ISTART
          DO I = II, 80     
            IF(LINE(I:I).EQ.' '.OR.LINE(I:I).EQ.',')THEN
              IEND=I
C
C--CONVERT LINE TO A DOUBLE PRECISION NUMBER            
              READ(LINE(ISTART:IEND),'(F20.0)',ERR=900) DPRNO(N)
              WRITE(IOUT,1000)NAME(N),DPRNO(N)  
              N = N+1
              EXIT
            ENDIF    
          ENDDO
          IF(I.EQ.81)GOTO 50
          II = IEND            
        ENDDO
      ENDDO
C      
  50  CONTINUE
C  
      RETURN
C      
C--IF AN ERROR OCCURED      
 900  WRITE(IOUT,*)' READ ERROR UNIT ',IN
      WRITE(IOUT,*)' PARAMETER NAME / NUMBER ',NAME(N),' ',N
C 
1000  FORMAT(X,A11,X,G13.6)
      RETURN     
      END         
C
C
C
C
C
      SUBROUTINE EDPRRDTD(DPRNO,IN,NAME,TD_FLG2,IOUT)
C
C***********************************************************************
C          READ LINE AND CONVERT TO A DOUBLE PRECISION NUMBER  22JAN1999
C***********************************************************************
C
C DPRNO     DOUBLE PRECISION NUMBER
C IN  		UNIT NUMBER FROM WHICH INPUT FOR THIS PACKAGE WILL BE READ
C IOUT  	UNIT NUMBER FOR ALL PRINTED OUTPUT
C ISTART    LOCATION FOR THE START OF THE NUMBER
C IEND      LOCATION FOR THE END OF THE NUMBER
C LINE		LINE FROM INPUT FILE
C NAME		NAME OF THE VARIABLE
C TD_FLG    FLAG FOR TIME DEPENDENT BOUNDARY DATA
C      
      USE CONSTANTS, ONLY: TRUE,FALSE,Z,ONE,NEG,NINER,DZ,DOS,NEARZERO_30
      CHARACTER*80 LINE
      CHARACTER*8 NAME
      INTEGER IN,I,ISTART,IEND,J,IOUT
      DOUBLE PRECISION DPRNO
      LOGICAL TD_FLG2
C
C--INITIALIZE TD_FLG2     
      TD_FLG2 = FALSE
C
C--READ A LINE; IGNORE BLANK LINES AND COMMENT LINES
  10  READ(IN,'(A)',ERR=900) LINE
      IF(LINE.EQ.' ') GO TO 10
      IF(LINE(1:1).EQ.'#') GO TO 10
      IF(LINE(1:2).EQ.'TD'.OR.LINE(1:2).EQ.'td')THEN
        TD_FLG2 = TRUE
      ENDIF
C      
C--FIND START AND END OF NUMBER: CHARACTER THAT IS NOT A BLANK OR A COMMA
      ISTART=Z
      IEND=80
      DO 20 I=1,80
        IF(TD_FLG2)THEN
          J=I+2
        ELSE
          J=I
        ENDIF
        IF(LINE(J:J).NE.' '.AND.LINE(J:J).NE.','.AND.ISTART.EQ.Z)
     1    ISTART=J
        IF((LINE(J:J).EQ.' '.OR.LINE(J:J).EQ.',').AND.ISTART.NE.Z)THEN
          IEND=J
          GOTO 30
        ENDIF
  20  CONTINUE
C
C--CONVERT LINE TO A DOUBLE PRECISION NUMBER            
  30  READ(LINE(ISTART:IEND),'(F20.0)',ERR=900) DPRNO
      IF(TD_FLG2)THEN
        WRITE(IOUT,9000)NAME,INT(DPRNO)
      ELSE
        WRITE(IOUT,9010)NAME,DPRNO
      ENDIF
      RETURN
C      
C--IF AN ERROR OCCURED      
 900  WRITE(IOUT,*) 'READ ERROR UNIT',IN
      WRITE(IOUT,*)'PARAMETER ',NAME
C 
      RETURN     
 9000 FORMAT(4X,'READ ',A8,' AS TIME DEPENDENT DATA FROM UNIT: ',I3) 
 9010 FORMAT(4X,'READ ',A8,' AS: ',F9.4)
      END         
C
C
C
C
C
      SUBROUTINE EARRRD(ARRAY,MXPARA,IN,IOUT,NAME,DPRNO)                !TR: 2013 08 23 DPRNO ADDED AS FLAG / VALUE
C         
C***********************************************************************
C                 READ LINE AND VALUES OF AN ARRAY      22JAN1999
C***********************************************************************
C
C ARRAY(MXPARA) DOUBLE PRECISION ARRAY
C IN  		    UNIT NUMBER FROM WHICH INPUT FOR THIS PACKAGE WILL BE READ
C IOUT  	    UNIT NUMBER FOR ALL PRINTED OUTPUT
C ISTART        LOCATION FOR THE START OF THE NUMBER
C IEND          LOCATION FOR THE END OF THE NUMBER
C MXPARA        NUMBER OF ARRAY VALUES
C NAME		    NAME OF THE VARIABLE
C DPRNO         DOUBLE PRECISION NUMBER // ALSO USED AS FLAG - IF -999.9
C               DPRNO IS READ IN (THIS WAS THE ORIGINAL WAY)
C
C
      USE CONSTANTS, ONLY: TRUE,FALSE,Z,ONE,NEG,NINER,DZ,DOS,NEARZERO_30
      CHARACTER*8 NAME
      INTEGER IN,IOUT,MXPARA,I
      DOUBLE PRECISION DPRNO,ARRAY(MXPARA),READNO
C
C--CHECK IF DPRNO NEED TO BE READ IN
      IF(DPRNO.EQ.-999.9) CALL EDPRRD(DPRNO,IN,IOUT,NAME)               !TR: 2013 08 23 
      IF(DPRNO.GT.1E6)
     1  WRITE(IOUT,*)'READING ',NAME,' FOR EACH ARRAY VALUE'
C
C--ASSIGN ARRAY VALUES      
      DO 100 I=1,MXPARA
C
C--IF DPRNO IS GREATER THAN 1E6 ARRAY VALUES ARE READ FROM INPUT FILE
        IF(DPRNO.GT.1E6)THEN
C          READ(IN,*,END=900) READNO
           WRITE(IOUT,*)'VALUE',I
           CALL EDPRRD(READNO,IN,IOUT,NAME)
           ARRAY(I)=READNO            
        ELSE
C
C--IF DPRNO IS LESS THAN 1E6 ARRAY VALUES EQUAL DPRNO
           ARRAY(I)=DPRNO
        ENDIF   
 100  CONTINUE    
      RETURN
C      
C--IF AN ERROR OCCURED      
 900  WRITE(IOUT,*) 'READ ERROR UNIT',IN  
      WRITE(IOUT,*) 'PARAMETER ',NAME    
C
      RETURN
      END
C
C
C
C
C
      SUBROUTINE EARRRDTD(ARRAY,IN,NAME,TD_FLG,TD_COUNT,BLK_FLG,TD_IN,
     + TD_LINESMAX,IOUT) 
C         
C***********************************************************************
C     READ LINE AND VALUES OF AN ARRAY      22JAN1999
C     UPDATED TO CONSIDER TIME DEPENDENT INPUT
C     LAST MODIFICATION 2013 04 04 BY THOMAS.REIMANN@TU-DRESDEN.DE
C***********************************************************************
C
C ARRAY(MXPARA) DOUBLE PRECISION ARRAY
C IN  		    UNIT NUMBER FROM WHICH INPUT FOR THIS PACKAGE WILL BE READ
C IOUT  	    UNIT NUMBER FOR ALL PRINTED OUTPUT
C ISTART        LOCATION FOR THE START OF THE NUMBER
C IEND          LOCATION FOR THE END OF THE NUMBER
C MXPARA        NUMBER OF ARRAY VALUES
C NAME		    NAME OF THE VARIABLE
C TD_FLG        FLAG IF TIME DEPENDENT
C BLK_FLG       ACTIVE IF ONE VALUE IS VALID FOR ALL NODES (BULK)
      USE GENERIC_OPEN_INTERFACE, ONLY: UTF8_BOM_OFFSET_REWIND
      USE CONSTANTS, ONLY: TRUE,FALSE,Z,ONE,NEG,NINER,DZ,DOS,NEARZERO_30
      USE CFPMODULE, ONLY: ACTIVENODE
C
      CHARACTER*8 NAME
      INTEGER IN,I,TD_COUNT,TD_IN(ACTIVENODE),TD_LINES, TD_LINESMAX,IOUT
      DOUBLE PRECISION DPRNO,ARRAY(ACTIVENODE),READNO
      LOGICAL TD_FLG,TD_FLG2,BLK_FLG                                    !TR: 2013 04 04 AR FLAG TO CONSIDER ARRAY VALUES
C
C--INITIALIZE
      TD_COUNT = Z      
C
      CALL EDPRRDTD(DPRNO,IN,NAME,TD_FLG2,IOUT)
      IF(DPRNO.GT.1E6)THEN
        WRITE(IOUT,*)'READING ',NAME,' FOR EACH ARRAY VALUE'
      ENDIF
C
C--ASSIGN ARRAY VALUES      
      DO 100 I=1,ACTIVENODE
C
C--IF DPRNO IS GREATER THAN 1E6 ARRAY VALUES ARE READ FROM INPUT FILE
        IF(DPRNO.GT.1E6)THEN
           WRITE(IOUT,*)'VALUE',I
           CALL EDPRRDTD(READNO,IN,NAME,TD_FLG2,IOUT)
           IF(TD_FLG2) THEN
             TD_FLG = TRUE
             TD_IN(I)=INT(READNO)
C
C--ASSESS NUMBER OF LINES IN INPUT FILE     
             CALL UTF8_BOM_OFFSET_REWIND(TD_IN(I)) 
             READ (TD_IN(I),*) TD_LINES
C
C--UPDATE MAXIMUM NUMBER OF LINES - IF NECESSARY      
             IF (TD_LINES.GT.TD_LINESMAX)TD_LINESMAX = TD_LINES
             ARRAY(I)=999
             TD_COUNT=TD_COUNT+1
           ELSE
             ARRAY(I)=READNO            
           ENDIF
        ELSE
C
C--IF DPRNO IS LESS THAN 1E6 ARRAY VALUES EQUAL DPRNO
          BLK_FLG = TRUE
          IF(TD_FLG2) THEN
C
C--SAVE INUNIT ONLY ONCE    
            TD_FLG = TRUE       
            IF(I.EQ.1)THEN
              TD_IN(I)=INT(DPRNO)                              
C
C--ASSESS NUMBER OF LINES IN INPUT FILE  
              READ (TD_IN(I),*) TD_LINESMAX
              TD_COUNT=TD_COUNT+1
            ENDIF
            ARRAY(I)=999       
          ELSE
            ARRAY(I)=DPRNO            
          ENDIF
        ENDIF   
 100  CONTINUE     
C      
      RETURN
C      
C--IF AN ERROR OCCURED      
 900  WRITE(IOUT,*) 'READ ERROR UNIT',IN  
      WRITE(IOUT,*) 'PARAMETER ',NAME    
C
      RETURN
      END
C
C
C
C
C
      SUBROUTINE EINTRD2(INTNO,IN,IOUT,NAME,DEFAULT)
C
C***********************************************************************
C               READ LINE AND CONVERT TO A INTEGER NUMBER      08FEB2000
C***********************************************************************
C
C DEFAULT       DEFAULT VALUE OF THE VARIABLE
C INTNO         INTEGER NUMBER
C IN  		    UNIT NUMBER FROM WHICH INPUT FOR THIS PACKAGE WILL BE READ
C IOUT  	    UNIT NUMBER FOR ALL PRINTED OUTPUT
C ISTART        LOCATION FOR THE START OF THE NUMBER
C IEND          LOCATION FOR THE END OF THE NUMBER
C LINE		    LINE FROM INPUT FILE
C NAME		    NAME OF THE VARIABLE
C
      USE CONSTANTS, ONLY: TRUE,FALSE,Z,ONE,NEG,NINER,DZ,DOS,NEARZERO_30
      CHARACTER*80 LINE
      CHARACTER*8 NAME
      INTEGER IN,IOUT,I,ISTART,IEND,INTNO,DEFAULT
C
C--READ A LINE; IGNORE BLANK LINES AND COMMENT LINES
  10  READ(IN,'(A)',ERR=900,END=910) LINE
      IF(LINE.EQ.' ') GO TO 10
      IF(LINE(1:1).EQ.'#') GO TO 10
C
C--FIND START AND END OF NUMBER: CHARACTER THAT IS NOT A BLANK OR A COMMA
      ISTART=Z
      IEND=80
      DO 20 I=1,80
        IF(LINE(I:I).NE.' '.AND.LINE(I:I).NE.','.AND.ISTART.EQ.Z)
     1    ISTART=I
        IF((LINE(I:I).EQ.' '.OR.LINE(I:I).EQ.',').AND.ISTART.NE.Z)THEN
          IEND=I
          GOTO 30
        ENDIF
  20  CONTINUE
C
C--CONVERT LINE TO A INTEGER NUMBER            
  30  READ(LINE(ISTART:IEND),'(I5)',ERR=900,END=910)INTNO
      WRITE(IOUT,1000)NAME,INTNO
      RETURN
C      
C--IF AN ERROR OCCURED      
 900  WRITE(IOUT,*) 'READ ERROR UNIT',IN
      WRITE(IOUT,*) 'PARAMETER ',NAME
C 
      RETURN 
C
C--END OF FILE
 910  WRITE(IOUT,*) 'END OF FILE ON UNIT',IN
      WRITE(IOUT,*) 'USING DEFAULT VALUE ',DEFAULT,' FOR ',NAME
      INTNO=DEFAULT
C
1000  FORMAT(X,A11,X,G13.6)      
      RETURN      
      END              
C
C
C
C
C
      SUBROUTINE INITDVARIABLES(TD_FLG,BLK_FLG,TD_LINESMAX,TD_COUNT,
     +           TD_IN)
C**********************************************************************
C     INITIALIZE VARIABLES USED FOR TIME DEPENDENT BOUNDARY DATA
C     2013 04 05 BY THOMAS.REIMANN@TU-DRESDEN.DE
C**********************************************************************   
C
      USE CONSTANTS, ONLY: TRUE,FALSE,Z,ONE,NEG,NINER,DZ,DOS,NEARZERO_30
      USE CFPMODULE, ONLY: MXNODE
C      
      IMPLICIT NONE      
C
      LOGICAL TD_FLG,BLK_FLG
      INTEGER TD_LINESMAX,TD_COUNT,TD_IN(MXNODE),N
C
      TD_FLG = FALSE
      BLK_FLG = FALSE
      TD_LINESMAX = Z
      TD_COUNT = Z
      DO N=1, MXNODE
        TD_IN(N)=Z
      ENDDO      
C      
      END SUBROUTINE INITDVARIABLES
C
C
C
C
C
      SUBROUTINE CADSVOL_TIME(CV,TTIME,TTIME_O)
C      
C**********************************************************************
C     COMPUTE CADS VOLUME DURING TRANSPORT TIMES (INTERPOLATION)
C     2014 02 24 BY THOMAS.REIMANN@TU-DRESDEN.DE
C**********************************************************************   
C
C     TTIME     TRANSPORT TIME
C     TTIME_O   TRANSPORT TIME AT BEGINNING OF FLOW TIME STEP
C     CV        CADSVOLUME AT ACTUAL TIME
C     CV_O      CADSVOLUME AT TIME 0 
C
      USE CONSTANTS, ONLY: TRUE,FALSE,Z,ONE,NEG,NINER,DZ,DOS,NEARZERO_30
      USE CFPMODULE, ONLY: MXNODE,L_NODE,W_CADS,B_MAT,NODEBOT,CADS_FLG,
     + CADSML_FLG,B_MAT_OTR                                        !TR: 2013 07 26 CADSML
      USE GWFBASMODULE, ONLY: DELT        
C
      IMPLICIT NONE
C      
      INTEGER N      
      DOUBLE PRECISION CV(MXNODE),CV_O(MXNODE)
      REAL TTIME, TTIME_O
C          
C--CADS VOLUME AT A SPECIFIC TRANSPORT TIME
      DO 100 N = 1, MXNODE
C
C--FOR CADS      
        IF(CADS_FLG.NE.Z)THEN
          CV(N) = W_CADS(N)*L_NODE(N)*(B_MAT(N)-NODEBOT(N))
          CV_O(N) = W_CADS(N)*L_NODE(N)*(B_MAT_OTR(N)-NODEBOT(N))
C
C--FOR CADSML        
        ELSEIF(CADSML_FLG.NE.Z)THEN
          CALL CADSML_VOL(N,B_MAT,CV(N))
          CALL CADSML_VOL(N,B_MAT_OTR,CV_O(N))
        ENDIF
C
C--INTERPOLATE CADS VOLUME AT ACTUAL TIME
        IF(TTIME.EQ.0.0) THEN
          CV(N) = CV_O(N)
        ELSE
          CV(N) = CV_O(N)+(CV(N)-CV_O(N))/DELT*(TTIME-TTIME_O)
        ENDIF                            
100   CONTINUE
C
      RETURN      
      END SUBROUTINE CADSVOL_TIME
C
C
C
C
C      
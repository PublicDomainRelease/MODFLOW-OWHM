! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
! MODULE TABLEFILE_INTERFACE
!  DESIGNED TO TAKE IN A LIST OF VARIABLE VALUES AND EVALUTE
!  VERSION 1.1 [5/30/2014] ADDED THE ABILITY TO EITHER READ ENTIRE TABFILE IN OR (NEW PART)
!                          ONLY THE PORTION THAT PERTAINS TO THE CURRENT TIME STEP VIA FILEIO FLAG
!  VERSION 1.0 [8/01/2013] ORIGINAL VERSION THAT RETURNS A TABFILE DATATYPE, READS TABFILE INFORMATION,
!                          RETURNS TO APPROPIATE LOCATION A DATA VALUE
!
C DATA TREE
      !TABIDX,PACIDX,CHARID,LRCIDX,TSFAC ARE ALL ONE TO ONE, WHERE EACH ROW RELATES THE SAME INFORMATION. 
      !THE NUMBER OR ROWS EQUALS TO THE NUMBER OF FEATURES THAT ARE LINKED TO A TABFILE (e.g. ONE FEATURE WOUDL BE A SINGLE SFR SEGMENT LINKED TO A TABFILE)
      !THE TOTAL NUMBER OF THE ROWS IS REFEREND AS "NLNK" IN CODE
      !TABIDX IS A POINTER OF TO THE TABFILE THAT IS ASSOCITED WITH THE FEATURE
      !
      !TABNAM, TAB  ARE ALL ONE TO ONE, WHERE EACH ROW RELATES THE SAME INFORMATION. 
      !EACH ROW REPRESENTS A SEPARATE TABFILE THAT IS POITNED TO BY TABIDX 
      !THE TOTAL NUMBER OF THE ROWS IS REFEREND AS "NTAB" IN CODE
      !
      !TIM, DAT ARE ALL ONE TO ONE. EACH ROW REPRESENTS A SEPARATE ENTRY POINTED TO BY POS FOR A SPECIFIC TABFILE POITNED TO BY TABIDX
      !THE TOTAL NUMBER OF THE ROWS IS REFEREND AS "NVAL" IN CODE
      
      MODULE TABLEFILE_INTERFACE
      USE GLOBAL,            ONLY:LSTCHK
      PRIVATE::LSTCHK                                                   !LSTCHK FUNCTION ONLY ACCESIBLE TO MODULAR SUBROUTINES
      !
      TYPE TABARRAY
        INTEGER::POS                                                    !HOLDS CURRENT POSITION IN TABFILE. THIS PREVENTS SEARCHING THROUGH SIMULATION TIMES THAT HAVE PASSED
        LOGICAL::USEVAL                                                 !FLAG TO TELL IF TABFILE HAS ALREADY BEEN INTERPOLATED TO CURRENT TIME STEP. THIS PREVENTS UNNECESSARY
        INTEGER::FILEIO                                                 !FLAG TO TELL IF TABFILE IS TREATED AS OPEN FILE OR ENTIRELY READ, IF ZERO ALL DATA IS READ IN. IF NONZERO THEN IS UNIT NUMBER OF TABFILE
        DOUBLE PRECISION::VAL                                           !HOLDS CURRENT INTERPOLATED TABFILE VALUE IF USEVAL=.TRUE.
        DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE::TIM,DAT              !TABFILE INFORMATION WHERE TIM HOLDS THE TIME AND DAT HOLDS THE VALUES/DATA
      END TYPE 
      !
      TYPE TABFILETYPE                                                  !ALL ARRAYS HERE ARE DIMENSION NTAB. ARRAYS TABNAM AND TAB ARE ONE TO ONE AND ARE POINTED TO BY TABIDX
        INTEGER::NTAB                                                   !NUMBER OF TABFILES HELD IN TABFILETYPE
        CHARACTER(20), DIMENSION(:),ALLOCATABLE::TABNAM                 !NAME/ID ASSOCIATED WITH EACH TABFILE. HAS DIM OF TABNAM(NTAB)
        TYPE(TABARRAY),DIMENSION(:),ALLOCATABLE::TAB                    !DATA TYPE THAT HOLDS ALLTABFILE INFORMATION. HAS DIM OF TABFILE%TAB(NTAB) AND A REFERENCE WOULD BE AS TABFILE%TAB(ITAB)%DAT(IVAL)
        LOGICAL::SIMTIME                                                !FLAG TO INDICATE THAT THE SIMULATED TIME AND DIS SPECIFIED UNITS ARE USED. IF FALSE THEN CODE WILL USE THE STARTTIME VALUE AND DECIMAL YEAR
        LOGICAL::TABPRINT                                               !FLAG TO INDICATE THAT DETAILED PRINTOUT IS REQUESTED
      END TYPE 
      !
      TYPE, EXTENDS (TABFILETYPE):: TABFILETYPELINKS                    !ALL ARRAYS HERE ARE DIMENSION NLNK (NUMBER OF LINKED FEATURES TO TABS). THEY ALL HAVE A ONE TO ONE MAPPING OF THEIR ROWS.
        DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE:: TSFAC               !SCALE FACTOR THAT IS APPLIED TO INTERPOLATED TABFILE RESULT
        INTEGER,         DIMENSION(:),ALLOCATABLE:: TABIDX              !LOCATION IN TABFILETYPE OF CORRECT TABFILE. FOR EXAMPLE TABFILE%TAB( TABFILE%TABIDX(1) ) WOULD GET THE TABFILE FOR THE FIRST REFERENCED TABLINK. THE TABLINK IS THE FEATURE OF THE PACKAGE THAT IS LINKED TO A TABFILE (e.g. THE FIRST SFR SEGMENT THAT IS LINKED TO A TABFILE)
        INTEGER,         DIMENSION(:),ALLOCATABLE:: PACIDX              !INDEX OF THE LOCATION OF THE FEATURE FROM A PACKAGE. SET TO ZERO WHEN FEATURE IS NOT USED
      END TYPE
      !
      TYPE, EXTENDS (TABFILETYPELINKS):: TABFILETYPE1IDX                !TABFILE DEFINED BY 1 INTEGER INDEX. HAS ONE TO ONE MATCHING WITH TABFILETYPELINKS
        INTEGER,      DIMENSION(:),ALLOCATABLE:: ONEIDX                 !ARRAY THAT HOLDS UNIQUE ID FOR PACKAGE THAT IS USED TO LINK THE PACKAGE FEATURE TO A ROW IN STORAGE. MOST PACKAGES USE THE ROW NUMBER AS THE SAME AS THE UNIQUE ID, LIKE IN SFR ISEG IS THE SEGMENT NUMBER AND COLUMN IN THE MATRIX
      END TYPE
      !
      TYPE, EXTENDS (TABFILETYPELINKS):: TABFILETYPECHARIDX             !TABFILE DEFINED BY A CHARACTER VARIABLE AND NEEDS TO MATCH AN INTEGER INDEX. HAS ONE TO ONE MATCHING WITH TABFILETYPELINKS
        CHARACTER(20),DIMENSION(:),ALLOCATABLE:: CHARID                 !CHARACTER THAT HOLDS THE ID OF THE FEATURE OF THE PACKAGE THAT IS BEING LINKED TO A TABFILE
      END TYPE
      !
      TYPE, EXTENDS (TABFILETYPELINKS):: TABFILETYPE3IDX                !TABFILE DEFINED BY 3 INTEGER INDEX (LAY,ROW,COL) AND IS CONVERTED TO A UNIQUE NUMBER. HAS ONE TO ONE MATCHING WITH TABFILETYPELINKS
        INTEGER,      DIMENSION(:),ALLOCATABLE:: LRCIDX                 !ARRAY THAT HOLDS UNIQUE ID FOR LAY, ROW, AND COL AS DEFINED AS LRCIDX = COL + NCOL*(ROW-1) + NCOL*NROW*(LAY-1)
      END TYPE
      !
      INTERFACE TABFILEUPDATE                                           !CALL TABFILEUPDATE(TABFILE,PACK, [S/D]RESULT )
C       MODULE PROCEDURES ARE DUMMY ROUTINES THAT LINK TO SUBROUTINE TABFILEUPDATER
C       SUBROUTINE TABFILEUPDATE ASSUMES THAT PACIDX HAS BEEN CONTRUCTED. 
C       LOOK THROUGH ALL LINKS AND INTERPOLATE THEIR APPROPIATE TABFILES
C       IF TABFILE PRINTING IS REQUESTED THEN PRINTS TABFILE RESULTS
C       VARIABLE LIST:
C       TABFILE: TABFILE THAT WILL BE UPDATED FOR TIMESTEP
C       PACK   : STRING THAT IS PASSED IN THAT IDENTIFIES THE CALLING PACKAGE. FOR EXAMPE PACK='WEL' OR 'SFR'
C       SRESULT: IS A SINGLE PRECISION ARRAY THAT IF PRESENT WILL HAVE THE TABFILE VALUE AND SCALE FACTORE APPLIED TO ITS PACKIDX LOCATION
C       DRESULT: IS A DOUBLE PRECISION ARRAY THAT IF PRESENT WILL HAVE THE TABFILE VALUE AND SCALE FACTORE APPLIED TO ITS PACKIDX LOCATION 
        MODULE PROCEDURE TABFILEUPDATE_S!(TABFILE,PACK, SRESULT )
        MODULE PROCEDURE TABFILEUPDATE_D!(TABFILE,PACK, DRESULT )
      END INTERFACE
      !
      CONTAINS
      !
      SUBROUTINE TABFILEPARSE(IN,IOUT,LINE,TABFILE)
C     ******************************************************************
C     GENERIC TABFILE INTERFACE AND READIN DEVELOPED BY SCOTT E. BOYCE 
C     ALLOCATE AND READ TABEFILE INFORMATION IF TABFILE FLAG IS FOUND
C     IF TABFILE IS **NOT** PRESENT THEN THE DERIVED DATA TYPE, TABFILE,
C     IS ALLOCATED AND TABFILE%NTAB IS SET TO 0
C     
C     ******************************************************************
C
C        SPECIFICATIONS:
C     ------------------------------------------------------------------
      USE GLOBAL,            ONLY:IUNIT,CUNIT
      USE GWFBASMODULE,      ONLY:REALTIM
      IMPLICIT NONE
      CLASS(TABFILETYPE)::TABFILE
      INTEGER:: IN,IOUT
      CHARACTER*(*) LINE
C     LOCAL VARIABLES
      CHARACTER(250)::FNAME
      CHARACTER(20)::TABNAM
      CHARACTER(8) :: EXT,TIMEOPTION
      INTEGER::LLOC,ISTART,ISTOP
      INTEGER::I,J,N,FN,NVAL,NTAB,PACKID,FILEIO
      REAL::R,T
      LOGICAL:: LVAL
C     ------------------------------------------------------------------
C
C     FIND CALLING PACKAGE
      N=0
      DO I=1,UBOUND(IUNIT,1)
        N=N+1
        IF(IUNIT(I).EQ.IN) EXIT
      END DO
      IF(N.EQ.0)THEN
          PACKID=UBOUND(IUNIT,1)
      ELSE
          PACKID=N
      END IF
      !
C     CHECK IF TABFILE IS SPECIFIED FOR SPECIFIC PACKAGE
C     IF NOT SPECIFIED ALLOCATE AND RETURN
      LLOC=1
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,IN)
      NTAB=0
      IF(LINE(ISTART:ISTOP).EQ.'TABFILE') THEN
        CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NTAB,R,IOUT,IN)
        CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,FILEIO,R,IOUT,IN)
        CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,IN)
        TIMEOPTION=LINE(ISTART:ISTOP);  TIMEOPTION=ADJUSTL(TIMEOPTION)
        IF(TIMEOPTION.EQ.'REALTIME')THEN
            TABFILE%SIMTIME=.FALSE.
        ELSE!.EQ.'SIMTIME'
            TABFILE%SIMTIME=.TRUE.
        END IF
        IF(REALTIM.LT.0D0 .AND. .NOT. TABFILE%SIMTIME)THEN
            IF(LSTCHK(1)) WRITE(IOUT,'(/ A /)')
     +      'TABFILE ERROR: SPECIFIED THAT TABFILE TIME '//
     +      'WILL USE REALTIME (NOT SIMTIME) FOR PACKAGE '//
     +      TRIM(CUNIT(PACKID))//', BUT A "STARTTIME" IS '//
     +      'NOT SPECIFIED IN THE DIS.'
            !
            CALL USTOP('TABFILE ERROR: SPECIFIED THAT TABFILE TIME '//
     +      'WILL USE REALTIME (NOT SIMTIME) FOR PACKAGE '//
     +      TRIM(CUNIT(PACKID))//', BUT A "STARTTIME" IS '//
     +      'NOT SPECIFIED IN THE DIS.')
        END IF
        READ(IN,'(A)') LINE                                             !READ IN NEXT LINE
      END IF
      !
      TABFILE%NTAB=NTAB
      !
      IF(TABFILE%NTAB.LE.0)THEN
       IF(LSTCHK(3)) WRITE(IOUT,'(/ 2A /)')
     +              ' NO TABFILE SPECIFIED FOR PACKAGE ',CUNIT(PACKID)
       TABFILE%NTAB=0
       RETURN      
      END IF
C
C     TABLEFILE IS SPECIFIED READ IN NAMELIST
      IF(LSTCHK(3)) WRITE(IOUT,'(/3A,/A,/)')'"TABFILE" FLAG SPECIFIED ',
     + 'IN PACKAGE ',CUNIT(PACKID),
     + 'NOW READING LIST OF TABFILE NAMES AND THEIR LOCATION'
C
C     ALLOCATE TABFILE DATATYPE SPACE
      ALLOCATE( TABFILE%TAB   (TABFILE%NTAB) )
      ALLOCATE( TABFILE%TABNAM(TABFILE%NTAB) )
C     TWO STRUCTION OPTIONS
C     TABGROUPNAME FILELOCATION 
C     TABGROUPNAME EXTERNAL FILENUMBER 
      DO I=1,TABFILE%NTAB
        LLOC=1
        CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,IN)
        TABNAM=LINE(ISTART:ISTOP)
        TABNAM=ADJUSTL(TABNAM)
        !
        TABFILE%TABNAM(I)=TABNAM
        !
        CALL URWORD(LINE,LLOC,ISTART,ISTOP,0,N,R,IOUT,IN)
        IF(ISTOP-ISTART+1.EQ.8) THEN
          EXT=LINE(ISTART:ISTOP)                                        !COULD CONTAIN EXTERNAL KEY WORD
          CALL UPCASE(EXT)
        ELSE
          EXT=' '
        END IF
        !
        FNAME=' '
        IF (EXT.EQ.'EXTERNAL')THEN
           CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,FN,R,IOUT,IN)           !EXTERNAL FILE, READ UNIT NUMBER
           INQUIRE(FN, NAME=FNAME )
           LVAL=.FALSE.                                                 !FLAG TO INDICATE THAT FILE IS EXTERNAL
        ELSE                                                            !FILE LOCATION SPECIFIED OPEN FILE NUMBER
           FNAME=LINE(ISTART:ISTOP)
           INQUIRE(FILE=FNAME, EXIST=LVAL )
           IF ( .NOT.LVAL ) THEN
             IF(LSTCHK(1)) WRITE(IOUT,'(A,/A,/A)')'SPECIFIED TABFILE '
     +                  ,TRIM(FNAME), ' DOES NOT EXIST'
             CALL USTOP('SPECIFIED TABFILE '//
     +                   TRIM(FNAME)//' DOES NOT EXIST')
           END IF
           !
           OPEN(NEWUNIT=FN,FILE=FNAME,ACTION='READ')
        END IF
        !
        !FIRST PASS TO CALCULATE SIZE
        REWIND(FN)
        IF(FILEIO.EQ.0) THEN
          TABFILE%TAB(I)%FILEIO=0
          NVAL=0
          DO
            READ(FN,*,IOSTAT=N)R
            IF(N.NE.0)EXIT
            NVAL=NVAL+1
          END DO
          ALLOCATE(TABFILE%TAB(I)%TIM(NVAL))
          ALLOCATE(TABFILE%TAB(I)%DAT(NVAL))
          TABFILE%TAB(I)%POS=1                                          !INITIAL POSITION IN TABFILE TO IMPROVE SPEED ON TIME SEARCH
          !
          !SECOND PASS TO READ IN DATA
          REWIND(FN)
          DO J=1,NVAL
            READ(FN,'(A)') LINE
            LLOC=1
            CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,N,T,IOUT,IN)
            CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,N,R,IOUT,IN)
            TABFILE%TAB(I)%TIM(J)=DBLE(T)
            TABFILE%TAB(I)%DAT(J)=DBLE(R)
          END DO
          !
          IF(LSTCHK(3))WRITE(IOUT,'(5A)')'CONTENTS OF TABFILE "',
     +     TRIM(FNAME),'" HAVE BEEN LOADED TO TABNAM "',TRIM(TABNAM),'"'
          !
          IF(LVAL) CLOSE(FN)
          !
        ELSE
          ALLOCATE(TABFILE%TAB(I)%TIM(2))
          ALLOCATE(TABFILE%TAB(I)%DAT(2))
          !
          TABFILE%TAB(I)%FILEIO=FN
          TABFILE%TAB(I)%POS=1                                          !INITIAL POSITION IN TABFILE TO IMPROVE SPEED ON TIME SEARCH
          !
          READ(FN,'(A)') LINE
          LLOC=1
          CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,N,T,IOUT,IN)
          CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,N,R,IOUT,IN)
          TABFILE%TAB(I)%TIM(1)=DBLE(T)
          TABFILE%TAB(I)%TIM(2)=1D99                                    !REQUIRES INITIAL VALUE THAT IS NEVER TRUE
          TABFILE%TAB(I)%DAT(1)=DBLE(R)
          REWIND(FN)
          !
          IF(LSTCHK(3))WRITE(IOUT,'(6A)')'CONTENTS OF TABFILE "',
     +    TRIM(FNAME),'" WILL BE READ DURING SIMULATION TO SAVE MEMORY',
     +    'FOR TABNAM "',TRIM(TABNAM),'"'
        END IF
        READ(IN,'(A)') LINE
      END DO
      IF(LSTCHK(3).AND.TABFILE%NTAB>0) WRITE(IOUT,*)                    !BLANK SPACE AFTER WRITING OUT TABFILE INFO
      !
      END SUBROUTINE
      !
      SUBROUTINE TABFILELINKS(IN,IOUT,LINE,TABFILE)
C     ******************************************************************
C     GENERIC TABFILE INDEX BUILDER DEVELOPED BY SCOTT E. BOYCE 
C     THIS FEATURE USES SELECT TYPE TO DISTINGUISH BETWEEN DIFFERNET PACKAGES
C     IT WILL READ IN THE FEATURE THAT A TABFILE IS LINKED TO AND THE TABNAM
C     WITH THIS INFORMATION A SET OF INDEXES ARE MADE
C     
C     VARIABLE LIST:
C     IN      : INPUT FILE THAT THE TABINDEX IS READ FROM
C     IOUT    : OUTPUT FILE TO WRITE ERROR (i.e. THE LST FILE)
C     LINE    : STRING THAT CONTAINS A LINE OF OF THE INPUT FILE TO BE 
C               ANALYZED AND THEN USED TO READ IN SUBSEQUENT LINES
C     TABFILE : DATATYPE THAT WILL BE ALLOCATED AND POPULATED WITH TAB DATA
C     ******************************************************************
      USE GLOBAL,            ONLY:NROW,NCOL
      IMPLICIT NONE
      CLASS(TABFILETYPELINKS),                   INTENT(INOUT)::TABFILE
      INTEGER,                                   INTENT(IN)   :: IN,IOUT
      CHARACTER(*),                              INTENT(INOUT):: LINE
C     LOCAL VARIABLES
      CHARACTER(20),DIMENSION(:),ALLOCATABLE::TABNAM
      CHARACTER(20)::TEXTID
      INTEGER::LLOC,ISTART,ISTOP
      INTEGER::I,K,N,NTAB,NLNK,LAY,ROW,COL
      REAL::R
C     ------------------------------------------------------------------
C
      TABFILE%TABPRINT=.FALSE.                                          !INITIALIZE TABPRINTING TO FALSE
C     CHECK IF TABFILES ARE SPECIFIED, IF NOT USED THEN RETURN
      IF ( TABFILE%NTAB.EQ.0) RETURN
      !
C     THERE ARE TABFILES SO READ IN THE FEATURES TO LINK TOO
      LLOC=1
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,I,R,IOUT,IN)                 !READ IN KEYWORD TABNOPRIRNT OR TABPRINT
      IF(LINE(ISTART:ISTOP).EQ.'TABPRINT') TABFILE%TABPRINT=.TRUE.
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NLNK,R,IOUT,IN)              !NUMBER OF SEGEMENTS (NLNK) ASSOCIATED WITH A TABFILE
      ALLOCATE( TABNAM(NLNK) )                                          !TEMPORARY VARIABLE TO HOLD TABNAMES
      ALLOCATE( TABFILE%TSFAC(NLNK)  )
      ALLOCATE( TABFILE%TABIDX(NLNK) )
      ALLOCATE( TABFILE%PACIDX(NLNK) )
      TABFILE%TABIDX=0                                                  !INITIALIZE INDEX TO ZERO
      TABFILE%PACIDX=0
      READ(IN,'(A)') LINE                                               !READ IN NEXT LINE
      !
      SELECT TYPE (TABFILE)
        CLASS IS (TABFILETYPE1IDX)                                      !READ IN SFR SPECIFIC PORTIONS
          ALLOCATE(TABFILE%ONEIDX(NLNK))
          DO I=1,NLNK
             LLOC=1
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,K,R,IOUT,IN)          !READ SEGMENT THAT IS LINKED TO TABNAM
             TABFILE%ONEIDX(I)=K                                        !UNIQUE NUMBER AS IDENTIFIER (SFR WOULD BE ISEG)
             !
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,K,R,IOUT,IN)          !READ TABNAM THAT SEGMENT IS LINKED THIS WILL MATCH TO A TABFILE 
             TEXTID=LINE(ISTART:ISTOP);   TEXTID=ADJUSTL(TEXTID)
             TABNAM(I)=TEXTID
             !
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,K,R,IOUT,IN)
             TABFILE%TSFAC(I) =R
             READ(IN,'(A)') LINE
          END DO
          !
        CLASS IS (TABFILETYPECHARIDX)                                   !READ IN MNW2SPECIFIC PORTIONS
          ALLOCATE( TABFILE%CHARID(NLNK) )
          TABFILE%CHARID=''
          DO I=1,NLNK
             LLOC=1
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,K,R,IOUT,IN)          !READ MWN2 WELL NAME
             TEXTID=LINE(ISTART:ISTOP);    TEXTID=ADJUSTL(TEXTID)       !MNW2 WEL NAME
             TABFILE%CHARID(I)=TEXTID
             !
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,K,R,IOUT,IN)          !READ TABNAM THAT SEGMENT IS LINKED THIS WILL MATCH TO A TABFILE 
             TEXTID=LINE(ISTART:ISTOP);    TEXTID=ADJUSTL(TEXTID)
             TABNAM(I)=TEXTID
             !
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,K,R,IOUT,IN)
             TABFILE%TSFAC(I) =R
             READ(IN,'(A)') LINE
          END DO
        CLASS IS (TABFILETYPE3IDX)
          ALLOCATE( TABFILE%LRCIDX(NLNK) )
          DO I=1,NLNK
             LLOC=1
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,LAY,R,IOUT,IN)
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,ROW,R,IOUT,IN)
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,COL,R,IOUT,IN)
             TABFILE%LRCIDX(I) = LRC2ID(LAY,ROW,COL)                    !=COL + NCOL*(ROW-1) + NCOL*NROW*(LAY-1)
             !
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,K,R,IOUT,IN)          !READ TABNAM THAT SEGMENT IS LINKED THIS WILL MATCH TO A TABFILE 
             TEXTID=LINE(ISTART:ISTOP);   TEXTID=ADJUSTL(TEXTID)
             TABNAM(I)=TEXTID
             !
             CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,K,R,IOUT,IN)
             TABFILE%TSFAC(I) =R
             READ(IN,'(A)') LINE
          END DO
        !
      END SELECT
      !
      NTAB=TABFILE%NTAB  
      DO I=1,NLNK                                                       !BUILD INDEX OF TABFILE LOCATIONS
          DO K=1, NTAB                                                  !SEARCH FOR LOCATION OF TABFILE
            IF(TABNAM(I).EQ.TABFILE%TABNAM(K)) THEN
               TABFILE%TABIDX(I)=K
               EXIT
            END IF
          END DO
          IF(TABFILE%TABIDX(I).EQ.0) THEN
          IF(LSTCHK(1))WRITE(IOUT,'(3A)')
     +         'ERROR FINDING TABFILE WITH TABNAM "',TRIM(TABNAM(I)),'"'
          CALL USTOP('ERROR FINDING TABFILE WITH TABNAM "'//
     +                TRIM(TABNAM(I))//'"')
          END IF
      END DO
      DEALLOCATE(TABNAM)
      !
      !READ(IN,'(A)') LINE                                               !READ IN NEXT LINE ALREADY DONE IN SELECT TYPE
      END SUBROUTINE
      !
      SUBROUTINE TABFILEPACKINDEX(TABFILE,NAMELST,INDEXLST,
     +                            INDEX3LST)
C     ******************************************************************
C     GENERIC TABFILE INDEX BUILDER DEVELOPED BY SCOTT E. BOYCE 
C     THIS FEATURE USES SELECT TYPE TO DISTINGUISH BETWEEN DIFFERNET PACKAGES
C     ITS PURPOSE IS TO BUILD THE LINKE TO THE PACKAGE INDEX THAT EACH TABFILE/TABNAM REFERS
C     SOME PACKAGES (e.g. SFR) DO NOT NEED THIS BECAUSE THEY HAVE A ONE TO ONE RELATIONSHIP 
C     WITH THE INDEX ID AND THE ACTUAL INDEX IN THE STORAGE ARRAY
C     
C     VARIABLE LIST:
C     IOUT    :  OUTPUT FILE TO WRITE ERROR (i.e. THE LST FILE)
C     TABFILE :  DATATYPE THAT WILL BE ALLOCATED AND POPULATED WITH TAB DATA
C     NAMELST :  OPTIONAL VARIABLE THAT CONTAINS A 1D ARRAY OF CHARACTER 
C                NAMES THAT REPRESENT THE ID USED BY PACKAGE (e.g MNW2 WELLID)
C                THIS VARIABLE IS REQUIRED WHEN THERE IS A NAME ID BEING 
C                MATCHED FOR A TABFILE
C     INDEXLST:  OPTIONAL VARIABLE THAT CONTAINS A 1D ARRAY OF INTEGER 
C                VALUES THAT REPRESENT THE ID USED BY PACKAGE 
C                (e.g SFR WHEN SEG ARE NOT IN NUMERICAL ORDER WELLID)
C                THIS VARIABLE IS REQUIRED IF YOU WANT TO SEARCH FOR LOCATION OF INTEGER ID
C                OTHERWISE IT IS ASSUMED THAT THE INTEGER READ IS ALSO THE INDEX 
C     INDEX3LST: OPTIONAL VARIABLE THAT CONTAINS A 2D ARRAY OF INTEGER 
C                VALUES THAT REPRESENT THE LAY, ROW, AND COL USED BY PACKAGE 
C                THE SHAPE OF THE ARRAY MUST BE (3,:) WHERE THE FIRST DIMENSION IS 
C                DEFINED AS ([LAY,ROW,COL],:)
C     ******************************************************************
      USE GLOBAL,            ONLY:IOUT,NROW,NCOL
      IMPLICIT NONE
      CLASS(TABFILETYPELINKS),                   INTENT(INOUT)::TABFILE
      CHARACTER(*),DIMENSION(:),OPTIONAL,        INTENT(IN)   :: NAMELST
      INTEGER,     DIMENSION(:),OPTIONAL,        INTENT(IN) :: INDEXLST
      INTEGER,     DIMENSION(:,:),OPTIONAL,      INTENT(IN) :: INDEX3LST
C     LOCAL VARIABLES
      CHARACTER(20)::TEXTID
      INTEGER::LAY,ROW,COL
      INTEGER::I,K,N,NTAB,NLST,NLNK,ID
C     ------------------------------------------------------------------
C
C     CHECK IF TABFILES ARE SPECIFIED, IF NOT USED THEN RETURN
      IF ( TABFILE%NTAB.EQ.0) RETURN
      !
      NLST=0
      IF(PRESENT(NAMELST ))  NLST=UBOUND(NAMELST, 1)                    !GET SIZE OF PACKAGE ARRAY OF INDICIES
      IF(PRESENT(INDEXLST))  NLST=UBOUND(INDEXLST,1)
      IF(PRESENT(INDEX3LST)) NLST=UBOUND(INDEX3LST,2)
      NLNK=UBOUND(TABFILE%PACIDX,1)
      !
C     THERE ARE TABFILES SO PROCESS THE FEATURES TO LINK TOO
      !
      TABFILE%PACIDX=0                                                  !INTIALIZE THE PACKAGE LOACTION, IF LEFT 0 THEN TABFILE FOR THAT ROW IS IGNORED
      !
      SELECT TYPE (TABFILE)
        CLASS IS (TABFILETYPE1IDX)                                      
          IF(PRESENT(INDEXLST))THEN                                     !IF INDEXLST IS PASSED THEN SEARCH FOR THE ROW THAT CONTAINS THE ID (K IS ID NOT INDEX LOCATION) [IN SFR THE ID, ISEG, IS ALSO THE INDEX LOCATION]
            DO I=1,NLNK
             DO K=1, NLST
               IF(TABFILE%ONEIDX(I).EQ.INDEXLST(K))THEN                 !ON ENTRANCE TABFILE%PACIDX(I) HOLDS THE UNIQUE ID FOR THAT TABFILE. IT IS OVERWRITTEN WITH THE ROW LOCATION IN INDEXLST OF THAT UNIQUE ID
                   TABFILE%PACIDX(I)=K
                   EXIT
               END IF
               IF(K.EQ.NLST) THEN
                   WRITE(TEXTID,'(I20)')TABFILE%ONEIDX(I)
                   CALL USTOP('ERROR IN TABFILEINDEX. UNABABLE TO '//
     +           'FIND INDEX MATCH IN TABFILE TO PACKAGE FOR INDEX '//
     +           TRIM(TEXTID))
               END IF
             END DO
            END DO
          ELSE
            CALL USTOP('ERROR IN CODE. SUBROUTINE TABFILEPACKINDEX '//
     +            'MUST PASS IN VARIABLE "INDEXLST" TO FORM LINKS')
          END IF
          !
        CLASS IS (TABFILETYPECHARIDX)
          IF(PRESENT(NAMELST))THEN
            DO I=1,NLNK
             TEXTID=TABFILE%CHARID(I)
             DO K=1, NLST
               IF(TEXTID.EQ.NAMELST(K))THEN
                   TABFILE%PACIDX(I)=K
                   EXIT
               END IF
               IF(K.EQ.NLST) THEN
                   CALL USTOP('ERROR IN TABFILEINDEX. UNABABLE TO '//
     +             'FIND NAME MATCH IN TABFILE TO PACKAGE FOR NAME '//
     +             TRIM(TEXTID))
               END IF
             END DO
            END DO
          ELSE
             CALL USTOP('ERROR IN CODE. SUBROUTINE TABFILEPACKINDEX '//
     +             'MUST PASS IN VARIABLE "NAMELST"')
          END IF
          !
        CLASS IS (TABFILETYPE3IDX)      
          IF(PRESENT(INDEX3LST))THEN
            DO K=1, NLST
             LAY=INDEX3LST(1,K)
             ROW=INDEX3LST(2,K)
             COL=INDEX3LST(3,K)
             ID = LRC2ID(LAY,ROW,COL)                                   !=COL + NCOL*(ROW-1) + NCOL*NROW*(LAY-1)
             DO I=1,NLNK                                                !CAN NOT HANDEL MORE THAN 1 DATA POINT FOR 1 ROW,COL,LAY
               IF(TABFILE%PACIDX(I).NE.0) CYCLE                         !LINK PREVIOUSLY DEFINED, SO THERE MUST BE MULTIPLE REFERENCES TO THE SAME CELL, SKIP AND FIND NEW LOCATION
               IF(TABFILE%LRCIDX(I).EQ.ID)THEN
                   TABFILE%PACIDX(I)=K
                   EXIT
               END IF
             END DO
            END DO
          ELSE
            CALL USTOP('ERROR IN CODE. SUBROUTINE TABFILEPACKINDEX '//
     +            'MUST PASS IN VARIABLE "INDEX3LST" TO FORM LINKS')
          END IF
          !
        CLASS DEFAULT
            WRITE(*,'(2A)')'TABFILEPACKINDEX CODE ERROR: UNIDEFIED ',
     +     'CLASS SENT INTO SUBROUTINE, RETURNED WITH NOTHING PROCESSED'
            RETURN
        !
      END SELECT
      !
      END SUBROUTINE
      !
      SUBROUTINE TABFILEUPDATE_S( TABFILE,PACK,SRESULT )
        CLASS(TABFILETYPELINKS),INTENT(INOUT):: TABFILE
        CHARACTER(*)           ,INTENT(IN   ):: PACK
        REAL,      DIMENSION(:),INTENT(INOUT):: SRESULT
        !
        CALL TABFILEUPDATER( TABFILE,PACK,SRESULT=SRESULT )
        !
      END SUBROUTINE
      !
      SUBROUTINE TABFILEUPDATE_D( TABFILE,PACK,DRESULT )
        CLASS(TABFILETYPELINKS)      ,INTENT(INOUT):: TABFILE
        CHARACTER(*)                 ,INTENT(IN   ):: PACK
        DOUBLE PRECISION,DIMENSION(:),INTENT(INOUT):: DRESULT
        !
        CALL TABFILEUPDATER( TABFILE,PACK,DRESULT=DRESULT )
        !
      END SUBROUTINE 
      !
      SUBROUTINE TABFILEUPDATER( TABFILE,PACK,SRESULT,DRESULT )
C SUBROUTINE ASSUMES THAT PACIDX HAS BEEN CONTRUCTED. 
C LOOK THROUGH ALL LINKS AND INTERPOLATE THEIR APPROPIATE TABFILES
C IF TABFILE PRINTING IS REQUESTED THEN PRINTS TABFILE RESULTS
C VARIABLE LIST:
C TABFILE: TABFILE THAT WILL BE UPDATED FOR TIMESTEP
C PACK   : STRING THAT IS PASSED IN THAT IDENTIFIES THE CALLING PACKAGE. FOR EXAMPE PACK='WEL' OR 'SFR'
C SRESULT: IS A SINGLE PRECISION ARRAY THAT IF PRESENT WILL HAVE THE TABFILE VALUE AND SCALE FACTORE APPLIED TO ITS PACKIDX LOCATION
C DRESULT: IS A DOUBLE PRECISION ARRAY THAT IF PRESENT WILL HAVE THE TABFILE VALUE AND SCALE FACTORE APPLIED TO ITS PACKIDX LOCATION 
      USE GLOBAL,       ONLY:IOUT
      USE GWFBASMODULE, ONLY:TOTIM,REALTIM
      IMPLICIT NONE
      CLASS(TABFILETYPELINKS),INTENT(INOUT)::TABFILE
      CHARACTER(*)           ,INTENT(IN):: PACK
      REAL,               OPTIONAL,DIMENSION(:),INTENT(INOUT)::SRESULT
      DOUBLE PRECISION,   OPTIONAL,DIMENSION(:),INTENT(INOUT)::DRESULT
C LOCAL
      DOUBLE PRECISION::VAL,TSFAC
      INTEGER::I,NLNK,PACIDX,TABIDX
      INTEGER::ID,LAY,ROW,COL
      CHARACTER(20)::CHARID
      !
C     CHECK IF TABFILES ARE SPECIFIED, IF NOT USED THEN RETURN
      IF ( TABFILE%NTAB.EQ.0) RETURN
      !      
      TABFILE%TAB%USEVAL=.FALSE.                                        !TELL TABFILEINTERP TO SEARCH FOR NEW TIME AND THEN START REUSING VALUES
      NLNK=UBOUND(TABFILE%PACIDX,1)
      DO I=1,NLNK                                                       !LOOP THROUGH TABFILES AND UPDATE THEIR VALUES TO CURRENT TIME
        PACIDX=TABFILE%PACIDX(I)
        IF(PACIDX.EQ.0) CYCLE
        !
        TABIDX=TABFILE%TABIDX(I)
        !
        CALL TABFILEINTERP( TABFILE%TAB(TABIDX),TABFILE%SIMTIME )       !CALCULATE CURRENT TABFILE VALUE AND STORE IT IN GHBTABFILE%TAB(TABIDX)%VAL
        !
      END DO
      !
      IF(TABFILE%TABPRINT)THEN                                          !IF TABPRINT IS REQUEST WRITE TO LIST FILE TABTABLE
        WRITE(CHARID,'(1PG20.9)') TOTIM;    CHARID=ADJUSTL(CHARID)
        IF(TABFILE%SIMTIME)THEN
          WRITE(IOUT,'(/ 2A)') PACK//
     +      ' PACKAGE TABFILE PRINT OUT AT SIMULTED TIME ',TRIM(CHARID)
        ELSE
          WRITE(IOUT,'(/ 3A,F11.5)') PACK//
     +      ' PACKAGE TABFILE PRINT OUT AT SIMULTED TIME ',TRIM(CHARID),
     +      ' AND DECIMAL YEAR (REALTIME) ',REALTIM
        END IF
        !
        SELECT TYPE (TABFILE)
          CLASS IS (TABFILETYPE1IDX)
          !
          WRITE(IOUT,'(2A)')'      ID          RESULT',
     +         '          TSFAC          TABVAL     TABNAM'
          DO I=1,NLNK
            PACIDX=TABFILE%PACIDX(I)
            IF(PACIDX.EQ.0) CYCLE
            !
            TSFAC =TABFILE%TSFAC(I)
            TABIDX=TABFILE%TABIDX(I)
            ID    =TABFILE%ONEIDX(I)
            !
            VAL=TABFILE%TAB(TABIDX)%VAL
            !
            WRITE(IOUT,'(I8,2x,1PG16.9,ES15.8,2x,1PG16.9,2x,A)') 
     +           ID,TSFAC*VAL,TSFAC,VAL,TABFILE%TABNAM(TABIDX)
            !
          END DO
          !
          CLASS IS (TABFILETYPECHARIDX)
          !
          WRITE(IOUT,'(2A)')'  ID                          RESULT',
     +         '          TSFAC            TABVAL     TABNAM'
          DO I=1,NLNK
            PACIDX=TABFILE%PACIDX(I)
            IF(PACIDX.EQ.0) CYCLE
            !
            TSFAC =TABFILE%TSFAC(I)
            TABIDX=TABFILE%TABIDX(I)
            CHARID=TABFILE%CHARID(I)
            !
            VAL=TABFILE%TAB(TABIDX)%VAL
            !
            WRITE(IOUT,'(A,2x,1PG16.9,ES15.8,2x,1PG16.9,2x,A)') 
     +         ID,TSFAC*VAL,TSFAC,VAL,TABFILE%TABNAM(TABIDX)
            !
          END DO
          !
        CLASS IS (TABFILETYPE3IDX) 
          !
          WRITE(IOUT,'(2A)')'   ID      LAY   ROW   COL        RESULT',
     +         '          TSFAC          TABVAL     TABNAM'
          DO I=1,NLNK
            PACIDX=TABFILE%PACIDX(I)
            IF(PACIDX.EQ.0) CYCLE
            !
            TSFAC =TABFILE%TSFAC(I)
            TABIDX=TABFILE%TABIDX(I)
            ID    =TABFILE%LRCIDX(I)
            CALL ID2LRC(ID,LAY,ROW,COL)
            !
            VAL=TABFILE%TAB(TABIDX)%VAL
            !
            WRITE(IOUT,'(I8,3I6,2x,1PG16.9,ES15.8,1PG16.9,2x,A)') 
     +         ID,LAY,ROW,COL,TSFAC*VAL,TSFAC,VAL,TABFILE%TABNAM(TABIDX)
            !
          END DO
          !
        END SELECT
      END IF
      !
      IF(PRESENT(SRESULT)) THEN
        DO I=1,NLNK
          PACIDX=TABFILE%PACIDX(I)
          IF(PACIDX.EQ.0) CYCLE
          !
          TABIDX=TABFILE%TABIDX(I)
          TSFAC =TABFILE%TSFAC(I)
          !
          SRESULT(PACIDX) = REAL(TSFAC * TABFILE%TAB(TABIDX)%VAL)
        END DO
      END IF
      IF(PRESENT(DRESULT)) THEN
        DO I=1,NLNK
          PACIDX=TABFILE%PACIDX(I)
          IF(PACIDX.EQ.0) CYCLE
          !
          TABIDX=TABFILE%TABIDX(I)
          TSFAC =TABFILE%TSFAC(I)
          !
          DRESULT(PACIDX) = TSFAC * TABFILE%TAB(TABIDX)%VAL
        END DO
      END IF
      !
      END SUBROUTINE
      !
      SUBROUTINE TABFILEINTERP( TABFILE, SIMTIME )
C FUNCTION SOLVES FOR TABFILE VALUE FOR CURRENT TIMESTEP
C NOTE THAT FUNCTION EXPECTS TO RECIEVE A SINGLE TABFILE, NOT A VECTOR CONTAINING MULTIPLE TAB FILES
C IT IS ASSUMED THAT THE CORRECT TABFILE IS BEING REQUESTED.
C      
C FUNCTION EITHER PASSES TO PURE SUBROUTINE OF FILEIO SUBROUTIEOND TIME STEP
      IMPLICIT NONE
      TYPE(TABARRAY),  INTENT(INOUT)::TABFILE
      LOGICAL,OPTIONAL,INTENT(IN   )::SIMTIME
      LOGICAL::SIMTIM
      !
      SIMTIM=.TRUE.
      IF(PRESENT(SIMTIME)) SIMTIM=SIMTIME      
      !
      IF(TABFILE%FILEIO.EQ.0)THEN
          CALL TABFILEINTERPFAST( TABFILE, SIMTIM )
      ELSE
          CALL TABFILEINTERPFILE( TABFILE, SIMTIM )
      END IF
      !
      END SUBROUTINE
      !
      PURE SUBROUTINE TABFILEINTERPFAST( TABFILE, SIMTIME )
C FUNCTION SOLVES FOR TABFILE VALUE FOR CURRENT TIMESTEP
C NOTE THAT FUNCTION EXPECTS TO RECIEVE A SINGLE TABFILE, NOT A VECTOR CONTAINING MULTIPLE TAB FILES
C THIS FUNCTION ALSO PROCESSES TABFILES THAT HAVE BEEN READ IN ENTIRELY INTO THE MODULE
C IT IS ASSUMED THAT THE CORRECT TABFILE IS BEING REQUESTED.
C      
C FUNCTION SEARCHES THROUGH A TABFILE DATA TYPE FOR A MATCHING TABNAM IF TABIDX<=0
C IF TABIDX>0 THEN THE INDEX IS ASSUMED TO BE THE LOCATION OF THE MATCHING TABFILE
C 3 CASES
C SINGLE VALUE IN TIME STEP, USE ONLY 1 VALUE
C MULTIPLE VALUES IN TIME STEP, TIME WEIGHTED AVERAGE
C NO VALUES IN TIME STEP, LINEAR INTERPOLATE CLOSEST VALUES BEYOND TIME STEP
      USE GLOBAL,       ONLY: ITMUNI
      USE GWFBASMODULE, ONLY: DELT,TOTIM,REALTIM
      IMPLICIT NONE
      TYPE(TABARRAY),  INTENT(INOUT)::TABFILE
      LOGICAL,OPTIONAL,INTENT(IN   )::SIMTIME
C LOCAL
      REAL::RES                                                         !TEMP VARIABLE TO HOLD RESULT
      DOUBLE PRECISION::B,ErrFrac                                       !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR
      DOUBLE PRECISION::TIMOLD,TIMNEW,SUMTAB,SUMTIM,TW
      INTEGER::I,J,IDX,NTIM,ISTR,ISTP,IPOS
      LOGICAL:: SIMTIM
      !
      IF(TABFILE%USEVAL) RETURN                                         !FLAG THAT INDICATES THAT THE TABFILE HAS ALREADY BEEN INTERPOLATED TO CURRENT TIME
      !
      SIMTIM=.TRUE.
      IF(PRESENT(SIMTIME)) SIMTIM=SIMTIME          
      !
      RES=-9.9E30 !SET TO EXTREME VALUE IN CASE OF ERROR
      IPOS=TABFILE%POS
      ISTR=0
      ISTP=0
      !
      NTIM=UBOUND(TABFILE%TIM,1)
      !
      ErrFrac=0.000001D0
      B=ErrFrac*DBLE(DELT)                                              !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR IN COMPARING TIMES
      IF(SIMTIM)THEN
        TIMOLD=DBLE(TOTIM-DELT)
        TIMNEW=DBLE(TOTIM)
      ELSE
         IF(ITMUNI.EQ.0 .OR. ITMUNI.EQ.4) THEN                          !DAYS
             TIMOLD=REALTIM - DBLE(DELT) * 0.00273791D0
             B = ErrFrac    * DBLE(DELT) * 0.00273791D0                 !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR IN COMPARING TIMES
         ELSE IF(ITMUNI.EQ.1) THEN                                      !SECONDS
             TIMOLD=REALTIM - DBLE(DELT) * 3.16888D-8
             B = ErrFrac    * DBLE(DELT) * 3.16888D-8                   !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR IN COMPARING TIMES
         ELSE IF(ITMUNI.EQ.2) THEN                                      !MINUTES
             TIMOLD=REALTIM - DBLE(DELT) * 1.90133D-6
             B = ErrFrac    * DBLE(DELT) * 1.90133D-6                   !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR IN COMPARING TIMES
         ELSE IF(ITMUNI.EQ.3) THEN                                      !HOURS
             TIMOLD=REALTIM - DBLE(DELT) * 0.00011408D0
             B = ErrFrac    * DBLE(DELT) * 0.00011408D0                 !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR IN COMPARING TIMES
         ELSE                                                           !YEARS
             TIMOLD=REALTIM - DBLE(DELT)
         END IF
         TIMNEW=REALTIM
      END IF
      !
      IF    ( REAL(TIMNEW) < REAL(TABFILE%TIM(1)   ) ) THEN             !FIRST TABFILE TIME IS GREATER THEN CURRENT TOTAL TIME, SO THERE IS NO POSSIBLILITY OF FINDING A TIME
                                               RES=TABFILE%DAT(1)
      ELSEIF( REAL(TIMOLD) >  REAL(TABFILE%TIM(NTIM)) ) THEN
                                               RES=TABFILE%DAT(NTIM)    !LAST TABFILE TIME IS LESS THAN PREVIOUS TIMESTEP TIME, SO THERE IS NO POSSIBLILITY OF FINDING A TIME
      ELSE
         ISTR=NTIM
         DO I=IPOS,NTIM                                                 !SEARCH FOR LOCATION AT BEGINING OF TIMESTEP
           IF( TIMOLD - TABFILE%TIM(I)  <  -B ) THEN
              ISTR=I
              EXIT
           END IF
         END DO
         DO I=ISTR,NTIM                                                 !SEARCH FOR LOCATION AT END OF TIMESTEP
           IF( TIMNEW - TABFILE%TIM(I)  <   -B ) THEN
              ISTP=I
              EXIT
           END IF
         END DO
         !
         IF (ISTP.EQ.0.AND.ISTR.GT.0) ISTP=ISTR
         IF (ISTP > ISTR) ISTP=ISTP-1                                   !ONLY WANT TABFILE TIMES WITHIN CURRENT TIMESTEP
         !
         IF     (REAL(TABFILE%TIM(ISTR)) > REAL(TIMNEW) ) THEN          !NO VALUE WITHIN TIME STEP, INTERPOATE TO TIME STEP BETWEEN ISTR-1 AND ISTR
             RES= REAL(
     +                 TABFILE%DAT(ISTR-1) + 
     +                 (TABFILE%DAT(ISTR)-TABFILE%DAT(ISTR-1)) *
     +                     ( 
     +                      (TIMNEW            - TABFILE%TIM(ISTR-1)) /
     +                      (TABFILE%TIM(ISTR) - TABFILE%TIM(ISTR-1)) 
     +                     )
     +                )        
         ELSEIF (ISTR == ISTP) THEN                                     !ONLY 1 VALUE WITHIN TIME STEP SO USE THAT
           RES=TABFILE%DAT(ISTR)
         ELSE                                                           !MULTIPLE VALUES WITHIN TIME STEP, TIME AVERAGE VALUES
           SUMTAB=0D0
           SUMTIM=0D0
           DO I=ISTR,ISTP
             IF    (I.EQ.ISTR) THEN
                TW=(TABFILE%TIM(I)-TIMOLD) + 
     +                             (TABFILE%TIM(I+1)-TABFILE%TIM(I))/2D0
                SUMTAB=SUMTAB + TW*TABFILE%DAT(I)
                SUMTIM=SUMTIM + TW
             ELSEIF(I.EQ.ISTP) THEN
                TW=(TIMNEW-TABFILE%TIM(I)) + 
     +                             (TABFILE%TIM(I)-TABFILE%TIM(I-1))/2D0
                SUMTAB=SUMTAB + TW*TABFILE%DAT(I)
                SUMTIM=SUMTIM + TW
             ELSE
                TW=(TABFILE%TIM(I+1)-TABFILE%TIM(I))/2D0 + 
     +                             (TABFILE%TIM(I)-TABFILE%TIM(I-1))/2D0
                SUMTAB=SUMTAB + TW*TABFILE%DAT(I)
                SUMTIM=SUMTIM + TW
             END IF
           END DO
           RES=REAL(SUMTAB/SUMTIM)
         END IF
      END IF
      !
      IF(ISTR>1) TABFILE%POS=ISTR-1                                     !RECORD CURRENT POSITION IN TABFILE TO IMPROVE SEARCH SPEED
      !
      TABFILE%USEVAL=.TRUE.                                             !TABFILE VALUE HAS BEEN RECORDED 
      TABFILE%VAL=RES
      !
      END SUBROUTINE
      !
      SUBROUTINE TABFILEINTERPFILE( TABFILE, SIMTIME )
C FUNCTION SOLVES FOR TABFILE VALUE FOR CURRENT TIMESTEP
C NOTE THAT FUNCTION EXPECTS TO RECIEVE A SINGLE TABFILE, NOT A VECTOR CONTAINING MULTIPLE TAB FILES
C ALSO TABFILE IS NOT ENTIRELY READ IN AND INSTEAD ONLY THE PORTION OF THE FILE WITHIN THE TIME STEP 
C   IS READ IN VIA A LINKED-LIST
C IT IS ASSUMED THAT THE CORRECT TABFILE IS BEING REQUESTED.
C      
C FUNCTION SEARCHES THROUGH A TABFILE DATA TYPE FOR A MATCHING TABNAM IF TABIDX<=0
C IF TABIDX>0 THEN THE INDEX IS ASSUMED TO BE THE LOCATION OF THE MATCHING TABFILE
C 3 CASES
C SINGLE VALUE IN TIME STEP, USE ONLY 1 VALUE
C MULTIPLE VALUES IN TIME STEP, TIME WEIGHTED AVERAGE
C NO VALUES IN TIME STEP, LINEAR INTERPOLATE CLOSEST VALUES BEYOND TIME STEP
C
C NEW DEFINITION OF TABFILE%DAT and TABFILE%TIM      
C TABFILE%TIM(1) and TABFILE%DAT(1) HOLD LAST VALUE FROM PREVIOUS TIMESTEP
C TABFILE%TIM(2) and TABFILE%DAT(2) HOLD FIRST VALUE THAT IS JUST BEYOND THE TIMESTEP
      USE GLOBAL,       ONLY: ITMUNI,IOUT
      USE GWFBASMODULE, ONLY: DELT,TOTIM,REALTIM
      IMPLICIT NONE
      TYPE(TABARRAY),  INTENT(INOUT)::TABFILE
      LOGICAL,OPTIONAL,INTENT(IN   )::SIMTIME
C LOCAL
      REAL::RES       
      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE::TIM                    !TEMP VARIABLE TO HOLD TIM RESULT
      DOUBLE PRECISION::B,ErrFrac                                       !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR
      DOUBLE PRECISION::TIMOLD,TIMNEW,SUMTAB,SUMTIM,TW
      INTEGER::I,J,ISTR,ISTP,FILEIO,ERR
      LOGICAL:: SIMTIM,FAILED
      INTEGER::LLOC,ISTART,ISTOP,N,NLST
      REAL:: T,R,TOLD
      CHARACTER(200)::LINE
      TYPE LINKEDLIST
        DOUBLE PRECISION:: T,R
        TYPE (LINKEDLIST),POINTER:: NXT=>NULL()
      END TYPE
      TYPE (LINKEDLIST),POINTER:: DATASTR=>NULL() 
      TYPE (LINKEDLIST),POINTER:: DATAPNT=>NULL() 
      !
      IF(TABFILE%USEVAL) RETURN                                         !FLAG THAT INDICATES THAT THE TABFILE HAS ALREADY BEEN INTERPOLATED TO CURRENT TIME
      !
      IF(TABFILE%TIM(2)<0D0) THEN                                       !END OF TABFILE AND IT HAS NOW BEEN CLOSED
        TABFILE%USEVAL=.TRUE.
        TABFILE%VAL=TABFILE%DAT(2) 
        RETURN
      END IF
      !
      SIMTIM=.TRUE.
      IF(PRESENT(SIMTIME)) SIMTIM=SIMTIME          
      !
      RES=-9.9E30 !SET TO EXTREME VALUE IN CASE OF ERROR
      FILEIO=TABFILE%FILEIO
      ISTP=0
      NLST=0
      !
      ErrFrac=0.000001D0
      B=ErrFrac*DBLE(DELT)                                              !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR IN COMPARING TIMES
      IF(SIMTIM)THEN
        TIMOLD=DBLE(TOTIM-DELT)
        TIMNEW=DBLE(TOTIM)
      ELSE
         IF(ITMUNI.EQ.0 .OR. ITMUNI.EQ.4) THEN                          !DAYS
             TIMOLD=REALTIM - DBLE(DELT) * 0.00273791D0
             B = ErrFrac    * DBLE(DELT) * 0.00273791D0                 !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR IN COMPARING TIMES
         ELSE IF(ITMUNI.EQ.1) THEN                                      !SECONDS
             TIMOLD=REALTIM - DBLE(DELT) * 3.16888D-8
             B = ErrFrac    * DBLE(DELT) * 3.16888D-8                   !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR IN COMPARING TIMES
         ELSE IF(ITMUNI.EQ.2) THEN                                      !MINUTES
             TIMOLD=REALTIM - DBLE(DELT) * 1.90133D-6
             B = ErrFrac    * DBLE(DELT) * 1.90133D-6                   !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR IN COMPARING TIMES
         ELSE IF(ITMUNI.EQ.3) THEN                                      !HOURS
             TIMOLD=REALTIM - DBLE(DELT) * 0.00011408D0
             B = ErrFrac    * DBLE(DELT) * 0.00011408D0                 !BUFFER SPACE TO ALLOW FOR NUMERICAL ERROR IN COMPARING TIMES
         ELSE                                                           !YEARS
             TIMOLD=REALTIM - DBLE(DELT)
         END IF
         TIMNEW=REALTIM
      END IF
      !
      IF    ( TIMNEW < TABFILE%TIM(1) ) THEN                            !FIRST TABFILE TIME IS GREATER THEN CURRENT TOTAL TIME, SO THERE IS NO POSSIBLILITY OF FINDING A TIME
                                               RES=TABFILE%DAT(1)
      ELSEIF( TIMOLD > TABFILE%TIM(2) ) THEN
                                               RES=TABFILE%DAT(2)       !LAST TABFILE TIME IS LESS THAN PREVIOUS TIMESTEP TIME, SO THERE IS NO POSSIBLILITY OF FINDING A TIME
      ELSE
       ALLOCATE(DATASTR)
       DATAPNT=>DATASTR
       NLST=0
       DO                                                               !INFINITE LOOP THAT BUILDS A LINKED LIST THAT HOLDS ALL VALUES READ IN THAT PERTAIN TO THE CURRENT TIME STEP
         READ(FILEIO,'(A)',IOSTAT=ERR) LINE                             !READ NEXT VALUE
         FAILED=ERR.NE.0                                                !FAILED=TRUE IF REACHED END OF PAGE OR FAILED URWORD READ
         LLOC=1
         CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,N,T,-1,FILEIO)
         FAILED = FAILED .OR. (LINE(LEN(LINE):LEN(LINE)).EQ.'E')
         CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,N,R,-1,FILEIO)
         FAILED = FAILED .OR. (LINE(LEN(LINE):LEN(LINE)).EQ.'E')
         !
         IF(FAILED)THEN                                                 !IF FAILED THEN IT IS ASSUMED THE END OF THE FILE HAS BEEN REACHED SET UP POINTERS ACCORDINGLY SO THAT FUTURE CALLS TO SUBROUTINE WILL ONLY RETURN LAST READ ENTRY
            INQUIRE(FILEIO,NAME=LINE)
            WRITE(IOUT,'(3A,/A)')
     +          'END OF TABFILE, ',TRIM(LINE),', REACHED.',
     +          'NOW USING LAST VALUE FOR REMAINDER OF SIMULATION' 
            DATAPNT%NXT=>NULL()
            CLOSE(FILEIO)
            !
            IF(NLST.EQ.0)THEN                                           !IF NLST=0 THEN NO VALUES WERE READ IN BEFORE THE BOTTOM OF THE FILE. TO COMPLETE CURRENT CALL FORCE ROUTINE TO USE LAST READ ENTRY FROM PRIOR CALL
              NLST=1  
              DATASTR%T=1D99
              DATASTR%R=TABFILE%DAT(1)
              TABFILE%TIM(2)=-1D99
              TABFILE%DAT(2)=TABFILE%DAT(1)                             !ONE ENTRY IS READ IN SO USE THAT AND SET IT TO BE USED IN FUTURE CALLS
            ELSEIF(NLST.EQ.1)THEN
              DATASTR%T=1D99
              TABFILE%TIM(2)=-1D99
              TABFILE%DAT(2)=DATASTR%R
            ELSEIF(NLST.GT.1)THEN                                       !MULTIPLE ENTRIES WERE READ BEFORE END OF FILE. PROCESS AS NORMAL BUT STORE LAST VALUE FOR RESUSE IN FUTURE CALLS TO SUBROUTINE
              DATAPNT=>DATASTR
              DO I=1,NLST
                DATAPNT=>DATAPNT%NXT
              END DO
              TABFILE%TIM(2)=-1D99
              TABFILE%DAT(2)=DATAPNT%R
            END IF
            EXIT
         END IF
         !                                                              !IF THIS POINT IS REACHED THEN THERE WAS A SUCCESSFUL READ OF NEW TAB INFORAMTION DATA
         IF( TIMNEW - T  <  -B ) THEN                                   !CHECK IF TAB TIME EXCEDES CURRENT TIME STEP. IF TRUE THEN STOP READING IN NEW TAB INFORMATION
            TABFILE%TIM(2)=DBLE(T)                                      !STORE TIME  OF TABFILE ENTRY THAT IS 1 BEYOND THE CURRENT TIME STEP
            TABFILE%DAT(2)=DBLE(R)                                      !STORE VALUE OF TABFILE ENTRY THAT IS 1 BEYOND THE CURRENT TIME STEP
            BACKSPACE(FILEIO)                                           !CURRENT IO POSITION IS 1 PAST THE TIME STEP ENDING, MOVE BACK TO READ IN VALUE DURING NEXT CALL
            DATAPNT%NXT=>NULL()
            EXIT
         END IF
         !
         IF( TIMOLD - T  <  -B ) THEN                                   !CHECK IF TABFILE ENTRY IS WITHIN CURRENT TIMESTEP. IF IT IS INCLUDE IT IN LINKED LIST
           NLST=NLST+1
           DATAPNT%T=T
           DATAPNT%R=R
           ALLOCATE(DATAPNT%NXT)                                        !ALLOCATE SPACE IN NEXT LINKED LIST ENTRY
           DATAPNT=>DATAPNT%NXT                                         !SET UP LOCAL POINTER TO NEW LINKED LIST ENTRY
         END IF
       END DO
       !
       IF     (NLST.EQ.0) THEN                                          !NO VALUE WITHIN TIME STEP, INTERPOATE TO TIME STEP BETWEEN ISTR-1 AND ISTR
           RES= REAL(
     +               TABFILE%DAT(1) + 
     +               (TABFILE%DAT(2)-TABFILE%DAT(1)) *
     +                   ( 
     +                    (TIMNEW            - TABFILE%TIM(1)) /
     +                    (TABFILE%TIM(2) - TABFILE%TIM(1)) 
     +                   )
     +              )        
       ELSEIF (NLST.EQ.1) THEN                                          !ONLY 1 VALUE WITHIN TIME STEP SO USE THAT
         TABFILE%TIM(1)=DATASTR%T
         TABFILE%DAT(1)=DATASTR%R
         RES=DATASTR%R
       ELSE                                                             !MULTIPLE VALUES WITHIN TIME STEP, TIME AVERAGE VALUES
         DATAPNT=>DATASTR
         SUMTAB=0D0
         SUMTIM=0D0
         DO I=1, NLST
           IF    (I.EQ.1) THEN
             TW=(DATAPNT%T-TIMOLD) 
             TW=TW+ (DATAPNT%NXT%T-DATAPNT%T)/2D0
             SUMTAB=SUMTAB + TW*DATAPNT%R
             SUMTIM=SUMTIM + TW
             TOLD=DATAPNT%T
             DATAPNT=>DATAPNT%NXT
           ELSEIF(I.EQ.NLST) THEN
             TW=(TIMNEW-DATAPNT%T) + (DATAPNT%T-TOLD)/2D0
             SUMTAB=SUMTAB + TW*DATAPNT%R
             SUMTIM=SUMTIM + TW
             TABFILE%TIM(1)=DATASTR%T
             TABFILE%DAT(1)=DATASTR%R
           ELSE
             TW=(DATAPNT%NXT%T-DATAPNT%T)/2D0 + (DATAPNT%T-TOLD)/2D0
             SUMTAB=SUMTAB + TW*DATAPNT%R
             SUMTIM=SUMTIM + TW
             TOLD=DATAPNT%T
             DATAPNT=>DATAPNT%NXT
           END IF
         END DO
         RES=REAL(SUMTAB/SUMTIM)
       END IF
      END IF
      !
      TABFILE%USEVAL=.TRUE.                                             !TABFILE VALUE HAS BEEN RECORDED 
      TABFILE%VAL=RES
      !
      !CLEANUP
      DO I=NLST,1,-1                                                    !NULLIFY THE LINKED LIST START WITH THE END AND WORKING TO THE BEGINING
        DATAPNT=>DATASTR                                                !SET SET POINT TO START AND CYCLE TO END OF LINKED LIST TO DEALLOCATE EACH POINTER IN THE LINKED LIST
        DO J=1,I
          DATAPNT=>DATAPNT%NXT
        END DO
        DEALLOCATE(DATAPNT)
      END DO
      DEALLOCATE(DATASTR)                                               !DEALLOCATE THE FINAL POINTER TO FREE ANY REMAINIGN MEMORY
         NULLIFY(DATAPNT)                                               !NULLIFY    THE FINAL POINTER TO FREE ANY REMAINIGN MEMORY HOLDS
      !
      END SUBROUTINE
      !
      SUBROUTINE MNW2TABFILE2QDES(TABFILE,WELLOC,QDES,FOUND)
C      IF THERE ARE TABFILES AVAILIBLE SET QDES TO ITS TABFILE
C      THIS SUBROUTINE IS WRITTEN TO MINIMIZE IMPACT ON MNW2 CODE BECAUSE 
C      OF MULTIPLE CONDITIONAL READS OF QDES THIS SUBROUTINE WILL BE 
C      REMOVED WITH UPDATE OF MNW2 RP AND AR SOURCE CODE
C     
C     VARIABLE LIST:
C     TABFILE :  DATATYPE THAT CONTAINS APPROPIATE TABFILE INFORMATION
C     FOUND   :  RETURNS THE LOCATION OF THE WELL. SET TO 0 IF NOT FOUND
C               
C               
C               
C     ******************************************************************
      IMPLICIT NONE
      TYPE(TABFILETYPECHARIDX),                 INTENT(INOUT):: TABFILE
      INTEGER,                                  INTENT(IN)   :: WELLOC
      DOUBLE PRECISION,                         INTENT(INOUT):: QDES   !LEFT ALONE IF NOT FOUND
      INTEGER,OPTIONAL,                         INTENT(OUT)  :: FOUND
C     LOCAL VARIABLES
      DOUBLE PRECISION::TSFAC
      CHARACTER(20)::TEXTID
      INTEGER::I,NTAB,NLNK,TABIDX
      !
      IF(TABFILE%NTAB.LE.0) RETURN                                      !REDUNDANT CHECK, BUT INCLUDED TO BE SAFE INCASE OF ACIDENTAL CALL
      !
      NTAB=TABFILE%NTAB
!      NLST=UBOUND(WELLNAME,1)
      NLNK=UBOUND(TABFILE%PACIDX,1)
      !
      IF(PRESENT(FOUND)) FOUND=0
      DO I=1,NLNK
        IF(WELLOC.EQ.TABFILE%PACIDX(I)) THEN
            IF(PRESENT(FOUND)) FOUND=I
            TABIDX=TABFILE%TABIDX(I)
            TSFAC =TABFILE%TSFAC(I)
            !
            CALL TABFILEINTERP( TABFILE%TAB(TABIDX),TABFILE%SIMTIME )   !CALCULATE CURRENT TABFILE VALUE AND STORE IT IN TABFILE%TAB(TABIDX)%VAL
            !
            QDES = DBLE( TSFAC * TABFILE%TAB(TABIDX)%VAL )
            !
            EXIT
         END IF
      END DO
      !
      END SUBROUTINE
      !
      ELEMENTAL FUNCTION LRC2ID(LAY,ROW,COL) RESULT(ID)                 !CALCULATES: ID = COL + NCOL*(ROW-1) + NCOL*NROW*(LAY-1)
        USE GLOBAL,ONLY: NROW,NCOL
        IMPLICIT NONE
        INTEGER,INTENT(IN) ::LAY,ROW,COL
        INTEGER::ID
        !
        ID = COL + NCOL*(ROW-1) + NCOL*NROW*(LAY-1)
        !
      END FUNCTION
      !
      ELEMENTAL SUBROUTINE ID2LRC(ID,LAY,ROW,COL)                       !CALCULATES: ID = COL + NCOL*(ROW-1) + NCOL*NROW*(LAY-1)
        USE GLOBAL,ONLY: NROW,NCOL
        IMPLICIT NONE
        INTEGER,INTENT(IN) ::ID
        INTEGER,INTENT(OUT)::LAY,ROW,COL
        INTEGER::IDX
        !
        IDX = ID
        IF(MODULO( IDX, (NCOL*NROW) ).EQ.0) THEN
          LAY = ( IDX / (NCOL*NROW) )
        ELSE
          LAY = ( IDX / (NCOL*NROW) ) + 1
        END IF
        !
        IDX = IDX - NCOL*NROW*(LAY-1)
        IF(MODULO( IDX, NCOL ).EQ.0) THEN
          ROW = ( IDX / NCOL)
        ELSE
          ROW = ( IDX / NCOL) + 1
        END IF
        !
        COL = IDX - NCOL*(ROW-1)
        !
      END SUBROUTINE
      !
      END MODULE  TABLEFILE_INTERFACE


!ERROR STUFF NOT USED
!                    IF(LSTCHK(1)) WRITE(IOUT,'(3A,/3I6,/A)')
!    +             'ERROR: TABFILE WITH 3 POINT LINK (ie LAY,ROW,COL) ',
!    +             'CAN ONLY REFERENCE ONE CELL WITH A TABFILE. '
!    +             'CELL [LAY,ROW,COL] ',LAY,ROW,COL,
!    +             ' HAS ALREADY BEEN USED TO LINK TABFILE'
!                     CALL USTOP('ERROR IN TABFILE REFERENCE '//
!    +                 'MULTIPLE REFERENCES OF SAME MODEL CELL. SEE LST'
!                  END IF
      
!      PURE FUNCTION TABFILEINTERP(TABFILE) RESULT( RES )
!C FUNCTION SOLVES FOR TABFILE VALUE FOR CURRENT TIMESTEP
!C NOTE THAT FUNCTION EXPECTS TO RECIEVE A SINGLE TABFILE, NOT A VECTOR CONTAINING MULTIPLE TAB FILES
!C IT IS ASSUMED THAT THE CORRECT TABFILE IS BEING REQUESTED.
!C      
!C FUNCTION SEARCHES THROUGH A TABFILE DATA TYPE FOR A MATCHING TABNAM IF TABIDX<=0
!C IF TABIDX>0 THEN THE INDEX IS ASSUMED TO BE THE LOCATION OF THE MATCHING TABFILE
!C 3 CASES
!C SINGLE VALUE IN TIME STEP, USE ONLY 1 VALUE
!C MULTIPLE VALUES IN TIME STEP, TIME WEIGHTED AVERAGE
!C NO VALUES IN TIME STEP, LINEAR INTERPOLATE CLOSEST VALUES BEYOND TIME STEP
!      USE GWFBASMODULE, ONLY: DELT,TOTIM
!      USE TABLEFILE_INTERFACE
!      IMPLICIT NONE
!      TYPE(TABARRAY),INTENT(IN)::TABFILE
!      REAL:: RES
!C LOCAL
!      DOUBLE PRECISION::TIMOLD,TIMNEW,SUMTAB,B
!      INTEGER::I,J,IDX,NTIM,ISTR,ISTP
!      
!      RES=-9.9E30 !SET TO EXTREME VALUE IN CASE OF ERROR
!      ISTR=0!TABFILE%POS
!      ISTP=0
!
!      NTIM=UBOUND(TABFILE%TIM,1)
!      TIMOLD=DBLE(TOTIM-DELT)
!      TIMNEW=DBLE(TOTIM)
!      B=0.0001D0*DBLE(DELT)                                             !BUFFER VARIABLE TO CREATE WINDOW OF ACCEPTANCE FOR TIMES NEAR A TAB TIME B IS ADDED OR SUBTRACTED FROM CONDITIONALS WHERE APPROPIATE
!      
!      IF    ( REAL(TIMNEW) < REAL(TABFILE%TIM(1)   ) ) THEN             !FIRST TABFILE TIME IS GREATER THEN CURRENT TOTAL TIME, SO THERE IS NO POSSIBLILITY OF FINDING A TIME
!                                               RES=TABFILE%DAT(1)
!      ELSEIF( REAL(TIMOLD) > REAL(TABFILE%TIM(NTIM)) ) THEN
!                                               RES=TABFILE%DAT(NTIM)    !LAST TABFILE TIME IS LESS THAN PREVIOUS TIMESTEP TIME, SO THERE IS NO POSSIBLILITY OF FINDING A TIME
!      ELSE
!         DO I=1,NTIM                                                    !SEARCH FOR LOCATION AT BEGINING OF TIMESTEP
!           IF( REAL(TABFILE%TIM(I)) >= REAL(TIMOLD) ) THEN
!              ISTR=I
!              EXIT
!           END IF
!         END DO
!         DO I=ISTR,NTIM                                                 !SEARCH FOR LOCATION AT END OF TIMESTEP
!           IF( REAL(TABFILE%TIM(I)) >= REAL(TIMNEW) ) THEN
!              ISTP=I
!              EXIT
!           END IF
!         END DO
!         !
!         !TABFILE%POS=ISTR
!         !
!         IF (ISTP > ISTR) ISTP=ISTP-1                                   !ONLY WANT TABFILE TIMES WITHIN CURRENT TIMESTEP
!         !
!         IF     (REAL(TABFILE%TIM(ISTR)) > REAL(TIMNEW) ) THEN          !NO VALUE WITHIN TIME STEP, INTERPOATE TO TIME STEP BETWEEN ISTR-1 AND ISTR
!             RES= REAL(
!     +                 TABFILE%DAT(ISTR-1) + 
!     +                 (TABFILE%DAT(ISTR)-TABFILE%DAT(ISTR-1)) *
!     +                     ( 
!     +                      (TIMNEW            - TABFILE%TIM(ISTR-1)) /
!     +                      (TABFILE%TIM(ISTR) - TABFILE%TIM(ISTR-1)) 
!     +                     )
!     +                )        
!!             REAL( LINTERP(ISTR-1,ISTR,TIMNEW) )
!         ELSEIF (ISTR == ISTP) THEN                                     !ONLY 1 VALUE WITHIN TIME STEP SO USE THAT
!           RES=TABFILE%DAT(ISTR)
!         ELSE                                                           !MULTIPLE VALUES WITHIN TIME STEP, TIME AVERAGE VALUES
!           SUMTAB=0D0
!           DO I=ISTR,ISTP
!             IF    (I.EQ.ISTR) THEN
!                SUMTAB=SUMTAB + (TABFILE%TIM(I)-TIMOLD)*TABFILE%DAT(I)
!             ELSEIF(I.EQ.ISTP) THEN
!                SUMTAB=SUMTAB + (TIMNEW-TABFILE%TIM(I))*TABFILE%DAT(I)
!             ELSE
!                SUMTAB=SUMTAB + (TABFILE%TIM(I)-TABFILE%TIM(I-1))
!     +                                                   *TABFILE%DAT(I)
!             END IF
!           END DO
!           RES=REAL(SUMTAB)/DELT
!         END IF
!      END IF
!
!!      CONTAINS
!!        PURE DOUBLE PRECISION FUNCTION LINTERP(I1,I2,T)
!!        DOUBLE PRECISION,INTENT(IN):: T
!!        INTEGER,INTENT(IN):: I1,I2
!!        LINTERP= TABFILE%DAT(I1) + (TABFILE%DAT(I2)-TABFILE%DAT(I1)) 
!!     +       * ( (T-TABFILE%TIM(I1))/(TABFILE%TIM(I2)-TABFILE%TIM(I1)) )
!!        END FUNCTION
!      
!      END FUNCTION


      
!      SFRTABFILE%TABPRINT=.FALSE.                                       !INITIALIZE TABPRINTING TO FALSE
!      IF ( SFRTABFILE%NTAB.GT.0) THEN                                   !seb READ TABLES FOR SPECIFIED INFLOWS TAFILE_INTERFACE VERSION
!        LLOC = 1
!        CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,I,R,IOUT,IN)               !READ IN KEYWORD TABNOPRIRNT OR TABPRINT
!        CALL UPCASE(LINE(ISTART:ISTOP))
!        IF(LINE(ISTART:ISTOP).EQ.'TABPRINT') SFRTABFILE%TABPRINT=.TRUE.
!        CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,II,R,IOUT,IN)              !NUMBER OF SEGEMENTS (II) ASSOCIATED WITH A TABFILE
!        ALLOCATE( SFRTABFILE%SEGNUM(II) )
!        ALLOCATE( SFRTABFILE%TABIDX(II) )
!        ALLOCATE( SFRTABFILE%TSFAC(II)  )
!        READ(IN,'(A)') LINE                                             !READ IN NEXT LINE
!        DO I=1,II
!         LLOC=1
!         CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,K,R,IOUT,IN)              !READ SEGMENT THAT IS LINKED TO TABNAM
!         SFRTABFILE%SEGNUM(I)=K
!         CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,K,R,IOUT,IN)              !READ TABNAM THAT SEGMENT IS LINKED THIS WILL MATCH TO A TABFILE 
!         TABNAM=LINE(ISTART:ISTOP); TABNAM=ADJUSTL(TABNAM)
!         CALL UPCASE(TABNAM)
!         CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,K,R,IOUT,IN)
!         SFRTABFILE%TSFAC(I) =R
!         SFRTABFILE%TABIDX(I)=0
!         DO K=1,SFRTABFILE%NTAB                                         !SEARCH FOR LOCATION OF TABFILE
!           IF(TABNAM.EQ.SFRTABFILE%TABNAM(K)) THEN
!              SFRTABFILE%TABIDX(I)=K
!              EXIT
!           END IF
!         END DO
!         IF(SFRTABFILE%TABIDX(I).EQ.0) THEN
!         IF(LSTCHK(1))WRITE(IOUT,'(3A)')
!     +        'ERROR FINDING TABFILE WITH TABNAM "',TRIM(TABNAM),'"'
!          CALL USTOP('ERROR FINDING TABFILE WITH TABNAM "'//
!     +                TRIM(TABNAM)//'"')
!         END IF
!        READ(IN,'(A)') LINE                                             !READ IN NEXT LINE
!        END DO
!      END IF
      !

      
      

      !

!
!#########################################################################################################
! EXAMPLE ADDITIONAL OBJECT
!MODULE OBJECT_DATA_FMP_INTERFACE
!  !
!  USE FMP_DIMENSION_INTERFACE,           ONLY: FMP_DIMENSION
!  !
!  USE UTIL_INTERFACE,                       ONLY: READ_TO_DATA, FILE_IO_ERROR, STOP_ERROR, WARNING_MESSAGE, &
!                                               NUM2STR, ALLOC, PARSE_WORD, GET_INTEGER, GET_NUMBER
!  USE CONSTANTS
!  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
!  USE LIST_ARRAY_INPUT_INTERFACE,        ONLY: LIST_ARRAY_INPUT, LIST_ARRAY_INPUT_INT
!  USE ULOAD_AND_SFAC_INTERFACE
!  IMPLICIT NONE
!  PRIVATE
!  PUBLIC:: OBJECT_DATA, INITIALIZE_OBJECT_DATA
!  !
!  TYPE OBJECT_DATA
!      INTEGER:: IOUT=Z, LOUT=Z
!      LOGICAL:: TFR_READ   = FALSE
!      !
!      TYPE(LIST_ARRAY_INPUT_INT):: LAI_INTEGER
!      TYPE(LIST_ARRAY_INPUT    ):: LAI_DOUBLE
!      !
!      CONTAINS
!      !
!      PROCEDURE, PASS(OBJ):: NEXT     => SETUP_NEXT_STRESS_PERIOD
!      FINAL:: DEALLOCATE_OBJECT_FINAL
!  END TYPE
!  !
!  CONTAINS
!  !
!  SUBROUTINE DEALLOCATE_OBJECT_FINAL(OBJ)
!     TYPE(OBJECT_DATA)::OBJ
!     CALL DEALLOCATE_SWFATE(OBJ)
!  END SUBROUTINE
!  !
!  SUBROUTINE DEALLOCATE_OBJECT(OBJ)
!  CLASS(OBJECT_DATA), INTENT(INOUT)::OBJ
!     !
!     OBJ%IOUT  = Z
!     OBJ%LOUT  = Z
!     OBJ%TFR_READ    = FALSE
!     !IF(ALLOCATED(OBJ%XXX)) DEALLOCATE(OBJ%XXX)
!     !
!  END SUBROUTINE
!  !  
!  SUBROUTINE INITIALIZE_OBJECT_DATA( BL, OBJ, LINE, FDIM )
!    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL   !DATA BLOCK
!    CLASS(OBJECT_DATA),   INTENT(INOUT):: OBJ
!    CHARACTER(*),                INTENT(INOUT):: LINE
!    TYPE(FMP_DIMENSION),         INTENT(IN   ):: FDIM
!    CHARACTER(5):: ERROR
!    INTEGER:: I, LLOC, ISTART, ISTOP, IERR
!    !
!    WRITE(BL%IOUT,'(/A/)') 'XXXXX BLOCK FOUND AND NOW LOADING PROPERTIES'
!    !
!    OBJ%IOUT = BL%IOUT
!    OBJ%LOUT = BL%IOUT
!    !
!    ERROR='ERROR'
!    !
!    CALL BL%MAKE_SCRATCH_FILE()  !OR CALL BL%START AND DO I=ONE, BL%NLINE WITH BL%NEXT FOR BL%LINE
!    !
!    READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
!    !
!    DO WHILE (IERR == Z)
!      !
!      LLOC=ONE
!      CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP,TRUE)
!      !
!      SELECT CASE ( LINE(ISTART:ISTOP) )
!      CASE ("")
!                        WRITE(BL%IOUT,'(A)') '                    KEYWORD FOUND.'
!                        CALL OBJ% %INIT('', LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM, ONE, Z, Z, SCRATCH=BL%SCRATCH)
!                        !
!      CASE DEFAULT
!                        CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP  BLOCK FOUND UNKNOWN KEYWORD "'//LINE(ISTART:ISTOP)//'" ***IT WILL BE IGNORED***',INLINE=TRUE,CMD_PRINT=TRUE)
!                        
!      END SELECT
!      !
!      READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
!      !
!    END DO
!    !
!  END SUBROUTINE 
!  !
!  SUBROUTINE SETUP_NEXT_STRESS_PERIOD(OBJ)
!    !
!    CLASS(OBJECT_DATA),                 INTENT(INOUT):: OBJ
!    LOGICAL:: UPDATE
!    !
!    IF(OBJ%TFR_READ) THEN
!        !
!        UPDATE = FALSE
!        !
!        CALL OBJ%  %NEXT()
!        !
!    ELSE
!        !
!        UPDATE = TRUE
!        !
!        OBJ%TFR_READ = TRUE
!    END IF
!    !
!    ! PROCESS SP DATA
!    !
!  END SUBROUTINE
!  !
!END MODULE 
!
!#########################################################################################################
!#########################################################################################################
!#########################################################################################################
!
MODULE FMP_DIMENSION_INTERFACE!, ONLY: FMP_DIMENSION
  USE GLOBAL, ONLY: DIS_GSE => GSE, BOTM, LBOTM, NLAY, IBOUND, ITMUNI, KND
  USE CONSTANTS
  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
  USE UTIL_INTERFACE,                    ONLY: STOP_ERROR, WARNING_MESSAGE, READ_TO_DATA, PARSE_WORD, PARSE_WORD_UP, GET_INTEGER
  USE ULOAD_AND_SFAC_INTERFACE,          ONLY: ULOAD
  USe SFR_INPUT_DATA_TYPES,              ONLY: SFR_NAMED_LOCATION
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: FMP_DIMENSION
  !
  TYPE FMP_DIMENSION
      INTEGER:: NFARM=NEG, NCROP, NSOIL, NIRRG, NSFR_DELIV, NSFR_RETURN, NSFR_MAR_DELIV, NMAR_ID, MXNRD, NCROP_ELEV
      INTEGER:: NPROJ, NDIST, NUNIT, NAUXDEM
      INTEGER:: NROW, NCOL, NROW_GW, NCOL_GW, ITMUNI
      LOGICAL:: HAS_FMP             = FALSE
      LOGICAL:: HAS_HIERARCHY       = FALSE
      LOGICAL:: UZF_LINK            = FALSE
      LOGICAL:: HAS_BY_TIMESTEP     = FALSE
      LOGICAL:: WBS_BY_TIMESTEP     = FALSE
      LOGICAL:: CROP_BY_TIMESTEP    = FALSE
      LOGICAL:: CLIMATE_BY_TIMESTEP = FALSE
      TYPE(SFR_NAMED_LOCATION):: SFR_ID
      !CHARACTER(:), ALLOCATABLE:: OUTDIR
      CONTAINS
      PROCEDURE, PASS(FDIM):: INIT => INITIALIZE_FMP_DIMENSION
  END TYPE
  !
  CONTAINS
  !
  SUBROUTINE INITIALIZE_FMP_DIMENSION( FDIM, BL, NROW, NCOL, IUNITUZF, GSE )  !, DELR, DELC   
    CLASS(FMP_DIMENSION),        INTENT(INOUT):: FDIM
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL   !DATA BLOCK
    INTEGER,                     INTENT(IN   ):: NROW, NCOL, IUNITUZF
    !DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE:: DELR, DELC
    DOUBLE PRECISION,DIMENSION(:,:), ALLOCATABLE, INTENT(INOUT):: GSE
    INTEGER:: I, J, K, N, LLOC, ISTART, ISTOP
    LOGICAL:: HAS_HIERARCHY, POP_LINE, EOF!, NO_OUTDIR
    !
    WRITE(BL%IOUT,'(/A/)') 'GLOBAL BLOCK FOUND AND NOW LOADING PROPERTIES'
    !
    FDIM%NROW_GW= NROW   !THIS IS INCASE THE MF GRID HAS A DIFFERENT DISCRETIZATION THAN THE FMP GRID
    FDIM%NCOL_GW= NCOL
    FDIM%NROW   = NROW
    FDIM%NCOL   = NCOL
    FDIM%ITMUNI = ITMUNI
    FDIM%NFARM  = NEG
    FDIM%NCROP  = Z
    FDIM%NSOIL  = NEG
    FDIM%NIRRG  = Z
    FDIM%NPROJ  = Z
    FDIM%NDIST  = Z
    FDIM%NUNIT  = Z
    FDIM%MXNRD  = Z
    FDIM%NCROP_ELEV  = Z
    FDIM%NSFR_DELIV  = Z
    FDIM%NSFR_RETURN = Z
    FDIM%NSFR_RETURN = Z
    FDIM%NAUXDEM = Z
    FDIM%SFR_ID%N = Z
    HAS_HIERARCHY = FALSE
    !NO_OUTDIR = TRUE
    !
    IF(ALLOCATED(GSE)) DEALLOCATE(GSE)
    !IF(ALLOCATED(DELR)) DEALLOCATE(DELR)
    !IF(ALLOCATED(DELC)) DEALLOCATE(DELC)
    !
    CALL BL%START()  !FIRST PASS TO GET GLOBAL DIMS -- SINGLE LINE LOADING VARIABLES ONLY!!!
    !
    DO I=ONE, BL%NLINE
                    POP_LINE = TRUE
                    LLOC=ONE
                    CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP)
                    !
                    SELECT CASE(BL%LINE(ISTART:ISTOP))
                    CASE("NFARM","NWBS");      CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,FDIM%NFARM,        MSG='FMP GLOBAL DIMENSION ERROR; FAILED TO LOAD THE NUMBER FOR NWBS (aka NFARM).')
                    CASE("NCROP");             CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,FDIM%NCROP,        MSG='FMP GLOBAL DIMENSION ERROR; FAILED TO LOAD THE NUMBER FOR NCROP.')
                    CASE("NSOIL");             CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,FDIM%NSOIL,        MSG='FMP GLOBAL DIMENSION ERROR; FAILED TO LOAD THE NUMBER FOR NSOIL.')
                    CASE("NIRRIGATE","NIRR");  CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,FDIM%NIRRG, MSG='FMP GLOBAL DIMENSION ERROR; FAILED TO LOAD THE NUMBER FOR NIRRIGATE.') 
                    !
                    !!!CASE("NAUX_DEMAND","NAUXDEM");    CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,FDIM%NAUXDEM,MSG='FMP GLOBAL DIMENSION ERROR; FAILED TO LOAD THE NUMBER FOR NAUX_DEMAND.')
                    !!!!
                    !!!CASE("NPROJ") 
                    !!!                  CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,FDIM%NPROJ,MSG='FMP GLOBAL DIMENSION ERROR; FAILED TO LOAD THE NUMBER FOR NPROJ.')
                    !!!                  HAS_HIERARCHY = HAS_HIERARCHY .OR. FDIM%NPROJ > Z
                    !!!CASE("NDIST") 
                    !!!                  CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,FDIM%NDIST,MSG='FMP GLOBAL DIMENSION ERROR; FAILED TO LOAD THE NUMBER FOR NDIST.')
                    !!!                  HAS_HIERARCHY = HAS_HIERARCHY .OR. FDIM%NDIST > Z
                    !!!CASE("NUNIT") 
                    !!!                  CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,FDIM%NUNIT,MSG='FMP GLOBAL DIMENSION ERROR; FAILED TO LOAD THE NUMBER FOR NUNIT.')
                    !!!                  HAS_HIERARCHY = HAS_HIERARCHY .OR. FDIM%NUNIT > Z
                    !
                    CASE("MXNRD","NRD_TYPES","NRD_TYPE","MXNRDT"); CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,FDIM%MXNRD,     MSG='FMP GLOBAL DIMENSION ERROR; FAILED TO LOAD THE NUMBER FOR NRD_TYPES (MXNRD).') 
                    !
                    CASE("NSFR_DELIV");                            CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,FDIM%NSFR_DELIV,MSG='FMP GLOBAL DIMENSION ERROR; FAILED TO LOAD THE NUMBER FOR NSFR_DELIV.')
                    !
                    CASE("NSFR_RETURN");                           CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,FDIM%NSFR_RETURN,MSG='FMP GLOBAL DIMENSION ERROR; FAILED TO LOAD THE NUMBER FOR NSFR_RETURN.')
                    !
                    !
                    CASE("NCROP_SPECIFIED_ELEVATIONS");            CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,FDIM%NCROP_ELEV,MSG='FMP GLOBAL DIMENSION ERROR; FAILED TO LOAD THE NUMBER FOR NCROP_SPECIFIED_ELEVATIONS.')
                    !
                    CASE("UZF_LINK", "UZF", "UZFLINK")
                                                      IF(IUNITUZF == Z ) THEN
                                                          CALL WARNING_MESSAGE(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='WITHIN THE GLOBAL DIMENSION BLOCK FOUND "'//BL%LINE(ISTART:ISTOP)//'" KEYWORD'//NL//'WHICH LINKES FMP TO UZF, BUT UZF PACKAGE IS NOT ENABLED (DECLAIRED IN NAME FILE).'//NL//'THIS OPTION WILL BE DISABLED DUE TO NO UZF BEING AVAILBLE TO SEND WATER TOO'//NL//'DEEP PERCOLATION WILL INSTEAD GO TO THE WATER TABLE.')
                                                      ELSE
                                                          FDIM%UZF_LINK = TRUE
                                                      END IF
                    !
                    CASE("BY_TIMESTEP", "TIMESTEP", "BYTIMESTEP") 
                                      CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP)
                                      !
                                      SELECT CASE(BL%LINE(ISTART:ISTOP))
                                      CASE("WBS",  "WATER_BALANCE_SUBREGION"); FDIM%WBS_BY_TIMESTEP     = TRUE  
                                      CASE("CROP", "LAND_USE"               ); FDIM%CROP_BY_TIMESTEP    = TRUE  
                                      CASE("CLIMATE"                        ); FDIM%CLIMATE_BY_TIMESTEP = TRUE
                                      CASE DEFAULT;      CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='WITHIN THE GLOBAL DIMENSION BLOCK FOUND "BY_TIMESTEP" (OR "TIMESTEP") KEYWORD.'//NL//'THIS MUST BE FOLLOWED ONE OF: "WBS", "LAND_USE", "CLIMATE", BUT INSTEAD FOUND "'//BL%LINE(ISTART:ISTOP)//'" KEYWORD.'//NL//'PLEASE REMOVE/FIX TO CONTINUE.')
                                      END SELECT 
                                      !
                                      FDIM%HAS_BY_TIMESTEP = TRUE
                    !
                    CASE("SCOTT","BOYCE") 
                                      WRITE(BL%IOUT,'(//A//, A//, A)') 'YOU SPECIFIED A MOST WONDERFUL NAME AND KEYWORD AVAILIBLE IN OneWater','OneWater WILL NOW SHOW ITS APPRECIATION WITH THE FOLLOWING:',REPEAT('   SCOTT E. BOYCE IS AWESOME!!!'//NL,100), 'THANKS FOR YOUR SUPPORT BY SELECTIONG OPTION '//BL%LINE(ISTART:ISTOP)
                                      WRITE(*,      '(//A//, A//, A)') 'YOU SPECIFIED A MOST WONDERFUL NAME AND KEYWORD AVAILIBLE IN OneWater','OneWater WILL NOW SHOW ITS APPRECIATION WITH THE FOLLOWING:',REPEAT('   SCOTT E. BOYCE IS AWESOME!!!'//NL,10), 'THANKS FOR YOUR SUPPORT BY SELECTIONG OPTION '//BL%LINE(ISTART:ISTOP)
                    !
                    !CASE('NROW');     CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,FDIM%NROW,MSG='FMP GLOBAL DIMENSION ERROR; FAILED TO LOAD NROW.')
                    !CASE('NCOL');     CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,FDIM%NCOL,MSG='FMP GLOBAL DIMENSION ERROR; FAILED TO LOAD NCOL.')
                    CASE DEFAULT
                                CALL BL%NEXT() !MOVE TO NEXT  LINE
                                POP_LINE = FALSE
                    END SELECT
                    !
                    IF(POP_LINE) CALL BL%DELETE_LINE() ! REMOVE LINE CAUSE ITS NO LONGER NEEDED
    END DO
    !
    CALL BL%START()
    !
    DO WHILE (BL%NOT_AT_END())
                    LLOC=ONE
                    CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP)
                    !
                    SELECT CASE(BL%LINE(ISTART:ISTOP))
                    CASE("SFR_NAME","SFR_NAMES") 
                                      CALL FDIM%SFR_ID%LOAD(BL, LLOC, ISTART, ISTOP)
                                      EXIT
                    END SELECT
                    !
                    CALL BL%NEXT()
    END DO
    !
    !  LOAD GSE --MIGHT HAVE INTERNAL
    !
    CALL BL%START()
    !
    CALL BL%MAKE_SCRATCH_FILE()
    !
    CALL BL%READ_SCRATCH(EOF)
    !
    DO WHILE (.NOT. EOF)
                    !
                    LLOC=ONE
                    CALL PARSE_WORD_UP(BL%LN,LLOC,ISTART,ISTOP)
                    !
                    SELECT CASE(BL%LN(ISTART:ISTOP))
                    CASE("SURFACE_ELEVATION", "GSE") 
                                      ALLOCATE(GSE(FDIM%NCOL,FDIM%NROW))
                                      N = Z
                                      CALL ULOAD(GSE, LLOC, BL%LN, BL%IOUT, BL%IU, N, NOID=TRUE, SCRATCH=BL%SCRATCH)  !IU = N
                    !CASE("OUTPUT_DIRECTORY","OUTDIR") 
                    !                  CALL GET_WORD(BL%LN,LLOC,ISTART,ISTOP,FDIM%OUTDIR,IS_ALLOC=TRUE,NO_UPCASE=TRUE)
                    !                  NO_OUTDIR = FALSE
                    !CASE("DELR") 
                    !                  I = Z
                    !                  CALL ULOAD(DELR, LLOC, BL%LN, BL%IOUT, BL%IU, I, NO_INTERNAL=TRUE)
                    !CASE("DELC") 
                    !                  I = Z
                    !                  CALL ULOAD(DELC, LLOC, BL%LN, BL%IOUT, BL%IU, I, NO_INTERNAL=TRUE)
                    !!!CASE ("HIERARCHY")
                    !!!                  WRITE(BL%IOUT,'(A)') '   HIERARCHY                        KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND FIRST LIST OF HIERARCHYS.'
                    !!!                  IF(.NOT. WBS%HAS_HIERARCHY) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FOUND "HIERARCHY" KEYWORD, WHICH REQUIRES REQUIRES THAT "NPROJ", "NDIST", AND "NUNIT" BE SPECIFIED AND SET TO GREATER THAN ZERO IN THE GLOBAL DIMENSION BLOCK. PLEASE DOUBLE CHECK BLOCK SET UP.')
                    !!!                  CALL WBS%HIERARCHY_TFR%INIT('HIERARCHY', LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM+FDIM%NAUXDEM, THREE, Z, Z, SCRATCH=BL%SCRATCH)  !, FDIM%NFARM, 'BYWBS', FDIM%NCROP, 'BYCROP'
                    CASE DEFAULT
                                CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP GLOBAL BLOCK FOUND UNKNOWN KEYWORD "'//BL%LN(ISTART:ISTOP)//'" ***IT WILL BE IGNORED***',INLINE=TRUE,CMD_PRINT=TRUE)
                    END SELECT
                    !
                    CALL BL%READ_SCRATCH(EOF)
    END DO
    !
    IF(.NOT. ALLOCATED(GSE)) THEN
        !
        IF( FDIM%NROW.NE.NROW .OR. FDIM%NCOL.NE.NCOL) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='GLOBAL DIMENSION BLOCK ERROR: YOU MUST SPECIFY THE GROND SURFACE ELEVATION WITH KEYWORD "SURFACE_ELEVATION" IF THE FMP GRID HAS AN NROW/NCOL THAT IS DIFFERENT FROM MODFLOW MODEL NROW/NCOL.')
        !
        ALLOCATE(GSE(FDIM%NCOL,FDIM%NROW))
        !
        !CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='GLOBAL DIMENSION BLOCK ERROR: YOU MUST SPECIFY THE GROND SURFACE ELEVATION EITHER IN THE DIS PACKAGE OR SPECIFY IT HERE WITH KEYWORD "SURFACE_ELEVATION".')
        !
        IF( DIS_GSE(1,1).NE.DIS_GSE(1,1) ) THEN
            CALL WARNING_MESSAGE(INFILE=BL%IU, OUTPUT=BL%IOUT, MSG='GLOBAL DIMENSION BLOCK: THE KEYWORD "SURFACE_ELEVATION" WAS NOT FOUND NOR WAS THE GROUND SURFACE ELEVATION DEFINED IN THE DIS PACKAGE.'//BLN//'FMP WILL ASSUME THAT THE GROUND SURFACE ELEVATION IS EQUAL TO THE TOP ELEVATION OF THE UPPER MOST ACTIVE CELL.')
            !
            DEALLOCATE(DIS_GSE)          !DIS GSE IGRID pointer must be updated outside of subroutine with call to: CALL SGWF2BAS7PSV(IGRID)
            ALLOCATE(DIS_GSE(NCOL,NROW))
            !
            DO I = ONE, NROW
            DO J = ONE, NCOL
                  DIS_GSE(J,I) = D100
                  DO K=ONE, NLAY
                               IF(IBOUND(J,I,K).NE.Z) THEN
                                   !
                                   DIS_GSE(J,I) = BOTM(J,I,LBOTM(K)-1)
                                   EXIT
                                   !
                               END IF
                  END DO
            END DO
            END DO
            !
        END IF
        !
        GSE = DIS_GSE              !REDUNDANT FROM BAS BECAUSE THERE MAYBE A TIME TO HAVE FMP GRID BE INDEPENDENT OF MODEL GRID.
        !
    ELSEIF( DIS_GSE(1,1).NE.DIS_GSE(1,1) .AND. FDIM%NROW==NROW .AND. FDIM%NCOL==NCOL ) THEN
                 DEALLOCATE(DIS_GSE)
                   ALLOCATE(DIS_GSE(NCOL,NROW), SOURCE=GSE)   !DIS GSE IGRID pointer must be updated outside of subroutine with call to: CALL SGWF2BAS7PSV(IGRID)
    END IF
    !
    FDIM%HAS_FMP = FDIM%NFARM > Z
    !
    IF( FDIM%NFARM < Z )   CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='WITHIN THE GLOBAL DIMENSION BLOCK FAILED TO LOCATE KEYWORD "NWBS" OR ITS VALUE IS LESS THAN ZERO. PLEASE DOUBLE CHECK BLOCK SET UP.')
    !IF( FDIM%NCROP < ONE ) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='WITHIN THE GLOBAL DIMENSION BLOCK FAILED TO LOCATE KEYWORD "NCROP" OR ITS VALUE IS LESS THAN ONE. PLEASE DOUBLE CHECK BLOCK SET UP.')
    IF( FDIM%NSOIL < Z )   CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='WITHIN THE GLOBAL DIMENSION BLOCK FAILED TO LOCATE KEYWORD "NSOIL" OR ITS VALUE IS LESS THAN ZERO. PLEASE DOUBLE CHECK BLOCK SET UP.')
    !
    !!!IF( HAS_HIERARCHY .AND. FDIM%NPROJ < ONE ) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='WITHIN THE GLOBAL DIMENSION BLOCK FAILED TO LOCATE KEYWORD "NPROJ" WHEN NDIST OR NUNIT WAS FOUND AND GREATER THAN ZERO. YOU MUST EITHER SPECIFIY ALL "NPROJ", "NDIST", AND "NUNIT" OR SPECIFIY NONE OF THEM (OR SET THEM ALL TO ZERO). PLEASE DOUBLE CHECK BLOCK SET UP.')
    !!!IF( HAS_HIERARCHY .AND. FDIM%NDIST < ONE ) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='WITHIN THE GLOBAL DIMENSION BLOCK FAILED TO LOCATE KEYWORD "NDIST" WHEN NPROJ OR NUNIT WAS FOUND AND GREATER THAN ZERO. YOU MUST EITHER SPECIFIY ALL "NPROJ", "NDIST", AND "NUNIT" OR SPECIFIY NONE OF THEM (OR SET THEM ALL TO ZERO). PLEASE DOUBLE CHECK BLOCK SET UP.')
    !!!IF( HAS_HIERARCHY .AND. FDIM%NUNIT < ONE ) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='WITHIN THE GLOBAL DIMENSION BLOCK FAILED TO LOCATE KEYWORD "NNUIT" WHEN NPROJ OR NDIST WAS FOUND AND GREATER THAN ZERO. YOU MUST EITHER SPECIFIY ALL "NPROJ", "NDIST", AND "NUNIT" OR SPECIFIY NONE OF THEM (OR SET THEM ALL TO ZERO). PLEASE DOUBLE CHECK BLOCK SET UP.')
    !
    FDIM%HAS_HIERARCHY = HAS_HIERARCHY
    !
    WRITE(BL%IOUT,'(A/)')'FMP GLOBAL BLOCK LOADED'
    WRITE(BL%IOUT,'(A,I10)')  'NWBS:      ',FDIM%NFARM
    WRITE(BL%IOUT,'(A,I10)')  'NCROP:     ',FDIM%NCROP
    WRITE(BL%IOUT,'(A,I10)')  'NSOIL:     ',FDIM%NSOIL
    WRITE(BL%IOUT,'(A,I10)')  'NIRRG:     ',FDIM%NIRRG
    WRITE(BL%IOUT,'(A,I10)')  'NRD_TYPES: ',FDIM%MXNRD
    WRITE(BL%IOUT,'(A,I10)')  'NSFR_DELIVERY: ',FDIM%NSFR_DELIV
    WRITE(BL%IOUT,'(A,I10)')  'NSFR_RETURN:   ',FDIM%NSFR_RETURN
    !WRITE(BL%IOUT,'(A,I10/)') 'NSFR_RETURN:   ',FDIM%NSFR_RETURN
    WRITE(BL%IOUT,'(A,I10,10x A)')  'NCROP_SPECIFIED_ELEVATIONS: ',FDIM%NCROP_ELEV, "-- ONLY USED BY CROP BLOCK KEYWORDS THAT ALTER THE CROP'S SURFACE ELEVATION FROM USING THE GLOBAL DIMENSION'S SURFACE_ELEVATION --"
    !
    !!!WRITE(BL%IOUT,'(/A/)')'FMP-SWO HIERARCHY PARAMETERS ARE:'
    !!!WRITE(BL%IOUT,'(A,I10)')  'NWBS:        ',FDIM%NFARM
    !!!WRITE(BL%IOUT,'(A,I10)')  'NAUX_DEMAND: ',FDIM%NAUXDEM
    !!!WRITE(BL%IOUT,'(A,I10)')  'NUNIT:       ',FDIM%NUNIT
    !!!WRITE(BL%IOUT,'(A,I10)')  'NDIST:       ',FDIM%NDIST
    !!!WRITE(BL%IOUT,'(A,I10/)') 'NPROJ:       ',FDIM%NPROJ
    !
    IF(FDIM%HAS_BY_TIMESTEP) THEN
        WRITE(BL%IOUT,'(A/,A/)')'BY TIME STEP KEYWORD FOUND','THE FOLLOWING BLOCKS WILL LOAD ALL "TRANSIENT" PROPERTIES EVERY TIME STEP.'
        IF(FDIM%WBS_BY_TIMESTEP    ) WRITE(BL%IOUT,'(A)' ) 'WBS     BLOCK'
        IF(FDIM%CROP_BY_TIMESTEP   ) WRITE(BL%IOUT,'(A)' ) 'CROP    BLOCK'
        IF(FDIM%CLIMATE_BY_TIMESTEP) WRITE(BL%IOUT,'(A/)') 'CLIMATE BLOCK'
    END IF
    !
    !IF(.NOT. HAS_HIERARCHY) THEN  !ASSUME EACH FARM IS ITS OWN PROJECT, DISTRICT, UNIT
    !    FDIM%NPROJ = FDIM%NFARM
    !    FDIM%NDIST = FDIM%NFARM
    !    FDIM%NUNIT = FDIM%NFARM
    !END IF
    !
    IF(FDIM%UZF_LINK) THEN
        WRITE(BL%IOUT,'(/A/)')  '   FMP-UZF LINK ENABLED.  DEEP PERCOLATION IS PASSED TO UZF OR TREATED AS RECHARGE.'
    ELSE 
        WRITE(BL%IOUT,'(/A/)')  '   FMP IS --NOT-- LINKED TO UZF.  DEEP PERCOLATION IS TREATED AS RECHARGE EVERYWHERE.'
    END IF
    !
    IF (FDIM%SFR_ID%N > Z) THEN
        WRITE(BL%IOUT,'(/A,/ A20,1x A7,1x A7)' )  '   SFR_NAMES HAVE BEEN SPECIFIED WITH THE FOLLOWING NAMES HAVE BEEN ASSOCIATED WITH THE FOLLOWING SEGMENT AND REACHES:','SFR_NAME','SEGMENT', 'REACH'
        DO I=ONE, FDIM%SFR_ID%N
            WRITE(BL%IOUT,'(A20,1x I7,1x I7)' ) FDIM%SFR_ID%NAM(I), FDIM%SFR_ID%SEG_RCH(ONE,I), FDIM%SFR_ID%SEG_RCH(TWO,I)
        END DO
        WRITE(BL%IOUT,'(A)' )
    ELSE
        WRITE(BL%IOUT,'(/A/)')  '   SFR_NAMES KEYWORD WAS NOT LOCATED, SO ALL FMP RELATED SEGMENT AND REACHES MUST BE SPECIFED DIRECTLY (NO SFR NAME BUT THEIR SEGEMETN AND REACH INSTEAD).'
    END IF
    !
    !IF(NO_OUTDIR) ALLOCATE(FDIM%OUTDIR, SOURCE='')
    !
  END SUBROUTINE
    !
!  SUBROUTINE INITIALIZE_OFE(OFE, LLOC, LINE, IOUT, IN, NCROP, NFARM, NROW, NCOL, LIST_DIM)
!  ! LISTARRAY   => TRUE indicates that only LIST keyword is allowed, but it is a multicolumn list
!  ! ONLY_ARRAY  => TRUE indicates that only ARRAY keyword is allowed
!  ! LIST_DIM    => When present and > 1 indicates the column dimension of the list htat is loaded, viz. multicolumn list
!  CLASS(CROP_PROP_INPUT_INT):: CPI
!  CHARACTER(*),           INTENT(INOUT):: LINE
!  INTEGER,                INTENT(INOUT):: LLOC
!  INTEGER,                INTENT(IN   ):: IOUT, IN, NCROP, NFARM, NROW, NCOL
!  INTEGER,                INTENT(IN   ):: LIST_DIM
!  REAL:: R
!  INTEGER:: IU,ISTART,ISTOP,ONE,Z,I,N
!  LOGICAL:: TRUE, FALSE, LISTARRAY, NOID, ONLYARRAY
!  !
!  Z = 0
!  ONE = 1
!  TRUE =.TRUE.
!  FALSE=.FALSE.
!  IU = Z
!  ALLOCATE(OFE%TYP, SOURCE = 'OFE')
!  !
!  N = LLOC
!  CALL URWORD(LINE,LLOC,ISTART,ISTOP,ONE,I,R,IOUT,IN)
!  SELECT CASE (LINE(ISTART:ISTOP))
!                                  CASE('LIST' );  OFE%LISTARRAY = TRUE
!                                  CASE('ARRAY');  OFE%LISTARRAY = FALSE
!                                  CASE DEFAULT
!                                               CALL STOP_ERROR(LINE,IN,IOUT,'FMP WBS BLOCK ERROR. EXPECTED TO FIND KEYWORD "LIST" OR "ARRAY" AFTER KEYWORD, BUT IT WAS NOT FOUND.')
!                                               LLOC = N
!  END SELECT
!  !
!  IF(LISTARRAY .OR. ONLYARRAY) CPI%LISTLOAD = FALSE
!  !
!  CALL URWORD(LINE,LLOC,ISTART,ISTOP,ONE,I,R,IOUT,IN)
!  SELECT CASE (LINE(ISTART:ISTOP))
!                                 CASE('TRANSIENT'); CPI%TRANSIENT = TRUE
!                                 CASE('STATIC');    CPI%TRANSIENT = FALSE
!                                 CASE DEFAULT; CALL STOP_ERROR(LINE,IN,IOUT,'FMP CROP BLOCK ERROR. FOUND KEYWORD THAT SHOULD BE FOLLOWED BY EITHER "TRANSIENT" OR "STATIC" KEYWORD')
!  END SELECT
!  !
!  IF     (CPI%LISTLOAD .AND. PRESENT(LIST_DIM)) THEN
!                              IF(LIST_DIM > ONE) THEN
!                                                     CPI%LISTLOAD  = FALSE
!                                                     CPI%LISTARRAY = TRUE
!                                                         LISTARRAY = TRUE
!                                                     ALLOCATE(CPI%ARRAY(LIST_DIM,NCROP))
!                              ELSE
!                                                     ALLOCATE(CPI%LIST(NCROP))
!                              END IF
!  ELSEIF (CPI%LISTLOAD ) THEN
!                              ALLOCATE(CPI%LIST(NCROP))
!  ELSE
!       IF(.NOT. FRACTION) THEN              
!                              ALLOCATE(CPI%ARRAY(NCOL,NROW))
!       ELSE
!                              ALLOCATE(CPI%ARRAY(NCOL,NROW*NCROP))
!       END IF
!  END IF
!  !
!  NOID = .NOT. LISTARRAY  !FOR READING OF ID WHEN READING LIST2D
!  IF(ONLYARRAY) NOID = TRUE
!  !
!  IF (.NOT. CPI%TRANSIENT ) THEN  
!      IF (CPI%LISTLOAD ) THEN
!                             CALL ULOAD(CPI%LIST,  LLOC, LINE, IOUT, IN, IU, NOID=FALSE)
!      ELSE
!                             CALL ULOAD(CPI%ARRAY, LLOC, LINE, IOUT, IN, IU, NOID=NOID)
!      END IF
!  ELSE
!      IF (CPI%LISTLOAD ) THEN
!                             CALL CPI%TFR%INIT(LLOC,LINE,IOUT,IN, NOID=FALSE)
!      ELSE
!                             CALL CPI%TFR%INIT(LLOC,LINE,IOUT,IN, NOID=NOID)
!      END IF
!  END IF
!  !
!  END SUBROUTINE
  !
END MODULE
!
!#########################################################################################################
!
MODULE WBS_DATA_FMP_INTERFACE
  !
  USE FMP_DIMENSION_INTERFACE, ONLY: FMP_DIMENSION
  !
  USE GLOBAL, ONLY: DIS_AREA => AREA, KND
  USE UTIL_INTERFACE,                    ONLY: FILE_IO_ERROR, STOP_ERROR, WARNING_MESSAGE,     &
                                               UPPER, PARSE_WORD, PARSE_WORD_UP, NEAR_ZERO
  USE NUM2STR_INTERFACE,                 ONLY: NUM2STR
  USE CONSTANTS
  USE ALLOC_INTERFACE,                   ONLY: ALLOC
  USE ARRAY_DATA_TYPES,                  ONLY: COMPRESSED_VALUE_STORAGE
  USE ULOAD_AND_SFAC_INTERFACE,          ONLY: ULOAD
  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
  USE LIST_ARRAY_INPUT_INTERFACE,        ONLY: LIST_ARRAY_INPUT, LIST_ARRAY_INPUT_INT
  USE LINKED_LIST_INSTRUCTION,           ONLY: INTEGER_LINKED_LIST
  USE WARNING_TYPE_INSTRUCTION,          ONLY: WARNING_TYPE
  !
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: WBS_DATA, INITIALIZE_WBS_DATA
  !  
  TYPE FARMLOCATION
    INTEGER:: NF=Z                                         !--NOT CURRENTLY SUPPORTED, WILL EVENTUALLY HOLD THE FARM ID WHEN THE INDEX IS NO LONGER HARDWIRED AS THE FID
    INTEGER:: Count=Z                                      ! TOTAL NUMBER OF CELLS THAT CONTRAIN THE FARM [FARMLOCATION(1) REFERS TO FARM 1]
    DOUBLE PRECISION:: AREA                                ! FARM TOTAL AREA (INCLUDES BARE LAND, NON-IRRIGIGATED, AND IRRIGATED CROPS)
    INTEGER, DIMENSION(:,:),ALLOCATABLE:: RC               ! LOC(1,:) CONTAINS THE ROW LOCATION OF THE FARM; LOC(2,:) CONTAINS THE COL LOCATION OF THE FARM
  END TYPE
  !
  TYPE FARM_RELATIONSHIP
      INTEGER:: PROJ=Z
      INTEGER:: DIST=Z
      INTEGER:: UNIT=Z
  END TYPE
  !
  TYPE UNIT_RELATIONSHIP
      INTEGER:: NFARM=Z, NAUX=Z
      INTEGER:: PROJ=Z, DIST=Z
      INTEGER,DIMENSION(:),ALLOCATABLE:: FARM
      INTEGER,DIMENSION(:),ALLOCATABLE:: AUX
  END TYPE
  !
  TYPE DIST_RELATIONSHIP
      INTEGER:: NUNIT=Z, NFARM=Z, NAUX=Z
      INTEGER:: PROJ=Z
      INTEGER,DIMENSION(:),ALLOCATABLE:: UNIT
      INTEGER,DIMENSION(:),ALLOCATABLE:: FARM
      INTEGER,DIMENSION(:),ALLOCATABLE:: AUX
  END TYPE
  !
  TYPE PROJ_RELATIONSHIP
      INTEGER:: NDIST=Z, NUNIT=Z, NFARM=Z, NAUX=Z
      INTEGER,DIMENSION(:),ALLOCATABLE:: DIST
      INTEGER,DIMENSION(:),ALLOCATABLE:: UNIT
      INTEGER,DIMENSION(:),ALLOCATABLE:: FARM
      INTEGER,DIMENSION(:),ALLOCATABLE:: AUX
  END TYPE
  !
  TYPE CROP_POINTER
      INTEGER:: N = Z
      INTEGER,DIMENSION(:,:),ALLOCATABLE:: PNT
  END TYPE
  !
  TYPE WBS_SUPPLY
      DOUBLE PRECISION:: TOTAL   = DZ
      DOUBLE PRECISION:: USED    = DZ
      DOUBLE PRECISION:: CROP    = DZ
      DOUBLE PRECISION:: SFR     = DZ
      DOUBLE PRECISION:: WEL     = DZ
      DOUBLE PRECISION:: NRD     = DZ
      DOUBLE PRECISION:: MAGIC   = DZ
      DOUBLE PRECISION:: SFR_TOT = DZ
      DOUBLE PRECISION:: WEL_TOT = DZ
      DOUBLE PRECISION:: NRD_TOT = DZ
      LOGICAL::          HAS_MAGIC = FALSE
      !DOUBLE PRECISION:: SWR     = DZ
      !DOUBLE PRECISION:: SWR_TOT = DZ
      CONTAINS
      PROCEDURE, PASS(SUP):: INIT=>INIT_SUPPLY
      PROCEDURE, PASS(SUP):: SET_TOTAL  !--DOES NOT INCLUDE MAGIC
      PROCEDURE, PASS(SUP):: SET_USED   !--INCLUDES MAGIC
      PROCEDURE, PASS(SUP):: SET_MAGIC
      PROCEDURE, PASS(SUP):: SET_SFR
      PROCEDURE, PASS(SUP):: SET_WEL
      PROCEDURE, PASS(SUP):: SET_NRD
      PROCEDURE, PASS(SUP):: SET_SFR_TOT
      PROCEDURE, PASS(SUP):: SET_WEL_TOT
      PROCEDURE, PASS(SUP):: SET_NRD_TOT
      !PROCEDURE, PASS(SUP):: SET_SWR
  END TYPE
  !
  TYPE WATER_SOURCES
      LOGICAL,DIMENSION(:),ALLOCATABLE:: GW,SW,NRD
      CONTAINS
      PROCEDURE,PASS(SRC):: ALLOC => ALLOCATE_WATER_SOURCES!(N)
  END TYPE
  
  !
  !TYPE FALLOW_ORDER
  !    INTEGER:: NF, N
  !    INTEGER,DIMENSION(:), ALLOCATABLE:: CROP
  !END TYPE
  !
  TYPE WBS_DATA
      !
      INTEGER:: NFARM, NCROP
      INTEGER:: NPROJ, NDIST, NUNIT, NAUXDEM
      INTEGER:: NROW, NCOL, ITMUNI
      INTEGER:: IOUT=Z, LOUT=Z
      INTEGER:: PRORATE_DEFICIENCY = ONE
      !
      LOGICAL,                 DIMENSION(:), ALLOCATABLE:: INUSE
      !
      TYPE(FARMLOCATION),      DIMENSION(:), ALLOCATABLE:: FID
      !!!TYPE (FARM_RELATIONSHIP),DIMENSION(:), ALLOCATABLE:: FARM, AUX_DEMAND
      !!!TYPE (PROJ_RELATIONSHIP),DIMENSION(:), ALLOCATABLE:: PROJ
      !!!TYPE (DIST_RELATIONSHIP),DIMENSION(:), ALLOCATABLE:: DIST
      !!!TYPE (UNIT_RELATIONSHIP),DIMENSION(:), ALLOCATABLE:: UNIT
      TYPE (CROP_POINTER),DIMENSION(:),      ALLOCATABLE:: CROP
      TYPE (WBS_SUPPLY),  DIMENSION(:),      ALLOCATABLE:: SUPPLY
      TYPE(WATER_SOURCES):: H2OSOURCE
      !TYPE(FALLOW_ORDER)      ,DIMENSION(:), ALLOCATABLE:: FALLOW
      !
      LOGICAL:: NEW_FID = TRUE  !SET TO FALSE IF STRESS PERIOD IS REUSING PREVIOUS STRESS PERIODS FID
      !
      INTEGER,                 DIMENSION(:),   ALLOCATABLE:: FALLOW_RANK, MAX_FALLOW_RANK
      INTEGER,                 DIMENSION(:,:), ALLOCATABLE:: FID_ARRAY
      !INTEGER,                 DIMENSION(:,:), ALLOCATABLE:: HIERARCHY_ARRAY
      !
      DOUBLE PRECISION,        DIMENSION(:,:), ALLOCATABLE:: GSE
      DOUBLE PRECISION,        DIMENSION(:,:), ALLOCATABLE:: AREA
      DOUBLE PRECISION,        DIMENSION(:,:), ALLOCATABLE:: DPERC
      DOUBLE PRECISION,        DIMENSION(:,:), ALLOCATABLE:: RUNOFF
      !
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: DEMAND
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: DEMAND_INI
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: DEMAND_POT
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: Q_DEMAND
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: Q_DEMAND_INI
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: CROP_DEMAND      !Total demand -- includes added
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: CROP_DEMAND_ADDED
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: TOT_DIR_RCH
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: TOT_DPERC
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: TOT_RUNOFF
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: TOT_FNRCH
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: TTOT, ETOT, TGWA, EGWA, TIRR, EIRR
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: PRECIP, TPRECIP, EPRECIP
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: IRR_AREA
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: EFF
      DOUBLE PRECISION,        DIMENSION(:,:), ALLOCATABLE:: CROP_VOLR
      DOUBLE PRECISION,        DIMENSION(:,:), ALLOCATABLE:: CROP_FLUX
      !DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: BARE_AREA
      DOUBLE PRECISION,        DIMENSION(:,:), ALLOCATABLE:: CROP_DEMAND_ARRAY
      DOUBLE PRECISION,        DIMENSION(:,:), ALLOCATABLE:: FNRCH
      !INTEGER,                 DIMENSION(:,:), ALLOCATABLE:: WATERSTACK
      !DOUBLE PRECISION,        DIMENSION(:,:), ALLOCATABLE:: OFE
      !
      CHARACTER(20)           ,DIMENSION(:), ALLOCATABLE:: FARM_NAME
      !!!CHARACTER(20)           ,DIMENSION(:), ALLOCATABLE:: PROJ_NAME, DIST_NAME, UNIT_NAME
      !
      !TYPE(LIST_ARRAY_INPUT_INT):: HIERARCHY_TFR
      TYPE(LIST_ARRAY_INPUT_INT):: FID_TFR, FALLOW_RANK_TFR, DEFICIENCY, H2OSOURCE_TFR, EFF_IMPROVE_TFR!, FALLOW_TFR
      TYPE(LIST_ARRAY_INPUT    ):: EFF_TFR
      TYPE(LIST_ARRAY_INPUT    ):: ADRF_TFR
      TYPE(LIST_ARRAY_INPUT    ):: CROP_VOLR_TFR
      TYPE(LIST_ARRAY_INPUT    ):: CROP_FLUX_TFR
      !TYPE(LIST_ARRAY_INPUT    ):: EFL_TFR
      TYPE(LIST_ARRAY_INPUT):: BARE_FRAC_RUNOFF
      !TYPE(LIST_ARRAY_INPUT):: BARE_FRAC_PRECIP
      !INTEGER,DIMENSION(:,:), ALLOCATABLE:: FID_ARRAY, HIERARCHY_ARRAY, EFF
      !
      LOGICAL:: UZF_LINK
      LOGICAL:: HAS_HIERARCHY
      LOGICAL:: HAS_WATERSTACK = FALSE
      LOGICAL:: HAS_CROP = FALSE
      LOGICAL:: HAS_WELL = FALSE
      LOGICAL:: HAS_ALLOT= FALSE
      LOGICAL:: HAS_SOIL = FALSE
      LOGICAL:: HAS_CLIM = FALSE
      LOGICAL:: HAS_SWO  = FALSE
      LOGICAL:: HAS_SALT = FALSE
      LOGICAL:: HAS_SFR  = FALSE
      LOGICAL:: HAS_UZF  = FALSE
      LOGICAL:: HAS_MNW1 = FALSE
      LOGICAL:: HAS_MNW2 = FALSE
      LOGICAL:: HAS_DRT  = FALSE
      LOGICAL:: HAS_NWT  = FALSE
      LOGICAL:: HAS_UPW  = FALSE
      LOGICAL:: HAS_CROP_VOLR
      LOGICAL:: HAS_CROP_FLUX
      LOGICAL:: EFF_IMPROVE = FALSE
      !
      LOGICAL, DIMENSION(:),ALLOCATABLE:: WBS_HAS_ADMD
      LOGICAL, DIMENSION(:),ALLOCATABLE:: CRP_HAS_ADMD
      !
      LOGICAL:: TFR_READ
      !
      CONTAINS
      !
      PROCEDURE, PASS(WBS):: NEXT => SETUP_NEXT_STRESS_PERIOD
      !
      PROCEDURE, PASS(WBS):: SETUP_FID_RC
      !!!PROCEDURE, PASS(WBS):: SETUP_FARM_HIERARCHY_POINTERS
      PROCEDURE, PASS(WBS):: SETUP_FALLOW_FRACTION_ARRAY
      PROCEDURE, PASS(WBS):: SUM_WBS_DEMAND!(WBS)
      PROCEDURE, PASS(WBS):: SUM_WBS_PRECIP!(CLIM%PRECIP)
      PROCEDURE, PASS(WBS):: SUM_WBS_RUNOFF_DPERC
      PROCEDURE, PASS(WBS):: SUM_WBS_DIRECT_RECHARGE
      PROCEDURE, PASS(WBS):: SUM_WBS_FNRCH
      PROCEDURE, PASS(WBS):: CHECK_SOIL_ID
  END TYPE
  !
  CONTAINS
  !
  SUBROUTINE INITIALIZE_WBS_DATA( BL, WBS, LINE, FDIM )  
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL   !DATA BLOCK
    CLASS(WBS_DATA),             INTENT(INOUT):: WBS
    CHARACTER(*),                INTENT(INOUT):: LINE
    TYPE(FMP_DIMENSION),         INTENT(IN   ):: FDIM
    !DOUBLE PRECISION, DIMENSION(:,:), CONTIGUOUS,INTENT(IN   ):: AREA
    CHARACTER(5):: ERROR
    LOGICAL:: EOF
    INTEGER:: I, LLOC, ISTART, ISTOP, IU, NIRRG
    CHARACTER(6):: BYFARM, BYCROP
    TYPE(WARNING_TYPE):: WARN_MSG
    BYFARM = 'BYWBS'
    BYCROP = 'BYCROP'
    !
    WRITE(BL%IOUT,'(/A/)') 'WBS BLOCK FOUND AND NOW LOADING PROPERTIES'
    !
    ERROR='ERROR'
    CALL WARN_MSG%INIT()
    !
    WBS%ITMUNI=FDIM%ITMUNI
    WBS%NCOL = FDIM%NCOL
    WBS%NROW = FDIM%NROW
    !
    WBS%NFARM = FDIM%NFARM
    WBS%NCROP = FDIM%NCROP
    WBS%NPROJ = FDIM%NPROJ
    WBS%NDIST = FDIM%NDIST
    WBS%NUNIT = FDIM%NUNIT
    WBS%NAUXDEM = FDIM%NAUXDEM
    WBS%UZF_LINK = FDIM%UZF_LINK
    !
    WBS%IOUT = BL%IOUT
    WBS%LOUT = BL%IOUT
    WBS%HAS_HIERARCHY = FDIM%HAS_HIERARCHY
    WBS%TFR_READ      = FALSE
    !
    NIRRG = FDIM%NIRRG
    IF(NIRRG < ONE) NIRRG = ONE
    !
    ALLOCATE(WBS%INUSE(WBS%NFARM), SOURCE=FALSE)
    !
    ALLOCATE(WBS%FID(WBS%NFARM))
    DO CONCURRENT(I=ONE:WBS%NFARM) 
                                  WBS%FID(I)%NF = I
    END DO
    !
    ALLOCATE( WBS%DEMAND      (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%DEMAND_INI  (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%DEMAND_POT  (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%Q_DEMAND    (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%Q_DEMAND_INI(WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%CROP_DEMAND (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%TOT_DPERC   (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%TOT_DIR_RCH (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%TOT_RUNOFF  (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%TOT_FNRCH   (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%EFF         (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%PRECIP      (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%TPRECIP     (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%EPRECIP     (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%TTOT        (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%ETOT        (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%TIRR        (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%EIRR        (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%TGWA        (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%EGWA        (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%IRR_AREA    (WBS%NFARM), SOURCE = DZ )
    !
    ALLOCATE( WBS%SUPPLY      (WBS%NFARM) )
    ALLOCATE( WBS%CROP        (WBS%NFARM) )
    !!!ALLOCATE( WBS%FARM        (WBS%NFARM) )
    ALLOCATE( WBS%FARM_NAME   (WBS%NFARM) )
    !
    ALLOCATE(WBS%CROP_DEMAND_ADDED(WBS%NFARM), SOURCE = DZ)
    !
    !!!IF(WBS%NAUXDEM > Z) ALLOCATE(WBS%AUX_DEMAND(WBS%NAUXDEM))
    !
    ALLOCATE(WBS%FID_ARRAY        (FDIM%NCOL,FDIM%NROW), SOURCE = NINER )
    ALLOCATE(WBS%FNRCH            (FDIM%NCOL,FDIM%NROW) , &
             WBS%CROP_DEMAND_ARRAY(FDIM%NCOL,FDIM%NROW) , &
             WBS%DPERC            (FDIM%NCOL,FDIM%NROW) , &
             WBS%RUNOFF           (FDIM%NCOL,FDIM%NROW), SOURCE=DZ )
    !
    !ALLOCATE(WBS%OFE(FDIM%NCOL,FDIM%NROW))
    !
    CALL WBS%H2OSOURCE%ALLOC(WBS%NFARM)
    WBS%H2OSOURCE%GW  = TRUE
    WBS%H2OSOURCE%SW  = TRUE
    WBS%H2OSOURCE%NRD = TRUE
    
    ALLOCATE(WBS%AREA(WBS%NCOL,WBS%NROW))
    WBS%AREA = DIS_AREA    !REDUNDANT FROM BAS BECAUSE THERE MAYBE A TIME TO HAVE FMP GRID BE INDEPENDENT OF MODEL GRID.  --WHEN MADE GRID INDEPENDENT, REMOVE AND CALCULATE AREA
    !
    !!!DO CONCURRENT (I=ONE:WBS%NFARM)
    !!!                             WBS%FARM(I)%UNIT = I
    !!!                             WBS%FARM(I)%DIST = I
    !!!                             WBS%FARM(I)%PROJ = I    
    !!!END DO
    !!!!
    !!!IF(WBS%HAS_HIERARCHY) THEN
    !!!                          ALLOCATE(WBS%HIERARCHY_ARRAY(THREE, FDIM%NFARM + FDIM%NAUXDEM), SOURCE=Z)
    !!!                          ALLOCATE(WBS%PROJ(FDIM%NPROJ))
    !!!                          ALLOCATE(WBS%DIST(FDIM%NDIST))
    !!!                          ALLOCATE(WBS%UNIT(FDIM%NUNIT))
    !!!                          !
    !!!                          ALLOCATE(WBS%PROJ_NAME(FDIM%NPROJ))
    !!!                          ALLOCATE(WBS%DIST_NAME(FDIM%NDIST))
    !!!                          ALLOCATE(WBS%UNIT_NAME(FDIM%NUNIT))
    !!!                          WBS%PROJ_NAME = BLNK
    !!!                          WBS%DIST_NAME = BLNK
    !!!                          WBS%UNIT_NAME = BLNK
    !!!END IF
    ! 
    DO CONCURRENT(I=ONE:WBS%NFARM); WBS%FARM_NAME(I) = 'FARM_'//NUM2STR(I,THREE,TRUE)
    END DO
    !
    CALL BL%MAKE_SCRATCH_FILE()
    !
    !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
    CALL BL%READ_SCRATCH(EOF,LINE)
    !
    DO WHILE (.NOT. EOF)
      !
      LLOC=ONE
      CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
      !
      SELECT CASE ( LINE(ISTART:ISTOP) )
      ! %INIT(TYP, LLOC, LINE, IOUT, IN, LDIM1, LDIM2, NROW, NCOL,EX1_DIM, EX1_WORD, EX2_DIM, EX2_WORD)
      CASE ("LOCATION")
                        WRITE(BL%IOUT,'(A)') '   LOCATION                         KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND FIRST LOCATION ARRAY.'
                        CALL WBS%FID_TFR%INIT('LOCATION', LLOC, LINE, BL%IOUT, BL%IU, Z, Z, FDIM%NROW, FDIM%NCOL, SCRATCH=BL%SCRATCH)  !, FDIM%NFARM, 'BYWBS', FDIM%NCROP, 'BYCROP'
      !
      CASE ("DEFICIENCY","DEFICIENCY_SCENARIO")
                        IF(LINE(ISTART:ISTOP) == "DEFICIENCY") CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP)
                        WRITE(BL%IOUT,'(A)') '   DEFICIENCY_SCENARIO              KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND LIST INPUT OF DEFICIENCY FLAG BY WBS.'
                        CALL WBS%DEFICIENCY%INIT('DEFICIENCY_SCENARIO', LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM, ONE, Z, Z, SCRATCH=BL%SCRATCH)  !, FDIM%NFARM, 'BYWBS', FDIM%NCROP, 'BYCROP'
      !
      CASE ("PRORATE","PRORATE_DEFICIENCY")
                        IF(LINE(ISTART:ISTOP) == "PRORATE") CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP)
                        WRITE(BL%IOUT,'(A)') '   PRORATE_DEFICIENCY               KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND LIST INPUT OF DEFICIENCY FLAG BY WBS.'
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        SELECT CASE(LINE(ISTART:ISTOP))
                        CASE("BYAVERAGE","BYAVE"); WBS%PRORATE_DEFICIENCY = Z   !BY AVERAGE SUPPLY
                        CASE("BYDEMAND");          WBS%PRORATE_DEFICIENCY = ONE !   --DEFAULT
                        CASE DEFAULT;              CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FOUND "PRORATE_DEFICIENCY" KEYWORD,'//NL//'WHICH MUST BE FOLLOWED BY EITHER "ByAVERAVE" OR "ByDEMAND".')
                        END SELECT
      !
      CASE ("EFFICIENCY", "EFF")
                        WRITE(BL%IOUT,'(A)') '   EFFICIENCY (EFF)                 KEYWORD FOUND. NOW LOADING LIST/ARRAY KEY AND STATIC/TRANSIENT KEYWORDS AND FIRST SET OF EFFICIENCIES.'
                        IF(FDIM%NIRRG > Z) THEN
                            CALL WBS%EFF_TFR%INIT('EFF', LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM, FDIM%NIRRG, FDIM%NROW, FDIM%NCOL, FDIM%NFARM, BYFARM, FDIM%NCROP, BYCROP, FDIM%NIRRG, 'BYIRRIGATE', SCRATCH=BL%SCRATCH, LISTARRAY=TRUE)  !, MSG='ALSO PLEASE DOUBLE CHECK THAT NIRRIGATE IN THE GLOBAL DIMENSION BLOCK IS SET UP CORRECTLY. EFFICIENCY EXPECTS TO READ AN ID COLUMN AND THEN NIRRIGATE COLUMNS OF EFECIENCIES.'
                        ELSE
                            CALL WBS%EFF_TFR%INIT('EFF', DZ, BL%IOUT, BL%IU, FDIM%NFARM, NIRRG, FDIM%NROW, FDIM%NCOL)
                            CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP WBS BLOCK: FOUND KEYWORD "EFFICIENCY" WHEN NIRRIGATE = 0. THIS LINE WILL BE IGNORED AND THE EFFICIENCY SET TO 0.0 FOR ALL WBS (FARMS).',CMD_PRINT=TRUE)
                        END IF
                        !
      CASE ("EFFICIENCY_IMPROVEMENT","EFF_IMPROVE")
                        WRITE(BL%IOUT,'(A)') '   EFFICIENCY_IMPROVEMENT           KEYWORD FOUND. NOW LOADING LIST/ARRAY KEY AND STATIC/TRANSIENT KEYWORDS AND FIRST SET OF EFFICIENCY IMPROVEMENT FLAGS (0 OR 1).'
                        IF(FDIM%NIRRG > Z) THEN
                            CALL WBS%EFF_IMPROVE_TFR%INIT('EFF_IMPROVE', LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM, FDIM%NIRRG, FDIM%NROW, FDIM%NCOL, SCRATCH=BL%SCRATCH, LISTARRAY=TRUE)
                        ELSE
                            CALL WBS%EFF_IMPROVE_TFR%INIT('EFF_IMPROVE', Z, BL%IOUT, BL%IU, FDIM%NFARM, NIRRG, FDIM%NROW, FDIM%NCOL, LISTARRAY=TRUE)
                            CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP WBS BLOCK: FOUND KEYWORD "EFFICIENCY_IMPROVEMENT" WHEN NIRRIGATE = 0. THIS LINE WILL BE IGNORED AND THE IMPROVEMENT FLAG SET TO 0 FOR ALL WBS (FARMS).',CMD_PRINT=TRUE)
                        END IF
                        !
      CASE ("ADDED_DEMAND_RUNOFF_SPLIT", "ADRS")
                        WRITE(BL%IOUT,'(A)') '   ADDED_DEMAND_RUNOFF_SPLIT (ADRS) KEYWORD FOUND. NOW LOADING LIST/ARRAY KEY AND STATIC/TRANSIENT KEYWORDS AND FIRST SET OF EFFICIENCIES.'
                        IF(FDIM%NIRRG > Z) THEN
                            CALL WBS%ADRF_TFR%INIT('ADRS', LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM, FDIM%NIRRG, FDIM%NROW, FDIM%NCOL, FDIM%NFARM, BYFARM, FDIM%NCROP, BYCROP, FDIM%NIRRG, 'BYIRRIGATE', SCRATCH=BL%SCRATCH, LISTARRAY=TRUE)
                        ELSE
                            CALL WBS%ADRF_TFR%INIT('ADRS', DZ, BL%IOUT, BL%IU, FDIM%NFARM, NIRRG, FDIM%NROW, FDIM%NCOL, LISTARRAY=TRUE)
                            CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP WBS BLOCK: FOUND KEYWORD "ADDED_DEMAND_RUNOFF_SPLIT" WHEN NIRRIGATE = 0. THIS LINE WILL BE IGNORED AND THE EFFICIENCY SET TO 0.0 FOR ALL WBS (FARMS).',CMD_PRINT=TRUE)
                        END IF
                        !
      CASE ("ADDED_CROP_DEMAND","CDMD")
                        WRITE(BL%IOUT,'(A)') '   ADDED_CROP_DEMAND (CDMD)         KEYWORD FOUND. NOW LOADING LENGTH (OR FLUX) OR RATE KEYWORDS THEN STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        SELECT CASE ( LINE(ISTART:ISTOP) )
                        CASE("LENGTH","FLUX")
                                               IF(WBS%CROP_FLUX_TFR%INUSE) CALL STOP_ERROR(OUTPUT=WBS%LOUT, MSG='FMP WBS BLOCK ERROR. YOU MAY ONLY SPECIFY KEYWORD "ADDED_CROP_DEMAND LENGTH" AT MOST ONE TIME. YOU MY SPECIFY "ADDED_CROP_DEMAND LENGTH" AND "ADDED_CROP_DEMAND RATE" AS TWO SEPARATE INPUTS (DIFFERENT LINES), BUT YOU MAY NOT SPECIFY THEM TWICE.')
                                               CALL WBS%CROP_FLUX_TFR%INIT('CDMD_FLUX',LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM, FDIM%NCROP, Z, Z, FDIM%NFARM, BYFARM, FDIM%NCROP, BYCROP,SCRATCH=BL%SCRATCH, LISTARRAY=TRUE)
                                               ALLOCATE(WBS%CROP_FLUX(FDIM%NFARM,FDIM%NCROP))
                        CASE("RATE")
                                               IF(WBS%CROP_VOLR_TFR%INUSE) CALL STOP_ERROR(OUTPUT=WBS%LOUT, MSG='FMP WBS BLOCK ERROR. YOU MAY ONLY SPECIFY KEYWORD "ADDED_CROP_DEMAND RATE" AT MOST ONE TIME. YOU MY SPECIFY "ADDED_CROP_DEMAND RATE" AND "ADDED_CROP_DEMAND LENGTH" AS TWO SEPARATE INPUTS (DIFFERENT LINES), BUT YOU MAY NOT SPECIFY THEM TWICE.')
                                               CALL WBS%CROP_VOLR_TFR%INIT('CDMD_VOLR',LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM, FDIM%NCROP, Z, Z, FDIM%NFARM, BYFARM, FDIM%NCROP, BYCROP,SCRATCH=BL%SCRATCH, LISTARRAY=TRUE)
                                               ALLOCATE(WBS%CROP_VOLR(FDIM%NFARM,FDIM%NCROP))
                        CASE DEFAULT;          CALL STOP_ERROR(OUTPUT=WBS%LOUT, MSG='FMP WBS BLOCK ERROR. IF YOU SPECIFY KEYWORD "ADDED_CROP_DEMAND", YOU MUST FOLLOW IT WITH THE KEYWORD "LENGTH" OR "RATE"'//NL//'TO INDICATE ADDED DEMAND IS LENGTH PER TIME OR VOLUME PER TIME.')
                        END SELECT
                        !
      CASE ("BARE_RUNOFF_FRACTION", "FALLOW_RUNOFF_FRACTION", "BARE_RUNOFF_FRAC", "BFR")
                        WRITE(BL%IOUT,'(A)') '   BARE_RUNOFF_FRACTION (BFR)       KEYWORD FOUND. NOW LOADING LIST/ARRAY KEY AND STATIC/TRANSIENT KEYWORDS AND FIRST SET OF FRACTIONS.'
                        CALL WBS%BARE_FRAC_RUNOFF%INIT('BFR',LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM, ONE, FDIM%NROW, FDIM%NCOL, FDIM%NFARM, BYFARM, SCRATCH=BL%SCRATCH)
                        !
      !CASE ("BARE_PRECIP_CONSUMPTION_FRACTION", "BARE_PRECIPITATION_CONSUMPTION_FRACTION", "BFP")
      !                  WRITE(BL%IOUT,'(A)') '   BARE_RUNOFF_FRACTION (BFR)       KEYWORD FOUND. NOW LOADING LIST/ARRAY KEY AND STATIC/TRANSIENT KEYWORDS AND FIRST SET OF FRACTIONS.'
      !                  CALL WBS%BARE_FRAC_PRECIP%INIT('BFR',LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM, ONE, FDIM%NROW, FDIM%NCOL, FDIM%NFARM, BYFARM, SCRATCH=BL%SCRATCH)
      !
      CASE ("WATERSOURCE", "WATER_SOURCE", "H2OSRC")
                        IF(LINE(ISTART:ISTOP) == "WATER") CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP)
                        WRITE(BL%IOUT,'(A)') '   WATER_SOURCE (H2OSRC)                         KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND LIST OF FARMS AND WHAT WATER SOURCES THEY HAVE TO PROVIDE WATER SUPPLIES.'
                        CALL WBS%H2OSOURCE_TFR%INIT('H2OSRC', LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM, THREE, Z, Z, SCRATCH=BL%SCRATCH)  !, FDIM%NFARM, 'BYWBS', FDIM%NCROP, 'BYCROP'
      !
      !CASE ("HIERARCHY")
      !                  WRITE(BL%IOUT,'(A)') '   HIERARCHY                        KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND FIRST LIST OF HIERARCHYS.'
      !                  IF(.NOT. WBS%HAS_HIERARCHY) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FOUND "HIERARCHY" KEYWORD, WHICH REQUIRES REQUIRES THAT "NPROJ", "NDIST", AND "NUNIT" BE SPECIFIED AND SET TO GREATER THAN ZERO IN THE GLOBAL DIMENSION BLOCK. PLEASE DOUBLE CHECK BLOCK SET UP.')
      !                  CALL WBS%HIERARCHY_TFR%INIT('HIERARCHY', LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM+FDIM%NAUXDEM, THREE, Z, Z, SCRATCH=BL%SCRATCH)  !, FDIM%NFARM, 'BYWBS', FDIM%NCROP, 'BYCROP'
      !
      CASE ("WBS_NAME","FARM_NAME", "NAME")
                        WRITE(BL%IOUT,'(A)') '   FARM_NAME                        KEYWORD FOUND. NOW LOADING WBS NAMES.'
                        IU = Z
                        CALL ULOAD(WBS%FARM_NAME, LLOC, LINE, BL%IOUT, BL%IU, IU, SCRATCH=BL%SCRATCH)
      !!!CASE ("PROJ_NAME")
      !!!                  WRITE(BL%IOUT,'(A)') '   PROJ_NAME                        KEYWORD FOUND. NOW LOADING PROJECT NAMES.'
      !!!                  IF(WBS%HAS_HIERARCHY) THEN
      !!!                      IU = Z
      !!!                      CALL ULOAD(WBS%PROJ_NAME, LLOC, LINE, BL%IOUT, BL%IU, IU, SCRATCH=BL%SCRATCH)
      !!!                  ELSE
      !!!                      CALL STOP_ERROR(LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG='FOUND KEYWORD "PROJ_NAME", WHICH REQUIRES THAT "NPROJ", "NDIST", AND "NUNIT" BE SPECIFIED AND SET TO GREATER THAN ZERO IN THE GLOBAL DIMENSION BLOCK. PLEASE DOUBLE CHECK BLOCK SET UP.')
      !!!                  END IF
      !!!CASE ("DIST_NAME")
      !!!                  WRITE(BL%IOUT,'(A)') '   DIST_NAME                        KEYWORD FOUND. NOW LOADING DSTRICT NAMES.'
      !!!                  IF(WBS%HAS_HIERARCHY) THEN
      !!!                      IU = Z
      !!!                      CALL ULOAD(WBS%DIST_NAME, LLOC, LINE, BL%IOUT, BL%IU, IU, SCRATCH=BL%SCRATCH)
      !!!                  ELSE
      !!!                      CALL STOP_ERROR(LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG='FOUND KEYWORD "DIST_NAME", WHICH REQUIRES THAT "NPROJ", "NDIST", AND "NUNIT" BE SPECIFIED AND SET TO GREATER THAN ZERO IN THE GLOBAL DIMENSION BLOCK. PLEASE DOUBLE CHECK BLOCK SET UP.')
      !!!                  END IF
      !!!CASE ("UNIT_NAME")
      !!!                  WRITE(BL%IOUT,'(A)') '   UNIT_NAME                        KEYWORD FOUND. NOW LOADING UNIT NAMES.'
      !!!                  IF(WBS%HAS_HIERARCHY) THEN
      !!!                      IU = Z
      !!!                      CALL ULOAD(WBS%UNIT_NAME, LLOC, LINE, BL%IOUT, BL%IU, IU, SCRATCH=BL%SCRATCH)
      !!!                  ELSE
      !!!                      CALL STOP_ERROR(LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG='FOUND KEYWORD "UNIT_NAME", WHICH REQUIRES THAT "NPROJ", "NDIST", AND "NUNIT" BE SPECIFIED AND SET TO GREATER THAN ZERO IN THE GLOBAL DIMENSION BLOCK. PLEASE DOUBLE CHECK BLOCK SET UP.')
      !!!                  END IF
      CASE DEFAULT
                        CALL WARN_MSG%ADD('FOUND UNKNOWN KEYWORD "'//LINE(ISTART:ISTOP)//'" ***IT WILL BE IGNORED***'//BLN)
      !
      !!!CASE ("IRRIGATION_IMMEDIATE_EVAPORATION")
      !!!                  WRITE(BL%IOUT,'(A)') '   EVAPORATION_LOSS_FRACTION KEYWORD FOUND. NOW LOADING LIST/ARRAY KEY AND STATIC/TRANSIENT KEYWORDS AND FIRST SET OF EFFICIENCIES.'
      !!!                  IF(FDIM%NIRRG > Z) THEN
      !!!                      CALL WBS%EFL_TFR%INIT('ELF', LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM, FDIM%NIRRG, FDIM%NROW, FDIM%NCOL, FDIM%NFARM, BYFARM, FDIM%NCROP, BYCROP, FDIM%NIRRG, 'BYIRRIGATE', SCRATCH=BL%SCRATCH)
      !!!                  ELSE
      !!!                      LLOC=ONE
      !!!                      LINE = 'CONSTANT 0D0 '
      !!!                      CALL WBS%EFL_TFR%INIT('ELF', LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM, NIRRG, FDIM%NROW, FDIM%NCOL, FDIM%NFARM, BYFARM, FDIM%NCROP, BYCROP, NIRRG, 'BYIRRIGATE', SCRATCH=BL%SCRATCH)
      !!!                      CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP WBS BLOCK: FOUND KEYWORD "" WHEN NIRRIGATE = 0. THIS LINE WILL BE IGNORED AND THE EFFICIENCY SET TO 0.0 FOR ALL WBS (FARMS).',CMD_PRINT=TRUE)
      !!!                  END IF
      !
      !CASE ("FALLOW_RANK")
      !                  WRITE(BL%IOUT,'(A)') '   FALLOW_RANK         KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND LIST OF FARMS OR LOCATIONS THAT ALLOW WATER STACKING. MAKE SURE TO SET THE "FOLLOW" KEYWORD.'
      !                  CALL WBS%FALLOW_RANK_TFR%INIT('WSTACK', LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM, FDIM%NCROP, FDIM%NROW, FDIM%NCOL, SCRATCH=BL%SCRATCH) 
      !                  ALLOCATE(WBS%FALLOW_RANK(FDIM%NFARM), WBS%MAX_FALLOW_RANK(FDIM%NFARM))
      !                  WBS%HAS_WATERSTACK = TRUE
      !
      !CASE ("FALLOW_RESET")
      !                  WRITE(BL%IOUT,'(A)') '   FALLOW_RESET KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND LIST OF FARMS OR LOCATIONS THAT ALLOW WATER STACKING. MAKE SURE TO SET THE "FOLLOW" KEYWORD.'
      !                  CALL WBS%FALLOW_RESET_TFR%INIT('WSTACK', LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM, FDIM%NCROP, FDIM%NROW, FDIM%NCOL, SCRATCH=BL%SCRATCH) 
      END SELECT
      !
      !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE 
      CALL BL%READ_SCRATCH(EOF, LINE)
      !
    END DO
    !
    CALL WARN_MSG%CHECK(HED='FMP WBS BLOCK'//NL,INFILE=BL%IU,OUTPUT=BL%IOUT,INLINE=TRUE,CMD_PRINT=TRUE,TAIL=NL,INIT=TRUE)
    !
    IF(.NOT. WBS%FID_TFR%INUSE) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FAILED TO LOCATE KEYWORD "LOCATION" WITHIN FMP WBS BLOCK. PLEASE DOUBLE CHECK BLOCK SET UP.') 
    IF(.NOT. WBS%EFF_TFR%INUSE) THEN
        IF(FDIM%NIRRG>Z) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FAILED TO LOCATE KEYWORD "EFFICIENCY" WITHIN FMP WBS BLOCK.'//BLN//'IT IS A REQUIRED INPUT IF YOU HAVE NIRRIGATE > 0.'//BLN//'IF YOU DO NOT HAVE IRRIGATION, YOU MUST SET NIRRIGATE=0 IN THE GLOBAL DIMENSION BLOCK.'//BLN//'PLEASE DOUBLE CHECK BLOCK SET UP.') 
        !
        CALL WBS%EFF_TFR%INIT('EFF', DZ, BL%IOUT, BL%IU, FDIM%NFARM, NIRRG, FDIM%NROW, FDIM%NCOL, LISTARRAY=TRUE)
    END IF
    !
    IF(.NOT. WBS%ADRF_TFR%INUSE .AND. FDIM%NIRRG>Z) THEN
        !CALL WBS%ADRF_TFR%INIT('ADRS', TENTH, BL%IOUT, BL%IU, FDIM%NFARM, NIRRG, FDIM%NROW, FDIM%NCOL, LISTARRAY=TRUE)
        CALL WARN_MSG%ADD('FMP WBS BLOCK FAILED TO LOCATE KEYWORD "ADDED_DEMAND_RUNOFF_SPLIT" WHEN NIRRIGATE > 0.'//NL//'THIS FRACTION IS THE SPLIT OF RUNOFF TO DEEP PERCOLATION OF ANY ADDITIONAL DEMAND SPECIFIED FOR CROPS.'//NL//'THE SPLIT IS AUTOMATICALLY SET TO 0.1 (10% BECOMES RUNOFF AND 90% DEEP PERCOLATION) FOR ALL WBS (FARMS) AND IRRIGATION TYPES.'//BLN)
    END IF
    !
    !!!IF(.NOT. WBS%EFL_TFR%INUSE .AND. FDIM%NIRRG>Z) THEN
    !!!    LLOC=ONE
    !!!    LINE = 'CONSTANT 0D0 '
    !!!    CALL WBS%EFL_TFR%INIT('EFL', LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM, NIRRG, FDIM%NROW, FDIM%NCOL, FDIM%NFARM, BYFARM, FDIM%NCROP, BYCROP, NIRRG, 'BYIRRIGATE', SCRATCH=BL%SCRATCH)
    !!!END IF
    !
    IF(.NOT. WBS%BARE_FRAC_RUNOFF%INUSE) THEN
                                               CALL WARN_MSG%ADD('FAILED TO LOCATE "BARE_RUNOFF_FRACTION" KEYWORD.'//NL//'THE FACTION OF PRECIPITATION TO RUNOFF FOR FALLOW/BARE LAND IS AUTOMATICALLY SET TO 1.'//BLN)
                                               !
                                               CALL WBS%BARE_FRAC_RUNOFF%INIT('BFR',UNO, BL%IOUT, BL%IU, FDIM%NFARM, ONE, FDIM%NROW, FDIM%NCOL)
    END IF
    !
    !IF(.NOT. WBS%BARE_FRAC_PRECIP%INUSE) THEN
    !                                           CALL WARN_MSG%ADD('FAILED TO LOCATE "BARE_PRECIP_CONSUMPTION_FRACTION" KEYWORD.'//NL//'THE FACTION OF AVAILIBLE FOR EVAPORATION OVER BARE/FALLOW SOIL IS AUTOMATICALLY SET TO 1.'//BLN)
    !                                           !
    !                                           CALL WBS%BARE_FRAC_PRECIP%INIT('BFP',UNO, BL%IOUT, BL%IU, FDIM%NFARM, ONE, FDIM%NROW, FDIM%NCOL)
    !END IF
    !
    !IF(.NOT. WBS%HIERARCHY_TFR%INUSE .AND. WBS%HAS_HIERARCHY) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='"NPROJ", "NDIST", "NUNIT", OR "NAUXDEM" WERE SPECIFIED AND GREATER THAN ZERO,'//NL//'BUT FAILED TO LOCATION KEYWORD "HIERARCHY" TO LOAD THE RELATIONSHIP BETWEEN THEM.'//NL//'PLEASE DOUBLE CHECK BLOCK SET UP.')
    !
    IF(.NOT. WBS%DEFICIENCY%INUSE) THEN
                            CALL WBS%DEFICIENCY%INIT('DEFF', ONE, BL%IOUT, BL%IU, FDIM%NFARM, ONE, Z, Z)  !, FDIM%NFARM, 'BYWBS', FDIM%NCROP, 'BYCROP'
                            CALL WARN_MSG%ADD('FAILED TO LOCATE KEYWORD "DEFICIENCY_SCENARIO" WITHIN FMP WBS BLOCK.'//NL//'IT WILL BE SET TO THE DEFAULT "DEFICIT IRRIGATION SCENARIO" (1),'//NL//'SO IRRIGATED CROPS THAT DO NOT HAVE ENOUGH SUPPLY WILL ONLY USE THE AVAILIBLE WATER AND NOT HAVE EXTERNAL WATER FROM SOURCES BEYOND THE MODEL INSTEAD OF DEFICIT IRRIGATE.'//NL//'IF YOU WANT TO USE THE ZERO SCENARIO OR HAVE A MIXTURE OF DEFICIT AND EXZTERNAL WATER IRRIGATION PRACTICES, PLEASE INCLUDE THE "DEFICIENCY_SCENARIO" KEYWORD FOLLOWED BY NFARM ZEROS AND ONES'//NL//'TO INDICATE IF THE WBS RECIEVES EXTERNAL WATER OR DEFICIT IRRIGATES.'//BLN)
                        
    END IF
    !
    IF(.NOT. WBS%EFF_IMPROVE_TFR%INUSE) THEN
        !
        CALL WBS%EFF_IMPROVE_TFR%INIT('EFF_IMPROVE', Z, BL%IOUT, BL%IU, FDIM%NFARM, NIRRG, FDIM%NROW, FDIM%NCOL, LISTARRAY=TRUE)  ! NIRRG = 1 or FDIM%NIRRG
        !       HAS DEFICIT IRR SCENARIO   MAY HAVE DEFICIT IRR SCENARIO 
        !IF(FDIM%NIRRG > Z .AND. (ANY(WBS%DEFICIENCY%LIST.NE.Z).OR.WBS%DEFICIENCY%TRANSIENT)) CALL WARN_MSG%ADD('FAILED TO LOCATE KEYWORD "EFFICIENCY_IMPROVEMENT" WITHIN FMP WBS BLOCK.'//NL//'IT WILL BE SET TO 0, WHICH INDICATES EFFICIENCIES ARE NOT IMPROVED UNDER DEFICIT IRRIGATION SCENARIOS.'//NL//'THIS KEEPS THE EFFICIENCY THE SAME AS IT IS SPECIFIED BY INPUT AND IS THE RECOMMEND OPTION.'//BLN)
    END IF
    !
    CALL WARN_MSG%CHECK('FMP WBS BLOCK: THE FOLLOWING ARE WARNING MESSAGES RECIEVED WHILE LOADING AND PROCESSING THE WBS BLOCK INPUT.',BL%IU,BL%IOUT)
    !
    WBS%HAS_CROP_FLUX = WBS%CROP_FLUX_TFR%INUSE
    WBS%HAS_CROP_VOLR = WBS%CROP_VOLR_TFR%INUSE
    !
    IF(WBS%HAS_CROP_FLUX .OR. WBS%HAS_CROP_VOLR) THEN
                                                 ALLOCATE(WBS%WBS_HAS_ADMD(FDIM%NFARM), SOURCE=FALSE)
                                                 ALLOCATE(WBS%CRP_HAS_ADMD(FDIM%NCROP), SOURCE=FALSE)    
    END IF
    !
  END SUBROUTINE 
  !
  SUBROUTINE SETUP_NEXT_STRESS_PERIOD(WBS)
    CLASS(WBS_DATA),        INTENT(INOUT):: WBS
    INTEGER:: I, F
    LOGICAL:: UPDATE
    !
    IF(WBS%TFR_READ) THEN
                         UPDATE = FALSE
                         !
                         CALL WBS%FID_TFR%NEXT()
                         !
                         IF(WBS%FID_TFR%TFR%REPEAT) THEN
                                                    WBS%NEW_FID = FALSE
                         ELSE
                                                    WBS%NEW_FID = TRUE  !ASSUME ITS TRUE UPDATED IN CALL WBS%SETUP_FID_RC()
                         END IF
                         !
                         CALL WBS%EFF_TFR         %NEXT()
                         CALL WBS%ADRF_TFR        %NEXT()
                         CALL WBS%EFF_IMPROVE_TFR %NEXT()
                         CALL WBS%BARE_FRAC_RUNOFF%NEXT()
                         !CALL WBS%BARE_FRAC_PRECIP%NEXT()
                         CALL WBS%DEFICIENCY      %NEXT()
                         !CALL WBS%HIERARCHY_TFR   %NEXT()
                         CALL WBS%FALLOW_RANK_TFR %NEXT()
                         CALL WBS%H2OSOURCE_TFR   %NEXT()
                         CALL WBS%CROP_FLUX_TFR   %NEXT()
                         CALL WBS%CROP_VOLR_TFR   %NEXT()
                         !CALL WBS%EFL_TFR         %NEXT()
                         !
                         !CALL WBS%FID_TFR%NEXT()
                         !
                         !!
                         !CALL WBS%HIERARCHY_TFR%NEXT()                              
                         !IF(WBS%HIERARCHY_TFR%TRANSIENT) CALL WBS%SETUP_FARM_HIERARCHY_POINTERS() !TRANSIENT WILL NEVER BE TRUE IF NOT INUSE
                         !!
                         !CALL WBS%EFF_TFR%NEXT()
    ELSE
        WBS%TFR_READ = TRUE
        UPDATE = TRUE
    END IF
    !
    IF(UPDATE .OR. WBS%NEW_FID) THEN
        !
        CALL WBS%SETUP_FID_RC()  !SETS WBS%NEW_FID
        !
        IF(WBS%NEW_FID) UPDATE = TRUE  !FORCE UPDATE DUE TO NEW FID ARRAY
        !
    END IF
    !
    !!!IF(WBS%HAS_HIERARCHY .AND. (WBS%HIERARCHY_TFR%TRANSIENT .OR. UPDATE)) CALL WBS%SETUP_FARM_HIERARCHY_POINTERS() !TRANSIENT WILL NEVER BE TRUE IF NOT INUSE
    !
    IF(WBS%HAS_WATERSTACK .AND. (WBS%FALLOW_RANK_TFR%TRANSIENT .OR. UPDATE) ) THEN
          !
          WBS%FALLOW_RANK = Z
          IF (WBS%FALLOW_RANK_TFR%LISTARRAY) THEN  !NOTE IT IS EITHER A LISTARRAY OR ARRAY
              DO CONCURRENT (F=ONE:WBS%NFARM)
                                             WBS%MAX_FALLOW_RANK(F) = MAXVAL(WBS%FALLOW_RANK_TFR%ARRAY(:,F))
              END DO
          ELSE
              DO CONCURRENT (F=ONE:WBS%NFARM)
                                             WBS%MAX_FALLOW_RANK(F) = MAXVAL( WBS%FALLOW_RANK_TFR%ARRAY, MASK = WBS%FID_ARRAY==F )
              END DO
          END IF
          !
    END IF
    !
    !
    IF (UPDATE .OR. WBS%EFF_IMPROVE_TFR%TRANSIENT) THEN
        IF( WBS%EFF_IMPROVE_TFR%LISTLOAD) THEN
            WBS%EFF_IMPROVE = ANY(WBS%EFF_IMPROVE_TFR%LIST  > Z)
        ELSE
            WBS%EFF_IMPROVE = ANY(WBS%EFF_IMPROVE_TFR%ARRAY > Z)
        END IF
  END IF
    !
    !
    IF(WBS%HAS_CROP_FLUX) THEN;  IF (UPDATE .OR. WBS%CROP_FLUX_TFR%TRANSIENT) THEN
            !
            WBS%CROP_FLUX = TRANSPOSE(WBS%CROP_FLUX_TFR%ARRAY)
            !    
            ASSOCIATE(SFAC=>WBS%CROP_FLUX_TFR%SFAC)
                !
                IF(SFAC%HAS_ALL) WBS%CROP_FLUX = WBS%CROP_FLUX * SFAC%ALL
                !
                IF(SFAC%HAS_EX1) THEN
                    DO CONCURRENT (I=ONE:WBS%NCROP, F=ONE:WBS%NFARM)
                          !
                          WBS%CROP_FLUX(F,I) = WBS%CROP_FLUX(F,I) * SFAC%EX1(F)
                          !
                    END DO
                END IF
                !  
                IF(SFAC%HAS_EX2) THEN
                    DO CONCURRENT (I=ONE:WBS%NCROP, F=ONE:WBS%NFARM)
                          !
                          WBS%CROP_FLUX(F,I) = WBS%CROP_FLUX(F,I) * SFAC%EX2(I)
                          !
                    END DO
                END IF
            END ASSOCIATE
            !
            DO CONCURRENT (I=ONE:WBS%NCROP, F=ONE:WBS%NFARM, NEAR_ZERO(WBS%CROP_FLUX(F,I)))
                  !
                  WBS%CROP_FLUX(F,I) = DZ
                  !
            END DO
            !
    END IF; END IF
    !
    IF(WBS%HAS_CROP_VOLR) THEN;  IF (UPDATE .OR. WBS%CROP_VOLR_TFR%TRANSIENT) THEN
            !
            DO CONCURRENT(I=ONE:WBS%NCROP, F=ONE:WBS%NFARM)
                                                     WBS%CROP_VOLR(F,I) = WBS%CROP_VOLR_TFR%ARRAY(I,F)
            END DO
            !    
            ASSOCIATE(SFAC=>WBS%CROP_VOLR_TFR%SFAC)
                !
                IF(SFAC%HAS_ALL) WBS%CROP_VOLR = WBS%CROP_VOLR * SFAC%ALL
                !
                IF(SFAC%HAS_EX1) THEN
                    DO CONCURRENT (I=ONE:WBS%NCROP, F=ONE:WBS%NFARM)
                          !
                          WBS%CROP_VOLR(F,I) = WBS%CROP_VOLR(F,I) * SFAC%EX1(F)
                          !
                    END DO
                END IF
                !  
                IF(SFAC%HAS_EX2) THEN
                    DO CONCURRENT (I=ONE:WBS%NCROP, F=ONE:WBS%NFARM)
                          !
                          WBS%CROP_VOLR(F,I) = WBS%CROP_VOLR(F,I) * SFAC%EX2(I)
                          !
                    END DO
                END IF
            END ASSOCIATE
            !
            DO CONCURRENT (I=ONE:WBS%NCROP, F=ONE:WBS%NFARM, NEAR_ZERO(WBS%CROP_VOLR(F,I)))
                  !
                  WBS%CROP_VOLR(F,I) = DZ
                  !
            END DO
            !
    END IF; END IF
    !
    IF(WBS%HAS_CROP_FLUX .OR. WBS%HAS_CROP_VOLR) THEN
        IF (UPDATE .OR. WBS%CROP_VOLR_TFR%TRANSIENT .OR. WBS%CROP_FLUX_TFR%TRANSIENT) THEN
            !
            WBS%WBS_HAS_ADMD = FALSE
            WBS%CRP_HAS_ADMD = FALSE
            !
            !DO CONCURRENT (I=ONE:WBS%NCROP, F=ONE:WBS%NFARM, WBS%CROP_FLUX(F,I).NE.DZ .OR. WBS%CROP_VOLR(F,I).NE.DZ)
            !      !
            !      WBS%WBS_HAS_ADMD(F) = TRUE
            !      WBS%CRP_HAS_ADMD(I) = TRUE
            !      !
            !END DO
            IF(WBS%HAS_CROP_FLUX) THEN
                !
                DO CONCURRENT (I=ONE:WBS%NCROP)
                    WBS%CRP_HAS_ADMD(I) = ANY( WBS%CROP_FLUX(:,I).NE.DZ)
                    !DO F=ONE, WBS%NFARM
                    !              IF( WBS%CROP_FLUX(F,I).NE.DZ ) THEN
                    !                  WBS%CRP_HAS_ADMD(I) = TRUE
                    !                  EXIT
                    !              END IF
                    !END DO
                END DO  
                DO CONCURRENT (F=ONE:WBS%NFARM)
                    DO I=ONE, WBS%NCROP 
                                  IF( WBS%CROP_FLUX(F,I).NE.DZ ) THEN
                                      WBS%WBS_HAS_ADMD(F) = TRUE
                                      EXIT
                                  END IF
                    END DO
                END DO
            END IF
            !
            IF(WBS%HAS_CROP_VOLR) THEN
                !
                DO CONCURRENT (I=ONE:WBS%NCROP, .NOT. WBS%CRP_HAS_ADMD(I))
                    WBS%CRP_HAS_ADMD(I) = ANY( WBS%CROP_VOLR(:,I).NE.DZ )
                    !DO F=ONE, WBS%NFARM
                    !              IF( WBS%CROP_VOLR(F,I).NE.DZ ) THEN
                    !                  WBS%CRP_HAS_ADMD(I) = TRUE
                    !                  EXIT
                    !              END IF
                    !END DO
                END DO  
                DO CONCURRENT (F=ONE:WBS%NFARM, .NOT. WBS%WBS_HAS_ADMD(F))
                    DO I=ONE, WBS%NCROP 
                                  IF( WBS%CROP_VOLR(F,I).NE.DZ ) THEN
                                      WBS%WBS_HAS_ADMD(F) = TRUE
                                      EXIT
                                  END IF
                    END DO
                END DO
            END IF
        END IF
    END IF
    !
    ! SET UP WATER SOURCES AVAILIBLE TO WBS IF IN USE
    !
    IF(WBS%H2OSOURCE_TFR%INUSE) THEN; IF (UPDATE .OR. WBS%H2OSOURCE_TFR%TRANSIENT) THEN
            !
            WBS%H2OSOURCE%GW  = WBS%H2OSOURCE_TFR%ARRAY(ONE,  :) .NE. Z
            WBS%H2OSOURCE%SW  = WBS%H2OSOURCE_TFR%ARRAY(TWO,  :) .NE. Z
            WBS%H2OSOURCE%NRD = WBS%H2OSOURCE_TFR%ARRAY(THREE,:) .NE. Z
            !
    END IF; END IF
    !
    ! SET UP WATER SUPPY FLAG FOR MAGIC WATER IF THERE IS NO DEFICIT SCENARIO IN USE.
    !
    IF (UPDATE .OR. WBS%DEFICIENCY%TRANSIENT) THEN
        DO CONCURRENT (F=ONE:WBS%NFARM )
            IF(WBS%DEFICIENCY%LIST(F) == Z) THEN
                     WBS%SUPPLY(F)%HAS_MAGIC = TRUE
            ELSE
                     WBS%SUPPLY(F)%HAS_MAGIC = FALSE
            END IF
        END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SUM_WBS_PRECIP(WBS,HAS_PRECIP,PRECIP) 
    CLASS(WBS_DATA),                              INTENT(INOUT):: WBS
    LOGICAL,                                      INTENT(IN   ):: HAS_PRECIP
    DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE,INTENT(IN   ):: PRECIP
    INTEGER:: I,K
    !
    WBS%PRECIP = DZ
    !
    !SUM CROP DEMANDS
    IF(HAS_PRECIP) THEN
       DO CONCURRENT (I=ONE:WBS%NFARM)
       DO CONCURRENT (K=ONE:WBS%FID(I)%Count)
                                             WBS%PRECIP(I) = WBS%PRECIP(I) + PRECIP( WBS%FID(I)%RC(TWO,K), WBS%FID(I)%RC(ONE,K) ) * WBS%AREA( WBS%FID(I)%RC(TWO,K), WBS%FID(I)%RC(ONE,K) )
       END DO; END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SUM_WBS_DEMAND(WBS) !EVENTUALLY COULD HAVE ADDITIONAL DEMANDS TO ADD IN
    CLASS(WBS_DATA),        INTENT(INOUT):: WBS
    INTEGER:: F,K
    !
    WBS%CROP_DEMAND = DZ
    !
    !SUM CROP DEMANDS
    DO CONCURRENT (F=ONE:WBS%NFARM)
    DO CONCURRENT (K=ONE:WBS%FID(F)%Count)
                                          WBS%CROP_DEMAND(F) = WBS%CROP_DEMAND(F) + WBS%CROP_DEMAND_ARRAY( WBS%FID(F)%RC(TWO,K), WBS%FID(F)%RC(ONE,K) )
    END DO; END DO
    !
    WBS%DEMAND = WBS%CROP_DEMAND
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SUM_WBS_RUNOFF_DPERC(WBS) !EVENTUALLY COULD HAVE ADDITIONAL DEMANDS TO ADD IN
    CLASS(WBS_DATA),        INTENT(INOUT):: WBS
    INTEGER:: F,K
    !
    WBS%TOT_DPERC   = DZ
    !
    DO CONCURRENT (F=ONE:WBS%NFARM)
    DO CONCURRENT (K=ONE:WBS%FID(F)%Count)
                                          WBS%TOT_DPERC(F) = WBS%TOT_DPERC(F) + WBS%DPERC( WBS%FID(F)%RC(TWO,K), WBS%FID(F)%RC(ONE,K) )
    END DO; END DO
    !
    WBS%TOT_RUNOFF  = DZ
    DO CONCURRENT (F=ONE:WBS%NFARM)
    DO CONCURRENT (K=ONE:WBS%FID(F)%Count)
                                          WBS%TOT_RUNOFF(F) = WBS%TOT_RUNOFF(F) + WBS%RUNOFF( WBS%FID(F)%RC(TWO,K), WBS%FID(F)%RC(ONE,K) )
    END DO; END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SUM_WBS_DIRECT_RECHARGE(WBS, DRCH)
    CLASS(WBS_DATA),                 INTENT(INOUT):: WBS
    CLASS(COMPRESSED_VALUE_STORAGE), INTENT(IN   ):: DRCH
    INTEGER:: F,K
    !
    WBS%TOT_DIR_RCH   = DZ
    !
    DO CONCURRENT (K=ONE:DRCH%N)
                               F = WBS%FID_ARRAY( DRCH%DIM(ONE,K), DRCH%DIM(TWO,K) )
                               !
                               IF( F > Z) WBS%TOT_DIR_RCH(F) = WBS%TOT_DIR_RCH(F) + DRCH%VAL(K)
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SUM_WBS_FNRCH(WBS) !EVENTUALLY COULD HAVE ADDITIONAL DEMANDS TO ADD IN
    CLASS(WBS_DATA),        INTENT(INOUT):: WBS
    INTEGER:: F,K
    !
    WBS%TOT_FNRCH = DZ
    !
    DO CONCURRENT (F=ONE:WBS%NFARM)
    DO CONCURRENT (K=ONE:WBS%FID(F)%Count)
                                                           WBS%TOT_FNRCH(F) = WBS%TOT_FNRCH(F) + WBS%FNRCH( WBS%FID(F)%RC(TWO,K), WBS%FID(F)%RC(ONE,K) )
    END DO; END DO
  END SUBROUTINE
  !
  PURE SUBROUTINE SETUP_FID_RC(WBS)
    CLASS(WBS_DATA),        INTENT(INOUT):: WBS
    INTEGER:: I,J
    !
    WBS%NEW_FID = FALSE
    DO CONCURRENT (J=ONE:WBS%NROW, I=ONE:WBS%NCOL, WBS%FID_TFR%ARRAY(I,J)>Z .AND. WBS%FID_TFR%ARRAY(I,J) <= WBS%NFARM ) 
        !
        IF(WBS%FID_TFR%ARRAY(I,J) .NE. WBS%FID_ARRAY(I,J)) WBS%NEW_FID = TRUE
    END DO
    !
    IF(WBS%NEW_FID) THEN
        !
        DO CONCURRENT (J=ONE:WBS%NROW, I=ONE:WBS%NCOL)
              !
              IF (WBS%FID_TFR%ARRAY(I,J)>Z .AND. WBS%FID_TFR%ARRAY(I,J) <= WBS%NFARM) THEN
                  WBS%FID_ARRAY(I,J) = WBS%FID_TFR%ARRAY(I,J)
              ELSE
                  WBS%FID_ARRAY(I,J) = Z
              END IF
        END DO
        !
        DO CONCURRENT (I=ONE:WBS%NFARM); CALL SETUP_SINGLE_FID_RC(WBS%FID(I), WBS%NROW, WBS%NCOL, WBS%FID_ARRAY, WBS%AREA)
        END DO
        !
        DO CONCURRENT (I=ONE:WBS%NFARM);  WBS%INUSE(I) = WBS%FID(I)%COUNT > Z
        END DO
    ELSE
        WBS%NEW_FID = FALSE
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SETUP_SINGLE_FID_RC(FID, NROW, NCOL, FID_ARRAY, AREA)
    CLASS(FARMLOCATION),                    INTENT(INOUT):: FID
    INTEGER,                                INTENT(IN   ):: NROW, NCOL
    INTEGER,          DIMENSION(NCOL,NROW), INTENT(IN   ):: FID_ARRAY         !FARM LOCATION ARRAY
    DOUBLE PRECISION, DIMENSION(NCOL,NROW), INTENT(IN   ):: AREA
    INTEGER:: I, IR, IC, N
    !
    N=COUNT(FID%NF.EQ.FID_ARRAY)                                 !COUNT THE NUMBER OF CELLS THAT CONTAIN FARM NF
    !
    CALL ALLOC( FID%RC, TWO, N, DIMCHK=TWO )
    !
    FID%Count = N
    FID%AREA = 0D0
    IF ( FID%Count > Z ) THEN
                               I=Z                    !COUNTER FOR NUMBER OR RC READS
                               DO IR=ONE, NROW  !SEARCH FOR FARM NF IN MODEL AND STORE ITS ROW/COL LOCATION  ==> FID_ARRAY(NCOL,NROW)
                               DO IC=ONE, NCOL
                                                      IF(FID_ARRAY(IC,IR).EQ.FID%NF) THEN
                                                                                      I=I+ONE
                                                                                      FID%RC(ONE,I)=IR
                                                                                      FID%RC(TWO,I)=IC
                                                                                      FID%AREA = FID%AREA + AREA(IC,IR)
                                                      END IF
                               END DO
                               END DO
    END IF
    !
  END SUBROUTINE
  !
  !!!SUBROUTINE SETUP_FARM_HIERARCHY_POINTERS(WBS)
  !!!  CLASS(WBS_DATA),  INTENT(INOUT):: WBS
  !!!  !
  !!!  TYPE(INTEGER_LINKED_LIST):: DIST_LIST, UNIT_LIST, FARM_LIST, AUX_LIST
  !!!  INTEGER:: I, J, P, D, U, NFARM, NAUX, TOT, AUX_STR
  !!!  LOGICAL:: SORT
  !!!  TYPE(WARNING_TYPE):: WARN_MSG
  !!!  !
  !!!  IF (WBS%HAS_HIERARCHY) THEN
  !!!      !
  !!!      NFARM= WBS%NFARM
  !!!      NAUX = WBS%NAUXDEM 
  !!!      AUX_STR = WBS%NFARM + ONE      
  !!!      TOT  = NFARM + NAUX
  !!!      !
  !!!      IF( ANY(WBS%HIERARCHY_ARRAY .NE. WBS%HIERARCHY_TFR%ARRAY) ) THEN
  !!!          !
  !!!          CALL WARN_MSG%INIT()
  !!!          !
  !!!          DO CONCURRENT (I=ONE:TOT, ANY(WBS%HIERARCHY_TFR%ARRAY(:,I) == Z) .AND. ANY(WBS%HIERARCHY_TFR%ARRAY(:,I) .NE. Z))
  !!!              IF(I <= WBS%NFARM) THEN
  !!!                  CALL WARN_MSG%ADD('WBS     '//NUM2STR(I)//NL )
  !!!              ELSE
  !!!                  CALL WARN_MSG%ADD('AUX_DEM '//NUM2STR(I-WBS%NFARM)//NL)
  !!!              END IF
  !!!              WBS%HIERARCHY_TFR%ARRAY(:,I) = Z
  !!!          END DO
  !!!          !
  !!!          CALL WARN_MSG%CHECK('FMP WBS BLOCK: VALUES IN THE HIERARCHY CONTAINED ZEROS AND NONZEROS FOR THE SAME WBS/AUXILIARY DEMAND.'//BLN//'SINCE THERE WAS A ZERO PROJECT, DISTRICT, OR UNIT SPECIFIED, THE REST ARE SET TO ZERO'//NL//'(EITHER ALL HIERARCHY RELATIONSHIPS MUST BE SPECIFIED GREATER THAN ZERO OR ALL SET TO ZERO).'//NL//'FOR PROGRAM TO CONTINUE THE FARMS/AUXILIARY DEMANDS WITH ZERO VALUES WILL BE SET TO 0 FOR ITS PROJECT, DISTRICT, AND UNIT.'//BLN//'THE FOLLOWING ARE THE FARMS/AUXILIARY DEMANDS THAT HAD THEIR HIERARCHY ZEROED OUT:', OUTPUT=WBS%IOUT, INLINE=TRUE, INIT=TRUE)
  !!!          !
  !!!          WBS%HIERARCHY_ARRAY = WBS%HIERARCHY_TFR%ARRAY
  !!!          !
  !!!          SORT = TRUE
  !!!          !
  !!!          !CHECK THAT PROJ, DIST, AND UNIT ARE UNIQUE
  !!!          P=Z;U=Z;D=Z
  !!!          DO CONCURRENT (U=ONE:WBS%NUNIT)
  !!!             D=Z
  !!!             DO CONCURRENT (I=ONE:TOT, WBS%HIERARCHY_ARRAY(ONE,I) == U)
  !!!                 IF(D==Z) THEN
  !!!                         D  =   WBS%HIERARCHY_ARRAY(TWO,I)
  !!!                 ELSEIF (D .NE. WBS%HIERARCHY_ARRAY(TWO,I)) THEN
  !!!                         CALL WARN_MSG%ADD('FMP UNIT '//NUM2STR(U)//' CAN ONLY BE ASSOCIATED WITH ONE DISTRICT AT ONE TIME. INSTEAD IT HAS BEEN SPECIFIED TO BE APART OF DISTRICT '//NUM2STR(D)//' AND DISTRICT '//NUM2STR(WBS%HIERARCHY_ARRAY(TWO,I))//NL )
  !!!                 END IF
  !!!             END DO
  !!!          END DO
  !!!          P=Z;U=Z;D=Z
  !!!          !
  !!!          DO CONCURRENT (D=ONE:WBS%NDIST)
  !!!             P=Z
  !!!             DO CONCURRENT (I=ONE:TOT, WBS%HIERARCHY_ARRAY(TWO,I) == D)
  !!!                 IF(P==Z) THEN
  !!!                         P  =   WBS%HIERARCHY_ARRAY(THREE,I)
  !!!                 ELSEIF (P .NE. WBS%HIERARCHY_ARRAY(THREE,I)) THEN
  !!!                         CALL WARN_MSG%ADD( 'FMP DISTRICT '//NUM2STR(D)//' CAN ONLY BE ASSOCIATED WITH ONE DISTRICT AT ONE TIME. INSTEAD IT HAS BEEN SPECIFIED TO BE APART OF DISTRICT '//NUM2STR(P)//' AND DISTRICT '//NUM2STR(WBS%HIERARCHY_ARRAY(THREE,I))//NL )
  !!!                 END IF
  !!!             END DO
  !!!          END DO
  !!!          !
  !!!          CALL WARN_MSG%CHECK(HED='FMP HIERARCHY HAD FATAL ERRORS:'//NL, OUTPUT=WBS%IOUT, KILL=TRUE, TAIL=NL )
  !!!          !
  !!!          ! ASSINGLE EACH FARMS PROJ, DIST, UNIT
  !!!          DO CONCURRENT (I=ONE:NFARM)
  !!!                                       WBS%FARM(I)%UNIT = WBS%HIERARCHY_ARRAY(ONE,  I)
  !!!                                       WBS%FARM(I)%DIST = WBS%HIERARCHY_ARRAY(TWO,  I)
  !!!                                       WBS%FARM(I)%PROJ = WBS%HIERARCHY_ARRAY(THREE,I)    
  !!!          END DO
  !!!          !
  !!!          IF( NAUX > Z) THEN
  !!!             J = AUX_STR
  !!!             DO I=ONE, NAUX
  !!!                                          WBS%AUX_DEMAND(I)%UNIT = WBS%HIERARCHY_ARRAY(ONE,  J)
  !!!                                          WBS%AUX_DEMAND(I)%DIST = WBS%HIERARCHY_ARRAY(TWO,  J)
  !!!                                          WBS%AUX_DEMAND(I)%PROJ = WBS%HIERARCHY_ARRAY(THREE,J)    
  !!!                                          J=J+1
  !!!             END DO
  !!!          END IF
  !!!          !
  !!!          !FIND ALL DIST, UNIT, AND FARM ASSOCIATED WITH PROJECT----------------------------------------------------------------
  !!!          P=Z;U=Z;D=Z
  !!!          DO P=ONE, WBS%NPROJ
  !!!            CALL DIST_LIST%INIT()
  !!!            CALL UNIT_LIST%INIT()
  !!!            CALL FARM_LIST%INIT()
  !!!            CALL AUX_LIST%INIT()
  !!!            !
  !!!            DO I=ONE, NFARM
  !!!                IF ( WBS%HIERARCHY_ARRAY(THREE,I) == P )  THEN!FIND ROWS WITH PROJECT P
  !!!                    CALL UNIT_LIST%ADD(WBS%HIERARCHY_ARRAY(ONE,I))
  !!!                    CALL DIST_LIST%ADD(WBS%HIERARCHY_ARRAY(TWO,I))
  !!!                    CALL FARM_LIST%ADD(I)
  !!!                END IF
  !!!            END DO
  !!!            !
  !!!            IF( NAUX > Z) THEN
  !!!               J = AUX_STR
  !!!               DO I=ONE, NAUX
  !!!                   IF ( WBS%HIERARCHY_ARRAY(THREE,J) == P )  THEN!FIND ROWS WITH PROJECT P
  !!!                              CALL UNIT_LIST%ADD(WBS%HIERARCHY_ARRAY(ONE,J))
  !!!                              CALL DIST_LIST%ADD(WBS%HIERARCHY_ARRAY(TWO,J))
  !!!                              CALL AUX_LIST%ADD(I)
  !!!                              J=J+1
  !!!                   END IF
  !!!               END DO
  !!!            END IF
  !!!            !
  !!!            CALL DIST_LIST%DROP_DUPLICATES()
  !!!            CALL UNIT_LIST%DROP_DUPLICATES()
  !!!            !CALL FARM_LIST%DROP_DUPLICATES()  --SHOULD NEVER BE A DUBLICATE FARM
  !!!            !
  !!!            WBS%PROJ(P)%NDIST=DIST_LIST%LEN()
  !!!            WBS%PROJ(P)%NUNIT=UNIT_LIST%LEN()
  !!!            WBS%PROJ(P)%NFARM=FARM_LIST%LEN()
  !!!            WBS%PROJ(P)%NAUX =AUX_LIST %LEN()
  !!!            !
  !!!            CALL DIST_LIST%TOARRAY(WBS%PROJ(P)%DIST, SORT)
  !!!            CALL UNIT_LIST%TOARRAY(WBS%PROJ(P)%UNIT, SORT)
  !!!            CALL FARM_LIST%TOARRAY(WBS%PROJ(P)%FARM, SORT)
  !!!            CALL AUX_LIST %TOARRAY(WBS%PROJ(P)%AUX,  SORT)
  !!!          END DO
  !!!          !
  !!!          !FIND ALL UNIT, AND FARM ASSOCIATED WITH DIST----------------------------------------------------------------
  !!!          P=Z;U=Z;D=Z
  !!!          DO D=ONE, WBS%NDIST
  !!!            CALL UNIT_LIST%INIT()
  !!!            CALL FARM_LIST%INIT()
  !!!            CALL AUX_LIST%INIT()
  !!!            !
  !!!            WBS%DIST(D)%PROJ = Z
  !!!            DO I=ONE, NFARM
  !!!                IF ( WBS%HIERARCHY_ARRAY(TWO,I) == D ) THEN !FIND ROWS WITH DISTRIC D
  !!!                    CALL UNIT_LIST%ADD(WBS%HIERARCHY_ARRAY(ONE,I))
  !!!                    CALL FARM_LIST%ADD(I)
  !!!                    !
  !!!                    IF(WBS%DIST(D)%PROJ == Z) WBS%DIST(D)%PROJ = WBS%HIERARCHY_ARRAY(THREE,I)
  !!!                END IF
  !!!            END DO
  !!!            !
  !!!            IF( NAUX > Z) THEN
  !!!                J = AUX_STR
  !!!                DO I=ONE, NAUX
  !!!                 IF ( WBS%HIERARCHY_ARRAY(TWO,J) == D ) THEN !FIND ROWS WITH DISTRIC D
  !!!                     CALL UNIT_LIST%ADD(WBS%HIERARCHY_ARRAY(ONE,J))
  !!!                     CALL AUX_LIST%ADD(I)
  !!!                     !
  !!!                     IF(WBS%DIST(D)%PROJ == Z) WBS%DIST(D)%PROJ = WBS%HIERARCHY_ARRAY(THREE,J)
  !!!                 END IF
  !!!                 J=J+1
  !!!                END DO
  !!!            END IF
  !!!            !
  !!!            CALL UNIT_LIST%DROP_DUPLICATES()
  !!!            !CALL FARM_LIST%DROP_DUPLICATES()  --SHOULD NEVER BE A DUBLICATE FARM
  !!!            !
  !!!            WBS%DIST(D)%NUNIT=UNIT_LIST%LEN()
  !!!            WBS%DIST(D)%NFARM=FARM_LIST%LEN()
  !!!            WBS%DIST(D)%NAUX = AUX_LIST%LEN()
  !!!            !
  !!!            CALL UNIT_LIST%TOARRAY(WBS%DIST(D)%UNIT, SORT)
  !!!            CALL FARM_LIST%TOARRAY(WBS%DIST(D)%FARM, SORT)
  !!!            CALL AUX_LIST %TOARRAY(WBS%DIST(D)%AUX,  SORT)
  !!!          END DO
  !!!          !
  !!!          !FIND ALL FARM ASSOCIATED WITH UNIT----------------------------------------------------------------
  !!!          P=Z;U=Z;D=Z
  !!!          DO U=ONE, WBS%NUNIT
  !!!            CALL FARM_LIST%INIT()
  !!!            !
  !!!            WBS%UNIT(U)%PROJ = Z
  !!!            WBS%UNIT(U)%DIST = Z
  !!!            DO I=ONE, WBS%NFARM
  !!!                IF ( WBS%HIERARCHY_ARRAY(ONE,I) == U ) THEN !FIND ROWS WITH UNIT U
  !!!                   CALL FARM_LIST%ADD(I)
  !!!                   IF(WBS%UNIT(U)%DIST == Z) WBS%UNIT(U)%DIST = WBS%HIERARCHY_ARRAY(TWO,I)
  !!!                   IF(WBS%UNIT(U)%PROJ == Z) WBS%UNIT(U)%PROJ = WBS%HIERARCHY_ARRAY(THREE,I)
  !!!                END IF
  !!!            END DO
  !!!            !
  !!!            IF( NAUX > Z) THEN
  !!!              J = AUX_STR
  !!!              DO I=ONE, NAUX
  !!!                IF ( WBS%HIERARCHY_ARRAY(ONE,J) == U ) THEN !FIND ROWS WITH UNIT U
  !!!                   CALL AUX_LIST%ADD(I)
  !!!                   IF(WBS%UNIT(U)%DIST == Z) WBS%UNIT(U)%DIST = WBS%HIERARCHY_ARRAY(TWO,  J)
  !!!                   IF(WBS%UNIT(U)%PROJ == Z) WBS%UNIT(U)%PROJ = WBS%HIERARCHY_ARRAY(THREE,J)
  !!!                END IF  
  !!!                J=J+1
  !!!              END DO
  !!!            END IF
  !!!            !
  !!!            !CALL FARM_LIST%DROP_DUPLICATES()  --SHOULD NEVER BE A DUBLICATE FARM
  !!!            !
  !!!            WBS%UNIT(U)%NFARM=FARM_LIST%LEN()
  !!!            WBS%UNIT(U)%NAUX = AUX_LIST%LEN()
  !!!            !
  !!!            CALL FARM_LIST%TOARRAY(WBS%UNIT(U)%FARM, SORT)
  !!!            CALL AUX_LIST %TOARRAY(WBS%UNIT(U)%AUX,  SORT)
  !!!          END DO
  !!!          !
  !!!          CALL DIST_LIST%DESTROY()
  !!!          CALL UNIT_LIST%DESTROY()
  !!!          CALL FARM_LIST%DESTROY()
  !!!          CALL AUX_LIST%DESTROY()
  !!!          !
  !!!      END IF
  !!!      !
  !!!  END IF
  !!!END SUBROUTINE
  !
  SUBROUTINE SETUP_FALLOW_FRACTION_ARRAY(WBS, WBS_BARE_FRAC, BFR, UPDATE)
    CLASS(WBS_DATA),                             INTENT(IN   ):: WBS
    TYPE(LIST_ARRAY_INPUT),                      INTENT(IN   ):: WBS_BARE_FRAC  ! SHOULD BE WBS%BARE_FRAC_RUNOFF OR WBS%BARE_FRAC_PRECIP
    DOUBLE PRECISION, DIMENSION(:,:),CONTIGUOUS, INTENT(INOUT):: BFR
    LOGICAL,                                     INTENT(IN   ):: UPDATE
    INTEGER:: I,J
    !
    IF(.NOT. WBS_BARE_FRAC%INUSE .AND. UPDATE) THEN
        !
        BFR = UNO
        !
    ELSEIF(WBS_BARE_FRAC%INUSE .AND. (WBS_BARE_FRAC%TRANSIENT .OR. WBS%FID_TFR%TRANSIENT .OR. UPDATE)) THEN
        !
        IF(WBS_BARE_FRAC%LISTLOAD) THEN
                                                !
                                                DO CONCURRENT(J=ONE:SIZE(WBS%FID_ARRAY,TWO), I=ONE:SIZE(WBS%FID_ARRAY,ONE))
                                                      !
                                                      IF (WBS%FID_ARRAY(I,J) == Z) THEN
                                                          BFR(I,J) = DZ
                                                      ELSE
                                                          BFR(I,J) = WBS_BARE_FRAC%LIST( WBS%FID_ARRAY(I,J) )
                                                          IF(WBS_BARE_FRAC%SFAC%HAS_EX1) BFR(I,J) = BFR(I,J) * WBS_BARE_FRAC%SFAC%EX1(WBS%FID_ARRAY(I,J))
                                                      END IF
                                                      !
                                                END DO
                                                !
                                                IF(WBS_BARE_FRAC%SFAC%HAS_ALL) BFR = BFR * WBS_BARE_FRAC%SFAC%ALL
                                                !
        ELSE
                                                BFR = WBS_BARE_FRAC%ARRAY
                                                !
                                                IF(WBS_BARE_FRAC%SFAC%HAS_ALL) BFR = BFR * WBS_BARE_FRAC%SFAC%ALL
                                                !
                                                IF(WBS_BARE_FRAC%SFAC%HAS_EX1) THEN
                                                      DO CONCURRENT(J=ONE:SIZE(WBS%FID_ARRAY,TWO), I=ONE:SIZE(WBS%FID_ARRAY,ONE), WBS%FID_ARRAY(I,J) > Z)
                                                            !
                                                            BFR(I,J) = BFR(I,J) * WBS_BARE_FRAC%SFAC%EX1(WBS%FID_ARRAY(I,J))
                                                      END DO
                                                END IF
                                                
        END IF
        !
        DO CONCURRENT(J=ONE:SIZE(WBS%FID_ARRAY,TWO), I=ONE:SIZE(WBS%FID_ARRAY,ONE))
            IF    ( BFR(I,J)>UNO ) THEN; BFR(I,J)=UNO
            ELSEIF( BFR(I,J)<DZ  ) THEN; BFR(I,J)=DZ
            END IF
        END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOCATE_WATER_SOURCES(SRC,N)
    CLASS(WATER_SOURCES),   INTENT(INOUT):: SRC
    INTEGER,                INTENT(IN   ):: N
    !
    IF(ALLOCATED(SRC%GW )) DEALLOCATE(SRC%GW )
    IF(ALLOCATED(SRC%SW )) DEALLOCATE(SRC%SW )
    IF(ALLOCATED(SRC%NRD)) DEALLOCATE(SRC%NRD)
    !
    ALLOCATE(SRC%GW (N))
    ALLOCATE(SRC%SW (N))
    ALLOCATE(SRC%NRD(N))
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_TOTAL(SUP)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    SUP%TOTAL = SUP%NRD_TOT + SUP%SFR_TOT + SUP%WEL_TOT
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_USED(SUP)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    SUP%USED = SUP%NRD + SUP%SFR + SUP%WEL + SUP%MAGIC
    SUP%CROP  = SUP%USED
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_MAGIC(SUP, TFDR, DEF)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    DOUBLE PRECISION,  INTENT(IN   ):: TFDR
    INTEGER,           INTENT(IN   ):: DEF
    !
    IF(DEF==Z) SUP%MAGIC = TFDR - SUP%NRD - SUP%SFR - SUP%WEL
    !
    IF(SUP%MAGIC<DZ) SUP%MAGIC=DZ
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_SFR  (SUP, FLOW)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    DOUBLE PRECISION,  INTENT(IN   ):: FLOW
    SUP%SFR = FLOW
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_NRD  (SUP, FLOW)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    DOUBLE PRECISION,  INTENT(IN   ):: FLOW
    SUP%NRD = FLOW
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_WEL  (SUP, FLOW)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    DOUBLE PRECISION,  INTENT(IN   ):: FLOW
    SUP%WEL = FLOW
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_SFR_TOT(SUP, FLOW)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    DOUBLE PRECISION,  INTENT(IN   ):: FLOW
    SUP%SFR_TOT = FLOW
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_NRD_TOT(SUP, FLOW)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    DOUBLE PRECISION,  INTENT(IN   ):: FLOW
    SUP%NRD_TOT = FLOW
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_WEL_TOT(SUP, FLOW)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    DOUBLE PRECISION,  INTENT(IN   ):: FLOW
    SUP%WEL_TOT = FLOW
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE INIT_SUPPLY(SUP)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    SUP%TOTAL   = DZ
    SUP%USED    = DZ
    SUP%CROP    = DZ
    SUP%MAGIC   = DZ
    SUP%SFR     = DZ
    SUP%WEL     = DZ
    SUP%NRD     = DZ
    SUP%SFR_TOT = DZ
    !SUP%SWR_TOT = DZ
    SUP%WEL_TOT = DZ
    SUP%NRD_TOT = DZ
    !SUP%SWR     = DZ
  END SUBROUTINE
  !  
  SUBROUTINE CHECK_SOIL_ID(WBS,SID)
    CLASS(WBS_DATA),                  INTENT(IN):: WBS
    INTEGER,DIMENSION(:,:),CONTIGUOUS,INTENT(IN):: SID
    INTEGER:: R,C
    TYPE(WARNING_TYPE):: ERR
    !
    CALL ERR%INIT()
    DO CONCURRENT (R=ONE:WBS%NROW, C=ONE:WBS%NCOL, WBS%FID_ARRAY(C,R) > Z .AND. SID(C,R) < ONE); CALL ERR%ADD(NUM2STR(R,-10)//' '//NUM2STR(C,-10)//NL)
    END DO
    !
    IF(ERR%RAISED) CALL ERR%CHECK(HED='FMP WBS ERROR. FOUND WBS ID > 0 BUT THE CORRESPONDING SOIL ID = 0 FOR THE SAME ROW/COLUMN. THE FOLLOWING ARE THE PROBLEM MODEL CELLS:'//NL//'ROW       COLUMN'//NL, OUTPUT=WBS%IOUT, KILL=TRUE, TAIL=NL )
    !
    !!!CHARACTER(:),ALLOCATABLE:: ERROR
    !!!!
    !!!ERROR=NL
    !!!DO CONCURRENT (R=ONE:WBS%NROW, C=ONE:WBS%NCOL, WBS%FID_ARRAY(C,R) > Z .AND. SID(C,R) < ONE); ERROR = ERROR//NUM2STR(R,-10)//' '//NUM2STR(C,-10)//NL
    !!!END DO
    !!!IF (ERROR.NE.NL) CALL STOP_ERROR(OUTPUT=WBS%LOUT,MSG='FMP WBS ERROR. FOUND FARM ID > 0 BUT THE CORRESPONDING SOIL ID = 0 FOR THE SAME ROW/COLUMN. THE FOLLOWING ARE THE PROBLEM MODEL CELLS:'//NL//'ROW       COLUMN'//ERROR)
    ! 
  END SUBROUTINE
END MODULE
!
!#########################################################################################################
!
MODULE OPTIONS_DATA_FMP_INTERFACE!, ONLY: OPTIONS_DATA, INITIALIZE_OPTIONS_DATA
  !
  USE FMP_DIMENSION_INTERFACE,           ONLY: FMP_DIMENSION
  !
  USE UTIL_INTERFACE,                    ONLY: FILE_IO_ERROR, STOP_ERROR, WARNING_MESSAGE, GET_NUMBER, PARSE_WORD_UP
  USE NUM2STR_INTERFACE,                 ONLY: NUM2STR
  USE ALLOC_INTERFACE,                   ONLY: ALLOC
  USE CONSTANTS
  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
  USE WARNING_TYPE_INSTRUCTION,          ONLY: WARNING_TYPE
  !
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: OPTIONS_DATA, INITIALIZE_OPTIONS_DATA
  !
  TYPE OPTIONS_DATA
      LOGICAL:: NOPRINT     = FALSE
      LOGICAL:: WELLFIELD   = FALSE
      LOGICAL:: RECOMP_Q_BD = FALSE
      LOGICAL:: HAS_MNWCLOSE= FALSE
      DOUBLE PRECISION,    DIMENSION(:), ALLOCATABLE:: MNWCLOSE
      !
      CONTAINS
      !
      FINAL:: DEALLOCATE_OPTIONS_FINAL
  END TYPE
  !
  CONTAINS
  !
  SUBROUTINE DEALLOCATE_OPTIONS_FINAL(OPT)
  TYPE(OPTIONS_DATA)::OPT
  CALL DEALLOCATE_OPTIONS(OPT)
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_OPTIONS(OPT)
  CLASS(OPTIONS_DATA), INTENT(INOUT)::OPT
  !
  IF(OPT%HAS_MNWCLOSE) DEALLOCATE(OPT%MNWCLOSE)
  OPT%NOPRINT     = FALSE
  OPT%WELLFIELD   = FALSE
  OPT%RECOMP_Q_BD = FALSE
  OPT%HAS_MNWCLOSE= FALSE
  !
  END SUBROUTINE
  !  
  SUBROUTINE INITIALIZE_OPTIONS_DATA( BL, OPT )
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL   !DATA BLOCK
    CLASS(OPTIONS_DATA),         INTENT(INOUT):: OPT
    TYPE(WARNING_TYPE):: WARN_MSG
    CHARACTER(5):: ERROR
    INTEGER:: I, LLOC, ISTART, ISTOP
    !
    WRITE(BL%IOUT,'(/A/)') 'OPTIONS BLOCK FOUND AND NOW LOADING OPTIONS'
    !
    OPT%NOPRINT = FALSE
    !
    ERROR='ERROR'
    CALL WARN_MSG%INIT()
    !
    CALL BL%START()
    !
    DO I=ONE, BL%NLINE
      !
      LLOC=ONE
      CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP)
      !
      SELECT CASE ( BL%LINE(ISTART:ISTOP) )
      CASE ("NOPRINT")
                        WRITE(BL%IOUT,'(A)') '   NOPRINT     OPTION FOUND.'
                        OPT%NOPRINT = TRUE
      CASE ("WELLFIELD")
                        WRITE(BL%IOUT,'(A)') '   WELLFIELD   OPTION FOUND.'
                        OPT%WELLFIELD = TRUE
                        !
      CASE ("RECOMP_Q_BD")
                        WRITE(BL%IOUT,'(A)') '   RECOMP_Q_BD OPTION FOUND.'
                        OPT%RECOMP_Q_BD = TRUE
                        !
      CASE ("MNWCLOSE")
                        WRITE(BL%IOUT,'(A)') '   MNWCLOSE    OPTION FOUND. NOW READING THE NUMBERS QCLOSE, HPCT, RPCT ON SAME LINE.'
                        OPT%HAS_MNWCLOSE = TRUE
                        ALLOCATE(OPT%MNWCLOSE(THREE))
                        CALL GET_NUMBER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,OPT%MNWCLOSE(ONE),  MSG='FMP OPTION BLOCK ERROR; OPTION MNWCLOSE FAILED TO LOAD QCLOSE.')
                        CALL GET_NUMBER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,OPT%MNWCLOSE(TWO),  MSG='FMP OPTION BLOCK ERROR; OPTION MNWCLOSE FAILED TO LOAD HPCT.')
                        CALL GET_NUMBER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,OPT%MNWCLOSE(THREE),MSG='FMP OPTION BLOCK ERROR; OPTION MNWCLOSE FAILED TO LOAD RPCT.')
                        !
      CASE DEFAULT
                        CALL WARN_MSG%ADD('FOUND UNKNOWN KEYWORD "'//BL%LINE(ISTART:ISTOP)//'" ***IT WILL BE IGNORED***'//BLN)
                        
      END SELECT
      !
      CALL BL%NEXT()
      !
    END DO
    !
    CALL WARN_MSG%CHECK(HED='FMP OPTIONS BLOCK'//NL,INFILE=BL%IU,OUTPUT=BL%IOUT,INLINE=TRUE,CMD_PRINT=TRUE,TAIL=NL)
    !
  END SUBROUTINE
  !
END MODULE
!
!#########################################################################################################
!
MODULE OUTPUT_DATA_FMP_INTERFACE!, ONLY: OUTPUT_DATA, INITIALIZE_OUTPUT_DATA
  !
  USE FMP_DIMENSION_INTERFACE,           ONLY: FMP_DIMENSION
  !
  USE UTIL_INTERFACE,                    ONLY: FILE_IO_ERROR, STOP_ERROR, WARNING_MESSAGE, GET_INTEGER, GET_WORD, PARSE_WORD_UP
  USE NUM2STR_INTERFACE,                 ONLY: NUM2STR
  USE ALLOC_INTERFACE,                   ONLY: ALLOC
  USE CONSTANTS
  USE GENERIC_OUTPUT_FILE_INSTRUCTION,   ONLY: GENERIC_OUTPUT_FILE
  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
  USE WARNING_TYPE_INSTRUCTION,          ONLY: WARNING_TYPE
  !
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: OUTPUT_DATA, INITIALIZE_OUTPUT_DATA
  !
  TYPE OUTPUT_DATA
      INTEGER:: WEL_CBC = Z
      INTEGER:: FNR_CBC = Z
      !INTEGER:: ISDPFL  = Z
      !INTEGER:: IFBPFL  = Z
      INTEGER:: HAS_ROUT= Z  ! 1 = STATIC, 2 = TRANSIENT 
      TYPE(GENERIC_OUTPUT_FILE):: WBS_WATER_USE
      TYPE(GENERIC_OUTPUT_FILE):: FDS
      TYPE(GENERIC_OUTPUT_FILE):: FB_COMPACT
      TYPE(GENERIC_OUTPUT_FILE):: FB_DETAILS
      TYPE(GENERIC_OUTPUT_FILE):: ET_ARRAY_SUM
      TYPE(GENERIC_OUTPUT_FILE):: ET_ARRAY_SEP
      TYPE(GENERIC_OUTPUT_FILE):: ET_LIST
      TYPE(GENERIC_OUTPUT_FILE):: ROUTING_INFORMATION
      TYPE(GENERIC_OUTPUT_FILE):: FNRCH_ARRAY
      TYPE(GENERIC_OUTPUT_FILE):: FNRCH_LIST
      TYPE(GENERIC_OUTPUT_FILE):: FWELLS
      TYPE(GENERIC_OUTPUT_FILE):: EGWA
      TYPE(GENERIC_OUTPUT_FILE):: TGWA
      TYPE(GENERIC_OUTPUT_FILE):: TI
      TYPE(GENERIC_OUTPUT_FILE):: EI
      TYPE(GENERIC_OUTPUT_FILE):: TP
      TYPE(GENERIC_OUTPUT_FILE):: EP
      TYPE(GENERIC_OUTPUT_FILE):: ETGW
      TYPE(GENERIC_OUTPUT_FILE):: ETI
      TYPE(GENERIC_OUTPUT_FILE):: ETP
      TYPE(GENERIC_OUTPUT_FILE):: RUNOFF
      TYPE(GENERIC_OUTPUT_FILE):: DPERC
      !MAYBE: 'RED_FMP_PMP.out' - FMPOUT%NAME(10)
      !
      CONTAINS
      !
      FINAL:: DEALLOCATE_OUTPUT_FINAL
  END TYPE
  !
  CONTAINS
  !
  SUBROUTINE DEALLOCATE_OUTPUT_FINAL(OFL)
  TYPE(OUTPUT_DATA)::OFL
  CALL DEALLOCATE_OUTPUT(OFL)
  END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_OUTPUT(OFL)
  CLASS(OUTPUT_DATA), INTENT(INOUT)::OFL
  !
  OFL%WEL_CBC = Z
  OFL%FNR_CBC = Z
  !OFL%ISDPFL  = Z
  !OFL%IFBPFL  = Z
  OFL%HAS_ROUT= Z
  !
  CALL OFL%WBS_WATER_USE      %CLOSE()
  CALL OFL%FDS                %CLOSE()
  CALL OFL%FB_COMPACT         %CLOSE()
  CALL OFL%FB_DETAILS         %CLOSE()
  CALL OFL%ET_ARRAY_SUM       %CLOSE()
  CALL OFL%ET_ARRAY_SEP       %CLOSE()
  CALL OFL%ET_LIST            %CLOSE()
  CALL OFL%FNRCH_ARRAY        %CLOSE()
  CALL OFL%FNRCH_LIST         %CLOSE()
  CALL OFL%FWELLS             %CLOSE()
  CALL OFL%ROUTING_INFORMATION%CLOSE()
  CALL OFL%EGWA               %CLOSE()
  CALL OFL%TGWA               %CLOSE()
  CALL OFL%TI                 %CLOSE()
  CALL OFL%EI                 %CLOSE()
  CALL OFL%TP                 %CLOSE()
  CALL OFL%EP                 %CLOSE()
  CALL OFL%ETGW               %CLOSE()
  CALL OFL%ETI                %CLOSE()
  CALL OFL%ETP                %CLOSE()
  CALL OFL%RUNOFF             %CLOSE()
  CALL OFL%DPERC              %CLOSE()
  !
  END SUBROUTINE
  !  
  SUBROUTINE INITIALIZE_OUTPUT_DATA( BL, OFL, ITMUNI)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL   !DATA BLOCK
    CLASS(OUTPUT_DATA),          INTENT(INOUT):: OFL
    INTEGER,                     INTENT(IN   ):: ITMUNI
    CHARACTER(14):: TIMEUNIT
    CHARACTER( 8):: KEY
    CHARACTER( 5):: ERROR
    INTEGER:: I, LLOC, ISTART, ISTOP!, IERR, NROW, NCOL
    TYPE(WARNING_TYPE):: WARN_MSG1, WARN_MSG2
    !
    WRITE(BL%IOUT,'(/A/)') 'OUTPUT BLOCK FOUND AND NOW LOADING OUTPUT OPTIONS'
    !
    !
    ERROR='ERROR'
    !
    CALL WARN_MSG1%INIT()
    CALL WARN_MSG2%INIT()
    !
    CALL BL%START()
    !
    DO I=ONE, BL%NLINE
      !
      LLOC=ONE
      CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP)
      !
      SELECT CASE ( BL%LINE(ISTART:ISTOP) )
      CASE ("FWEL_CBC","FWELL_CBC","FARM_WELL_CBC")
                        WRITE(BL%IOUT,'(A)') '   FARM_WELL_CBC (FWEL_CBC)               OUTPUT KEYWORD FOUND. NOW READING UNIT NUMBER (MUST BE 0 OR >1)'
                        CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,OFL%WEL_CBC,  MSG='FMP OUTPUT BLOCK ERROR; OUTPUT WEL_CBC FAILED TO LOAD ITS ASSOCIATED UNIT NUMBER.')
                        IF( OFL%WEL_CBC<Z .OR. OFL%WEL_CBC==ONE) THEN
                                 CALL WARN_MSG2%ADD('FOUND KEYWORD "'//BL%LINE(ISTART:ISTOP)//'", IT MUST BE >1 OR 0, BUT WAS SET TO '//NUM2STR(OFL%WEL_CBC)//' IT IS RESET TO ZERO'//BLN)
                                 OFL%WEL_CBC = Z
                        END IF
                        !
      CASE ("FNR_CBC","FARM_NET_RECHARGE_CBC")
                        WRITE(BL%IOUT,'(A)') '   FARM_NET_RECHARGE_CBC (FNR_CBC)        OUTPUT KEYWORD FOUND. NOW READING UNIT NUMBER (MUST BE 0 OR >3)'
                        CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,OFL%FNR_CBC,  MSG='FMP OUTPUT BLOCK ERROR; OUTPUT FNR_CBC FAILED TO LOAD ITS ASSOCIATED UNIT NUMBER.')
                        IF( OFL%FNR_CBC<=THREE .AND. OFL%FNR_CBC.NE.Z) THEN
                                 CALL WARN_MSG2%ADD('FOUND KEYWORD "'//BL%LINE(ISTART:ISTOP)//'", IT MUST BE >3 OR 0, BUT WAS SET TO '//NUM2STR(OFL%FNR_CBC)//' IT IS RESET TO ZERO'//BLN)
                                 OFL%FNR_CBC = Z
                        END IF
                        !
!      CASE ("ISDPFL")
!                        WRITE(BL%IOUT,'(A)') '   ISDPFL              OUTPUT KEYWORD FOUND. NOW READING THE INTEGER FLAG.'
!                        CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,OFL%ISDPFL,  MSG='FMP OUTPUT BLOCK ERROR; OUTPUT ISDPFL FAILED TO LOAD ITS INTEGER FLAG.')
!                        !
!      CASE ("IFBPFL")
!                        WRITE(BL%IOUT,'(A)') '   IFBPFL              OUTPUT KEYWORD FOUND. NOW READING THE INTEGER FLAG.'
!                        CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,OFL%IFBPFL,  MSG='FMP OUTPUT BLOCK ERROR; OUTPUT IFBPFL FAILED TO LOAD ITS INTEGER FLAG.')
!                        !
      CASE ("FWELLS","FARM_WELL_SUMMARY")
                        WRITE(BL%IOUT,'(A)') '   FARM_WELL_SUMMARY (FWELLS)             OUTPUT KEYWORD FOUND. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "FWELLS.out"'
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%FWELLS%OPEN("FWELLS.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        ELSE
                                CALL OFL%FWELLS%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                !
                                IF(OFL%FWELLS%IU==Z) CALL OFL%FWELLS%OPEN("FWELLS.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        END IF
      CASE ("FNRCH_ARRAY","FARM_NET_RECHARGE_ARRAY")
                        WRITE(BL%IOUT,'(A)') '   FARM_NET_RECHARGE_ARRAY (FNRCH_ARRAY)  OUTPUT KEYWORD FOUND. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "FNRCH_ARRAY.out"'
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%FNRCH_ARRAY%OPEN("FNRCH_ARRAY.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        ELSE
                                CALL OFL%FNRCH_ARRAY%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                !
                                IF(OFL%FNRCH_ARRAY%IU==Z) CALL OFL%FNRCH_ARRAY%OPEN("FNRCH_ARRAY.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        END IF
      CASE ("FNRCH_LIST","FARM_NET_RECHARGE_LIST")
                        WRITE(BL%IOUT,'(A)') '   FARM_NET_RECHARGE_LIST (FNRCH_LIST)    OUTPUT KEYWORD FOUND. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "FNRCH_LIST.out"'
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%FNRCH_LIST%OPEN("FNRCH_LIST.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        ELSE
                                CALL OFL%FNRCH_LIST%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                !
                                IF(OFL%FNRCH_LIST%IU==Z) CALL OFL%FNRCH_LIST%OPEN("FNRCH_LIST.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        END IF
      CASE ("WBS_WATER_USE")
                        WRITE(BL%IOUT,'(A)') '   WBS_WATER_USE                          OUTPUT KEYWORD FOUND. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "FMP_WBS_WATER_USE.txt"'
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%WBS_WATER_USE%OPEN("FMP_WBS_WATER_USE.txt",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        ELSE
                                CALL OFL%WBS_WATER_USE%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                !
                                IF(OFL%WBS_WATER_USE%IU==Z) CALL OFL%WBS_WATER_USE%OPEN("FMP_WBS_WATER_USE.txt",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        END IF
      CASE ("FDS","FARM_DEMAND_SUPPLY_SUMMARY")
                        WRITE(BL%IOUT,'(A)') '   FARM_DEMAND_SUPPLY_SUMMARY (FDS)       OUTPUT KEYWORD FOUND. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "FDS.out"'
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%FDS%OPEN("FDS.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        ELSE
                                CALL OFL%FDS%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11)
                                !
                                IF(OFL%FDS%IU==Z) CALL OFL%FDS%OPEN("FDS.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        END IF
                        !
      CASE ("FB_COMPACT","FARM_BUDGET_COMPACT")
                        WRITE(BL%IOUT,'(A)') '   FARM_BUDGET_COMPACT  (FB_COMPACT)      OUTPUT FOUND. NOW OPENING GENERIC_OUTPUT FILE. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "FB_COMPACT.out"'
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%FB_COMPACT%OPEN("FB_COMPACT.out",LLOC,BL%IOUT,BL%IU)
                        ELSE
                                CALL OFL%FB_COMPACT%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11)
                                !
                                IF(OFL%FB_COMPACT%IU==Z)  CALL OFL%FB_COMPACT%OPEN("FB_COMPACT.out",LLOC,BL%IOUT,BL%IU)
                        END IF
                        
                        !
      CASE ("FB_DETAILS","FB_DETAIL","FARM_BUDGET")
                        WRITE(BL%IOUT,'(A)') '   FARM_BUDGET (FB_DETAILS)               OUTPUT FOUND. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "FB_DETAILS.out"'
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%FB_DETAILS%OPEN("FB_DETAILS.out",LLOC,BL%IOUT,BL%IU)
                        ELSE
                                CALL OFL%FB_DETAILS%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11)
                                !
                                IF(OFL%FB_DETAILS%IU==Z)  CALL OFL%FB_DETAILS%OPEN("FB_DETAILS.out",LLOC,BL%IOUT,BL%IU)
                        END IF
                        !
      CASE ("ET_ARRAY","EVAPOTRANSPIRATION_SUMMARY")
                        WRITE(BL%IOUT,'(A)') '   EVAPOTRANSPIRATION_SUMMARY (ET_ARRAY)  OUTPUT KEYWORD FOUND. NOW LOADING KEYWORD "SUM" OR "SEPARATE" AND OPENING GENERIC_OUTPUT FILE.'
                        CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP)
                        SELECT CASE ( BL%LINE(ISTART:ISTOP) )
                        CASE("SUM")      
                                           WRITE(BL%IOUT,'(A)') 'FOUND SUM KEYWORD, NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "ET_ARRAY.out"'
                                           IF(BL%LINE(LLOC:) == BLNK) THEN
                                                   LLOC=ONE
                                                   CALL OFL%ET_ARRAY_SUM%OPEN("ET_ARRAY.out",LLOC,BL%IOUT,BL%IU)
                                           ELSE
                                                   CALL OFL%ET_ARRAY_SUM%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                                   !
                                                   IF(OFL%ET_ARRAY_SUM%IU==Z)  CALL OFL%ET_ARRAY_SUM%OPEN("ET_ARRAY.out",LLOC,BL%IOUT,BL%IU)
                                           END IF
                        CASE("SEPARATE")      
                                           WRITE(BL%IOUT,'(A)') 'FOUND SEPARATE KEYWORD, NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "E_n_T_ARRAY.out"'
                                           IF(BL%LINE(LLOC:) == BLNK) THEN
                                                   LLOC=ONE
                                                   CALL OFL%ET_ARRAY_SEP%OPEN("E_n_T_ARRAY.out",LLOC,BL%IOUT,BL%IU)
                                           ELSE
                                                   CALL OFL%ET_ARRAY_SEP%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                                   !
                                                   IF(OFL%ET_ARRAY_SEP%IU==Z)  CALL OFL%ET_ARRAY_SEP%OPEN("E_n_T_ARRAY.out",LLOC,BL%IOUT,BL%IU)
                                           END IF
                        CASE DEFAULT;     CALL STOP_ERROR(OUTPUT=BL%IOUT, MSG='FMP OUTPUT BLOCK ERROR. IF YOU SPECIFY KEYWORD "ET_ARRAY",'//NL//'YOU MUST FOLLOW IT WITH THE KEYWORD "SUM" OR "SEPARATE".')
                        END SELECT
      CASE ("ET_LIST","EVAPOTRANSPIRATION_LIST")
                        WRITE(BL%IOUT,'(A)') '   EVAPOTRANSPIRATION_LIST (ET_LIST)      OUTPUT KEYWORD FOUND. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "ET_LIST.out"'
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%ET_LIST%OPEN("ET_LIST.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        ELSE
                                CALL OFL%ET_LIST%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                !
                                IF(OFL%ET_LIST%IU==Z) CALL OFL%ET_LIST%OPEN("ET_LIST.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        END IF
                        !
      CASE ("ROUTING_INFORMATION")
                        WRITE(BL%IOUT,'(A)') '   ROUTING_INFORMATION                    OUTPUT KEYWORD FOUND. NOW LOADING KEYWORD "STATIC" OR "TRANSIENT" AND OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "ROUT.out"'
                        CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP)
                        SELECT CASE ( BL%LINE(ISTART:ISTOP) ) ! HAS_ROUT => 1 = STATIC, 2 = TRANSIENT 
                        CASE("STATIC");    OFL%HAS_ROUT = TWO
                        CASE("TRANSIENT"); OFL%HAS_ROUT = ONE
                        CASE DEFAULT;      CALL STOP_ERROR(OUTPUT=BL%IOUT, MSG='FMP OUTPUT BLOCK ERROR. IF YOU SPECIFY KEYWORD "ROUTING_INFORMATION", YOU MUST FOLLOW IT WITH THE KEYWORD "STATIC" OR "TRANSIENT".')
                        END SELECT
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%ROUTING_INFORMATION%OPEN("ROUT.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        ELSE
                                CALL OFL%ROUTING_INFORMATION%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                !
                                IF(OFL%ROUTING_INFORMATION%IU==Z) CALL OFL%ROUTING_INFORMATION%OPEN("ROUT.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        END IF
                        !
      CASE ("GROUNDWATER_EVAPORATION", "EGWA")
                        WRITE(BL%IOUT,'(A)') '   GROUNDWATER_EVAPORATION (EGWA)         OUTPUT KEYWORD FOUND. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "EGWA.out"'
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%EGWA%OPEN("EGWA.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        ELSE
                                CALL OFL%EGWA%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                !
                                IF(OFL%EGWA%IU==Z) CALL OFL%EGWA%OPEN("EGWA.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        END IF
                        !
      CASE ("GROUNDWATER_TRANSPIRATION", "TGWA")
                        WRITE(BL%IOUT,'(A)') '   GROUNDWATER_TRANSPIRATION (TGWA)       OUTPUT KEYWORD FOUND. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "TGWA.out"'
                        IF(BL%LINE(LLOC:) == BLNK) THEN 
                                LLOC=ONE
                                CALL OFL%TGWA%OPEN("TGWA.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        ELSE
                                CALL OFL%TGWA%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                !
                                IF(OFL%TGWA%IU==Z) CALL OFL%TGWA%OPEN("TGWA.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        END IF
                        !
      CASE ("GROUNDWATER_EVAPOTRANSPIRATION", "ETGW")
                        WRITE(BL%IOUT,'(A)') '   GROUNDWATER_EVAPOTRANSPIRATION (ETGW)  OUTPUT KEYWORD FOUND. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "ETGW.out"'
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%ETGW%OPEN("ETGW.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        ELSE
                                CALL OFL%ETGW%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                !
                                IF(OFL%ETGW%IU==Z) CALL OFL%ETGW%OPEN("ETGW.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        END IF
                        !
      CASE ("IRRIGATION_EVAPORATION", "EI")
                        WRITE(BL%IOUT,'(A)') '   IRRIGATION_EVAPORATION (EI)            OUTPUT KEYWORD FOUND. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "EI.out"'
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%EI%OPEN("EI.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        ELSE
                                CALL OFL%EI%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                !
                                IF(OFL%EI%IU==Z) CALL OFL%EI%OPEN("EI.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        END IF
                        !
      CASE ("IRRIGATION_TRANSPIRATION", "TI")
                        WRITE(BL%IOUT,'(A)') '   IRRIGATION_TRANSPIRATION (TI)          OUTPUT KEYWORD FOUND. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "TI.out"'
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%TI%OPEN("TI.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        ELSE
                                CALL OFL%TI%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                !
                                IF(OFL%TI%IU==Z) CALL OFL%TI%OPEN("TI.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        END IF
                        !
      CASE ("IRRIGATION_EVAPOTRANSPIRATION", "ETI")
                        WRITE(BL%IOUT,'(A)') '   IRRIGATION_EVAPOTRANSPIRATION (ETI)    OUTPUT KEYWORD FOUND. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "ETI.out"'
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%ETI%OPEN("ETI.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        ELSE
                                CALL OFL%ETI%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                !
                                IF(OFL%ETI%IU==Z) CALL OFL%ETI%OPEN("ETI.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        END IF
                        !
      CASE ("PRECIPITATION_EVAPORATION", "EP")
                        WRITE(BL%IOUT,'(A)') '   PRECIPITATION_EVAPORATION (EP)         OUTPUT KEYWORD FOUND. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "EP.out"'
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%EP%OPEN("EP.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        ELSE
                                CALL OFL%EP%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                !
                                IF(OFL%EP%IU==Z) CALL OFL%EP%OPEN("EP.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        END IF
                        !
      CASE ("PRECIPITATION_TRANSPIRATION", "TP")
                        WRITE(BL%IOUT,'(A)') '   PRECIPITATION_TRANSPIRATION (TP)       OUTPUT KEYWORD FOUND. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "TP.out"'
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%TP%OPEN("TP.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        ELSE
                                CALL OFL%TP%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                !
                                IF(OFL%TP%IU==Z) CALL OFL%TP%OPEN("TP.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        END IF
                        !
      CASE ("PRECIPITATION_EVAPOTRANSPIRATION", "ETP")
                        WRITE(BL%IOUT,'(A)') '   PRECIPITATION_EVAPOTRANSPIRATION (ETP) OUTPUT KEYWORD FOUND. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "ETP.out"'
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%ETP%OPEN("ETP.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        ELSE
                                CALL OFL%ETP%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                !
                                IF(OFL%ETP%IU==Z) CALL OFL%ETP%OPEN("ETP.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        END IF
                        !
      CASE ("LANDSCAPE_RUNOFF", "RUNOFF")
                        WRITE(BL%IOUT,'(A)') '   LANDSCAPE_RUNOFF (RUNOFF)              OUTPUT KEYWORD FOUND. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "RUNOFF.out"'
                        !
                        CALL GET_WORD(BL%LINE,LLOC,ISTART,ISTOP,KEY) 
                        IF(KEY.NE.'COMPACT') LLOC = ISTART
                        !
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%RUNOFF%OPEN("RUNOFF.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        ELSE
                                CALL OFL%RUNOFF%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                !
                                IF(OFL%RUNOFF%IU==Z) CALL OFL%RUNOFF%OPEN("RUNOFF.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        END IF
                        !
                        IF(OFL%RUNOFF%NULL_FILE) CALL OFL%RUNOFF%CLOSE()
                        !
                        IF(OFL%RUNOFF%IS_OPEN .AND. KEY=='COMPACT') OFL%RUNOFF%NULL_FILE = TRUE
                        !
      CASE ("DEEP_PERCOLATION", "INFILTRATION")
                        WRITE(BL%IOUT,'(A)') '   DEEP_PERCOLATION (INFILTRATION)        OUTPUT KEYWORD FOUND. NOW OPENING GENERIC_OUTPUT FILE. IF NOTHING SPECIFIED THEN OPENING FILE: "DPERC.out"'
                        !
                        CALL GET_WORD(BL%LINE,LLOC,ISTART,ISTOP,KEY) 
                        IF(KEY.NE.'COMPACT') LLOC = ISTART
                        !
                        IF(BL%LINE(LLOC:) == BLNK) THEN
                                LLOC=ONE
                                CALL OFL%DPERC%OPEN("DPERC.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        ELSE
                                CALL OFL%DPERC%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE)
                                !
                                IF(OFL%DPERC%IU==Z) CALL OFL%DPERC%OPEN("DPERC.out",LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11,NOBINARY=TRUE, NO_INTERNAL=TRUE)
                        END IF
                        !
                        IF(OFL%DPERC%NULL_FILE) CALL OFL%DPERC%CLOSE()
                        !
                        IF(OFL%DPERC%IS_OPEN .AND. KEY=='COMPACT') OFL%DPERC%NULL_FILE = TRUE
      CASE DEFAULT
                        CALL WARN_MSG1%ADD('FOUND UNKNOWN KEYWORD "'//BL%LINE(ISTART:ISTOP)//'" ***IT WILL BE IGNORED***'//BLN)
                        
      END SELECT
      !
      CALL BL%NEXT()
      CALL WARN_MSG1%CHECK(HED='FMP OUTPUT BLOCK'//NL,INFILE=BL%IU,OUTPUT=BL%IOUT,INLINE=TRUE,CMD_PRINT=TRUE,TAIL=NL)
      CALL WARN_MSG2%CHECK(INFILE=BL%IU,OUTPUT=BL%IOUT)
      !
    END DO
    !
    SELECT CASE(ITMUNI)
    CASE(1); TIMEUNIT='       SECONDS'
    CASE(2); TIMEUNIT='       MINUTES'
    CASE(3); TIMEUNIT='         HOURS'
    CASE(4); TIMEUNIT='          DAYS'
    CASE(5); TIMEUNIT='         YEARS'
    CASE DEFAULT
            TIMEUNIT='       UNKNOWN'
    END SELECT
    !
    IF(OFL%FDS       %IS_OPEN .AND. .NOT. OFL%FDS       %BINARY) CALL OFL%FDS       %SET_HEADER('  PER  STP'//TIMEUNIT//'    FID         OFE              TFDR-INI            NR-SWD-INI             R-SWD-INI              QREQ-INI              TFDR-FIN            NR-SWD-FIN             R-SWD-FIN              QREQ-FIN                 Q-FIN  DEF-FLAG           DATE_START   ACTIVE')
    IF(OFL%FB_COMPACT%IS_OPEN .AND. .NOT. OFL%FB_COMPACT%BINARY) CALL OFL%FB_COMPACT%SET_HEADER('         PER         STP'//TIMEUNIT//'         FID            Q-p-in           Q-sw-in           Q-gw-in          Q-ext-in          Q-tot-in          Q-et-out       Q-ineff-out          Q-sw-out          Q-gw-out         Q-tot-out          Q-in-out  Q-Discrepancy[%]        DATE_START            ACTIVE')
    IF(OFL%FB_DETAILS%IS_OPEN .AND. .NOT. OFL%FB_DETAILS%BINARY) CALL OFL%FB_DETAILS%SET_HEADER('         PER         STP'//TIMEUNIT//'         FID            Q-p-in          Q-nrd-in          Q-srd-in          Q-drt-in        Q-wells-in          Q-egw-in          Q-tgw-in         Q-drch-in          Q-ext-in          Q-tot-in          Q-ei-out          Q-ep-out         Q-egw-out          Q-ti-out          Q-tp-out         Q-tgw-out         Q-run-out          Q-dp-out         Q-nrd-out         Q-srd-out          Q-rd-out       Q-wells-out         Q-tot-out          Q-in-out  Q-Discrepancy[%]   DATE_START            ACTIVE')
    IF(OFL%ET_LIST   %IS_OPEN .AND. .NOT. OFL%ET_LIST   %BINARY) CALL OFL%ET_LIST   %SET_HEADER('  PER  STP'//TIMEUNIT//'    FARM ID           EVAPOARATION          TRANSPIRATION     EVAPOTRANSPIRATION')
    IF(OFL%FNRCH_LIST%IS_OPEN .AND. .NOT. OFL%FNRCH_LIST%BINARY) CALL OFL%FNRCH_LIST%SET_HEADER('  PER  STP'//TIMEUNIT//'    FARM ID         RATE')
    !
    IF(OFL%WBS_WATER_USE%IS_OPEN .AND. .NOT. OFL%WBS_WATER_USE%BINARY) &
       CALL OFL%WBS_WATER_USE%SET_HEADER('    PER    STP    WBS             AREA   IRRIGATED_AREA          PET_NAT         ETgw_NAT          ETp_NAT            P_NAT          PET_IRR         ETgw_IRR          ETp_IRR          ETi_IRR            P_IRR       DEMAND_POT       EFFICIENCY          NRD_USE          SRD_USE            Q_USE             DELT   DYEAR            DATE_START')
    !
    !IF(OFL%ET_ARRAY_SUM       %IS_OPEN) CALL OFL%ET_ARRAY_SUM       %SET_HEADER()
    !IF(OFL%ET_ARRAY_SEP       %IS_OPEN) CALL OFL%ET_ARRAY_SEP       %SET_HEADER()
    !IF(OFL%FNRCH_ARRAY        %IS_OPEN) CALL OFL%FNRCH_ARRAY        %SET_HEADER()
    !IF(OFL%FWELLS             %IS_OPEN) CALL OFL%FWELLS             %SET_HEADER()
    !IF(OFL%ROUTING_INFORMATION%IS_OPEN) CALL OFL%ROUTING_INFORMATION%SET_HEADER()
    !
    ! NOT YET IMPLIMENTED
    !
    !IF(OFL%EGWA               %IS_OPEN) CALL OFL%EGWA               %SET_HEADER()
    !IF(OFL%TGWA               %IS_OPEN) CALL OFL%TGWA               %SET_HEADER()
    !IF(OFL%TI                 %IS_OPEN) CALL OFL%TI                 %SET_HEADER()
    !IF(OFL%EI                 %IS_OPEN) CALL OFL%EI                 %SET_HEADER()
    !IF(OFL%TP                 %IS_OPEN) CALL OFL%TP                 %SET_HEADER()
    !IF(OFL%EP                 %IS_OPEN) CALL OFL%EP                 %SET_HEADER()
    !IF(OFL%ETGW               %IS_OPEN) CALL OFL%ETGW               %SET_HEADER()
    !IF(OFL%ETI                %IS_OPEN) CALL OFL%ETI                %SET_HEADER()
    !IF(OFL%ETP                %IS_OPEN) CALL OFL%ETP                %SET_HEADER()
    !IF(OFL%RUNOFF             %IS_OPEN) CALL OFL%RUNOFF             %SET_HEADER()
    !IF(OFL%DPERC              %IS_OPEN) CALL OFL%DPERC              %SET_HEADER()
    !
  END SUBROUTINE 
  !
END MODULE
!
!#########################################################################################################
!
MODULE SURFACE_WATER_DATA_FMP_INTERFACE
  !
  USE FMP_DIMENSION_INTERFACE,           ONLY: FMP_DIMENSION
  !
  USE CONSTANTS
  USE UTIL_INTERFACE,                    ONLY: STOP_ERROR, WARNING_MESSAGE,GET_NUMBER, READ_TO_DATA, PARSE_WORD_UP, IS_CLOSE
  USE NUM2STR_INTERFACE,                 ONLY: NUM2STR
  USE ALLOC_INTERFACE,                   ONLY: ALLOC
  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
  USE LIST_ARRAY_INPUT_INTERFACE,        ONLY: LIST_ARRAY_INPUT, LIST_ARRAY_INPUT_INT
  USE WARNING_TYPE_INSTRUCTION,          ONLY: WARNING_TYPE
  USE SFR_INPUT_DATA_TYPES,              ONLY: SFR_NAMED_LOCATION, WBS_SEG_RCH_WT_TFR, SFR_SEGRCH_TFR, SFR_SEG_TFR, FMP_FLOW_REMOVE_SFR
  USE LINKED_LIST_INSTRUCTION,           ONLY: INTEGER_LINKED_LIST
  USE SORT_INTERFACE,                    ONLY: SORT, REVERSE_ORDER
  USE GENERIC_OUTPUT_FILE_INSTRUCTION,   ONLY: GENERIC_OUTPUT_FILE
  
  USE ULOAD_AND_SFAC_INTERFACE
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: SURFACE_WATER_DATA, INITIALIZE_SURFACE_WATER_DATA, SRD_LOC, RETURN_LOC
  !
  TYPE SRD_LOC
      INTEGER:: N=Z
      LOGICAL:: NO_WT = TRUE
      INTEGER,         DIMENSION(:,:),ALLOCATABLE:: SR
      INTEGER,         DIMENSION(:),  ALLOCATABLE:: ISRD       !OLD SRD TFR POSITION
      INTEGER,         DIMENSION(:),  ALLOCATABLE:: ISTRM      !SFR Location
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: WT         !Fraction of dmd tfat each delivery satisfies
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: FLOW       !Delivery Flow Rate
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: FLOW_OLD   !Delivery Flow Rate From Preivous Iter
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: LLIM, ULIM !Delivery limits
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: MAXDEL     !Delivery limit - Used for output
      DOUBLE PRECISION:: TOT_DMD_INI, TOT_DMD_MET
  END TYPE
  !
  TYPE RETURN_LOC
      LOGICAL:: HAS_RETURN = FALSE
      LOGICAL:: FULLY      = FALSE
      LOGICAL:: BUILD_FULLY= FALSE
      LOGICAL:: LEAVE_MODEL= FALSE
      INTEGER:: N=Z
      INTEGER,         DIMENSION(:,:),ALLOCATABLE:: SR
      INTEGER,         DIMENSION(  :),ALLOCATABLE:: ISRR       !OLD SRD TFR POSITION
      INTEGER,         DIMENSION(  :),ALLOCATABLE:: ISTRM
      DOUBLE PRECISION,DIMENSION(  :),ALLOCATABLE:: WT
      DOUBLE PRECISION,DIMENSION(  :),ALLOCATABLE:: RUNOFF
      DOUBLE PRECISION:: TOTLENGTH
  END TYPE
  !
  TYPE SURFACE_WATER_DATA
      LOGICAL:: HAS_SW = FALSE
      INTEGER:: IOUT=Z, LOUT=Z
      INTEGER:: NFARM = Z
      INTEGER:: NSFR_DELIV  = Z
      INTEGER:: NSFR_RETURN = Z
      INTEGER:: IRRFL = Z
      !INTEGER:: IRDFL = Z
      INTEGER:: MXNRD = Z
      INTEGER:: NSEG = Z
      LOGICAL:: REQ_SFR    = FALSE
      LOGICAL:: HAS_NRD    = FALSE
      LOGICAL:: HAS_SRD    = FALSE
      LOGICAL:: HAS_RET    = FALSE
      LOGICAL:: NRD_IS_RAT = FALSE
      LOGICAL:: HAS_NRD_LOC= FALSE
      LOGICAL:: NORETURNFLOW=FALSE
      LOGICAL:: TFR_READ   = FALSE
      LOGICAL:: ALWAYS_BUILD_FULLY_ROUTED_RETURN = FALSE
      LOGICAL:: BUILD_FULLY_ROUTED_RETURN = FALSE  ! = ANY(BUILD_FRR)
      LOGICAL:: CMD_RUNOFF_PRNT = TRUE
      LOGICAL, DIMENSION(:),   ALLOCATABLE:: RUNOFF_PRNT   !0 = Printed Before, 1 = Not Printed Yet
      LOGICAL, DIMENSION(:),   ALLOCATABLE:: BUILD_FRR
      INTEGER, DIMENSION(:,:), ALLOCATABLE:: H2ORETURN
      LOGICAL, DIMENSION(:),   ALLOCATABLE:: HAS_SRD_WBS
      !
      DOUBLE PRECISION:: SRD_TOL     = UNO
      INTEGER::          SRD_TOL_CNT = Z
      !
      INTEGER,          DIMENSION(:,:), ALLOCATABLE:: NRD_DP_LOC
      DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE:: NRD_DP
      !
      TYPE(SRD_LOC),   DIMENSION(:), ALLOCATABLE:: SRDLOC
      TYPE(RETURN_LOC),DIMENSION(:), ALLOCATABLE:: SRRLOC
      !
      !TYPE(LIST_ARRAY_INPUT_INT):: ISRD
      !TYPE(LIST_ARRAY_INPUT_INT):: ISRR
      TYPE(WBS_SEG_RCH_WT_TFR):: ISRD_TFR
      TYPE(WBS_SEG_RCH_WT_TFR):: ISRR_TFR
      !TYPE(SFR_SEGRCH_TFR):: ISRR
      TYPE(LIST_ARRAY_INPUT_INT):: NRD_DP_TFR
      TYPE(LIST_ARRAY_INPUT_INT):: CHOICE
      TYPE(LIST_ARRAY_INPUT_INT):: NORETURNFLOW_TFR
      TYPE(LIST_ARRAY_INPUT    ):: NRD
      TYPE(LIST_ARRAY_INPUT    ):: DELIV_L_LIM
      TYPE(LIST_ARRAY_INPUT    ):: DELIV_U_LIM
      !
      TYPE(GENERIC_OUTPUT_FILE):: OUT_SFR_SRD_BYWBS
      TYPE(GENERIC_OUTPUT_FILE):: OUT_SFR_SRD
      TYPE(GENERIC_OUTPUT_FILE):: OUT_SFR_SRR
      TYPE(GENERIC_OUTPUT_FILE):: OUT_SFR_RET
      !
      CONTAINS
      !
      PROCEDURE, PASS(SWF):: NEXT     => SETUP_NEXT_STRESS_PERIOD
      PROCEDURE, PASS(SWF):: NEXT_TS  => SETUP_NEXT_TIME_STEP
      PROCEDURE, PASS(SWF):: SET_NRD_ARRAY
      !PROCEDURE, PASS(SWF):: SET_SRD_ARRAY
      !PROCEDURE, PASS(SWF):: SET_SRR_ARRAY
      PROCEDURE, PASS(SWF):: SET_CHOICE_ARRAY
      PROCEDURE, PASS(SWF):: NO_SURFACE_WATER_DATA!( FDIM, IOUT )
      !
      !!!PROCEDURE, PASS(SWF):: SET_SFR_SRD_FLOW
      PROCEDURE, PASS(SWF):: BUILD_SRD_LOC_FLOW
      PROCEDURE, PASS(SWF):: ADD_SRD_TO_SFR_DELIV!(SFR_DELIV)
      PROCEDURE, PASS(SWF):: APPLY_SRD_DEMAND    !(F, DEMAND, SFR_DELIV)
      PROCEDURE, PASS(SWF):: APPLY_SRD_SURPLUS   !(F, SURPLUS, STRM)
      PROCEDURE, PASS(SWF):: APPLY_RUNOFF_TO_SFR !(RUNOFF, STRM)
      !
      PROCEDURE, PASS(SWF):: BUILD_SRR_LOC_FLOW
      PROCEDURE, PASS(SWF):: BUILD_FULLY_ROUTED_RETURN_SRRLOC!(WBS, IDIVAR, ISTRM, STRM)
      !
      PROCEDURE, PASS(SWF):: PRINT_OUT_SFR_SRD!(DMD, STRM, KPER, KSTP, DELT, DYEAR, DATE)
      PROCEDURE, PASS(SWF):: PRINT_OUT_SFR_SRR!(DMD, STRM, KPER, KSTP, DELT, DYEAR, DATE)
      PROCEDURE, PASS(SWF):: PRINT_OUT_SFR_RET!(DMD, STRM, KPER, KSTP, DELT, DYEAR, DATE)
      PROCEDURE, PASS(SWF):: PRINT_OUT_SFR_SRD_BYWBS
      !
      FINAL:: DEALLOCATE_SURFACE_WATER_FINAL
  END TYPE
  !
  CONTAINS
  !
  SUBROUTINE DEALLOCATE_SURFACE_WATER_FINAL(SWF)
     TYPE(SURFACE_WATER_DATA)::SWF
     CALL DEALLOCATE_SURFACE_WATER(SWF)
  END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_SURFACE_WATER(SWF)
  CLASS(SURFACE_WATER_DATA), INTENT(INOUT)::SWF
     !
     SWF%IOUT  = Z
     SWF%LOUT  = Z
     SWF%NFARM = Z
     SWF%IRRFL = Z
     !SWF%IRDFL = Z
     SWF%MXNRD = Z
     SWF%NSFR_DELIV = Z
     SWF%NSFR_RETURN= Z
     SWF%HAS_SW      = FALSE
     SWF%REQ_SFR     = FALSE
     SWF%HAS_RET     = FALSE
     SWF%HAS_SRD     = FALSE
     SWF%HAS_NRD     = FALSE
     SWF%NRD_IS_RAT  = FALSE
     SWF%HAS_NRD_LOC = FALSE
     SWF%NORETURNFLOW= FALSE
     SWF%TFR_READ    = FALSE
     SWF%BUILD_FULLY_ROUTED_RETURN = FALSE
     SWF%ALWAYS_BUILD_FULLY_ROUTED_RETURN = FALSE
     !
     IF(ALLOCATED(SWF%H2ORETURN )) DEALLOCATE(SWF%H2ORETURN )
     IF(ALLOCATED(SWF%SRDLOC    )) DEALLOCATE(SWF%SRDLOC    )
     IF(ALLOCATED(SWF%SRRLOC    )) DEALLOCATE(SWF%SRRLOC    )
     IF(ALLOCATED(SWF%BUILD_FRR )) DEALLOCATE(SWF%BUILD_FRR )
     IF(ALLOCATED(SWF%NRD_DP_LOC)) DEALLOCATE(SWF%NRD_DP_LOC)
     IF(ALLOCATED(SWF%NRD_DP    )) DEALLOCATE(SWF%NRD_DP    )
     IF(ALLOCATED(SWF%RUNOFF_PRNT)) DEALLOCATE(SWF%RUNOFF_PRNT)
     IF(ALLOCATED(SWF%HAS_SRD_WBS)) DEALLOCATE(SWF%HAS_SRD_WBS)
     !
  END SUBROUTINE
  !  
  SUBROUTINE NO_SURFACE_WATER_DATA(SWF, FDIM, IOUT )
    CLASS(SURFACE_WATER_DATA), INTENT(INOUT):: SWF
    TYPE(FMP_DIMENSION),       INTENT(IN   ):: FDIM
    INTEGER,                   INTENT(IN   ):: IOUT
    INTEGER:: F
    !
    CALL DEALLOCATE_SURFACE_WATER(SWF)
    !
    SWF%IOUT = IOUT
    SWF%LOUT = IOUT
    SWF%NFARM= FDIM%NFARM
    SWF%MXNRD= FDIM%MXNRD
    !
    SWF%NORETURNFLOW = TRUE
    !
    ALLOCATE(SWF%H2ORETURN(TWO,SWF%NFARM), SOURCE=Z)
    ALLOCATE(SWF%SRDLOC(SWF%NFARM))
    ALLOCATE(SWF%SRRLOC(SWF%NFARM))
    ALLOCATE(SWF%RUNOFF_PRNT(SWF%NFARM), SOURCE=TRUE)
    ALLOCATE(SWF%HAS_SRD_WBS(SWF%NFARM), SOURCE=TRUE)
    !
    DO CONCURRENT(F=ONE:SWF%NFARM); SWF%HAS_SRD_WBS(F) = FALSE
    END DO
    !
    DO CONCURRENT(F=ONE:SWF%NFARM); SWF%SRRLOC(F)%HAS_RETURN = FALSE
    END DO
    !
    DO CONCURRENT(F=ONE:SWF%NFARM); SWF%SRRLOC(F)%N = Z
    END DO
    !
    DO CONCURRENT(F=ONE:SWF%NFARM); SWF%SRRLOC(F)%TOTLENGTH = DZ
    END DO
    !
  END SUBROUTINE
  !  
  SUBROUTINE INITIALIZE_SURFACE_WATER_DATA( BL, SWF, LINE, FDIM, NSEG )
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL   !DATA BLOCK
    CLASS(SURFACE_WATER_DATA),   INTENT(INOUT):: SWF
    CHARACTER(*),                INTENT(INOUT):: LINE
    TYPE(FMP_DIMENSION),         INTENT(IN   ):: FDIM
    INTEGER,                     INTENT(IN   ):: NSEG
    CHARACTER(5):: ERROR
    LOGICAL:: EOF, BINARY
    INTEGER:: LLOC, ISTART, ISTOP, F
    INTEGER:: RET_SET
    TYPE(WARNING_TYPE):: WARN_MSG
    !FDIM%SFR_ID%GET(LINE, LLOC, ISTART, ISTOP, SEG, RCH)
    WRITE(BL%IOUT,'(/A/)') 'SURFACEWATER BLOCK FOUND AND NOW LOADING PROPERTIES'
    !
    SWF%HAS_SW      = TRUE
    SWF%HAS_RET     = FALSE
    SWF%HAS_SRD     = FALSE
    SWF%HAS_NRD     = FALSE
    SWF%NRD_IS_RAT  = FALSE
    SWF%HAS_NRD_LOC = FALSE
    !
    SWF%BUILD_FULLY_ROUTED_RETURN = FALSE
    SWF%ALWAYS_BUILD_FULLY_ROUTED_RETURN = FALSE !IF TRUE THEN SFR RETURN FLOW NETWORK IS SCANNED EVERY STRESS PERIOD INSTEAD OF THE FIRST PERIOD
    !
    SWF%IOUT = BL%IOUT
    SWF%LOUT = BL%IOUT
    SWF%NFARM= FDIM%NFARM
    SWF%MXNRD= FDIM%MXNRD
    SWF%NSFR_DELIV = FDIM%NSFR_DELIV
    SWF%NSFR_RETURN= FDIM%NSFR_RETURN
    SWF%NSEG = NSEG
    SWF%SRD_TOL = 0.02D0  !DIVERIES BETWEEN SOLVER ITERATIONS MUST BE WITHIN 2% OF EACH OTHER
    !
    RET_SET = Z
    ERROR='ERROR'
    CALL WARN_MSG%INIT()
    ALLOCATE(SWF%H2ORETURN(TWO,SWF%NFARM))
    ALLOCATE(SWF%SRDLOC(SWF%NFARM))
    ALLOCATE(SWF%SRRLOC(SWF%NFARM))
    ALLOCATE(SWF%BUILD_FRR(SWF%NFARM))         ! = SWF%SRRLOC(F)%HAS_RETURN .AND. SWF%SRRLOC(F)%FULLY .AND. SWF%SRRLOC(F)%BUILD_FULLY
    ALLOCATE(SWF%RUNOFF_PRNT(SWF%NFARM), SOURCE=TRUE)
    ALLOCATE(SWF%HAS_SRD_WBS(SWF%NFARM), SOURCE=FALSE)
    !
    DO CONCURRENT(LLOC=ONE:SWF%NFARM); 
        SWF%SRRLOC(LLOC)%BUILD_FULLY = TRUE     !FLAG TO INDICATE THAT FRR NETWORK MUST BE BUILT
        SWF%SRRLOC(LLOC)%FULLY       = FALSE    !FLAG TO INDICATE THAT FRR IS IN USE FOR FARM
    END DO
    !
    CALL BL%MAKE_SCRATCH_FILE()
    !
    !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
    CALL BL%READ_SCRATCH(EOF, LINE)
    !
    DO WHILE (.NOT. EOF)
      !
      LLOC=ONE
      CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
      !
      SELECT CASE ( LINE(ISTART:ISTOP) )
      CASE ("NON_ROUTED_DELIVERY", "NRD")
                        WRITE(BL%IOUT,'(A)') '   NON_ROUTED_DELIVERY (NRD)       KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN NRD_TYPE TRIPLETS OF NRDs.'
                        IF (SWF%MXNRD>Z) THEN
                            !
                            CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                            SELECT CASE ( LINE(ISTART:ISTOP) )
                            CASE("RATE"  ); SWF%NRD_IS_RAT  = TRUE
                            CASE("VOLUME"); CONTINUE
                            CASE DEFAULT;   LLOC=ISTART
                            END SELECT
                            !CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,SWF%MXNRD,  MSG='FMP OUTPUT BLOCK ERROR; OUTPUT NON_ROUTED_DELIVERY MUST BE FOLLOWED BY INTEGER "MXNRD" (TOTAL/MAX NUMBER OF NRDs).')
                            CALL SWF%NRD%INIT('NRD',  LLOC, LINE, BL%IOUT, BL%IU,SWF%NFARM, SWF%MXNRD*THREE, Z, Z, SWF%NFARM, 'BYWBS', SWF%MXNRD, 'BYNRD', SCRATCH=BL%SCRATCH, LISTARRAY=TRUE)
                            !
                            IF(SWF%NRD%IS_CONSTANT) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SURFACE_WATER BLOCK ERROR. KEYWORD NON_ROUTED_DELIVERY DOES NOT ALLOW THE USE OF KEYWORD "CONSTANT". PLEASE DIRECTLY SPECIFY THE NRD TRIPLETS WITH INTERNAL, EXTERNAL, OPEN/CLOSE, DATAFILE, DATAUNIT.')
                            !
                            SWF%HAS_NRD = SWF%NRD%INUSE
                        ELSE
                            CALL WARNING_MESSAGE(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SURFACE_WATER BLOCK "NON_ROUTED_DELIVERY" KEYWORD IS ONLY ALLOWED'//BLN//'IF YOU SPECIFY IN THE "GLOBAL DIMENSION" BLOCK THE "NRD_TYPES" KEYWORD WITH A VALUE GREATER THAN ZERO.'//BLN//'EITHER KEYWORD NRD_TYPES WAS NOT FOUND IN THE GLOBAL DIMENSION BLOCK OR IT WAS SET TO ZERO OR LESS.'//NL//'ITS CURRENT VALUE IS:'//NUM2STR(SWF%MXNRD)//BLN//'NON-ROUTED DILIVERIES WILL BE IGNORED DURING SIMULATION.')
                        END IF
         CASE ("NRD_INFILTRATION_LOCATION")
                        WRITE(BL%IOUT,'(A)') '   NRD_INFILTRATION_LOCATION    KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD.'
                        !
                        CALL SWF%NRD_DP_TFR%INIT('NRD_DP_LOC', LLOC, LINE, BL%IOUT, BL%IU, Z, Z, FDIM%NROW, FDIM%NCOL, SCRATCH=BL%SCRATCH, CDIM=[3,0,0]) 
                        !
                        ALLOCATE(SWF%NRD_DP_LOC(FDIM%NCOL,FDIM%NROW), SOURCE=Z)
                        ALLOCATE(SWF%NRD_DP    (FDIM%NCOL,FDIM%NROW))
                        !
      CASE ("NORETURNFLOW", "NO_RETURN_FLOW")
                        WRITE(BL%IOUT,'(A)') '   NORETURNFLOW                    KEYWORD FOUND. ALL RUNOFF WILL BECOME INFILTRATION'
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        SELECT CASE(LINE(ISTART:ISTOP))
                        CASE("STATIC","TRANSIENT","LIST")
                                   LLOC = ISTART
                                   CALL SWF%NORETURNFLOW_TFR%INIT('NORETURNFLOW', LLOC, LINE, BL%IOUT, BL%IU, SWF%NFARM, ONE, Z, Z, SCRATCH=BL%SCRATCH)
                        CASE DEFAULT
                                   SWF%NORETURNFLOW = TRUE
                        END SELECT
                        !
      CASE ("RETURN_FLOW_CHOICES")
                        WRITE(BL%IOUT,'(A)') '   RETURN_FLOW_CHOICES             KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST STYLE SEGMENT AND REACH INTEGERS.'
                        CALL SWF%CHOICE%INIT('RET_TYP', LLOC, LINE, BL%IOUT, BL%IU, SWF%NFARM, TWO, Z, Z, SCRATCH=BL%SCRATCH)
                        SWF%REQ_SFR = TRUE
                        !
      CASE ("SEMI_ROUTED_DELIVERY","SRD")
                        WRITE(BL%IOUT,'(A)') '   SEMI_ROUTED_DELIVERY (SRD)      KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST STYLE INPUT OF SEGMENT AND REACH INTEGERS.'
                        !
                        IF(SWF%NSFR_DELIV > Z) THEN
                            CALL SWF%ISRD_TFR%INIT('ISRD', LLOC, LINE, BL%IOUT, BL%IU, SCRATCH=BL%SCRATCH, DIM=[SWF%NSFR_DELIV], WILD_IN=FDIM%SFR_ID )
                            !
                            SWF%REQ_SFR = TRUE
                            !
                            SWF%HAS_SRD = SWF%ISRD_TFR%INUSE
                        ELSE
                            CALL WARNING_MESSAGE(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SURFACE_WATER BLOCK "SEMI_ROUTED_DELIVERY" KEYWORD IS ONLY ALLOWED'//BLN//'IF YOU SPECIFY IN THE "GLOBAL DIMENSION" BLOCK THE "NSFR_DELIV" KEYWORD WITH A VALUE GREATER THAN ZERO.'//BLN//'EITHER KEYWORD NSFR_DELIV WAS NOT FOUND IN THE GLOBAL DIMENSION BLOCK OR IT WAS SET TO ZERO OR LESS.'//NL//'ITS CURRENT VALUE IS:'//NUM2STR(SWF%NSFR_DELIV)//BLN//'SEMI-ROUTED DILIVERIES WILL BE IGNORED DURING SIMULATION.')
                        END IF
                        !
      CASE ("SEMI_ROUTED_DELIVERY_LOWER_LIMIT")
                        WRITE(BL%IOUT,'(A)') '   SEMI_ROUTED_DELIVERY_LOWER_LIMIT KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST STYLE INPUT OF SEGMENT AND REACH INTEGERS.'
                        !
                        IF(SWF%NSFR_DELIV > Z) THEN
                            CALL SWF%DELIV_L_LIM%INIT('SRD_LOWER_LIM',  LLOC, LINE, BL%IOUT, BL%IU,SWF%NSFR_DELIV, ONE, Z, Z, SCRATCH=BL%SCRATCH)
                        ELSE
                            CALL WARNING_MESSAGE(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SURFACE_WATER BLOCK "SEMI_ROUTED_DELIVERY_LOWER_LIMIT" KEYWORD IS ONLY ALLOWED'//BLN//'IF YOU SPECIFY IN THE "GLOBAL DIMENSION" BLOCK THE "NSFR_DELIV" KEYWORD WITH A VALUE GREATER THAN ZERO.'//BLN//'EITHER KEYWORD NSFR_DELIV WAS NOT FOUND IN THE GLOBAL DIMENSION BLOCK OR IT WAS SET TO ZERO OR LESS.'//NL//'ITS CURRENT VALUE IS:'//NUM2STR(SWF%NSFR_DELIV)//BLN//'SEMI-ROUTED DILIVERIES WILL BE IGNORED DURING SIMULATION.')
                        END IF
                        !
      CASE ("SEMI_ROUTED_DELIVERY_UPPER_LIMIT")
                        WRITE(BL%IOUT,'(A)') '   SEMI_ROUTED_DELIVERY_UPPER_LIMIT KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST STYLE INPUT OF SEGMENT AND REACH INTEGERS.'
                        !
                        IF(SWF%NSFR_DELIV > Z) THEN
                            CALL SWF%DELIV_U_LIM%INIT('SRD_UPPER_LIM',  LLOC, LINE, BL%IOUT, BL%IU,SWF%NSFR_DELIV, ONE, Z, Z, SCRATCH=BL%SCRATCH)
                        ELSE
                            CALL WARNING_MESSAGE(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SURFACE_WATER BLOCK "SEMI_ROUTED_DELIVERY_UPPER_LIMIT" KEYWORD IS ONLY ALLOWED'//BLN//'IF YOU SPECIFY IN THE "GLOBAL DIMENSION" BLOCK THE "NSFR_DELIV" KEYWORD WITH A VALUE GREATER THAN ZERO.'//BLN//'EITHER KEYWORD NSFR_DELIV WAS NOT FOUND IN THE GLOBAL DIMENSION BLOCK OR IT WAS SET TO ZERO OR LESS.'//NL//'ITS CURRENT VALUE IS:'//NUM2STR(SWF%NSFR_DELIV)//BLN//'SEMI-ROUTED DILIVERIES WILL BE IGNORED DURING SIMULATION.')
                        END IF
                        !
      CASE ("SEMI_ROUTED_RETURN", "SRR")
                        WRITE(BL%IOUT,'(A)') '   SEMI_ROUTED_RETURN (SRR)        KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST STYLE INPUT OF SEGMENT AND REACH INTEGERS.'
                        !
                        IF(SWF%NSFR_RETURN > Z) THEN
                            CALL SWF%ISRR_TFR%INIT('ISRR', LLOC, LINE, BL%IOUT, BL%IU, SCRATCH=BL%SCRATCH, DIM=[SWF%NSFR_RETURN], WILD_IN=FDIM%SFR_ID )
                            !
                            SWF%REQ_SFR = TRUE
                        ELSE
                            CALL WARNING_MESSAGE(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SURFACE_WATER BLOCK "SEMI_ROUTED_RETURN" KEYWORD IS ONLY ALLOWED'//BLN//'IF YOU SPECIFY IN THE "GLOBAL DIMENSION" BLOCK THE "NSFR_RETURN" KEYWORD WITH A VALUE GREATER THAN ZERO.'//BLN//'EITHER KEYWORD NSFR_RETURN WAS NOT FOUND IN THE GLOBAL DIMENSION BLOCK OR IT WAS SET TO ZERO OR LESS.'//NL//'ITS CURRENT VALUE IS:'//NUM2STR(SWF%NSFR_RETURN)//BLN//'SEMI-ROUTED RETURN FLOW WILL BE IGNORED DURING SIMULATION.')
                        END IF
                        !!!!CALL SWF%ISRR%INIT('ISRR', LLOC, LINE, BL%IOUT, BL%IU, SCRATCH=BL%SCRATCH, DIM=[TWO, SWF%NFARM], WILD_IN=FDIM%SFR_ID )
                        !!!!SWF%REQ_SFR = TRUE
                        !
      !!!CASE ("ROUTED_DELIVERY_UPPER_DIVERSION")
      !!!                  WRITE(BL%IOUT,'(A)') '   ROUTED_DELIVERY_UPPER_DIVERSION KEYWORD FOUND. IF SEMI-ROUTED DELIVERY NOT SPECIFIED THEN WBS/FARM WILL TAKE FROM UPPER MOST DIVERSION SEGEMENT LOCATED IN WBS.'
      !!!                  SWF%IRDFL = ONE
      !!!                  SWF%REQ_SFR = TRUE
      !!!                  DIV_SET = DIV_SET + ONE
      !!!                  !
      !!!CASE ("ROUTED_DELIVERY_UPPER_REACH")
      !!!                  WRITE(BL%IOUT,'(A)') '   ROUTED_DELIVERY_UPPER_REACH     KEYWORD FOUND.  IF SEMI-ROUTED DELIVERY NOT SPECIFIED THEN WBS/FARM WILL TAKE FROM UPPER MOST REACH LOCATED IN WBS.'
      !!!                  SWF%IRDFL = NEG
      !!!                  SWF%REQ_SFR = TRUE
      !!!                  DIV_SET = DIV_SET + ONE
      !!!                  !
      CASE ("ROUTED_RETURN_ANY_NON_DIVERSION_REACH")
                        WRITE(BL%IOUT,'(A)') '   ROUTED_RETURN_NON_DIVERSION     KEYWORD FOUND. IF SEMI-ROUTED RETURN FLOW NOT SPECIFIED THEN WBS/FARM WILL PRORATE RUNOFF ACROSS ALL NON-DIVERSION REACHES BY LENGTH WITHIN WBS.'
                        SWF%IRRFL = ONE
                        SWF%REQ_SFR = TRUE
                        RET_SET = RET_SET + ONE
                        !
      CASE ("ROUTED_RETURN_ANY_REACH")
                        WRITE(BL%IOUT,'(A)') '   ROUTED_RETURN_ANY_REACH         KEYWORD FOUND. IF SEMI-ROUTED RETURN FLOW NOT SPECIFIED THEN WBS/FARM WILL PRORATE RUNOFF ACROSS ALL REACHES BY LENGTH WITHIN WBS.'
                        SWF%IRRFL = NEG
                        SWF%REQ_SFR = TRUE
                        RET_SET = RET_SET + ONE
                        !
      CASE ("REBUILD_FULLY_ROUTED_RETURN")
                        WRITE(BL%IOUT,'(A)') '   REBUILD_FULLY_ROUTED_RETURN      KEYWORD FOUND. FULLY ROUTED RETURN FLOW NETWORK MAP WILL BE REBUILT AT THE START OF EVERY STRESS PERIOD.'
                        SWF%ALWAYS_BUILD_FULLY_ROUTED_RETURN = TRUE
      CASE("SEMI_ROUTED_DELIVERY_CLOSURE_TOLERANCE")
                        WRITE(BL%IOUT,'(A)') '   SEMI_ROUTED_DELIVERY_CLOSURE_TOLERANCE KEYWORD FOUND, NOW LOADING NEW CONVERTGENCE TOLERANCE.'
                        CALL GET_NUMBER(LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,SWF%SRD_TOL,MSG='FMP SURFACE_WATER BLOCK ERROR; FOUND KEYWORD "SEMI_ROUTED_DELIVERY_CLOSURE_TOLERANCE" BUT FAILED TO LOAD THE NUMBER AFTER IT.')
                        !
                        IF(SWF%SRD_TOL < NEARZERO_7) SWF%SRD_TOL= NEARZERO_7
      CASE ("PRINT")
                        BINARY = FALSE
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        IF(LINE(ISTART:ISTOP) == 'BINARY') THEN
                            BINARY = TRUE
                            CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        END IF
                        !
                        SELECT CASE ( LINE(ISTART:ISTOP) )
                        CASE ("SFR_DELIVERY_BY_WBS")
                                          CALL SWF%OUT_SFR_SRD_BYWBS%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("SFR_DELIVERY")
                                          CALL SWF%OUT_SFR_SRD%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("SFR_SRR_ONLY")
                                          CALL SWF%OUT_SFR_SRR%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("SFR_RETURN")
                                          CALL SWF%OUT_SFR_RET%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        !
                        CASE DEFAULT;     CALL STOP_ERROR(LINE,BL%IU,BL%IOUT,'FMP SURFACE_WATER BLOCK KEYWORD ERROR. IDENTIFIED KEYWORD "PRINT", BUT THE NEXT WORD WAS NOT IDENTIFIED.'//NL//'WORDS EXPECTED ARE: "SFR_DELIVERY", "SFR_DELIVERY_BY_WBS", "SFR_RETURN", "SFR_SRR_ONLY"')
                        END SELECT
      CASE DEFAULT
                        CALL WARN_MSG%ADD('FOUND UNKNOWN KEYWORD "'//LINE(ISTART:ISTOP)//'" ***IT WILL BE IGNORED***'//BLN)
                        
      END SELECT
      !
      !IF(DIV_SET > ONE) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SURFACE_WATER BLOCK ERROR. YOU CAN ONLY SELECT AT MOST ONE FULLY-ROUTED DELIVERY OPTION, FOUND KEYWORDS "ROUTED_DELIVERY_UPPER_DIVERSION" AND "ROUTED_RETURN_NON_DIVERSION". PROGRAM WILL NOW TERMINATE.')
      !
      IF(RET_SET > ONE) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SURFACE_WATER BLOCK ERROR. YOU CAN ONLY SELECT AT MOST ONE FULLY-ROUTED RETURN FLOW OPTION, FOUND KEYWORDS "ROUTED_RETURN_NON_DIVERSION" AND "ROUTED_RETURN_ANY_REACH". PROGRAM WILL NOW TERMINATE.')
      !
      !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
      CALL BL%READ_SCRATCH(EOF, LINE)
      !
    END DO
    !
    CALL WARN_MSG%CHECK(HED='FMP SURFACE_WATER BLOCK'//NL,INFILE=BL%IU,OUTPUT=BL%IOUT,INLINE=TRUE,CMD_PRINT=TRUE,TAIL=NL)
    !
    IF (SWF%MXNRD > Z .AND. .NOT. SWF%HAS_NRD) THEN
        SWF%MXNRD = Z
        CALL WARNING_MESSAGE(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SURFACE_WATER BLOCK FAILED TO LOCATE "NON_ROUTED_DELIVERY" WHEN THE "GLOBAL DIMENSION" BLOCK SPECIFIED A NONZERO "NRD_TYPES"'//BLN//'THE FOLLOWING IS THE NUMBER OF NRD_TYPES EXPECTED: '//NUM2STR(SWF%MXNRD)//BLN//'NON-ROUTED DILIVERIES WILL BE IGNORED DURING SIMULATION.')
        !CALL SWF%NRD%INIT('NRD', DZ, BL%IOUT, BL%IU, SWF%NFARM, SWF%MXNRD*THREE, Z, Z)
        !
        !DO CONCURRENT(J=ONE:SWF%NFARM, I=ONE:SWF%MXNRD); SWF%NRD%ARRAY( (I-ONE)*THREE + TWO, J ) = DBLE(I)
        !END DO
    END IF
    !
    IF(SWF%NSFR_DELIV > Z .AND. SWF%HAS_SRD) THEN
        !
        IF(.NOT. SWF%DELIV_L_LIM%INUSE) CALL SWF%DELIV_L_LIM%INIT('SRD_LOWER_LIM', DZ,   BL%IOUT, BL%IU, SWF%NSFR_DELIV, ONE, Z, Z)
        IF(.NOT. SWF%DELIV_U_LIM%INUSE) CALL SWF%DELIV_U_LIM%INIT('SRD_UPPER_LIM', D100, BL%IOUT, BL%IU, SWF%NSFR_DELIV, ONE, Z, Z)
        
    END IF
    !
    DO CONCURRENT(F=ONE:SWF%NFARM); SWF%SRRLOC(F)%TOTLENGTH = DZ  !INITIALIZE
    END DO
    !
    IF(SWF%NORETURNFLOW) THEN
                             SWF%H2ORETURN = Z
                             SWF%IRRFL     = Z
                             SWF%REQ_SFR   = SWF%HAS_SRD 
                             SWF%ALWAYS_BUILD_FULLY_ROUTED_RETURN = FALSE
                             !
                             CALL SWF%CHOICE%DESTROY()
                             CALL SWF%ISRR_TFR%DESTROY()
    ELSE
        SWF%HAS_RET = SWF%ISRR_TFR%INUSE .OR. RET_SET > Z
    END IF
    !
    !IF(.NOT. SWF%ISRD%INUSE) THEN
    !                             CALL SWF%ISRD%INIT('ISRD', Z, BL%IOUT, BL%IU, SWF%NFARM, TWO, Z, Z)
    !                             SWF%ISRD%INUSE = FALSE
    !END IF
    !
  END SUBROUTINE 
  !
  SUBROUTINE SETUP_NEXT_STRESS_PERIOD(SWF, FDIM, NEW_FID, SEG_NSTRM, STRM, SW_SOURCE)
    !
    CLASS(SURFACE_WATER_DATA),          INTENT(INOUT):: SWF
    TYPE(FMP_DIMENSION),                INTENT(IN   ):: FDIM
    LOGICAL,                            INTENT(IN   ):: NEW_FID
    INTEGER, DIMENSION(:),  CONTIGUOUS, INTENT(IN   ):: SEG_NSTRM
    REAL,    DIMENSION(:,:),CONTIGUOUS, INTENT(IN   ):: STRM
    LOGICAL, DIMENSION(:),  CONTIGUOUS, INTENT(IN   ):: SW_SOURCE
    !
    INTEGER:: I,J,K,F,N
    LOGICAL:: UPDATE, UPDATE_RETURN, NO_RETURN, IS_FULLY_RETURN
    LOGICAL:: SRD_CHK, SRR_CHK
    TYPE(WARNING_TYPE):: WRN
    !
    IF(.NOT. SWF%HAS_SW) RETURN
    !
    IF(SWF%TFR_READ) THEN
        !
        UPDATE = FALSE
        !
        CALL SWF%ISRD_TFR%NEXT(FDIM%SFR_ID)
        CALL SWF%ISRR_TFR%NEXT(FDIM%SFR_ID)
        CALL SWF%DELIV_L_LIM%NEXT()
        CALL SWF%DELIV_U_LIM%NEXT()
        CALL SWF%CHOICE%NEXT()
        CALL SWF%NRD   %NEXT()
        CALL SWF%NRD_DP_TFR      %NEXT()
        CALL SWF%NORETURNFLOW_TFR%NEXT()
        !
    ELSE
        !
        UPDATE = TRUE
        !
        SWF%TFR_READ = TRUE
    END IF
    !
    CALL WRN%INIT()
    !
    !------------------------------------------------------------------------
    !
    IF(UPDATE .OR. SWF%DELIV_L_LIM%TRANSIENT) THEN
           DO CONCURRENT(K=ONE:SWF%NSFR_DELIV, SWF%DELIV_L_LIM%LIST(K) < DZ );   SWF%DELIV_L_LIM%LIST(K) = DZ
           END DO
    END IF
    !
    IF(UPDATE .OR. SWF%DELIV_U_LIM%TRANSIENT) THEN
           DO CONCURRENT(K=ONE:SWF%NSFR_DELIV, SWF%DELIV_U_LIM%LIST(K) < DZ );   SWF%DELIV_U_LIM%LIST(K) = D100
           END DO
    END IF
    !
    !------------------------------------------------------------------------
    !
    IF(SWF%HAS_SRD) THEN
                   SRD_CHK = UPDATE .OR. (SWF%ISRD_TFR%TRANSIENT .AND. .NOT. SWF%ISRD_TFR%TFR%REPEAT)
    ELSE
                   SRD_CHK = FALSE
    END IF
    !
    IF(SWF%ISRR_TFR%INUSE) THEN
                   SRR_CHK = UPDATE .OR. (SWF%ISRR_TFR%TRANSIENT .AND. .NOT. SWF%ISRR_TFR%TFR%REPEAT)
    ELSE
                   SRR_CHK = FALSE
    END IF
    !
    IF(SRD_CHK) THEN  ! SWF%ISRD%ARRAY CHANGED SWF%ISRD%SEGRCH
        !
        DO K=ONE, SWF%NSFR_DELIV
            IF(SWF%ISRD_TFR%WBS(K) > SWF%NFARM) THEN
                SWF%ISRD_TFR%WBS(K)  = Z
                SWF%ISRD_TFR%SR(:,K) = Z
                SWF%ISRD_TFR%WT(K)   = DZ
            END IF
            !
            IF(SWF%NSEG < SWF%ISRD_TFR%SR(ONE,K)) THEN
                J = SWF%ISRD_TFR%WBS(K)
                I = SWF%ISRD_TFR%SR(ONE,K)
                CALL WRN%ADD( NUM2STR(J,-5)//BLNK//NUM2STR(I,-5)//'    Semi-Routed DELIVERY Segment is greater then SFR number of segments'//NL )
            END IF
        END DO
        !
    END IF
    !
    IF(SRR_CHK) THEN  ! SWF%ISRD%ARRAY CHANGED SWF%ISRD%SEGRCH
        !
        DO CONCURRENT (K=ONE:SWF%NSFR_RETURN, SWF%ISRR_TFR%WBS(K) < ONE .OR. SWF%ISRR_TFR%WBS(K) > SWF%NFARM)
                SWF%ISRR_TFR%SR(ONE,K) = Z
                SWF%ISRR_TFR%SR(TWO,K) = Z
                SWF%ISRR_TFR%WBS(K)    = Z
                SWF%ISRR_TFR%WT(K)     = DZ
        END DO
        !
        DO K=ONE, SWF%NSFR_RETURN
            !
            IF(SWF%NSEG < SWF%ISRR_TFR%SR(ONE,K)) THEN
                J = SWF%ISRR_TFR%WBS(K)
                I = SWF%ISRR_TFR%SR(ONE,K)
                CALL WRN%ADD( NUM2STR(J,-5)//BLNK//NUM2STR(I,-5)//'    Semi-Routed RETURN Segment is greater then SFR number of segments'//NL )
            END IF
        END DO
        !
    END IF
    !
    IF(WRN%RAISED) CALL WRN%CHECK('SURFACE_WATER BLOCK ERROR.'//NL//'THE FOLLOWING ARE A LIST OF BAD FMP-SFR LINKS AND THE REASON THEY ARE BAD.'//BLN//'WBS  SEGMENT  REASON', OUTPUT=SWF%IOUT, KILL=TRUE)
    !
    IF(SRD_CHK) THEN
        !
        DO CONCURRENT(K=ONE:SWF%NSFR_DELIV, SWF%ISRD_TFR%WBS(K) > Z )
            IF( SWF%ISRD_TFR%SR(ONE,K) > Z .AND. SWF%ISRD_TFR%SR(TWO,K) < ONE) THEN
                F = SWF%ISRD_TFR%WBS(K)
                I = SWF%ISRD_TFR%SR(ONE,K)
                J = SWF%ISRD_TFR%SR(TWO,K)
                SWF%ISRD_TFR%WBS(K)  = Z
                SWF%ISRD_TFR%SR(:,K) = Z
                SWF%ISRD_TFR%WT(K)   = DZ
                CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  Semi-Routed DELIVERY Segment is greater then 0, but delivery Reach is  0, the delivery Segment is reset to 0'//NL )
            END IF
        END DO
        !
        DO CONCURRENT(K=ONE:SWF%NSFR_DELIV, SWF%ISRD_TFR%WBS(K) > Z )
            IF( SWF%ISRD_TFR%SR(ONE,K) < ONE) THEN
                F = SWF%ISRD_TFR%WBS(K)
                I = SWF%ISRD_TFR%SR(ONE,K)
                J = SWF%ISRD_TFR%SR(TWO,K)
                SWF%ISRD_TFR%WBS(K)  = Z
                SWF%ISRD_TFR%SR(:,K) = Z
                SWF%ISRD_TFR%WT(K)   = DZ
                CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  Semi-Routed DELIVERY Segment is less then 0, it is reset to 0'//NL )
            END IF
        END DO
        !
        DO CONCURRENT(K=ONE:SWF%NSFR_DELIV, SWF%ISRD_TFR%WBS(K) > Z )
            IF( SWF%ISRD_TFR%SR(TWO,K) < Z) THEN
                F = SWF%ISRD_TFR%WBS(K)
                I = SWF%ISRD_TFR%SR(ONE,K)
                J = SWF%ISRD_TFR%SR(TWO,K)
                SWF%ISRD_TFR%WBS(K)  = Z
                SWF%ISRD_TFR%SR(:,K) = Z
                SWF%ISRD_TFR%WT(K)   = DZ
                CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  Semi-Routed DELIVERY Reach is less then 0, reset to 0'//NL )
            END IF
        END DO
        !
        DO CONCURRENT(K=ONE:SWF%NSFR_DELIV, SWF%ISRD_TFR%WBS(K) > Z )
            IF( SWF%ISRD_TFR%SR(ONE,K) == Z .AND. SWF%ISRD_TFR%SR(TWO,K) > Z) THEN
                F = SWF%ISRD_TFR%WBS(K)
                I = SWF%ISRD_TFR%SR(ONE,K)
                J = SWF%ISRD_TFR%SR(TWO,K)
                SWF%ISRD_TFR%WBS(K)  = Z
                SWF%ISRD_TFR%SR(:,K) = Z
                SWF%ISRD_TFR%WT(K)   = DZ
                CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  Semi-Routed DELIVERY Segment is 0, but delivery Reach is greater than 0, the delivery Reach is reset to 0'//NL )
            END IF
        END DO
        !
    END IF
    !
    IF(SRR_CHK) THEN
        !
        DO CONCURRENT(K=ONE:SWF%NSFR_RETURN, SWF%ISRR_TFR%WBS(K) > Z )
            IF( SWF%ISRR_TFR%SR(ONE,K) > Z .AND. SWF%ISRR_TFR%SR(TWO,K) < ONE) THEN
                SWF%ISRR_TFR%SR(TWO,K) = Z
                SWF%ISRR_TFR%WT(K)     = DNEG
                !!!F = SWF%ISRR_TFR%WBS(K)
                !!!I = SWF%ISRR_TFR%SR(ONE,K)
                !!!J = SWF%ISRR_TFR%SR(TWO,K)
                !!!SWF%ISRR_TFR%WBS(K)  = Z
                !!!SWF%ISRR_TFR%SR(:,K) = Z
                !!!SWF%ISRR_TFR%WT(K)   = DZ
                !!!CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  Semi-Routed RETURN Segment is greater then 0, but return Reach is  0, the return Segment is reset to 0'//NL )
            END IF
        END DO
        !
        DO CONCURRENT(K=ONE:SWF%NSFR_RETURN, SWF%ISRR_TFR%WBS(K) > Z )
            IF( SWF%ISRR_TFR%SR(ONE,K) < Z) THEN
                F = SWF%ISRR_TFR%WBS(K)
                I = SWF%ISRR_TFR%SR(ONE,K)
                J = SWF%ISRR_TFR%SR(TWO,K)
                SWF%ISRR_TFR%WBS(K)  = Z
                SWF%ISRR_TFR%SR(:,K) = Z
                SWF%ISRR_TFR%WT(K)   = DZ
                CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  Semi-Routed RETURN Segment is less then 0, it is reset to 0'//NL )
            END IF
        END DO
        !
        !!!DO CONCURRENT(K=ONE:SWF%NSFR_RETURN, SWF%ISRR_TFR%WBS(K) > Z )
        !!!    IF( SWF%ISRR_TFR%SR(TWO,K) < Z) THEN
        !!!        F = SWF%ISRR_TFR%WBS(K)
        !!!        I = SWF%ISRR_TFR%SR(ONE,K)
        !!!        J = SWF%ISRR_TFR%SR(TWO,K)
        !!!        SWF%ISRR_TFR%WBS(K)  = Z
        !!!        SWF%ISRR_TFR%SR(:,K) = Z
        !!!        SWF%ISRR_TFR%WT(K)   = DZ
        !!!        CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  Semi-Routed RETURN Reach is less then 0, reset to 0'//NL )
        !!!    END IF
        !!!END DO
        !
        DO CONCURRENT(K=ONE:SWF%NSFR_RETURN, SWF%ISRR_TFR%WBS(K) > Z )
            IF( SWF%ISRR_TFR%SR(ONE,K) == Z .AND. SWF%ISRR_TFR%SR(TWO,K) > Z) THEN
                F = SWF%ISRR_TFR%WBS(K)
                I = SWF%ISRR_TFR%SR(ONE,K)
                J = SWF%ISRR_TFR%SR(TWO,K)
                !SWF%ISRR_TFR%WBS(K)  = Z
                SWF%ISRR_TFR%SR(:,K) = Z
                SWF%ISRR_TFR%WT(K)   = DZ
                CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  Semi-Routed RETURN Segment is 0, but return Reach is greater than 0, the return Reach is reset to 0'//NL )
            END IF
        END DO
        !
        DO F=ONE, SWF%NFARM
          J = COUNT(SWF%ISRR_TFR%WBS == F)
          I = Z
          DO K=ONE, SWF%NSFR_RETURN
            IF( SWF%ISRR_TFR%WBS(K) == F .AND. SWF%ISRR_TFR%SR(ONE,K) == Z ) THEN
                I = K
                EXIT
            END IF
          END DO
          !
          IF(I > Z .AND. J > ONE) THEN ! NO FLOW OPTION IS ON, BUT WBS DEFINED MORE THEN ONCE
              DO CONCURRENT (K=ONE:SWF%NSFR_RETURN, SWF%ISRR_TFR%WBS(K) == F .AND. I.NE.K)
                IF    (SWF%ISRR_TFR%SR(ONE,K) > Z ) THEN
                    !
                    CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(SWF%ISRR_TFR%SR(1,K),-5)//'   '//NUM2STR(SWF%ISRR_TFR%SR(2,K),-5)//'  Semi-Routed RETURN - WBS had a record with SEGMENT = 0 to indicate flow leaves model, but found additional records with SEGMENT > 0 -- This record is Disabled/Ignored'//NL )
                    !
                ELSEIF(SWF%ISRR_TFR%SR(ONE,K) == Z) THEN
                    !
                    CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(SWF%ISRR_TFR%SR(1,K),-5)//'   '//NUM2STR(SWF%ISRR_TFR%SR(2,K),-5)//'  Semi-Routed RETURN - WBS has multiple entires defining SEGMENT = 0 to indicate flow leaves model -- This record is Disabled/Ignored'//NL )
                END IF
                SWF%ISRR_TFR%WBS(K)  = Z
                SWF%ISRR_TFR%SR(:,K) = Z
                SWF%ISRR_TFR%WT(K)   = DZ
              END DO
          END IF
        END DO
        !
    END IF
    !
    IF(WRN%RAISED) CALL WRN%CHECK('SURFACE_WATER BLOCK WARNING.'//NL//'THE FOLLOWING ARE A LIST OF BAD FMP-SFR LINKS THAT CONTAINED PROBLEM SEGMENTS THAT HAD TO BE CHANGED.'//BLN//'WBS  SEGMENT REACH  REASON', OUTPUT=SWF%IOUT, INIT=TRUE)
    !
    ! CHECK FOR BAD REACHES
    !
    IF(SRD_CHK) THEN
        !
        DO CONCURRENT(K=ONE:SWF%NSFR_DELIV, SWF%ISRD_TFR%WBS(K) > Z .AND. SWF%ISRD_TFR%SR(ONE,K) > Z )
           I = SWF%ISRD_TFR%SR(ONE,K)            !ISEG
           J = SWF%ISRD_TFR%SR(TWO,K)            !IRCH
           N = SEG_NSTRM(I+ONE) -  SEG_NSTRM(I)  !NRCH
           IF(J > N) THEN
                 F = SWF%ISRD_TFR%WBS(K)
                 SWF%ISRD_TFR%WBS(K)  = Z
                 SWF%ISRD_TFR%SR(:,K) = Z
                 SWF%ISRD_TFR%WT(K)   = DZ
                 CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'    Semi-Routed DELIVERY reach is greater then SFR number of reaches ('//NUM2STR(N)//') for specified segment'//NL )
           END IF
        END DO
    END IF
    !
    IF(SRR_CHK) THEN
        !
        DO CONCURRENT(K=ONE:SWF%NSFR_RETURN, SWF%ISRR_TFR%WBS(K) > Z )
           I = SWF%ISRR_TFR%SR(ONE,K)            !ISEG
           J = SWF%ISRR_TFR%SR(TWO,K)            !IRCH
           N = SEG_NSTRM(I+ONE) -  SEG_NSTRM(I)  !NRCH
           IF(J > N) THEN
                 F = SWF%ISRR_TFR%WBS(K)
                 SWF%ISRR_TFR%WBS(K)  = Z
                 SWF%ISRR_TFR%SR(:,K) = Z
                 SWF%ISRR_TFR%WT(K)   = DZ
                 CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'    Semi-Routed RETURN reach is greater then SFR number of reaches ('//NUM2STR(N)//') for specified segment'//NL )
           END IF
        END DO
    END IF
    !
    IF(WRN%RAISED) CALL WRN%CHECK('SURFACE_WATER BLOCK ERROR.'//NL//'THE FOLLOWING ARE A LIST OF BAD FMP-SFR LINKS AND THE REASON THEY ARE BAD.'//BLN//'WBS  SEGMENT REACH  REASON', OUTPUT=SWF%IOUT, KILL=TRUE)
    !
    IF(SWF%CHOICE%INUSE .AND. (UPDATE .OR. SWF%CHOICE%TRANSIENT)) THEN
          DO CONCURRENT(J=ONE:SWF%NFARM)
              IF(SWF%CHOICE%ARRAY(ONE,J) > ONE) SWF%CHOICE%ARRAY(ONE,J) = ONE
              IF(SWF%CHOICE%ARRAY(ONE,J) < Z  ) SWF%CHOICE%ARRAY(ONE,J) = Z
              !
              IF(SWF%CHOICE%ARRAY(TWO,J) > ONE) SWF%CHOICE%ARRAY(TWO,J) = ONE
              IF(SWF%CHOICE%ARRAY(TWO,J) < Z  ) SWF%CHOICE%ARRAY(TWO,J) = Z
          END DO
    END IF
    !
    IF(.NOT. SWF%NORETURNFLOW .AND. (UPDATE .OR. SWF%CHOICE%TRANSIENT) ) THEN
        !
        DO CONCURRENT(J=ONE:SWF%NFARM)
          !
          ASSOCIATE(FULY => SWF%H2ORETURN(ONE,J), SEMI => SWF%H2ORETURN(TWO,J))
              !
              IF(SWF%CHOICE%INUSE) THEN
                  FULY = SWF%CHOICE%ARRAY(ONE,J)
                  SEMI = SWF%CHOICE%ARRAY(TWO,J)
              ELSE
                  FULY = ONE
                  SEMI = ONE
              END IF
              !
              IF(FULY == ONE .AND. SWF%IRRFL==Z) FULY = Z
              !
              IF(SWF%NORETURNFLOW_TFR%INUSE) THEN
                  IF(SWF%NORETURNFLOW_TFR%LIST(J)==ONE) THEN
                      FULY = Z
                      SEMI = Z
                  END IF
              END IF
          END ASSOCIATE
        END DO
    END IF
    !
    IF(SWF%NRD_DP_TFR%INUSE ) THEN
        IF(UPDATE .OR. SWF%NRD_DP_TFR%TRANSIENT .OR. SWF%NRD%TRANSIENT) THEN
            !
            K = SWF%MXNRD*THREE
            SWF%HAS_NRD_LOC = FALSE
            OUTER: DO J=ONE,   SWF%NFARM
                   DO I=THREE, K, THREE
                         IF(SWF%NRD%ARRAY(I,J) >9.99999999D0) THEN
                             SWF%HAS_NRD_LOC = TRUE
                             EXIT OUTER
                         END IF
                   END DO
            END DO OUTER
        END IF
        !
        IF(SWF%HAS_NRD_LOC .AND. (UPDATE .OR. SWF%NRD_DP_TFR%TRANSIENT)) THEN
            CONTINUE
        END IF
    END IF
    !
    !------------------------------------------------------------------------
    !
    IF(SRD_CHK) CALL BUILD_SRD_LOC_FLOW(SWF, SW_SOURCE, SEG_NSTRM)
    !
    IF(SRD_CHK .OR. SWF%DELIV_L_LIM%TRANSIENT .OR. SWF%DELIV_U_LIM%TRANSIENT) THEN
        !
        ASSOCIATE(WBS  => SWF%ISRD_TFR%WBS,     &
                  LLIM => SWF%DELIV_L_LIM%LIST, &
                  ULIM => SWF%DELIV_U_LIM%LIST   )
                 !
           DO CONCURRENT(K=ONE:SWF%NSFR_DELIV, WBS(K) > Z )
               !
               DO I=ONE, SWF%SRDLOC(WBS(K))%N
                   !
                   IF(SWF%SRDLOC(WBS(K))%ISRD(I) == K) THEN
                       !
                       SWF%SRDLOC(WBS(K))%LLIM(I) = LLIM(K)
                       SWF%SRDLOC(WBS(K))%ULIM(I) = ULIM(K)
                       EXIT
                   END IF
               END DO
           END DO
        END ASSOCIATE
    END IF
    !
    !------------------------------------------------------------------------
    !
    UPDATE_RETURN = UPDATE
    !
    IF(.NOT. UPDATE_RETURN .AND. SWF%CHOICE%TRANSIENT) UPDATE_RETURN = TRUE
    IF(.NOT. UPDATE_RETURN .AND. SRR_CHK             ) UPDATE_RETURN = TRUE
    !
    IF(UPDATE_RETURN) THEN
        !
        DO F=ONE, SWF%NFARM
          !
          NO_RETURN       = FALSE
          IS_FULLY_RETURN = FALSE
          !
          IF(ALL(SWF%H2ORETURN(:,F)==Z)) THEN ! NO RETURN FLOW
              !
              NO_RETURN = TRUE
              !
          ELSEIF( SWF%NSFR_RETURN == Z .OR. .NOT. SWF%ISRR_TFR%INUSE .OR. SWF%H2ORETURN(TWO,F) == Z) THEN  !SEMI => SWF%H2ORETURN(TWO,F)
              !
              IF(SWF%IRRFL .NE. Z .AND. SWF%H2ORETURN(ONE,F)==ONE) THEN !FULY => SWF%H2ORETURN(ONE,F)
                  !
                  IS_FULLY_RETURN = TRUE
              ELSE
                  NO_RETURN = TRUE
              END IF
          ELSE
              DO K=ONE, SWF%NSFR_RETURN
                  IF(F == SWF%ISRR_TFR%WBS(K)) THEN    ! .AND. SWF%ISRR_TFR%SR(ONE,K) > Z
                      SWF%SRRLOC(F)%HAS_RETURN  = TRUE
                      SWF%SRRLOC(F)%FULLY       = FALSE
                      EXIT
                  ELSEIF(K == SWF%NSFR_RETURN) THEN
                      IF(SWF%IRRFL .NE. Z .AND. SWF%H2ORETURN(ONE,F)==ONE) THEN !FULY => SWF%H2ORETURN(ONE,F))
                          !
                          IS_FULLY_RETURN = TRUE
                      ELSE
                          NO_RETURN = TRUE
                      END IF
                  END IF
              END DO
          END IF
          !
          IF(IS_FULLY_RETURN) THEN
                 !
                 SWF%SRRLOC(F)%HAS_RETURN  = TRUE
                 !
                 IF(.NOT. SWF%SRRLOC(F)%FULLY) THEN         !NEW FULLY ROUTED NETWORK NEED TO REBUILD IT
                          SWF%SRRLOC(F)%FULLY       = TRUE
                          SWF%SRRLOC(F)%BUILD_FULLY = TRUE
                 END IF
                 !
          ELSEIF(NO_RETURN) THEN                           !DISABLE RETURN FLOW
                          SWF%SRRLOC(F)%HAS_RETURN  = FALSE
                          SWF%SRRLOC(F)%FULLY       = FALSE
                          SWF%SRRLOC(F)%N = Z
          END IF
        END DO
    END IF
    !
    !------------------------------------------------------------------------
    ! 
    IF(SRR_CHK) THEN
                CALL BUILD_SRR_LOC_FLOW(SWF, SEG_NSTRM, STRM)
    ELSE
        DO CONCURRENT (F=ONE:SWF%NFARM, .NOT. SWF%SRRLOC(F)%HAS_RETURN)
                 !
                 SWF%SRRLOC(F)%N = Z
                 CALL ALLOC(SWF%SRRLOC(F)%RUNOFF,ONE)   !IF THERE IS RUNOFF, THEN IT LEAVES MODEL 
        END DO
    END IF
    !
    !------------------------------------------------------------------------
    ! 
    IF(SWF%ALWAYS_BUILD_FULLY_ROUTED_RETURN .OR. NEW_FID) THEN
        DO CONCURRENT (F=ONE:SWF%NFARM)
            SWF%BUILD_FRR(F) = SWF%SRRLOC(F)%HAS_RETURN .AND. SWF%SRRLOC(F)%FULLY  !BUILD FRR NETWORK EVEN IF IT HAS ALREADY BEEN BUILT
        END DO
    ELSE
        DO CONCURRENT (F=ONE:SWF%NFARM)
            SWF%BUILD_FRR(F) = SWF%SRRLOC(F)%HAS_RETURN .AND. SWF%SRRLOC(F)%FULLY .AND. SWF%SRRLOC(F)%BUILD_FULLY
        END DO
    END IF
    !
    SWF%BUILD_FULLY_ROUTED_RETURN = ANY(SWF%BUILD_FRR)
    !
  END SUBROUTINE
  !
  SUBROUTINE SETUP_NEXT_TIME_STEP(SWF)
    !
    CLASS(SURFACE_WATER_DATA),           INTENT(INOUT):: SWF
    INTEGER:: F, I
    DOUBLE PRECISION:: WT_SUM
    !
    DO F=ONE, SWF%NFARM
      !
      SWF%SRDLOC(F)%TOT_DMD_INI = DZ
      SWF%SRDLOC(F)%TOT_DMD_MET = DZ
    END DO
    !
    DO CONCURRENT (F=ONE:SWF%NFARM, SWF%SRDLOC(F)%N > Z) 
      DO CONCURRENT (I = ONE:SWF%SRDLOC(F)%N)
            !
      SWF%SRDLOC(F)%FLOW(I)   = DZ
      SWF%SRDLOC(F)%MAXDEL(I) = DZ
      END DO
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE ADD_SRD_TO_SFR_DELIV(SWF, SFR_DELIV)
    !
    CLASS(SURFACE_WATER_DATA), INTENT(IN):: SWF
    TYPE(FMP_FLOW_REMOVE_SFR), INTENT(INOUT):: SFR_DELIV
    INTEGER:: F, K
    !
    DO CONCURRENT (F=ONE:SWF%NFARM, SWF%SRDLOC(F)%N > Z) 
      DO CONCURRENT (K = ONE:SWF%SRDLOC(F)%N,  SWF%SRDLOC(F)%ISTRM(K) > Z)
            !
            CALL SFR_DELIV%ADD_ISTRM( SWF%SRDLOC(F)%ISTRM(K) )
      END DO
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE BUILD_SRD_LOC_FLOW(SWF, SW_SOURCE, SEG_NSTRM)
    !
    CLASS(SURFACE_WATER_DATA),           INTENT(INOUT):: SWF
    LOGICAL, DIMENSION(:),   CONTIGUOUS, INTENT(IN   ):: SW_SOURCE
    INTEGER, DIMENSION(:),   CONTIGUOUS, INTENT(IN   ):: SEG_NSTRM
    INTEGER:: F, K, DIM
    DOUBLE PRECISION:: WT_SUM
    !
    DO F=ONE, SWF%NFARM
      !
      SWF%SRDLOC(F)%TOT_DMD_INI = DZ
      SWF%SRDLOC(F)%TOT_DMD_MET = DZ
      !
      SWF%SRDLOC(F)%N = Z
      SWF%SRDLOC(F)%NO_WT = TRUE
      SWF%HAS_SRD_WBS(F)  = FALSE
      !
      !
      IF(SW_SOURCE(F)) THEN
         !
         DIM = COUNT(F == SWF%ISRD_TFR%WBS)
         !
         IF(DIM > Z) THEN
             SWF%SRDLOC(F)%N = DIM
             SWF%HAS_SRD_WBS(F) = TRUE
             !
             CALL ALLOC(SWF%SRDLOC(F)%ISRD,DIM)         !(ARR, N)
             CALL ALLOC(SWF%SRDLOC(F)%ISTRM,DIM)        !(ARR, N)
             CALL ALLOC(SWF%SRDLOC(F)%WT,DIM)           !(ARR, N)
             CALL ALLOC(SWF%SRDLOC(F)%FLOW,DIM)         !(ARR, N)
             CALL ALLOC(SWF%SRDLOC(F)%FLOW_OLD,DIM)     !(ARR, N)
             CALL ALLOC(SWF%SRDLOC(F)%LLIM,  DIM)       !(ARR, N)
             CALL ALLOC(SWF%SRDLOC(F)%ULIM,  DIM)       !(ARR, N)
             CALL ALLOC(SWF%SRDLOC(F)%MAXDEL,DIM)       !(ARR, N)
             CALL ALLOC(SWF%SRDLOC(F)%SR,TWO,DIM,Z) !(ARR, N, M, DIMCHK)
             !
             DIM = Z
             DO K=ONE, SWF%NSFR_DELIV
                 IF(F == SWF%ISRD_TFR%WBS(K)) THEN
                     DIM = DIM + ONE
                     !
                     SWF%SRDLOC(F)%ISRD(DIM) = K
                     !
                     SWF%SRDLOC(F)%SR(ONE,DIM) = SWF%ISRD_TFR%SR(ONE,K)
                     SWF%SRDLOC(F)%SR(TWO,DIM) = SWF%ISRD_TFR%SR(TWO,K)
                     !
                     SWF%SRDLOC(F)%ISTRM(DIM) = SEG_NSTRM(SWF%ISRD_TFR%SR(ONE,K))  + SWF%ISRD_TFR%SR(TWO,K)
                     !
                     SWF%SRDLOC(F)%WT(DIM) = SWF%ISRD_TFR%WT(K)
                     !
                 END IF
             END DO
             !
             !Assumed SWF%SRDLOC(F)%NO_WT = TRUE
             !
             IF(DIM > ONE) THEN
                IF( ALL(NEGNEARZERO_5 < SWF%SRDLOC(F)%WT .AND. SWF%SRDLOC(F)%WT < NEAR_ONE_5) ) THEN
                    !
                    SWF%SRDLOC(F)%NO_WT = FALSE
                    !
                    DO CONCURRENT(K=ONE:DIM)
                        IF(   SWF%SRDLOC(F)%WT(K) < DZ  ) THEN
                                                               SWF%SRDLOC(F)%WT(K) = DZ
                        ELSEIF(SWF%SRDLOC(F)%WT(K) > UNO) THEN
                                                               SWF%SRDLOC(F)%WT(K) = UNO
                        END IF
                    END DO
                    !
                    WT_SUM = SUM( SWF%SRDLOC(F)%WT )
                    !
                    IF(WT_SUM.NE.UNO) SWF%SRDLOC(F)%WT = SWF%SRDLOC(F)%WT / WT_SUM  !RESCALE TO SUM TO ONE
                    !
                    CALL SORT(DIM,SWF%SRDLOC(F)%WT,SWF%SRDLOC(F)%ISTRM) !SORTS FROM SMALLEST TO LARGEST
                    !
                    CALL REVERSE_ORDER(    DIM,SWF%SRDLOC(F)%WT)
                    CALL REVERSE_ORDER(    DIM,SWF%SRDLOC(F)%ISTRM)
                    !
                    !!!ASSOCIATE(IDX=>SWF%SRDLOC(F)%ISTRM)
                    !!!   DO CONCURRENT(K=ONE:DIM)
                    !!!          SWF%SRDLOC(F)%SEGRCH(ONE,K) = ISTRM(4,IDX(K)) !SEG
                    !!!          SWF%SRDLOC(F)%SEGRCH(TWO,K) = ISTRM(5,IDX(K)) !RCH
                    !!!   END DO
                    !!!END ASSOCIATE
                END IF !( ALL(NEGNEARZERO_5 < SWF%SRDLOC(F)%WT .AND. SWF%SRDLOC(F)%WT < NEAR_ONE_5) ) THEN
             END IF !(DIM > ONE) THEN
         END IF !(DIM > Z) THEN
      END IF !(SW_SOURCE(F)) THEN
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE APPLY_SRD_DEMAND(SWF, F, DEMAND, SFR_DELIV)
    !
    CLASS(SURFACE_WATER_DATA), INTENT(INOUT):: SWF
    INTEGER,                   INTENT(IN   ):: F
    TYPE(FMP_FLOW_REMOVE_SFR), INTENT(INOUT):: SFR_DELIV
    DOUBLE PRECISION,          INTENT(IN   ):: DEMAND
    INTEGER:: K
    DOUBLE PRECISION:: DMD,SUP,DTMP,TOT_FLOW
    !
    ASSOCIATE(         DIM => SWF%SRDLOC(F)%N,           &
                      NO_WT=> SWF%SRDLOC(F)%NO_WT,       &
               TOT_DMD_INI => SWF%SRDLOC(F)%TOT_DMD_INI, &
               TOT_DMD_MET => SWF%SRDLOC(F)%TOT_DMD_MET, &
                      FLOW => SWF%SRDLOC(F)%FLOW,        &
                      LLIM => SWF%SRDLOC(F)%LLIM,        &
                      ULIM => SWF%SRDLOC(F)%ULIM,        &
                    MAXDEL => SWF%SRDLOC(F)%MAXDEL,      &
                     ISTRM => SWF%SRDLOC(F)%ISTRM,       &
                        WT => SWF%SRDLOC(F)%WT)
      ! 
      DMD = DEMAND
      TOT_DMD_INI = DMD
      TOT_DMD_MET = DZ
      !
      IF    (DIM == ONE) THEN
                               CALL SFR_DELIV%APPLY_DMD(ISTRM(ONE), DMD, TOT_DMD_MET, LLIM(ONE), ULIM(ONE), MAXDEL(ONE))
                               FLOW(ONE) = TOT_DMD_MET
      ELSEIF(DIM  > ONE) THEN
          !
          DO CONCURRENT(K=ONE:DIM); FLOW(K) = DZ
          END DO
          !
          TOT_FLOW = DZ
          DO K=ONE, DIM
             !
             CALL SFR_DELIV%SET_TO_INFLOW(ISTRM(K), DTMP, LLIM(K), ULIM(K))
             !
             TOT_FLOW = TOT_FLOW + DTMP
          END DO
          !
          IF(TOT_DMD_INI > TOT_FLOW) THEN  !SRD WILL NEVER MEET DEMAND
              !
              DO K=ONE, DIM
                  !
                  CALL SFR_DELIV%APPLY_DMD(ISTRM(K), DMD, SUP, LLIM(K), ULIM(K), MAXDEL(K))
                  !
                  FLOW(K)     = FLOW(K)     + SUP
                  TOT_DMD_MET = TOT_DMD_MET + SUP
                  !
                  DMD = DMD - SUP
                  !
              END DO
              !
          ELSEIF(NO_WT) THEN !REMOVE DEMAND IN ORDER
              !
              DO K=ONE, DIM
                  !
                  CALL SFR_DELIV%APPLY_DMD(ISTRM(K), DMD, SUP, LLIM(K), ULIM(K), MAXDEL(K))
                  !
                  FLOW(K)     = FLOW(K)     + SUP
                  TOT_DMD_MET = TOT_DMD_MET + SUP
                  !
                  DMD = DMD - SUP
                  IF(DMD < NEARZERO_29) EXIT
                  !
              END DO
          ELSE
              DO K=ONE, DIM !FIRST PASS
                  !
                  DTMP = TOT_DMD_INI * WT(K)
                  !
                  CALL SFR_DELIV%APPLY_DMD(ISTRM(K), DTMP, SUP, LLIM(K), ULIM(K), MAXDEL(K))
                  !
                  FLOW(K)     = FLOW(K)     + SUP
                  TOT_DMD_MET = TOT_DMD_MET + SUP
                  !
                  DMD = DMD - SUP
                  IF(DMD < NEARZERO_29) EXIT
                  !
              END DO
              !
              IF(TOT_DMD_INI - TOT_DMD_MET > NEARZERO_29) THEN  !NOT FULL MET, UPDATE AVAILIBLE FLOW
                  !
                  TOT_FLOW = DZ
                  DO K=ONE, DIM
                     TOT_FLOW = TOT_FLOW + SFR_DELIV%GET_INFLOW(ISTRM(K))
                  END DO
                  !
                  IF(TOT_FLOW > NEARZERO_29) THEN
                      !
                      TOT_FLOW = DMD / TOT_FLOW !FRACTION OF DEMAND == USED FOR DMD * (SFR_DELIV%GET_INFLOW(ISTRM(K))/TOT_FLOW) -- BUT INSTEAD HOLDING DMD/TOT_INFLOW
                      !
                      DO K=ONE, DIM !SECOND PASS
                          !
                          DTMP = SFR_DELIV%GET_INFLOW(ISTRM(K)) * TOT_FLOW  ! TOT_FLOW = DMD / TOT_FLOW
                          !
                          IF(DTMP > NEARZERO_29) THEN
                              CALL SFR_DELIV%APPLY_DMD(ISTRM(K), DTMP, SUP, LLIM(K), ULIM(K))
                              !
                              FLOW(K)     = FLOW(K)     + SUP
                              TOT_DMD_MET = TOT_DMD_MET + SUP
                              !
                              DMD = DMD - SUP
                              IF(DMD < NEARZERO_29) EXIT
                          END IF
                          !
                      END DO
                  END IF
              END IF
          END IF
      END IF
    END ASSOCIATE
    !
  END SUBROUTINE
  !
  SUBROUTINE APPLY_SRD_SURPLUS(SWF, F, SURPLUS, STRM)
    !
    CLASS(SURFACE_WATER_DATA),       INTENT(INOUT):: SWF
    INTEGER,                         INTENT(IN   ):: F
    DOUBLE PRECISION,                INTENT(IN   ):: SURPLUS
    REAL,DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: STRM
    INTEGER:: I, K
    DOUBLE PRECISION:: DTMP
    !
    ASSOCIATE(  DIM => SWF%SRDLOC(F)%N,       &
               FLOW => SWF%SRDLOC(F)%FLOW,    &
          LOWER_LIM => SWF%SRDLOC(F)%LLIM,    &
          UPPER_LIM => SWF%SRDLOC(F)%ULIM,    &
             MAXDEL => SWF%SRDLOC(F)%MAXDEL,  &
              ISTRM => SWF%SRDLOC(F)%ISTRM    )
              !
      DO K=ONE, DIM 
          !
          I = ISTRM(K)
          !
          MAXDEL(K) = STRM(10,I)
          !
          IF(MAXDEL(K) > UPPER_LIM(K)) MAXDEL(K) = UPPER_LIM(K)
          !
          IF(MAXDEL(K) <= LOWER_LIM(K)) THEN
             MAXDEL(K) = DZ
          ELSE
             MAXDEL(K) = MAXDEL(K) - LOWER_LIM(K)
          END IF
          !
          IF(MAXDEL(K) < DZ) MAXDEL(K) = DZ
      END DO
      ! 
      IF(DIM == ONE) THEN
          !
          I = ISTRM(ONE)
          !
          STRM(12,I) = STRM(12,I) + SURPLUS
          !
          IF(SURPLUS < FLOW(ONE)) THEN
              FLOW(ONE) = FLOW(ONE) - SURPLUS
          ELSE
              FLOW(ONE) = DZ
          END IF
          !
      ELSEIF(DIM  > ONE) THEN
          !
          IF    (DIM == ONE  ) THEN; DTMP = UNO
          ELSEIF(DIM == TWO  ) THEN; DTMP = HALF
          ELSEIF(DIM == THREE) THEN; DTMP = THIRD
          ELSEIF(DIM == FOUR ) THEN; DTMP = FOURTH
          ELSEIF(DIM == FIVE ) THEN; DTMP = FIFTH
          ELSE;                      DTMP = UNO / DBLE(DIM)
          END IF
          !
          DTMP = DTMP * SURPLUS
          !
          DO CONCURRENT (K=ONE:DIM)
             IF    (DTMP < FLOW(K)) THEN
                 FLOW(K) = FLOW(K) - DTMP
             ELSE
                 FLOW(K) = DZ
             END IF
          END DO
          !
          DO K=ONE, DIM 
              !
              I = ISTRM(K)
              !
              STRM(12,I) = STRM(12,I) + DTMP
              !
          END DO
      END IF
    END ASSOCIATE
    !
  END SUBROUTINE
  !
  SUBROUTINE BUILD_SRR_LOC_FLOW(SWF, SEG_NSTRM, STRM)
    !
    CLASS(SURFACE_WATER_DATA),           INTENT(INOUT):: SWF
    INTEGER, DIMENSION(:),   CONTIGUOUS, INTENT(IN   ):: SEG_NSTRM
    REAL,    DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: STRM
    INTEGER:: F, K, IRCH, ISTRM, NRCH, S, DIM
    DOUBLE PRECISION:: WT_SUM
    !
    DO F=ONE, SWF%NFARM
       IF    ( .NOT. SWF%SRRLOC(F)%HAS_RETURN) THEN
             !
             SWF%SRRLOC(F)%N = Z
             CALL ALLOC(SWF%SRRLOC(F)%RUNOFF,ONE)   !(ARR, N)  !IF THERE IS RUNOFF, THEN IT LEAVES MODEL 
             !
       ELSEIF(       SWF%SRRLOC(F)%HAS_RETURN  .AND. .NOT. SWF%SRRLOC(F)%FULLY) THEN
         !
         SWF%SRRLOC(F)%TOTLENGTH = DZ
         SWF%SRRLOC(F)%LEAVE_MODEL = FALSE
         DIM = Z
         DO K=ONE, SWF%NSFR_RETURN
             IF(F == SWF%ISRR_TFR%WBS(K)) THEN
                 IF    ( SWF%ISRR_TFR%SR(ONE,K) == Z) THEN ! =Z INDICATES RETURN FLOW LEAVES MODEL
                                                 SWF%SRRLOC(F)%LEAVE_MODEL = TRUE
                                                 DIM = Z
                                                 EXIT
                 ELSEIF( SWF%ISRR_TFR%SR(TWO,K)  > Z) THEN ! >Z INDICATES SINGLE REACH 
                                                 DIM = DIM + ONE
                 ELSE !OR USE ALL REACHES
                                                 S    = SWF%ISRR_TFR%SR(ONE,K)
                                                 NRCH = SEG_NSTRM(S+ONE) - SEG_NSTRM(S)
                                                 DIM  = DIM + NRCH
                 END IF
             END IF
         END DO
         !
         IF(DIM < ONE) THEN      !ONLY TRUE IF SWF%SRRLOC(F)%LEAVE_MODEL
             SWF%SRRLOC(F)%N = Z
             CALL ALLOC(SWF%SRRLOC(F)%RUNOFF,ONE)   !(ARR, N)
         ELSE
             SWF%SRRLOC(F)%N = DIM
             !
             CALL ALLOC(SWF%SRRLOC(F)%WT,    DIM)   !(ARR, N)
             CALL ALLOC(SWF%SRRLOC(F)%ISTRM, DIM)   !(ARR, N)
             CALL ALLOC(SWF%SRRLOC(F)%RUNOFF,DIM)   !(ARR, N)
             CALL ALLOC(SWF%SRRLOC(F)%ISRR,  DIM)   !(ARR, N)
             CALL ALLOC(SWF%SRRLOC(F)%SR,TWO,DIM,Z) !(ARR, N, M, DIMCHK)
             !
             DIM = Z
             DO K=ONE, SWF%NSFR_RETURN
                 IF(F == SWF%ISRR_TFR%WBS(K)) THEN
                     S     = SWF%ISRR_TFR%SR(ONE,K)
                     IRCH  = SWF%ISRR_TFR%SR(TWO,K)
                     ISTRM = SEG_NSTRM(S)
                     !
                     IF( IRCH > Z) THEN
                         !
                         DIM = DIM + ONE
                         !
                         SWF%SRRLOC(F)%ISTRM(DIM) = ISTRM + IRCH  !ISTRM LOCATION IN SFR
                         SWF%SRRLOC(F)%WT(DIM)    = SWF%ISRR_TFR%WT(K)
                         !
                         SWF%SRRLOC(F)%SR(ONE,DIM) = S
                         SWF%SRRLOC(F)%SR(TWO,DIM) = IRCH
                         !
                         SWF%SRRLOC(F)%ISRR(DIM) = K
                     ELSE
                         NRCH  = SEG_NSTRM(S+ONE) - ISTRM     ! ==> ISTRM = SEG_NSTRM(S)
                         !
                         IF    (NRCH == ONE) THEN  !ONLY ONE REACH IN SEGMENET
                                !
                                IRCH = ONE
                                DIM  = DIM + ONE
                                SWF%SRRLOC(F)%ISTRM(DIM) = ISTRM + IRCH  
                                SWF%SRRLOC(F)%WT(DIM)    = SWF%ISRR_TFR%WT(K)
                                !
                                SWF%SRRLOC(F)%SR(ONE,DIM) = S
                                SWF%SRRLOC(F)%SR(TWO,DIM) = IRCH
                                !
                                SWF%SRRLOC(F)%ISRR(DIM) = K
                                !
                         ELSEIF( SWF%ISRR_TFR%WT(K) < NEGNEARZERO_5) THEN !IMPLIES LENGTH WEIGHTING
                             DO IRCH = ONE, NRCH
                                DIM = DIM + ONE
                                SWF%SRRLOC(F)%ISTRM(DIM) = ISTRM + IRCH  !ADD INDEX FOR EACH REACH
                                SWF%SRRLOC(F)%WT(DIM)    = DNEG          !FLAG TO INDICATE LENGTH WEIGHTING
                                !
                                SWF%SRRLOC(F)%SR(ONE,DIM) = S
                                SWF%SRRLOC(F)%SR(TWO,DIM) = IRCH
                                !
                                SWF%SRRLOC(F)%ISRR(DIM) = K
                             END DO
                         ELSE             ! LENGTH PRORATE WEIGHT SPEFICIED FRACTION
                             WT_SUM = DZ  ! GET SEGMENT'S LENGTH
                             DO IRCH = ONE, NRCH
                                 WT_SUM = WT_SUM + STRM( 1, ISTRM + IRCH )
                             END DO
                             !
                             IF(WT_SUM > NEARZERO_29) THEN
                                 DO IRCH = ONE, NRCH
                                    DIM = DIM + ONE
                                    SWF%SRRLOC(F)%ISTRM(DIM) = ISTRM + IRCH
                                    SWF%SRRLOC(F)%WT(DIM)    = SWF%ISRR_TFR%WT(K) * STRM( 1, ISTRM + IRCH ) / WT_SUM  
                                    !
                                    SWF%SRRLOC(F)%SR(ONE,DIM) = S
                                    SWF%SRRLOC(F)%SR(TWO,DIM) = IRCH
                                    !
                                    SWF%SRRLOC(F)%ISRR(DIM) = K
                                 END DO
                             ELSE
                                 WT_SUM = SWF%ISRR_TFR%WT(K) / DBLE(NRCH)  !LENGTH TOO SMALL JUST DO AVERAGE
                                 DO IRCH = ONE, NRCH
                                    DIM = DIM + ONE
                                    SWF%SRRLOC(F)%ISTRM(DIM) = ISTRM + IRCH  
                                    SWF%SRRLOC(F)%WT(DIM)    = WT_SUM  
                                    !
                                    SWF%SRRLOC(F)%SR(ONE,DIM) = S
                                    SWF%SRRLOC(F)%SR(TWO,DIM) = IRCH
                                    !
                                    SWF%SRRLOC(F)%ISRR(DIM) = K
                                 END DO
                             END IF
                         END IF
                     END IF
                 END IF
             END DO
             !
             ! GET TOTAL LEGNTH
             DO K=ONE, DIM
                          SWF%SRRLOC(F)%TOTLENGTH = SWF%SRRLOC(F)%TOTLENGTH + STRM( 1, SWF%SRRLOC(F)%ISTRM(K) )
             END DO
             IF( SWF%SRRLOC(F)%TOTLENGTH < NEARZERO_29 ) SWF%SRRLOC(F)%TOTLENGTH = DZ
             !
             IF    (DIM == ONE) THEN
                                    SWF%SRRLOC(F)%WT(ONE) = UNO
             ELSEIF(DIM  > ONE) THEN
                IF( ALL(NEGNEARZERO_5 < SWF%SRRLOC(F)%WT .AND. SWF%SRRLOC(F)%WT < NEAR_ONE_5) ) THEN
                    !
                    DO CONCURRENT(K=ONE:DIM)
                        IF(   SWF%SRRLOC(F)%WT(K) < DZ  ) THEN
                                                               SWF%SRRLOC(F)%WT(K) = DZ
                        ELSEIF(SWF%SRRLOC(F)%WT(K) > UNO) THEN
                                                               SWF%SRRLOC(F)%WT(K) = UNO
                        END IF
                    END DO
                    !
                    WT_SUM = SUM( SWF%SRRLOC(F)%WT )
                    !
                    IF(WT_SUM.NE.UNO) SWF%SRRLOC(F)%WT = SWF%SRRLOC(F)%WT / WT_SUM  !RESCALE TO SUM TO ONE
                    !
                    CALL SORT(DIM,SWF%SRRLOC(F)%ISTRM,SWF%SRRLOC(F)%WT) !SORTS FROM SMALLEST TO LARGESTs
                    !
                    !
                ELSEIF( ANY( SWF%SRRLOC(F)%WT < DZ) ) THEN !LENGTH PRORATED
                    !
                    ASSOCIATE(ISTRM=>SWF%SRRLOC(F)%ISTRM,     &
                            TOT_LEN=>SWF%SRRLOC(F)%TOTLENGTH, &
                                 WT=>SWF%SRRLOC(F)%WT          )
                                 !
                        !
                        IF(TOT_LEN > NEARZERO_29) THEN
                            DO K=ONE, DIM
                                         WT(K) = STRM(1,ISTRM(K))/TOT_LEN
                            END DO
                        ELSE
                            SWF%SRRLOC(F)%N = Z              !NO STREAMS TO FLOW TOO
                            SWF%SRRLOC(F)%HAS_RETURN = FALSE
                        END IF
                        !
                    END ASSOCIATE
                ELSE !ASSUME AN EVEN SPLIT OF RUNOFF
                    WT_SUM = DZ
                    ASSOCIATE(ISTRM=>SWF%SRRLOC(F)%ISTRM, &
                                 WT=>SWF%SRRLOC(F)%WT      )
                                 !
                        IF(    DIM == TWO  ) THEN; WT_SUM = HALF
                        ELSEIF(DIM == THREE) THEN; WT_SUM = THIRD
                        ELSEIF(DIM == FOUR ) THEN; WT_SUM = FOURTH
                        ELSEIF(DIM == FIVE ) THEN; WT_SUM = FIFTH
                        ELSE;                      WT_SUM = UNO / DBLE(DIM)
                        END IF
                        !
                        DO CONCURRENT (K=ONE:DIM);  WT(K) = WT_SUM
                        END DO
                        !
                    END ASSOCIATE
                END IF
             END IF
         END IF
      END IF
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE BUILD_FULLY_ROUTED_RETURN_SRRLOC(SWF, WBS, IDIVAR, ISTRM, STRM)
    !
    CLASS(SURFACE_WATER_DATA),           INTENT(INOUT):: SWF
    INTEGER, DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: WBS
    INTEGER, DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: IDIVAR, ISTRM
    REAL,    DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: STRM
    TYPE(INTEGER_LINKED_LIST), DIMENSION(:), ALLOCATABLE:: LST
    INTEGER:: NSTRM, F, K, I, J, S
    LOGICAL:: ADD
    !
    !--------------------------------------
    !
    !
    NSTRM = SIZE(ISTRM, TWO)
    !
    ALLOCATE(LST(SWF%NFARM))
    !
    DO F = ONE, SWF%NFARM
                         CALL LST(F)%INIT()
    END DO
    !
    !--------------------------------------
    !
    DO K = ONE, NSTRM
       J = ISTRM(2,K) !row number
       I = ISTRM(3,K) !column number
       S = ISTRM(4,K) !Stream Segment Number
       F = WBS(I,J)
       IF(F > Z) THEN
        IF(SWF%BUILD_FRR(F)) THEN
            ADD = FALSE
            !
            IF(SWF%IRRFL == NEG) THEN
                                          ADD = TRUE
            ELSEIF(SWF%IRRFL == ONE) THEN
                     IF(IDIVAR(1,S) == Z) ADD = TRUE
            END IF
            !
            IF(ADD) CALL LST(F)%ADD(K)
            !
        END IF !( SWF%SRRLOC(F)%HAS_RETURN  .AND. SWF%SRRLOC(F)%FULLY)
       END IF  !(F > Z)
    END DO
    !
    !--------------------------------------
    !
    DO F = ONE, SWF%NFARM
        !
        IF( SWF%BUILD_FRR(F) ) THEN
         !
         SWF%SRRLOC(F)%BUILD_FULLY = FALSE     !NO NEED TO REBUILD UNLESS REQUESTED IN RP
         !
         SWF%SRRLOC(F)%LEAVE_MODEL = FALSE
         !
         SWF%SRRLOC(F)%N = LST(F)%LEN()
         !
         SWF%SRRLOC(F)%TOTLENGTH = DZ
         !
         IF(SWF%SRRLOC(F)%N < ONE) THEN
             CALL ALLOC(SWF%SRRLOC(F)%RUNOFF,ONE)   !(ARR, N)
         ELSE
             CALL ALLOC(SWF%SRRLOC(F)%RUNOFF,SWF%SRRLOC(F)%N)   !(ARR, N)
             CALL ALLOC(SWF%SRRLOC(F)%WT,    SWF%SRRLOC(F)%N)   !(ARR, N)
             !CALL ALLOC(SWF%SRRLOC(F)%ISTRM, SWF%SRRLOC(F)%N)   !(ARR, N)
             CALL ALLOC(SWF%SRRLOC(F)%SR,TWO,SWF%SRRLOC(F)%N,Z) !(ARR, N, M, DIMCHK)
             !
             CALL LST(F)%TOARRAY(SWF%SRRLOC(F)%ISTRM)
             CALL LST(F)%DESTROY()                   !NO LONGER NEEDED
             !
             IF(SWF%SRRLOC(F)%N > ONE) THEN !LENGTH PRORATED
                    !
                    ASSOCIATE(  DIM=>SWF%SRRLOC(F)%N,         &
                                IST=>SWF%SRRLOC(F)%ISTRM,     &
                                 SR=>SWF%SRRLOC(F)%SR,        &
                            TOT_LEN=>SWF%SRRLOC(F)%TOTLENGTH, &
                                 WT=>SWF%SRRLOC(F)%WT         )
                                 !
                        DO K=ONE, DIM
                                    SR(ONE,K) = ISTRM(4, IST(K))  !SEG
                                    SR(TWO,K) = ISTRM(5, IST(K))  !RCH
                        END DO
                        !
                        DO K=ONE, DIM
                                  TOT_LEN = TOT_LEN + STRM( 1, IST(K) )
                        END DO
                        !
                        IF(TOT_LEN > NEARZERO_29) THEN
                            DO K=ONE, DIM
                                         WT(K) = STRM(1,IST(K))/TOT_LEN
                            END DO
                        ELSE
                            SWF%SRRLOC(F)%N = Z !NO STREAMS TO FLOW TOO
                            TOT_LEN = DZ
                        END IF
                        !
                    END ASSOCIATE
             ELSE 
                 SWF%SRRLOC(F)%WT(ONE)   = UNO
                 SWF%SRRLOC(F)%TOTLENGTH = STRM( 1, SWF%SRRLOC(F)%ISTRM(ONE) )
             END IF
         END IF
         !
      END IF
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE APPLY_RUNOFF_TO_SFR(SWF, RUNOFF, STRM)
    !
    CLASS(SURFACE_WATER_DATA),                   INTENT(INOUT):: SWF
    DOUBLE PRECISION,DIMENSION(:),   CONTIGUOUS, INTENT(IN   ):: RUNOFF
    REAL,            DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: STRM
    LOGICAL:: WRN_PRT
    INTEGER:: I, K, F
    DOUBLE PRECISION:: REACH_RUNFOFF
    TYPE(WARNING_TYPE):: WRN
    !
    CALL WRN%INIT()
    !
    WRN_PRT = FALSE
    !
    DO F=ONE, SWF%NFARM
        IF( SWF%SRRLOC(F)%HAS_RETURN  .AND. SWF%SRRLOC(F)%N > Z) THEN
            !
            ASSOCIATE(  DIM=>SWF%SRRLOC(F)%N,      &
                      ISTRM=>SWF%SRRLOC(F)%ISTRM,  &
                      RNOFF=>SWF%SRRLOC(F)%RUNOFF, &
                         WT=>SWF%SRRLOC(F)%WT       )
                         !
               IF(DIM==ONE) THEN
                   !
                   RNOFF(ONE) = RUNOFF(F)
                   !
                   I = ISTRM(ONE)
                   !
                   STRM(12,I) = STRM(12,I) + RUNOFF(F)
               ELSE
                   DO K=ONE, DIM
                       !
                       REACH_RUNFOFF = RUNOFF(F) * WT(K)
                       !
                       RNOFF(K) = REACH_RUNFOFF
                       !
                       I = ISTRM(K)
                       !
                       STRM(12,I) = STRM(12,I) + REACH_RUNFOFF
                       !
                   END DO
               END IF
            END ASSOCIATE
            !
        ELSEIF(RUNOFF(F) > NEARZERO_6 .AND. .NOT. SWF%SRRLOC(F)%LEAVE_MODEL)THEN
            !
            IF(SWF%RUNOFF_PRNT(F)) THEN
                                       SWF%RUNOFF_PRNT(F) = FALSE
                                       WRN_PRT = TRUE
            END IF
            !
            CALL WRN%ADD(NUM2STR(F,6)//'   '//NUM2STR(RUNOFF(F))//NL)
            SWF%SRRLOC(F)%RUNOFF(ONE) = RUNOFF(F)
        ELSE
            SWF%SRRLOC(F)%RUNOFF(ONE) = RUNOFF(F)
        END IF
    END DO
    !
    IF(WRN_PRT) THEN
       CALL WRN%CHECK(HED=NL//REPEAT('-',71)//NL//'   THIS IS A SOFT WARNING, IGNORE IT IF YOU INTENTIONALLY WANT THIS.  |'//NL//REPEAT('-',71)//BLN//   &
       'WBS RUNOFF IS NOT CONNECTED TO A SFR STREAM, SO RUNOFF WILL FLOW OUT OF THE MODEL DOMAIN'//BLN//         &
       'THIS OCCURS BECAUSE EITHER SFR IS NOT USED IN SIMULATION'//NL//                                          &
       'OR A SET OF REACHES COULD NOT BE FOUND WITHIN THE WBS/FARM AREA.'//BLN//                                 &
       'SINCE THE SURFACE WATER RUNOFF HAS NO WHERE TO GO IT IS REMOVED FROM THE MODEL.'//BLN//                  &
       'IF YOU WANT TO KEEP RUNOFF WITHIN THE MODEL USE THE SURFACE_WATER BLOCK KEYWORD "NORETURNFLOW"'//NL//    &
       'TO INDICATE THAT SURFACE RUNOFF SHOULD REINFILTRATE AS DEEP PERCOLATION'//NL//                           &
       'OR SPECIFY A "SEMI_ROUTED_RETURN" LOCATION FOR THE FOLLOWING WBS.'//BLN//                                &
       '(NOTE IF YOU DEFINE A WBS WITH A "SEMI_ROUTED_RETURN" SEGMENT=0 THEN THIS WARNING IS DISABLED.)'//BLN// &
       'THE FOLLOWING ARE THE WBS/FARMS THAT HAD RUNOFF THAT FLOWS OUT OF THE MODEL DOMAIN'//BLN//               &
       '   WBS   RUNOFF',                                        &
        OUTPUT=SWF%IOUT, CMD_PRINT=SWF%CMD_RUNOFF_PRNT, NO_NL=TRUE, TAIL=BLN//'THIS WARNING APPEARS THE FIRST TIME FMP HAS A WBS WITH RUNOFF > 0 AND THE RUNOFF HAS NO WHERE TO FLOW'//NL)
        !
        IF(SWF%CMD_RUNOFF_PRNT) SWF%CMD_RUNOFF_PRNT = FALSE
    END IF
    !
  END SUBROUTINE
  !
  !!!SUBROUTINE SET_SFR_SRD_FLOW(SWF, STRM)
  !!!  !
  !!!  CLASS(SURFACE_WATER_DATA),           INTENT(INOUT):: SWF
  !!!  REAL,    DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: STRM
  !!!  INTEGER:: F, L, K
  !!!  !
  !!!  DO CONCURRENT (F=ONE:SWF%NFARM, SWF%SRDLOC(F)%N > Z) 
  !!!    DO K = ONE, SWF%SRDLOC(F)%N
  !!!       ASSOCIATE(IRCH  => SWF%SRDLOC(F)%SEGRCH(TWO,K), &
  !!!                 ISTRM => SWF%SRDLOC(F)%ISTRM(K     ), &
  !!!                 FLOW  => SWF%SRDLOC(F)%FLOW(      K)   )
  !!!                 !
  !!!          L = ISTRM
  !!!          !
  !!!          IF(IRCH == ONE) THEN
  !!!              FLOW = STRM(10, L) !INFLOW TO CURRENT REACH
  !!!          ELSE
  !!!              L = L - ONE
  !!!              FLOW = STRM(9, L) !OUTFLOW FROM PREVIOUS REACH -- WHICH IS THE SAME AS INFLOW
  !!!          END IF
  !!!       END ASSOCIATE
  !!!    END DO
  !!!  END DO
  !!!  !
  !!!END SUBROUTINE
  !  
  SUBROUTINE SET_NRD_ARRAY( SWF, NRD, UPDATE )
    CLASS(SURFACE_WATER_DATA),                    INTENT(IN   ):: SWF
    DOUBLE PRECISION, DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: NRD
    LOGICAL,                                      INTENT(IN   ):: UPDATE
    INTEGER:: I,J,II,DIM
    !
    IF(SWF%NRD%INUSE) THEN 
        !
        IF(UPDATE) THEN
                   DO CONCURRENT(J=ONE:SWF%NFARM); NRD(ONE,J) = J
                   END DO
        END IF
        !
        IF(UPDATE .OR. SWF%NRD%TRANSIENT) THEN 
            !
            DO CONCURRENT(J=ONE:SWF%NFARM, I=ONE:SWF%MXNRD*THREE)
                NRD(I+ONE,J) = SWF%NRD%ARRAY(I,J)
            END DO
            !
            DIM = SWF%MXNRD*THREE + ONE  !DIM OF NRD ARRAY
            !
            ASSOCIATE(SFAC=> SWF%NRD%SFAC)
                IF(SFAC%HAS_ALL) THEN
                    DO CONCURRENT(J=ONE:SWF%NFARM, I=TWO:DIM:THREE)  !I=ONE:SWF%MXNRD and II = (I-ONE)*THREE + TWO
                          NRD(I,J) = NRD(I,J) * SFAC%ALL
                    END DO
                END IF
                IF(SFAC%HAS_EX1) THEN
                    DO CONCURRENT(J=ONE:SWF%NFARM, I=TWO:DIM:THREE)
                          NRD(I,J) = NRD(I,J) * SFAC%EX1(J)
                    END DO
                END IF
                IF(SFAC%HAS_EX2) THEN
                    DO CONCURRENT(J=ONE:SWF%NFARM, I=ONE:SWF%MXNRD)
                          II = (I-ONE)*THREE + TWO
                          NRD(II,J) = NRD(II,J) * SFAC%EX2(I)
                    END DO
                END IF
            END ASSOCIATE
            !
        END IF
    END IF
    !
  END SUBROUTINE
  !  
  !SUBROUTINE SET_SRD_ARRAY( SWF, SRD, UPDATE )
  !  CLASS(SURFACE_WATER_DATA),           INTENT(IN   ):: SWF
  !  INTEGER, DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: SRD
  !  LOGICAL,                             INTENT(IN   ):: UPDATE
  !  INTEGER:: J
  !  !
  !  !!!IF(SWF%ISRD%INUSE) THEN
  !  !!!    !
  !  !!!    IF(UPDATE) THEN
  !  !!!        SRD = Z
  !  !!!        DO CONCURRENT(J=ONE:SWF%NFARM); SRD(ONE,J) = J
  !  !!!        END DO
  !  !!!    END IF
  !  !!!    !
  !  !!!    IF(UPDATE .OR. SWF%ISRD%TRANSIENT) THEN 
  !  !!!        DO CONCURRENT(J=ONE:SWF%NFARM)
  !  !!!            SRD(FOUR,J) = SWF%ISRD%SEGRCH(ONE,J)
  !  !!!            SRD(FIVE,J) = SWF%ISRD%SEGRCH(TWO,J)
  !  !!!        END DO
  !  !!!    END IF
  !  !!!    !
  !  !!!END IF
  !  !
  !END SUBROUTINE
  !  
  !SUBROUTINE SET_SRR_ARRAY( SWF, SRR, UPDATE )
  !  CLASS(SURFACE_WATER_DATA),           INTENT(IN   ):: SWF
  !  INTEGER, DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: SRR
  !  LOGICAL,                             INTENT(IN   ):: UPDATE
  !  INTEGER:: J
  !  !
  !  IF(SWF%ISRR_TFR%INUSE) THEN
  !      !
  !      IF(UPDATE) THEN
  !          SRR = Z
  !          FORALL(J=ONE:SWF%NFARM) SRR(ONE,J) = J
  !      END IF
  !      !
  !      IF(UPDATE .OR. SWF%ISRR_TFR%TRANSIENT) THEN 
  !          DO CONCURRENT(J=ONE:SWF%NFARM)
  !              !!!SRR(FOUR,J) = SWF%ISRR_TFR%SEGRCH(ONE,J)
  !              !!!SRR(FIVE,J) = SWF%ISRR_TFR%SEGRCH(TWO,J)
  !          END DO
  !      END IF
  !      !
  !  END IF
  !  !
  !END SUBROUTINE
  !  
  SUBROUTINE SET_CHOICE_ARRAY( SWF, CHOICE, UPDATE )
    CLASS(SURFACE_WATER_DATA),           INTENT(IN   ):: SWF
    INTEGER, DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: CHOICE
    LOGICAL,                             INTENT(IN   ):: UPDATE
    !
    IF(SWF%HAS_SW) THEN
       IF(UPDATE .OR. SWF%CHOICE%TRANSIENT) THEN
                          CHOICE = SWF%H2ORETURN
       END IF
    ELSE
        CHOICE = Z
    END IF
    !
  END SUBROUTINE
  !
!!!  PURE SUBROUTINE APPY_FARM_SRD_SFR()
!!!        IF(IUNITSFR.NE.Z .AND. (IRDFL.NE.Z .OR. ISRDFL.NE.Z).AND. WBS%H2OSOURCE%SW(NF)) THEN                     ! seb H2OSRC(1,:)=FID; H2OSRC(2,:)=GW; H2OSRC(3,:)=SW; H2OSRC(4,:)=NRD  
!!!         FSLEN=FCSEGL(NF)
!!!         !AFDELSW=DZ
!!!         !RDEL=DZ
!!!         IFCRIDOLD=Z
!!!         IF(ISRDFL.EQ.-1) GOTO 665
!!!         !
!!!         IF(    SWFL%ISRD%ARRAY(ONE,NF) > Z) THEN
!!!            I = SWFL%ISRD%ARRAY(ONE,NF)
!!!            !
!!!            L = SEG_NSTRM(I) + SWFL%ISRD%ARRAY(TWO,NF)
!!!            LL=L-1
!!!            IF(LL<ONE) LL=ONE
!!!            !
!!!            FLOWIN=STRM(9,LL)
!!!            FLOWIN=ANINT(FLOWIN*AC)/AC  
!!!            TOT_DIV_FLOW = FLOWIN
!!!            !
!!!            IF(ALLOT%HAS_SW_ALLOTMENT .AND.
!!!     1         FARMALLOT.LT.FLOWIN) FLOWIN=FARMALLOT
!!!            !
!!!            IF(WBS%HAS_SWO)THEN
!!!               IF(SWODAT%FMP_SW_LIMIT(NF).LT.FLOWIN)
!!!     1                    FLOWIN=SWODAT%FMP_SW_LIMIT(NF)
!!!            END IF
!!!            !
!!!            IF(ND.LE.TF) THEN
!!!                RDEL=TF-ND-QR
!!!            ELSE
!!!                RDEL=-SURPLUS1       !recharge cumulative surplus of nrd (if desired to be sent to SW) into canal
!!!            END IF
!!!            IF(RDEL.GT.FLOWIN) RDEL=FLOWIN
!!!            !
!!!            STRM(12,L)=SNGL(SFRADD(L)-RDEL)
!!!            AFDELSW   =RDEL
!!!            RDR(L)    =RDEL
!!!         ELSE
!!!         !
!!!         DO L=3,NSTRM
!!!            LL=L-1                              
!!!            FLOWIN=STRM(9,LL)
!!!            FLOWIN=ANINT(FLOWIN*AC)/AC                        !STRM(10,L) ?   seb response STRM(9,L-1) = STRM(10,L)  **note that LL=L-1
!!!            RCHLEN=DBLE(STRM(1,L))
!!!C
!!!C7E2A---DETERMINE SW DELIVERY FROM HEAD-GATE REACH
!!!
!!!C7E2A1--DETERMINE LOCATION OF HEAD-GATE REACH
!!!C       Farm Reach: * belongs to farm, * is at all a farm reach,
!!!C                   * 1st one being different from previous one,
!!!C                   * 1st one being different from second previous one, meaning
!!!C                     1st previous one could be just a blank (FCRID(NF,L)=0 at farm corner point),
!!!C                     but still within the same farm.
!!!           IF(IFCRID(NF,L).EQ.NF .AND. IFCRID(NF,L).GT.0 .AND.
!!!     1      IFCRID(NF,L).NE.IFCRID(NF,L-1).AND.IFCRID(NF,L).NE.
!!!     2      IFCRID(NF,L-2).AND.IFCRID(NF,L).NE.IFCRIDOLD) THEN
!!!C
!!!C7E2A2--DETERMINE REACH DELIVERY REQUIREMENT AND ACTUAL DELIVERY FROM HEAD-GATE REACH INTO FARM
!!!              TOT_DIV_FLOW = TOT_DIV_FLOW + FLOWIN
!!!              IFCRIDOLD=IFCRID(NF,L)
!!!              IF(IOPTFL.EQ.0.AND.ND.LE.TF) RDEL=TF-ND-QR                !QR is not zero for acreage optimization, otherwise zero here
!!!              IF(IOPTFL.EQ.1.AND.ND.LE.TF) RDEL=SW-SURPLUS1
!!!              IF(ND.GT.TF) RDEL=-SURPLUS1                               !recharge cumulative surplus of nrd (if desired to be sent to SW) into canal
!!!C
!!!C             GENERAL CASE & EQUAL APPROPRIATION
!!!              IF(ALLOT%HAS_SW_ALLOTMENT .AND.
!!!     1           FARMALLOT.LT.FLOWIN) FLOWIN=FARMALLOT
!!!              !
!!!              IF(WBS%HAS_SWO)THEN
!!!                 IF(SWODAT%FMP_SW_LIMIT(NF).LT.FLOWIN)
!!!     1                      FLOWIN=SWODAT%FMP_SW_LIMIT(NF)
!!!              END IF
!!!              !
!!!              IF(RDEL.GT.FLOWIN) RDEL=FLOWIN
!!!!             IF(IGRID.EQ.1.AND.ANY(IALLOTSW.EQ.[1,4])) FALLOT(NF)=FLOWIN!OVERWRITE PARENT ALLOTMENT WITH JOINT (PARENT + CHILD) ALLOTMENT OR UNRESTRICTED STREAMFLOW
!!!!              IF(IALLOTSW.LT.2.AND.RDEL.GT.FLOWIN) RDEL=FLOWIN                                    SCOTT
!!!!              IF(IGRID.EQ.1.AND.IALLOTSW.EQ.1) FALLOT(NF)=FLOWIN        !OVERWRITE PARENT ALLOTMENT WITH JOINT (PARENT + CHILD) ALLOTMENT OR UNRESTRICTED STREAMFLOW
!!!!           
!!!!           save actual delivery from surface water to farm and pull it from canal 
!!!!           (by adding a 'negative recharge' " - RDEL " to 'reach-by-reach overland recharge' of SFR package)
!!!!
!!!!-----------FOR A PARENT MODEL FARM WITH A HEAD-GATE REACH, FOR A CHILD MODEL WHERE FMP IS ACTIVE, AND WHERE THE CURRENT FARM STRADDLES BOTH MODELS,
!!!!           CHECK IF THE SUM OF RESIDUAL DEMANDS OF PARENT AND CHILD MODEL FARMS EXCEED THE AVAILABLE STREAMFLOW OR NOT:
!!!!           --> for the case that the sum of both residual demands (parent and child) exceed the available streamflow:
!!!!               scale the RDEL of parent farm back by flowin/(parent_farm_demand + child_farm_demand) AND divert all streamflow.
!!!!           --> for the case that the sum of both residual demands (parent and child) does not exceed the available streamflow:
!!!!               divert child farm demand in addition to parent farm demand from the available streamflow.  
!!!            IF(ILGR.NE.0.AND.LGRITER.GT.1.AND.IGRID.EQ.1.AND.
!!!     1         NGRIDS.GT.1) THEN 
!!!               CRDEL=0
!!!               DO N=2,NGRIDS
!!!               IF(N.EQ.LGRDAT(N)%IFMPGRID) THEN
!!!                IF(FMPDAT(N)%ISRDFL.EQ.-1)THEN
!!!                  CRDEL=CRDEL+FMPDAT(N)%TFDR(NF)-FMPDAT(N)%NRD(1,NF)
!!!                  IF(TF-ND-QR+CRDEL.GT.FLOWIN) THEN
!!!                    STRM(12,L)=SNGL(SFRADD(L)-FLOWIN)
!!!                    RDEL=(TF-ND-QR)*FLOWIN/(TF-ND-QR+CRDEL)
!!!                  ELSE
!!!                    STRM(12,L)=SNGL(SFRADD(L)-RDEL-CRDEL)
!!!                  ENDIF
!!!                ENDIF
!!!               ENDIF
!!!               ENDDO
!!!            ELSE
!!!               STRM(12,L)=SNGL(SFRADD(L)-RDEL)
!!!            ENDIF
!!!     
!!!            AFDELSW=RDEL
!!!            RDR(L)=RDEL
!!!         ENDIF
!!!         ENDDO
!!!         !
!!!         END IF
!!!  
!!!  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_SFR_SRD(SWF, STRM, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(SURFACE_WATER_DATA),                 INTENT(INOUT):: SWF
    REAL, DIMENSION(:,:), CONTIGUOUS,          INTENT(IN   ):: STRM
    INTEGER,                                   INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,                          INTENT(IN   ):: DELT
    DOUBLE PRECISION,                          INTENT(IN   ):: DYEAR
    CHARACTER(*),                              INTENT(IN   ):: DATE
    INTEGER:: IU, F, I, FF, II, ISTRM
    DOUBLE PRECISION:: INFLOW, DMD
    CHARACTER(17):: ZER, DT
    CHARACTER(11):: REASON
    !
    IF(SWF%OUT_SFR_SRD%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !
    CALL SWF%OUT_SFR_SRD%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = SWF%OUT_SFR_SRD%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. SWF%IOUT==IU )  THEN
        IF(SWF%OUT_SFR_SRD%BINARY) THEN 
            WRITE(SWF%IOUT,'(A,/A)')'SURFACE_WATER SFR_DELIVERY (SEMI_ROUTED_DELIVERY) INFORMATION OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), WBS ID (INT), SEGMENT (INT), REACH (INT), DELIVERY (double), SFR_INFLOW (double), LOWER_LIMIT (double), UPPER_LIMIT (double), WBS_SFR_DMD (double), SRD ID (int)"
        ELSE
            !
            IF (SWF%IOUT==IU) WRITE(IU,*)
            !                                                                                                                                                        x
            CALL SWF%OUT_SFR_SRD%SET_HEADER( '    PER    STP    WBS    SEG    RCH      WBS_SFR_DMD         DELIVERY       SFR_INFLOW      LOWER_LIMIT      UPPER_LIMIT  DEFICIT_REASON        DELT   DYEAR         DATE_START           ISRD' )
        END IF
    END IF
    !
    DO F=ONE, SWF%NFARM
       !
      IF(SWF%SRDLOC(F)%N == Z) THEN
          CONTINUE        
      ELSEIF(ALL(SWF%SRDLOC(F)%ISTRM < ONE)) THEN
          REASON = '  NO_DELIV'
          WRITE(IU, '(5I7, 5A17, A, A17, 2x F13.7, 2x A, 2x A)') KPER, KSTP, F, Z, Z, ZER, ZER, ZER, ZER, ZER, REASON, DT, DYEAR, DATE, '0'
      ELSE
          IF( SWF%SRDLOC(F)%TOT_DMD_INI - SWF%SRDLOC(F)%TOT_DMD_MET <= NEARZERO_12 ) REASON = '  NONE'
          !
          DO I = ONE, SWF%SRDLOC(F)%N
           !
           IF(SWF%SRDLOC(F)%ISTRM(I) > Z) THEN
             !
             ISTRM = SWF%SRDLOC(F)%ISTRM(I)
             !
             INFLOW = STRM(10,SWF%SRDLOC(F)%ISTRM(I))
             !
             DMD    = SWF%SRDLOC(F)%TOT_DMD_INI
             !
             !--------------------------------------------------------------------------------------------
             ! Deduct previous farms
             DO FF = ONE, F-ONE
                 DO II = ONE, SWF%SRDLOC(FF)%N
                                         IF(ISTRM == SWF%SRDLOC(FF)%ISTRM(II)) THEN
                                             !
                                             INFLOW = INFLOW - SWF%SRDLOC(FF)%FLOW(II)  !Water removed from SFR before current delivery
                                         END IF
                 END DO
             END DO
             !
             !Deduct previous delivery locations
             DO II = ONE, I-ONE
                                     IF(ISTRM == SWF%SRDLOC(F)%ISTRM(II)) THEN
                                         !
                                         INFLOW = INFLOW - SWF%SRDLOC(F)%FLOW(II)  !Water removed from SFR before current delivery
                                     END IF
                                     !
                                     DMD = DMD - SWF%SRDLOC(F)%FLOW(II)
             END DO
             !
             IF(INFLOW < DZ) INFLOW = DZ
             !--------------------------------------------------------------------------------------------
             !
             IF(SWF%SRDLOC(F)%TOT_DMD_INI - SWF%SRDLOC(F)%TOT_DMD_MET > NEARZERO_12) THEN
                 !
                 IF( INFLOW - SWF%SRDLOC(F)%FLOW(I) <= NEARZERO_12 ) THEN  !IS_CLOSE(INFLOW,SWF%SRDLOC(F)%FLOW(I))
                     !
                     REASON = '  INFLOW'
                     !
                 ELSEIF( SWF%SRDLOC(F)%ULIM(I) - SWF%SRDLOC(F)%LLIM(I) - SWF%SRDLOC(F)%FLOW(I) <= NEARZERO_12 ) THEN
                     !
                     REASON = '  LIMIT'
                     !
                 ELSE
                    IF(IS_CLOSE(INFLOW,SWF%SRDLOC(F)%FLOW(I), NEARZERO_5, NEARZERO_3) ) THEN  ! Check in cauase its a precision issue
                        !
                        REASON = '  INFLOW'
                        !
                    ELSEIF( IS_CLOSE(SWF%SRDLOC(F)%ULIM(I) - SWF%SRDLOC(F)%LLIM(I), SWF%SRDLOC(F)%FLOW(I), NEARZERO_5, NEARZERO_3) ) THEN
                        !
                        REASON = '  LIMIT'
                    ELSE
                            REASON = '  UNKNOWN'  !Probably failed to converge on delivery or time step
                    END IF
                 END IF
             END IF
             !
             IF(SWF%OUT_SFR_SRD%BINARY) THEN
                                      !WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,I,CDAT%CROP_NAME(I),AREA,AREA_IRR,EFF,CU_I,CU,CIRI,CIR,DMDI,DMD,ADMD_I,ADMD,DP,RO,DP_E,RO_E,TPOT,ANOX_LOSS,SOIL_LOSS,TACT,TSURF_I,TSURF,TI,TP,TGWA,EI,EP,EGWA,P
             ELSE
                     WRITE(IU, '(5I7, 5A17, A, A17, 2x F13.7, 2x A, 2x A)') KPER, KSTP, F, SWF%SRDLOC(F)%SR(ONE,I), SWF%SRDLOC(F)%SR(TWO,I), NUM2STR(DMD), NUM2STR(SWF%SRDLOC(F)%FLOW(I)), NUM2STR(INFLOW), NUM2STR(SWF%SRDLOC(F)%LLIM(I)), NUM2STR(SWF%SRDLOC(F)%ULIM(I)), REASON, DT, DYEAR, DATE, NUM2STR(SWF%SRDLOC(F)%ISRD(I))
             END IF
           END IF
          END DO
      END IF
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_SFR_SRD_BYWBS(SWF, STRM, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(SURFACE_WATER_DATA),                 INTENT(INOUT):: SWF
    REAL, DIMENSION(:,:), CONTIGUOUS,          INTENT(IN   ):: STRM
    INTEGER,                                   INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,                          INTENT(IN   ):: DELT
    DOUBLE PRECISION,                          INTENT(IN   ):: DYEAR
    CHARACTER(*),                              INTENT(IN   ):: DATE
    INTEGER:: IU, F, I
    DOUBLE PRECISION:: INFLOW, DELIV, MAX_DELIV, DEFICIT, TOT_ULIM, TOT_LLIM, DMD, SHORT
    CHARACTER(17):: ZER, DT
    !
    IF(SWF%OUT_SFR_SRD_BYWBS%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !
    CALL SWF%OUT_SFR_SRD_BYWBS%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = SWF%OUT_SFR_SRD_BYWBS%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. SWF%IOUT==IU )  THEN
        IF(SWF%OUT_SFR_SRD_BYWBS%BINARY) THEN 
            WRITE(SWF%IOUT,'(A,/A)')'SURFACE_WATER SFR_DELIVERY BY WBS (SEMI_ROUTED_DELIVERY) INFORMATION OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), WBS ID (INT), SEGMENT (INT), REACH (INT), DELIVERY (double), SFR_INFLOW (double), LOWER_LIMIT (double), UPPER_LIMIT (double), WBS_TOT_SFR_DMD (double), SRD ID (int)"
        ELSE
            !
            IF (SWF%IOUT==IU) WRITE(IU,*)
            !                                                                                                                      X
            CALL SWF%OUT_SFR_SRD_BYWBS%SET_HEADER( '    PER    STP    WBS      WBS_SFR_DMD         DELIVERY       SFR_INFLOW     MAX_DELIVERY   INFLOW_DEFICIT  TOTAL_LOWER_LIM  TOTAL_UPPER_LIM             DELT   DYEAR         DATE_START' )
        END IF
    END IF
    !
    DO F=ONE, SWF%NFARM
      !
      IF(SWF%SRDLOC(F)%N == Z) THEN
          IF(SWF%OUT_SFR_SRD_BYWBS%BINARY) THEN
                                 WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,F,DZ, DZ, DZ, DZ, DZ, DZ, DZ
          ELSE
                  WRITE(IU, '(3I7, 8A17, 2x F13.7, 2x A)') KPER, KSTP, F, ZER,ZER,ZER,ZER,ZER,ZER,ZER, DT, DYEAR, DATE
          END IF
      ELSEIF(ALL(SWF%SRDLOC(F)%ISTRM < ONE)) THEN
          IF(SWF%OUT_SFR_SRD_BYWBS%BINARY) THEN
                                 WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,F,DZ, DZ, DZ, DZ, DZ, DZ, DZ
          ELSE
                  WRITE(IU, '(3I7, 8A17, 2x F13.7, 2x A)') KPER, KSTP, F, ZER,ZER,ZER,ZER,ZER,ZER,ZER, DT, DYEAR, DATE
          END IF
      ELSE
          INFLOW    = DZ
          DELIV     = DZ
          MAX_DELIV = DZ
          TOT_ULIM  = DZ
          TOT_LLIM  = DZ
          DEFICIT   = DZ
          DMD       = SWF%SRDLOC(F)%TOT_DMD_INI
          !
          DO I = ONE, SWF%SRDLOC(F)%N
                !
                IF(SWF%SRDLOC(F)%ISTRM(I) > Z) THEN
                  !
                  SHORT = SWF%SRDLOC(F)%ULIM(I) - SWF%SRDLOC(F)%LLIM(I)
                  !
                  IF(SHORT > DMD) SHORT = DMD
                  SHORT = SHORT - SWF%SRDLOC(F)%FLOW(I)
                  !
                  IF(SHORT > NEARZERO_12) THEN
                      DEFICIT = DEFICIT + SHORT
                  ELSE
                      SHORT = DZ
                  END IF
                  !
                  INFLOW    = INFLOW    + STRM(10,SWF%SRDLOC(F)%ISTRM(I))
                  DELIV     = DELIV     + SWF%SRDLOC(F)%FLOW(I)
                  MAX_DELIV = MAX_DELIV + SWF%SRDLOC(F)%MAXDEL(I)
                  TOT_ULIM  = TOT_ULIM  + SWF%SRDLOC(F)%ULIM(I)
                  TOT_LLIM  = TOT_LLIM  + SWF%SRDLOC(F)%LLIM(I)
                  !
                  DMD       = DMD       - SWF%SRDLOC(F)%FLOW(I) - SHORT
                  !
                END IF
          END DO
          !
          DEFICIT = SWF%SRDLOC(F)%TOT_DMD_INI - SWF%SRDLOC(F)%TOT_DMD_MET
          !
          IF( DEFICIT <= NEARZERO_12 ) DEFICIT = DZ
          !
          IF(SWF%OUT_SFR_SRD_BYWBS%BINARY) THEN
                                 WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,F,DELIV, INFLOW, MAX_DELIV, SWF%SRDLOC(F)%TOT_DMD_INI, DEFICIT
          ELSE
                  WRITE(IU, '(3I7, 8A17, 2x F13.7, 2x A)') KPER, KSTP, F, NUM2STR(SWF%SRDLOC(F)%TOT_DMD_INI), NUM2STR(DELIV), NUM2STR(INFLOW), NUM2STR(MAX_DELIV), NUM2STR(DEFICIT), NUM2STR(TOT_LLIM), NUM2STR(TOT_ULIM), DT, DYEAR, DATE
          END IF
      END IF
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_SFR_SRR(SWF, STRM, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(SURFACE_WATER_DATA),                 INTENT(INOUT):: SWF
    REAL, DIMENSION(:,:), CONTIGUOUS,          INTENT(IN   ):: STRM
    INTEGER,                                   INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,                          INTENT(IN   ):: DELT
    DOUBLE PRECISION,                          INTENT(IN   ):: DYEAR
    CHARACTER(*),                              INTENT(IN   ):: DATE
    INTEGER:: IU, F, I
    DOUBLE PRECISION:: INFLOW, OTFLOW
    CHARACTER(17):: ZER, DT
    !
    IF(SWF%OUT_SFR_SRR%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !
    CALL SWF%OUT_SFR_SRR%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = SWF%OUT_SFR_SRR%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. SWF%IOUT==IU )  THEN
        IF(SWF%OUT_SFR_SRR%BINARY) THEN 
            WRITE(SWF%IOUT,'(A,/A)')'SURFACE_WATER SFR_RETURN (SEMI_ROUTED_RETURN + FULLY_ROUTED_RETURN) INFORMATION OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), WBS ID (INT), SEGMENT (INT), REACH (INT), DELIVERY (double), SFR_INFLOW (double), LOWER_LIMIT (double), UPPER_LIMIT (double), WBS_TOT_SFR_DMD (double), SRR ID (int)"
        ELSE
            !
            IF (SWF%IOUT==IU) WRITE(IU,*)
            !
            CALL SWF%OUT_SFR_SRR%SET_HEADER( '    PER    STP    WBS    SEG    RCH           RUNOFF       SFR_INFLOW      SFR_OUTFLOW             DELT   DYEAR         DATE_START           ISRR' )
        END IF
    END IF
    !
    DO F=ONE, SWF%NFARM
      !
      IF(.NOT. SWF%SRRLOC(F)%FULLY) THEN
         IF(SWF%SRRLOC(F)%N == Z) THEN
                IF(SWF%OUT_SFR_SRR%BINARY) THEN
                                             WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,F, Z, Z, SWF%SRRLOC(F)%RUNOFF(I), DZ, DZ, NEG
                ELSE
                        WRITE(IU, '(5I7, 4A17, 2x F13.7, 2x A, 2x A)') KPER, KSTP, F, Z, Z, NUM2STR(SWF%SRRLOC(F)%RUNOFF(ONE)), ZER, ZER, DT, DYEAR, DATE, '-1'
                END IF
         ELSE
             DO I = ONE, SWF%SRRLOC(F)%N
              !
              IF(SWF%SRRLOC(F)%ISTRM(I) > Z) THEN
                !
                OTFLOW = STRM(9, SWF%SRRLOC(F)%ISTRM(I))
                INFLOW = STRM(10,SWF%SRRLOC(F)%ISTRM(I))
                !
                IF(SWF%OUT_SFR_SRR%BINARY) THEN
                                             WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,F, SWF%SRRLOC(F)%SR(ONE,I), SWF%SRRLOC(F)%SR(TWO,I), SWF%SRRLOC(F)%RUNOFF(I), INFLOW, OTFLOW, SWF%SRRLOC(F)%ISRR(I)
                ELSE
                        WRITE(IU, '(5I7, 4A17, 2x F13.7, 2x A, 2x A)') KPER, KSTP, F, SWF%SRRLOC(F)%SR(ONE,I), SWF%SRRLOC(F)%SR(TWO,I), NUM2STR(SWF%SRRLOC(F)%RUNOFF(I)), NUM2STR(INFLOW), NUM2STR(OTFLOW), DT, DYEAR, DATE, NUM2STR(SWF%SRRLOC(F)%ISRR(I))
                END IF
              END IF
             END DO
         END IF
      END IF
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_SFR_RET(SWF, STRM, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(SURFACE_WATER_DATA),                 INTENT(INOUT):: SWF
    REAL, DIMENSION(:,:), CONTIGUOUS,          INTENT(IN   ):: STRM
    INTEGER,                                   INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,                          INTENT(IN   ):: DELT
    DOUBLE PRECISION,                          INTENT(IN   ):: DYEAR
    CHARACTER(*),                              INTENT(IN   ):: DATE
    INTEGER:: IU, F, I
    DOUBLE PRECISION:: INFLOW, OTFLOW
    CHARACTER(17):: ZER, DT
    !
    IF(SWF%OUT_SFR_RET%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !
    CALL SWF%OUT_SFR_RET%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = SWF%OUT_SFR_RET%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. SWF%IOUT==IU )  THEN
        IF(SWF%OUT_SFR_RET%BINARY) THEN 
            WRITE(SWF%IOUT,'(A,/A)')'SURFACE_WATER SFR_RETURN (SEMI_ROUTED_RETURN) INFORMATION OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), WBS ID (INT), SEGMENT (INT), REACH (INT), RUNOFF (double), SFR_INFLOW (double), SFR_OUTFLOW (double), SRR ID (int)"
        ELSE
            !
            IF (SWF%IOUT==IU) WRITE(IU,*)
            !
            CALL SWF%OUT_SFR_RET%SET_HEADER( '    PER    STP    WBS    SEG    RCH           RUNOFF       SFR_INFLOW      SFR_OUTFLOW             DELT   DYEAR         DATE_START           ISRR' )
        END IF
    END IF
    !
    DO F=ONE, SWF%NFARM
      !
      IF(SWF%SRRLOC(F)%N == Z) THEN
             IF(SWF%OUT_SFR_RET%BINARY) THEN
                                           WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP, F, SWF%SRRLOC(F)%SR(ONE,I), SWF%SRRLOC(F)%SR(TWO,I), SWF%SRRLOC(F)%RUNOFF(I), INFLOW, OTFLOW, SWF%SRRLOC(F)%ISRR(I), NEG
             ELSE
                     WRITE(IU, '(5I7, 4A17, 2x F13.7, 2x A, 2x A)') KPER, KSTP, F, Z, Z, NUM2STR(SWF%SRRLOC(F)%RUNOFF(ONE)), ZER, ZER, DT, DYEAR, DATE, '-1'
             END IF
      ELSEIF(SWF%SRRLOC(F)%FULLY) THEN
          DO I = ONE, SWF%SRRLOC(F)%N
             !
             OTFLOW = STRM(9, SWF%SRRLOC(F)%ISTRM(I))
             INFLOW = STRM(10,SWF%SRRLOC(F)%ISTRM(I))
             !
             IF(SWF%OUT_SFR_RET%BINARY) THEN
                                           WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP, F, SWF%SRRLOC(F)%SR(ONE,I), SWF%SRRLOC(F)%SR(TWO,I), SWF%SRRLOC(F)%RUNOFF(I), INFLOW, OTFLOW, SWF%SRRLOC(F)%ISRR(I), Z
             ELSE
                     WRITE(IU, '(5I7, 4A17, 2x F13.7, 2x A, 2x A)') KPER, KSTP, F, SWF%SRRLOC(F)%SR(ONE,I), SWF%SRRLOC(F)%SR(TWO,I), NUM2STR(SWF%SRRLOC(F)%RUNOFF(I)), NUM2STR(INFLOW), NUM2STR(OTFLOW), DT, DYEAR, DATE, '0'
             END IF
          END DO
      ELSE
          DO I = ONE, SWF%SRRLOC(F)%N
           !
           IF(SWF%SRRLOC(F)%ISTRM(I) > Z) THEN
             !
             OTFLOW = STRM(9, SWF%SRRLOC(F)%ISTRM(I))
             INFLOW = STRM(10,SWF%SRRLOC(F)%ISTRM(I))
             !
             IF(SWF%OUT_SFR_RET%BINARY) THEN
                                           WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP, F, SWF%SRRLOC(F)%SR(ONE,I), SWF%SRRLOC(F)%SR(TWO,I), SWF%SRRLOC(F)%RUNOFF(I), INFLOW, OTFLOW, SWF%SRRLOC(F)%ISRR(I)
             ELSE
                     WRITE(IU, '(5I7, 4A17, 2x F13.7, 2x A, 2x A)') KPER, KSTP, F, SWF%SRRLOC(F)%SR(ONE,I), SWF%SRRLOC(F)%SR(TWO,I), NUM2STR(SWF%SRRLOC(F)%RUNOFF(I)), NUM2STR(INFLOW), NUM2STR(OTFLOW), DT, DYEAR, DATE, NUM2STR(SWF%SRRLOC(F)%ISRR(I))
             END IF
           END IF
          END DO
      END IF
    END DO
    !
  END SUBROUTINE
  !
END MODULE
!
!#########################################################################################################
!
MODULE SOIL_DATA_FMP_INTERFACE!, ONLY: SOIL_DATA, SOIL_DATA_INITIALIZE
  !
  USE FMP_DIMENSION_INTERFACE, ONLY: FMP_DIMENSION
  !
  USE UTIL_INTERFACE,                    ONLY: FILE_IO_ERROR, STOP_ERROR, WARNING_MESSAGE, &
                                               UPPER, JOIN_TXT, PARSE_WORD, PARSE_WORD_UP
  USE NUM2STR_INTERFACE,                 ONLY: NUM2STR
  USE CONSTANTS
  USE ALLOC_INTERFACE,                   ONLY: ALLOC
  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
  USE LIST_ARRAY_INPUT_INTERFACE,        ONLY: LIST_ARRAY_INPUT, LIST_ARRAY_INPUT_INT
  USE ULOAD_AND_SFAC_INTERFACE
  USE WARNING_TYPE_INSTRUCTION,          ONLY: WARNING_TYPE
  USE LOOKUP_TABLE_INSTRUCTION,          ONLY: LOOKUP_TABLE_TYPE
  !
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: SOIL_DATA, INITIALIZE_SOIL_DATA
  !
  TYPE SOIL_COEF_DATA
      DOUBLE PRECISION:: A,B,C,D,E
      !CONTAINS                                           !-- MAYBE NECESSARY TO UNCOMMENT IF THERE IS A PROBLEM WITH SOIL%COEF(I,J) = SOIL_COEF(SOIL%SID(I,J))
      !GENERIC:: ASSIGNMENT(=) => COPY_SOIL_COEF_DATA
      !PROCEDURE, PRIVATE::       COPY_SOIL_COEF_DATA
  END TYPE
  !
  TYPE SOIL_DATA
      INTEGER:: IOUT=Z, LOUT=Z
      LOGICAL:: HAS_SOIL      = FALSE
      LOGICAL:: TFR_READ      = FALSE
      LOGICAL:: HAS_FRINGE    = FALSE
      LOGICAL:: HAS_SOIL_COEF = FALSE
      INTEGER:: HAS_Pe_TABLE  = Z     !0 = NO Pe, 1 = Pe, 2 =Pe as Fraction
      INTEGER,                DIMENSION(:,:),ALLOCATABLE:: SID
      DOUBLE PRECISION,       DIMENSION(:,:),ALLOCATABLE:: CAPILLARY_FRINGE
      TYPE(SOIL_COEF_DATA),   DIMENSION(:,:),ALLOCATABLE:: COEF
      TYPE(LOOKUP_TABLE_TYPE),DIMENSION(:),  ALLOCATABLE:: Pe_Table !Lookup tables that determine effective precip
      DOUBLE PRECISION,       DIMENSION(:,:),ALLOCATABLE:: SURF_VK
      !
      TYPE(LIST_ARRAY_INPUT):: CAPILLARY_TFR
      TYPE(LIST_ARRAY_INPUT):: SURF_VK_TFR
      !
  CONTAINS
      !
      PROCEDURE, PASS(SOIL):: NO_SOIL  => SET_NO_SOIL
      FINAL:: DEALLOCATE_SOIL_FINAL
  END TYPE
  !
  CONTAINS
  !
  !PURE ELEMENTAL SUBROUTINE COPY_SOIL_COEF_DATA(SOIL_OUT,SOIL_IN)  !-- MAYBE NECESSARY TO UNCOMMENT IF THERE IS A PROBLEM WITH SOIL%COEF(I,J) = SOIL_COEF(SOIL%SID(I,J))
  !  CLASS(SOIL_COEF_DATA), INTENT(IN ):: SOIL_IN
  !  CLASS(SOIL_COEF_DATA), INTENT(OUT):: SOIL_OUT
  !  !
  !  SOIL_OUT%A = SOIL_IN%A 
  !  SOIL_OUT%B = SOIL_IN%B 
  !  SOIL_OUT%C = SOIL_IN%C 
  !  SOIL_OUT%D = SOIL_IN%D 
  !  SOIL_OUT%E = SOIL_IN%E 
  !  !
  !END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_SOIL_FINAL(SOIL)
  TYPE(SOIL_DATA)::SOIL
  CALL DEALLOCATE_SOIL(SOIL)
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_SOIL(SOIL)
  CLASS(SOIL_DATA), INTENT(INOUT)::SOIL
  !
  IF(ALLOCATED(SOIL%SID))              DEALLOCATE(SOIL%SID)
  IF(ALLOCATED(SOIL%CAPILLARY_FRINGE)) DEALLOCATE(SOIL%CAPILLARY_FRINGE)
  IF(ALLOCATED(SOIL%COEF))             DEALLOCATE(SOIL%COEF)
  IF(ALLOCATED(SOIL%SURF_VK))          DEALLOCATE(SOIL%SURF_VK)
  !
  END SUBROUTINE
  !
  SUBROUTINE SET_NO_SOIL(SOIL, FDIM, SET_ONE)
    CLASS(SOIL_DATA),    INTENT(INOUT):: SOIL
    TYPE(FMP_DIMENSION), INTENT(IN   ):: FDIM
    LOGICAL,             INTENT(IN   ):: SET_ONE
    INTEGER:: NS
    NS = FDIM%NSOIL
    IF(NS<ONE) NS=ONE
    !
    CALL DEALLOCATE_SOIL(SOIL)
    !
    IF(SET_ONE) THEN
        CALL SOIL%CAPILLARY_TFR%INIT('CAP_FRINGE',DZ, Z, Z, NS, ONE, Z, Z)
        ALLOCATE(SOIL%SID(FDIM%NCOL,FDIM%NROW),              SOURCE=ONE)
        ALLOCATE(SOIL%CAPILLARY_FRINGE(FDIM%NCOL,FDIM%NROW), SOURCE=DZ)
    END IF
    !
    SOIL%HAS_SOIL      = SET_ONE
    SOIL%HAS_FRINGE    = SET_ONE
    SOIL%HAS_SOIL_COEF = FALSE
    SOIL%HAS_Pe_TABLE  = Z
    !
    IF(ALLOCATED(SOIL%SURF_VK)) THEN
                                SOIL%SURF_VK = D200
    ELSE
        ALLOCATE(SOIL%SURF_VK(FDIM%NCOL,FDIM%NROW), SOURCE=D200)
    END IF
  END SUBROUTINE
  !  
  SUBROUTINE INITIALIZE_SOIL_DATA( BL, SOIL, LINE, FDIM )
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL   !DATA BLOCK
    CLASS(SOIL_DATA),            INTENT(INOUT):: SOIL
    CHARACTER(*),                INTENT(INOUT):: LINE
    TYPE(FMP_DIMENSION),         INTENT(IN   ):: FDIM
    TYPE(SOIL_COEF_DATA),DIMENSION(:), ALLOCATABLE:: SOIL_COEF
    CHARACTER(200),      DIMENSION(:), ALLOCATABLE:: SOIL_COEF_LINE
    CHARACTER(5):: ERROR
    LOGICAL:: EOF, NO_SOIL_LOCATION
    INTEGER:: I, J, LLOC, ISTART, ISTOP, IU
    TYPE(WARNING_TYPE):: WARN_MSG
    !
    CALL WARN_MSG%INIT()
    !
    WRITE(BL%IOUT,'(/A/)') 'SOIL BLOCK FOUND AND NOW LOADING PROPERTIES'
    !
    SOIL%IOUT = BL%IOUT
    SOIL%LOUT = BL%IOUT
    SOIL%HAS_Pe_TABLE  = Z
    !
    ALLOCATE(SOIL%SURF_VK(FDIM%NCOL,FDIM%NROW), SOURCE=D200)  !Default value is not to limit
    !
    IF (FDIM%NSOIL > Z) THEN
        SOIL%HAS_SOIL      = TRUE
    ELSE
        CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP SOIL. NSOIL = 0. SOIL BLOCK WILL ASSUME SOIL_ID = 0 SO NO SOILS CACULATIONS ALLOWED AND THE CAPILARY FRINGE IS SET TO ZERO. IF YOU ARE USING CROPS THEN PROGRAM WILL STOP SOON WITH AN ERROR.')
        !ALLOCATE(SOIL%SID(FDIM%NCOL,FDIM%NROW), SOURCE=Z)
        !ALLOCATE(SOIL%CAPILLARY_FRINGE(FDIM%NCOL,FDIM%NROW), SOURCE=DZ)
        CALL SET_NO_SOIL(SOIL, FDIM, FALSE)
        RETURN
    END IF
    !
    NO_SOIL_LOCATION = TRUE
    ERROR='ERROR'
    !
    IF(SOIL%HAS_SOIL) THEN
       !
       CALL BL%MAKE_SCRATCH_FILE()
       !
       !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
       CALL BL%READ_SCRATCH(EOF, LINE)
       !
       DO WHILE (.NOT. EOF)
         !
         LLOC=ONE
         CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
         !
         SELECT CASE ( LINE(ISTART:ISTOP) )
         CASE ("SOIL_ID","SOILID","SID","LOCATION")
                           WRITE(BL%IOUT,'(A)') '   SOIL_ID (LOCATION, SID) KEYWORD FOUND. NOW LOADING USING ULOAD TO LOAD IN 2D ARRAY SOILD IDs.'
                           IU=Z
                           NO_SOIL_LOCATION = FALSE
                           ALLOCATE(SOIL%SID(FDIM%NCOL,FDIM%NROW))
                           CALL ULOAD(SOIL%SID, LLOC, LINE, BL%IOUT, BL%IU, IU, NOID=TRUE, SCRATCH=BL%SCRATCH)
                           !
                           WHERE( SOIL%SID > FDIM%NSOIL ) SOIL%SID = Z
                           !
         CASE ("CAPILLARY_FRINGE","CAPF")
                           WRITE(BL%IOUT,'(A)') '   CAPILLARY_FRINGE (CAPF) KEYWORD FOUND. NOW LOADING LIST/ARRAY KEYWORD.'
                           ALLOCATE(SOIL%CAPILLARY_FRINGE(FDIM%NCOL,FDIM%NROW), SOURCE=DZ)
                           CALL SOIL%CAPILLARY_TFR%INIT('CAP_FRINGE',  LLOC, LINE, BL%IOUT, BL%IU, FDIM%NSOIL, ONE, FDIM%NROW, FDIM%NCOL, FDIM%NSOIL, 'BYSOIL', SCRATCH=BL%SCRATCH, NO_TRANSIENT=TRUE)
                           SOIL%HAS_FRINGE = TRUE
                           !
         CASE ("COEFFICIENT", "COEFICIENT")
                           WRITE(BL%IOUT,'(A)') '   COEFFICIENT             KEYWORD FOUND. NOW LOADING USING ULOAD TO LOAD LIST OF SOIL COEFIENTS (EITHER AS KEYWORDS OR COEFICIENTS A,B,C,D,E).'
                           SOIL%HAS_SOIL_COEF = TRUE
                           IU=Z
                           ALLOCATE(SOIL_COEF(FDIM%NSOIL), SOIL_COEF_LINE(FDIM%NSOIL))
                           CALL ULOAD(SOIL_COEF_LINE, LLOC, LINE, BL%IOUT, BL%IU, IU, SCRATCH=BL%SCRATCH, ENTIRE_LINE = TRUE)  !READ ENTIRE LINE AND PARSE LATER
                           !CALL UPPER(SOIL_COEF(ONE,:))
         CASE ("EFFECTIVE_PRECIPITATION_TABLE","EFFECTIVE_PRECIP_TABLE")
                           WRITE(BL%IOUT,'(A)') '   EFFECTIVE_PRECIPITATION_TABLE KEYWORD FOUND. FIRST CHECKING "BY_LENGTH" OR "BY_FRAC" KEYWORD. IF NOT PRESENT THEN AN ERROR IS  RAISED.'
                           !
                           CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                           !
                           SELECT CASE ( LINE(ISTART:ISTOP) )
                           CASE('BYLENGTH', 'BY_LENGTH','BYHEIGHT',"BY_HEIGHT");  SOIL%HAS_Pe_TABLE = ONE
                           CASE('BYFRAC',"BY_FRAC","BYFRACTION","BY_FRACTION");   SOIL%HAS_Pe_TABLE = TWO
                           CASE DEFAULT
                                           !WRITE(BL%IOUT,'(3x 3A)') '"BY_LENGTH" OR "BY_FRAC" FLAG NOT FOUND, ASSUMING IT IS NOT SPECIFIED AND WILL USE "BY_FRAC".'
                                           CALL STOP_ERROR(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG='FMP SOIL ERROR. KEYWORD "EFFECTIVE_PRECIPITATION_TABLE" MUST BE FOLLOWED BY THE KEYWORD "BY_LENGTH" OR "BY_FRAC"')
                           END SELECT
                           !
                           WRITE(BL%IOUT,'(3x 2A)') LINE(ISTART:ISTOP),' KEYWORD FOUND, SO IF USING ULOAD LIST-STYLE TO READ NSOIL EFFECTIVE PRECIPITATION LOOKUP TABLES.'
                           !
                           ALLOCATE(SOIL%Pe_Table(FDIM%NSOIL))
                           IU=Z
                           CALL ULOAD(SOIL%Pe_Table, LLOC, LINE, BL%IOUT, BL%IU, IU, SCRATCH=BL%SCRATCH)
                           !
         CASE ("SURFACE_VERTICAL_HYDRAULIC_CONDUCTIVITY", "SURF_VK")
                           WRITE(BL%IOUT,'(A)') '   SURFACE_VERTICAL_HYDRAULIC_CONDUCTIVITY (SURF_VK) KEYWORD FOUND. NOW LOADING LIST/ARRAY KEYWORD.'
                           CALL SOIL%SURF_VK_TFR%INIT('SURF_VK',  LLOC, LINE, BL%IOUT, BL%IU, FDIM%NSOIL, ONE, FDIM%NROW, FDIM%NCOL, FDIM%NSOIL, 'BYSOIL', SCRATCH=BL%SCRATCH, NO_TRANSIENT=TRUE)
         CASE DEFAULT
                           CALL WARN_MSG%ADD('FOUND UNKNOWN KEYWORD "'//LINE(ISTART:ISTOP)//'" ***IT WILL BE IGNORED***'//BLN)
                           
         END SELECT
         !
         !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
         CALL BL%READ_SCRATCH(EOF, LINE)
         !
       END DO
    END IF
    !
    CALL WARN_MSG%CHECK(HED='FMP SOIL BLOCK'//NL,INFILE=BL%IU,OUTPUT=BL%IOUT,INLINE=TRUE,CMD_PRINT=TRUE,TAIL=NL)
    !
    IF(NO_SOIL_LOCATION .AND. FDIM%NSOIL == ONE) THEN
        !
        NO_SOIL_LOCATION = FALSE
        ALLOCATE(SOIL%SID(FDIM%NCOL,FDIM%NROW), SOURCE=ONE)
        !
    END IF
    !
    !Check if Capilary Fringe is specifed as an ARRAY and nothing else is specified, then fake soil IDs
    !
    IF(NO_SOIL_LOCATION .AND.       SOIL%HAS_FRINGE             &
                        .AND. .NOT. SOIL%HAS_SOIL_COEF          &
                        .AND. .NOT. SOIL%CAPILLARY_TFR%LISTLOAD &
                        .AND.       SOIL%HAS_Pe_TABLE == Z      ) THEN
                                                                      ALLOCATE(SOIL%SID(FDIM%NCOL,FDIM%NROW), SOURCE=ONE)
                                                                      NO_SOIL_LOCATION = FALSE
    END IF
    !
    ! -----------------------------------------------------------------------------------------------------------------------------------
    !
    IF(NO_SOIL_LOCATION) THEN
        CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP SOIL. FAILED TO LOCATE KEYWORD "SOIL_ID" WITHIN SOIL BLOCK. IT WILL BE ASSUMED THAT  SOIL_ID = 0 SO NO SOILS CACULATIONS ALLOWED AND THE CAPILARY FRINGE IS SET TO ZERO. IF YOU ARE USING CROPS THEN PROGRAM WILL STOP SOON WITH AN ERROR.')
        !
        IF(SOIL%HAS_SOIL_COEF) DEALLOCATE(SOIL_COEF, SOIL_COEF_LINE)
        IF(ALLOCATED(SOIL%CAPILLARY_FRINGE)) DEALLOCATE(SOIL%CAPILLARY_FRINGE)
        IF(SOIL%HAS_Pe_TABLE > Z )           DEALLOCATE(SOIL%Pe_Table        )
        !
        SOIL%HAS_SOIL      = FALSE
        SOIL%HAS_FRINGE    = FALSE
        SOIL%HAS_SOIL_COEF = FALSE
        SOIL%HAS_Pe_TABLE  = Z
        RETURN
        !
    ELSEIF(.NOT. SOIL%CAPILLARY_TFR%INUSE) THEN
        CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP SOIL ERROR. FAILED TO LOCATE KEYWORD "CAPILLARY_FRINGE" WITHIN SOIL BLOCK. IT WILL BE ASSUMED ZERO.')
        !
        ALLOCATE(SOIL%CAPILLARY_FRINGE(FDIM%NCOL,FDIM%NROW), SOURCE=DZ)
        CALL SOIL%CAPILLARY_TFR%INIT('CAP_FRINGE',  DZ, BL%IOUT, BL%IU, FDIM%NSOIL, ONE, FDIM%NROW, FDIM%NCOL)
        SOIL%HAS_FRINGE    = FALSE
        SOIL%HAS_SOIL_COEF = FALSE
        !
    END IF
    !
    IF(SOIL%CAPILLARY_TFR%SFAC%HAS_ALL) THEN
        DO CONCURRENT(J=ONE:FDIM%NROW, I=ONE:FDIM%NCOL, SOIL%SID(I,J)>Z .AND. SOIL%SID(I,J)<=FDIM%NSOIL)
              !
              SOIL%CAPILLARY_FRINGE(I,J) = SOIL%CAPILLARY_TFR%GET(SOIL%SID(I,J), I, J) * SOIL%CAPILLARY_TFR%SFAC%ALL
        END DO
    ELSE
        DO CONCURRENT(J=ONE:FDIM%NROW, I=ONE:FDIM%NCOL, SOIL%SID(I,J)>Z .AND. SOIL%SID(I,J)<=FDIM%NSOIL)
              !
              SOIL%CAPILLARY_FRINGE(I,J) = SOIL%CAPILLARY_TFR%GET(SOIL%SID(I,J), I, J)
        END DO
    END IF
    !
    IF(SOIL%CAPILLARY_TFR%SFAC%HAS_EX1) THEN
        DO CONCURRENT(J=ONE:FDIM%NROW, I=ONE:FDIM%NCOL, SOIL%SID(I,J)>Z .AND. SOIL%SID(I,J)<=FDIM%NSOIL)
              !
              SOIL%CAPILLARY_FRINGE(I,J) = SOIL%CAPILLARY_FRINGE(I,J) * SOIL%CAPILLARY_TFR%SFAC%EX1(SOIL%SID(I,J))
        END DO
    END IF
    !
    ! -----------------------------------------------------------------------------------------------------------------------------------
    !
    IF(SOIL%SURF_VK_TFR%INUSE) THEN
       !
       IF(SOIL%SURF_VK_TFR%SFAC%HAS_ALL) THEN
           DO CONCURRENT(J=ONE:FDIM%NROW, I=ONE:FDIM%NCOL, SOIL%SID(I,J)>Z .AND. SOIL%SID(I,J)<=FDIM%NSOIL)
                 !
                 SOIL%SURF_VK(I,J) = SOIL%SURF_VK_TFR%GET(SOIL%SID(I,J), I, J) * SOIL%SURF_VK_TFR%SFAC%ALL
           END DO
       ELSE
           DO CONCURRENT(J=ONE:FDIM%NROW, I=ONE:FDIM%NCOL, SOIL%SID(I,J)>Z .AND. SOIL%SID(I,J)<=FDIM%NSOIL)
                 !
                 SOIL%SURF_VK(I,J) = SOIL%SURF_VK_TFR%GET(SOIL%SID(I,J), I, J)
           END DO
       END IF
       !
       IF(SOIL%SURF_VK_TFR%SFAC%HAS_EX1) THEN
           DO CONCURRENT(J=ONE:FDIM%NROW, I=ONE:FDIM%NCOL, SOIL%SID(I,J)>Z .AND. SOIL%SID(I,J)<=FDIM%NSOIL)
                 !
                 SOIL%SURF_VK(I,J) = SOIL%SURF_VK(I,J) * SOIL%SURF_VK_TFR%SFAC%EX1(SOIL%SID(I,J))
           END DO
       END IF
       !
    END IF
    !
    ! -----------------------------------------------------------------------------------------------------------------------------------
    !
    IF(SOIL%HAS_SOIL_COEF) THEN
        !
        DO I=ONE, FDIM%NSOIL
              !
              LLOC=ONE
              CALL PARSE_WORD_UP(SOIL_COEF_LINE(I),LLOC,ISTART,ISTOP)
              !
              SELECT CASE(SOIL_COEF_LINE(I)(ISTART:ISTOP))
              CASE("SILT")
                               SOIL_COEF(I)%A =  0.320149668D0 
                               SOIL_COEF(I)%B = -0.328586793D0
                               SOIL_COEF(I)%C =  2.851921250D0
                               SOIL_COEF(I)%D =  1.3027D0
                               SOIL_COEF(I)%E = -2.0416D0
              CASE("SANDYLOAM")
                               !SOIL_COEF(I)%A =  0.201D0
                               !SOIL_COEF(I)%B = -0.195D0
                               !SOIL_COEF(I)%C =  3.083D0
                               !SOIL_COEF(I)%D =  3.201D0
                               !SOIL_COEF(I)%E = -3.903D0
                               SOIL_COEF(I)%A =  0.200738267D0
                               SOIL_COEF(I)%B = -0.195485538D0
                               SOIL_COEF(I)%C =  3.083110101D0
                               SOIL_COEF(I)%D =  3.2012D0
                               SOIL_COEF(I)%E = -3.9025D0
              CASE("SILTYCLAY")
                               SOIL_COEF(I)%A =  0.348098866D0
                               SOIL_COEF(I)%B = -0.327445062D0
                               SOIL_COEF(I)%C =  1.730759566D0
                               SOIL_COEF(I)%D =  0.5298D0
                               SOIL_COEF(I)%E = -0.3767D0
              CASE("SAND")
                               SOIL_COEF(I)%A =  0.11D0                       
                               SOIL_COEF(I)%B = -0.059D0
                               SOIL_COEF(I)%C =  3.09D0
                               SOIL_COEF(I)%D =  4.326D0
                               SOIL_COEF(I)%E = -4.099D0
              CASE DEFAULT
                                         READ(SOIL_COEF_LINE(I)(ISTART:ISTOP), *, IOSTAT=IU) SOIL_COEF(I)%A   ;  CALL PARSE_WORD(SOIL_COEF_LINE(I),LLOC,ISTART,ISTOP)
                               IF(IU==Z) READ(SOIL_COEF_LINE(I)(ISTART:ISTOP), *, IOSTAT=IU) SOIL_COEF(I)%B   ;  CALL PARSE_WORD(SOIL_COEF_LINE(I),LLOC,ISTART,ISTOP)
                               IF(IU==Z) READ(SOIL_COEF_LINE(I)(ISTART:ISTOP), *, IOSTAT=IU) SOIL_COEF(I)%C   ;  CALL PARSE_WORD(SOIL_COEF_LINE(I),LLOC,ISTART,ISTOP)
                               IF(IU==Z) READ(SOIL_COEF_LINE(I)(ISTART:ISTOP), *, IOSTAT=IU) SOIL_COEF(I)%D   ;  CALL PARSE_WORD(SOIL_COEF_LINE(I),LLOC,ISTART,ISTOP)
                               IF(IU==Z) READ(SOIL_COEF_LINE(I)(ISTART:ISTOP), *, IOSTAT=IU) SOIL_COEF(I)%E
                               !
                               IF(IU.NE.Z) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SOIL ERROR. KEYWORD "COEFFICIENT" FOUND'//NL//'BUT FAILED TO EITHER CONVERT SOIL COEFICIENTS (A, B, C, D, E) TO A NUMBER'//NL//'OR IDENTIFY THE KEYWORDS "SILT", "SANDYLOAM", OR "SILTYCLAY"'//NL//'FOR SOIL ID '//NUM2STR(I)//NL//'THE FOLLOWING IS THE LINE (OR PORTION OF THE LINE) THAT WAS BEING PROCESSED THAT RESULTED IN THE ERROR: '//NL//SOIL_COEF_LINE(I))
              END SELECT
        END DO
        !
        ALLOCATE(SOIL%COEF(FDIM%NCOL,FDIM%NROW))
        !
        DO CONCURRENT(J=ONE:FDIM%NROW, I=ONE:FDIM%NCOL,SOIL%SID(I,J)>Z);   SOIL%COEF(I,J) = SOIL_COEF(SOIL%SID(I,J))
        END DO
        DEALLOCATE(SOIL_COEF, SOIL_COEF_LINE)
    END IF
    !
  END SUBROUTINE 
  !
END MODULE
!
!#########################################################################################################
!
MODULE CLIMATE_DATA_FMP_INTERFACE
  !
  USE FMP_DIMENSION_INTERFACE,           ONLY: FMP_DIMENSION
  USE SOIL_DATA_FMP_INTERFACE,           ONLY: SOIL_DATA
  !
  USE UTIL_INTERFACE,                    ONLY: FILE_IO_ERROR, STOP_ERROR, WARNING_MESSAGE, &
                                               GET_NUMBER, PARSE_WORD_UP
  USE NUM2STR_INTERFACE,                 ONLY: NUM2STR
  USE CONSTANTS
  USE ALLOC_INTERFACE,                   ONLY: ALLOC
  USE ARRAY_DATA_TYPES,                  ONLY: COMPRESSED_VALUE_STORAGE
  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
  USE LIST_ARRAY_INPUT_INTERFACE,        ONLY: LIST_ARRAY_INPUT, LIST_ARRAY_INPUT_INT
  USE ULOAD_AND_SFAC_INTERFACE
  USE WARNING_TYPE_INSTRUCTION,          ONLY: WARNING_TYPE
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: CLIMATE_DATA, INITIALIZE_CLIMATE_DATA
  !
  TYPE CLIMATE_DATA
      INTEGER:: IOUT=Z, LOUT=Z
      INTEGER:: NROW, NCOL, NFARM
      INTEGER:: HAS_Pe_TFR = Z     !0 = NO Pe, 1 = Pe, 2 =Pe as Fraction
      LOGICAL:: HAS_PRECIP = FALSE
      LOGICAL:: HAS_Pe     = FALSE  !SET TO TRUE IF PRECIP_EFFECTIVE IS ALLOCATED
      LOGICAL:: HAS_REF_ET = FALSE
      LOGICAL:: HAS_BARE_REF_ET = FALSE
      LOGICAL:: HAS_RECHARGE    = FALSE
      LOGICAL:: RECHARGE_AS_FLUX
      LOGICAL:: TFR_READ   = FALSE
      DOUBLE PRECISION:: REF_ET_TO_BARE = HALF
      DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: REF_ET
      DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: PRECIP
      DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: PRECIP_EFFECTIVE
      DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: BARE_POT_EVAP
      !
      !!!DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: EGW_POT, TGW_POT
      !!!DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: EGW_ACT, TGW_ACT
      !!!DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: PRECIP_POT_TRAN, PRECIP_POT_EVAP
      !
      TYPE(COMPRESSED_VALUE_STORAGE), ALLOCATABLE:: DIRECT_RECHARGE
      !
      TYPE(LIST_ARRAY_INPUT):: REF_ET_BARE_TFR
      TYPE(LIST_ARRAY_INPUT):: REF_ET_TFR
      TYPE(LIST_ARRAY_INPUT):: PRECIP_TFR
      TYPE(LIST_ARRAY_INPUT):: PRECIP_EFF_TFR
      TYPE(LIST_ARRAY_INPUT):: RCH_TFR
      !
      CONTAINS
      !
      PROCEDURE, PASS(CLIM):: NEXT     => SETUP_NEXT_STRESS_PERIOD
      PROCEDURE, PASS(CLIM):: ADD_DIRECT_RECHARGE
      FINAL:: DEALLOCATE_CLIMATE_FINAL
  END TYPE
  !
  CONTAINS
  !
  SUBROUTINE DEALLOCATE_CLIMATE_FINAL(CLIM)
  TYPE(CLIMATE_DATA)::CLIM
  CALL DEALLOCATE_CLIMATE(CLIM)
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_CLIMATE(CLIM)
  CLASS(CLIMATE_DATA), INTENT(INOUT)::CLIM
  !
  IF(ALLOCATED(CLIM%REF_ET))          DEALLOCATE(CLIM%REF_ET)
  IF(ALLOCATED(CLIM%PRECIP))          DEALLOCATE(CLIM%PRECIP)
  IF(ALLOCATED(CLIM%PRECIP_EFFECTIVE))DEALLOCATE(CLIM%PRECIP_EFFECTIVE)
  IF(ALLOCATED(CLIM%BARE_POT_EVAP))   DEALLOCATE(CLIM%BARE_POT_EVAP)
  !
  END SUBROUTINE
  !  
  SUBROUTINE INITIALIZE_CLIMATE_DATA( BL, CLIM, LINE, FDIM )
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL   !DATA BLOCK
    CLASS(CLIMATE_DATA),         INTENT(INOUT):: CLIM
    CHARACTER(*),                INTENT(INOUT):: LINE
    TYPE(FMP_DIMENSION),         INTENT(IN   ):: FDIM
    CHARACTER(5):: ERROR, BYWBS
    LOGICAL:: EOF
    INTEGER:: LLOC, ISTART, ISTOP, NROW, NCOL
    INTEGER, DIMENSION(3):: CDIM
    TYPE(WARNING_TYPE):: WARN_MSG
    !
    CALL WARN_MSG%INIT()
    !
    WRITE(BL%IOUT,'(/A/)') 'CLIMATE BLOCK FOUND AND NOW LOADING PROPERTIES'
    !
    CLIM%REF_ET_TO_BARE = HALF  !Default value
    !
    CLIM%IOUT = BL%IOUT
    CLIM%LOUT = BL%IOUT
    NROW = FDIM%NROW
    NCOL = FDIM%NCOL
    CLIM%NROW = NROW 
    CLIM%NCOL = NCOL
    CLIM%NFARM = FDIM%NFARM
    CLIM%HAS_Pe_TFR = Z
    !
    CLIM%HAS_Pe = FALSE
    !
    ERROR = 'ERROR'
    BYWBS = 'BYWBS'
    !
    CDIM = [2,1,0]
    !
    CALL BL%MAKE_SCRATCH_FILE()
    !
    !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
    CALL BL%READ_SCRATCH(EOF, LINE)
    !
    DO WHILE (.NOT. EOF)
      !
      LLOC=ONE
      CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
      !
      SELECT CASE ( LINE(ISTART:ISTOP) )
      CASE ("REFERENCE_ET","ETR")
                        WRITE(BL%IOUT,'(A)') '   REFERENCE_ET (ETR)                  KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN ARRAY OF REFERENCE ET VALUES.'
                        CLIM%HAS_REF_ET = TRUE
                        CALL CLIM%REF_ET_TFR%INIT('ETR',  LLOC, LINE, BL%IOUT, BL%IU, Z, Z, NROW, NCOL, FDIM%NFARM, BYWBS, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                        !CALL CLIM%REF_ET_TFR%NEXT()  --AUTOCALLED!
                        !
                        ALLOCATE(CLIM%REF_ET(NCOL,NROW))
      CASE ("REFERENCE_ET_TO_BARE")
                        WRITE(BL%IOUT,'(A)') '   REFERENCE_ET_TO_BARE                KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN ARRAY OF REFERENCE ET VALUES.'
                        
                        CALL GET_NUMBER(LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,CLIM%REF_ET_TO_BARE,  MSG='FMP CLIMATE BLOCK: "REFERENCE_ET_TO_BARE" FAILED TO LOAD THE NUMBER SPECIFIED AFTER THE KEYWORD.')
      CASE ("POTENTIAL_EVAPORATION_BARE","ETR_BARE")
                        WRITE(BL%IOUT,'(A)') '   POTENTIAL_EVAPORATION_BARE (ETR_BARE) KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN ARRAY OF REFERENCE EVAPORATION VALUES FOR BARE SOIL.'
                        CLIM%HAS_REF_ET = TRUE
                        CLIM%REF_ET_TO_BARE = UNO
                        CALL CLIM%REF_ET_BARE_TFR%INIT('ETR_BARE',  LLOC, LINE, BL%IOUT, BL%IU, Z, Z, NROW, NCOL, FDIM%NFARM, BYWBS, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                        !
      CASE ("PRECIPITATION", "PRECIP")
                        WRITE(BL%IOUT,'(A)') '   PRECIPITATION (PRECIP)                KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN ARRAY OF PRECIPITATION VALUES.'
                        CLIM%HAS_PRECIP = TRUE
                        CALL CLIM%PRECIP_TFR%INIT('PRECIP', LLOC, LINE, BL%IOUT, BL%IU, Z, Z, NROW, NCOL, FDIM%NFARM, BYWBS, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                        !
      CASE ("PRECIPITATION_POTENTIAL_CONSUMPTION")
                        WRITE(BL%IOUT,'(A)') '   PRECIPITATION_POTENTIAL_CONSUMPTION KEYWORD FOUND. FIRST CHECKING "BY_LENGTH" OR "BY_FRACTION" KEYWORD. IF NOT PRESENT THEN AN ERROR IS  RAISED.'
                        !
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        !
                        SELECT CASE ( LINE(ISTART:ISTOP) )
                        CASE('BYLENGTH', 'BY_LENGTH','BYHEIGHT',"BY_HEIGHT");  CLIM%HAS_Pe_TFR = ONE
                        CASE("BYFRACTION","BY_FRACTION",'BYFRAC',"BY_FRAC" );  CLIM%HAS_Pe_TFR = TWO
                        CASE DEFAULT
                                        !WRITE(BL%IOUT,'(3x 3A)') '"BY_LENGTH" OR "BY_FRAC" FLAG NOT FOUND, ASSUMING IT IS NOT SPECIFIED AND WILL USE "BY_FRAC".'
                                        CALL STOP_ERROR(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG='FMP CLIMATE ERROR. KEYWORD "PRECIPITATION_POTENTIAL_CONSUMPTION" MUST BE FOLLOWED BY THE KEYWORD "BY_LENGTH" OR "BY_FRACTION"')
                        END SELECT
                        !
                        CALL CLIM%PRECIP_EFF_TFR%INIT('Peff', LLOC, LINE, BL%IOUT, BL%IU, Z, Z, NROW, NCOL, FDIM%NFARM, BYWBS, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                        !
      CASE ("DIRECT_RECHARGE", "DIRECTRECHARGE", "DRCH")
                        WRITE(BL%IOUT,'(A)') '   DIRECT_RECHARGE                       KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN ARRAY OF PRECIPITATION VALUES.'
                        !
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        SELECT CASE ( LINE(ISTART:ISTOP) )
                        CASE("LENGTH","FLUX"); CLIM%RECHARGE_AS_FLUX = TRUE
                        CASE("RATE");        CLIM%RECHARGE_AS_FLUX = FALSE
                        CASE DEFAULT;          CALL STOP_ERROR(OUTPUT=CLIM%LOUT, MSG='FMP CLIMATE BLOCK ERROR. IF YOU SPECIFY KEYWORD "DIRECT_RECHARGE",'//NL//'YOU MUST FOLLOW IT WITH THE KEYWORD "LENGTH" OR "RATE".')
                        END SELECT
                        CLIM%HAS_RECHARGE = TRUE
                        ALLOCATE(CLIM%DIRECT_RECHARGE)
                        CALL CLIM%RCH_TFR%INIT('DRCH', LLOC, LINE, BL%IOUT, BL%IU, Z, Z, NROW, NCOL, FDIM%NFARM, BYWBS, SCRATCH=BL%SCRATCH, CDIM=CDIM)
      CASE DEFAULT
                        CALL WARN_MSG%ADD('FOUND UNKNOWN KEYWORD "'//LINE(ISTART:ISTOP)//'" ***IT WILL BE IGNORED***'//BLN)
                        
      END SELECT
      !
      !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
      CALL BL%READ_SCRATCH(EOF, LINE)
      !
    END DO
    !
    CALL WARN_MSG%CHECK(HED='FMP SOIL BLOCK'//NL,INFILE=BL%IU,OUTPUT=BL%IOUT,INLINE=TRUE,CMD_PRINT=TRUE,TAIL=NL)
    !
    IF    (CLIM%HAS_PRECIP .AND. .NOT. CLIM%PRECIP_TFR%TRANSIENT) THEN
        IF(ALL(CLIM%PRECIP_TFR%ARRAY < NEARZERO_30)) THEN
            CLIM%HAS_PRECIP = FALSE
            CALL CLIM%PRECIP_TFR%DESTROY()
        END IF
    ELSEIF(.NOT. CLIM%HAS_PRECIP) THEN
        CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP CLIMATE BLOCK: DID NOT FIND "PRECIPITATION" KEYWORD.'//BLN//'PRECIPITATION IS ASSUMED TO BE ZERO FOR ENTIRE MODEL.'//BLN//'TO DISABLE THIS WARNING YOU MAY WANT TO SPECIFY IN THE CLIMATE BLOCK "PRECIPITATION CONSTANT 0.0".')
    END IF
    !
    IF(CLIM%HAS_PRECIP) ALLOCATE(CLIM%PRECIP( NCOL, NROW ))
    !
  END SUBROUTINE 
  !
  SUBROUTINE SETUP_NEXT_STRESS_PERIOD(CLIM, SOIL, FID_ARRAY, NEW_FID, AREA)
    !
    CLASS(CLIMATE_DATA),                 INTENT(INOUT):: CLIM
    TYPE(SOIL_DATA),                     INTENT(IN   ):: SOIL
    INTEGER, DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: FID_ARRAY
    LOGICAL,                             INTENT(IN   ):: NEW_FID
    DOUBLE PRECISION, DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: AREA
    INTEGER:: R, C
    LOGICAL:: UPDATE, ERROR
    !
    IF(CLIM%TFR_READ) THEN
        !
        UPDATE = FALSE
        !
        CALL CLIM%REF_ET_TFR%NEXT()
        CALL CLIM%PRECIP_TFR%NEXT()
        CALL CLIM%PRECIP_EFF_TFR%NEXT()
        CALL CLIM%RCH_TFR%NEXT()
        !
        CALL CLIM%REF_ET_BARE_TFR%NEXT()
        !
    ELSE
        !
        UPDATE = TRUE
        !
        CLIM%HAS_BARE_REF_ET = CLIM%HAS_REF_ET .OR. CLIM%REF_ET_BARE_TFR%INUSE  !CODE BLOCK IN RP CAUSE THERE IS A CHANCE THAT CLIMITE BLOCK IS NOT DECLAIRED
        !
        IF(  CLIM%HAS_REF_ET .AND. .NOT. CLIM%REF_ET_BARE_TFR%INUSE) THEN
              !
              CALL WARNING_MESSAGE(OUTPUT=CLIM%IOUT,MSG='FMP CLIMATE BLOCK: DID NOT FIND "POTENTIAL_EVAPORATION_BARE" KEYWORD.'//NL//'FALLOW/BARE LAND POTENTIAL EVAPORATION IS ASSUMED TO BE EQUAL TO '//NUM2STR(CLIM%REF_ET_TO_BARE)//NL//' TIMES THE SPECIFIED REFERENCE ET FROM "REFERENCE_ET" KEYWORD.', INLINE=TRUE)
              !
        ELSEIF(.NOT. CLIM%HAS_BARE_REF_ET) THEN
              !
              CALL WARNING_MESSAGE(OUTPUT=CLIM%IOUT,MSG='FMP CLIMATE BLOCK: DID NOT FIND "POTENTIAL_EVAPORATION_BARE" KEYWORD OR "REFERENCE_ET" KEYWORD.'//NL//'PROGRAM WILL TERMINATE IF THERE ARE ANY CROPS THAT BECOME FALLOW OR BARE LAND AS A RESULT OF FRACTIONS OF CROPS WITHIN A CELL.', INLINE=TRUE)
        END IF
        !
        IF (CLIM%HAS_BARE_REF_ET) ALLOCATE(CLIM%BARE_POT_EVAP(CLIM%NCOL,CLIM%NROW))
        !
        IF((CLIM%HAS_Pe_TFR > Z .OR. SOIL%HAS_Pe_TABLE > Z) .AND. CLIM%HAS_PRECIP) THEN
                                                        CLIM%HAS_Pe = TRUE
                                                        ALLOCATE(CLIM%PRECIP_EFFECTIVE(CLIM%NCOL,CLIM%NROW))
        END IF
        !
        CLIM%TFR_READ = TRUE
    END IF
    !
    IF(CLIM%HAS_RECHARGE .AND.                            &
       (    CLIM%RCH_TFR%TRANSIENT                        &
       .OR. UPDATE                                        &
       .OR. (CLIM%RCH_TFR%SFAC%HAS_EX1.AND.NEW_FID) &
       )) THEN
        !
        IF(CLIM%RCH_TFR%HAS_IXJ) THEN
            CALL CLIM%RCH_TFR%IXJ%TO_CVS(TWO, ONE, ONE, CLIM%DIRECT_RECHARGE)  !(IDIM1, IDIM2, VPOS, CVS)
        ELSE
            CALL CLIM%DIRECT_RECHARGE%BUILD_NONZERO( CLIM%RCH_TFR%ARRAY )
        END IF
        !
        CALL DIRECT_RECHARGE_SFAC_AND_FLUX(CLIM%DIRECT_RECHARGE, CLIM%RCH_TFR,CLIM%RECHARGE_AS_FLUX, AREA, FID_ARRAY)
    END IF
    !
    IF(CLIM%HAS_PRECIP .AND. (CLIM%PRECIP_TFR%TRANSIENT .OR. UPDATE .OR. (CLIM%PRECIP_TFR%SFAC%HAS_EX1.AND.NEW_FID))) THEN
        IF(CLIM%PRECIP_TFR%HAS_IXJ) THEN
                                             CALL CLIM%PRECIP_TFR%IXJ%TO_ARRAY(TWO, ONE, ONE, CLIM%NCOL, CLIM%NROW, CLIM%PRECIP, ERROR)  !(IROW, ICOL, VPOS, DIM1, DIM2, ARR, ERROR)
                                             !
                                             IF(ERROR) CALL STOP_ERROR(OUTPUT=CLIM%LOUT, MSG='FMP CLIMATE BLOCK ERROR. PRECIPITATION ARRAY SPECIFED WITH IXJ INPUT, BUT IT CONTAINED A ROW/COLUMN THAT WAS IN INPUT IS EITHER LESS THEN ZERO OR GREATER THEN NROW/NCOL.')
        ELSE
                                             DO CONCURRENT(R=ONE:CLIM%NROW, C=ONE:CLIM%NCOL)
                                                       CLIM%PRECIP(C,R) = CLIM%PRECIP_TFR%ARRAY(C,R)
                                             END DO
        END IF
        !
        IF(CLIM%PRECIP_TFR%SFAC%HAS_ALL) THEN
                                             DO CONCURRENT(R=ONE:CLIM%NROW, C=ONE:CLIM%NCOL)
                                                       CLIM%PRECIP(C,R) = CLIM%PRECIP(C,R) * CLIM%PRECIP_TFR%SFAC%ALL
                                             END DO
        END IF
        !
        IF(CLIM%PRECIP_TFR%SFAC%HAS_EX1) THEN
              DO CONCURRENT(R=ONE:CLIM%NROW, C=ONE:CLIM%NCOL, FID_ARRAY(C,R)>Z)
                    !
                    CLIM%PRECIP(C,R) = CLIM%PRECIP(C,R) * CLIM%PRECIP_TFR%SFAC%EX1(FID_ARRAY(C,R))
              END DO
        END IF
        !
        DO CONCURRENT(R=ONE:CLIM%NROW, C=ONE:CLIM%NCOL, FID_ARRAY(C,R)<ONE .OR. FID_ARRAY(C,R)>CLIM%NFARM .OR. (CLIM%PRECIP(C,R)<NEARZERO_30 .AND. CLIM%PRECIP(C,R).NE.DZ))
              CLIM%PRECIP(C,R) = DZ
        END DO
        !WHERE(FID_ARRAY<ONE) CLIM%PRECIP = DZ
        !
        IF(CLIM%HAS_Pe) THEN
                IF(CLIM%HAS_Pe_TFR > Z) THEN
                  ASSOCIATE(PRECIP => CLIM%PRECIP, Peff => CLIM%PRECIP_EFFECTIVE )
                    IF(CLIM%PRECIP_EFF_TFR%HAS_IXJ) THEN
                                                         CALL CLIM%PRECIP_EFF_TFR%IXJ%TO_ARRAY(TWO, ONE, ONE, CLIM%NCOL, CLIM%NROW, Peff, ERROR, D100)  !(IROW, ICOL, VPOS, DIM1, DIM2, ARR, ERROR, NULL_VALUE)
                                                         !
                                                         IF(ERROR) CALL STOP_ERROR(OUTPUT=CLIM%LOUT, MSG='FMP CLIMATE BLOCK ERROR. PRECIPITATION ARRAY SPECIFED WITH IXJ INPUT, BUT IT CONTAINED A ROW/COLUMN THAT WAS IN INPUT IS EITHER LESS THEN ZERO OR GREATER THEN NROW/NCOL.')
                    ELSE
                                                         DO CONCURRENT(R=ONE:CLIM%NROW, C=ONE:CLIM%NCOL)
                                                                   Peff(C,R) = CLIM%PRECIP_EFF_TFR%ARRAY(C,R)
                                                         END DO
                    END IF
                    !
                    IF(CLIM%PRECIP_EFF_TFR%SFAC%HAS_ALL) THEN
                                                         DO CONCURRENT(R=ONE:CLIM%NROW, C=ONE:CLIM%NCOL)
                                                                   Peff(C,R) = Peff(C,R) * CLIM%PRECIP_EFF_TFR%SFAC%ALL
                                                         END DO
                    END IF
                    !
                    IF(CLIM%PRECIP_EFF_TFR%SFAC%HAS_EX1) THEN
                          DO CONCURRENT(R=ONE:CLIM%NROW, C=ONE:CLIM%NCOL, FID_ARRAY(C,R)>Z)
                                !
                                Peff(C,R) = Peff(C,R) * CLIM%PRECIP_EFF_TFR%SFAC%EX1(FID_ARRAY(C,R))
                          END DO
                    END IF
                    !
                    IF(CLIM%HAS_Pe_TFR == TWO) THEN      !INPUT IS AS A FRACTION
                                                         DO CONCURRENT(R=ONE:CLIM%NROW, C=ONE:CLIM%NCOL)
                                                                   Peff(C,R) = Peff(C,R) * PRECIP(C,R)
                                                         END DO
                        
                    END IF
                    !
                    DO CONCURRENT (R=ONE:CLIM%NROW, C=ONE:CLIM%NCOL)
                        IF    (Peff(C,R) < DZ .OR. PRECIP(C,R) < NEARZERO_30) THEN
                                                                               Peff(C,R) = DZ
                        ELSEIF(Peff(C,R) > PRECIP(C,R)) THEN
                                                                               Peff(C,R) = PRECIP(C,R)
                        END IF
                    END DO
                  END ASSOCIATE
                ELSE !-----------------------------------------------------------------------
                  ASSOCIATE(Pe_TABLE => SOIL%Pe_TABLE, SID=>SOIL%SID, PRECIP => CLIM%PRECIP, Peff => CLIM%PRECIP_EFFECTIVE )
                      !
                    DO CONCURRENT (R=ONE:CLIM%NROW, C=ONE:CLIM%NCOL)
                        !
                        IF( PRECIP(C,R) < NEARZERO_30) THEN
                            !
                            Peff(C,R) = DZ
                            !
                        ELSEIF(SID(C,R) < ONE) THEN
                            !
                            Peff(C,R) = PRECIP(C,R)
                        ELSE
                            CALL Pe_TABLE( SID(C,R) )%LOOKUP( PRECIP(C,R), Peff(C,R) )  !Peff set to table result
                            !
                            IF(SOIL%HAS_Pe_TABLE == TWO) Peff(C,R) = Peff(C,R) * PRECIP(C,R) !INPUT IS AS A FRACTION
                            !
                            IF    (Peff(C,R) .NE. Peff(C,R)) THEN
                                                                 Peff(C,R) = PRECIP(C,R)
                            ELSEIF(Peff(C,R) < NEARZERO_30 ) THEN
                                                                 Peff(C,R) = DZ
                            ELSEIF(Peff(C,R) > PRECIP(C,R) ) THEN
                                                                 Peff(C,R) = PRECIP(C,R)
                            END IF
                        END IF
                    END DO
                  END ASSOCIATE
                END IF
        END IF
    END IF
    !
    IF(CLIM%HAS_REF_ET .AND. (CLIM%REF_ET_TFR%TRANSIENT .OR. UPDATE .OR. (CLIM%REF_ET_TFR%SFAC%HAS_EX1.AND.NEW_FID) )) THEN
        IF(CLIM%REF_ET_TFR%HAS_IXJ) THEN
                                             CALL CLIM%REF_ET_TFR%IXJ%TO_ARRAY(TWO, ONE, ONE, CLIM%NCOL, CLIM%NROW, CLIM%REF_ET, ERROR)  !(IROW, ICOL, VPOS, DIM1, DIM2, ARR, ERROR)
                                             !
                                             IF(ERROR) CALL STOP_ERROR(OUTPUT=CLIM%LOUT, MSG='FMP CLIMATE BLOCK ERROR. REFERENCE_ET ARRAY SPECIFED WITH IXJ INPUT, BUT IT CONTAINED A ROW/COLUMN THAT WAS IN INPUT IS EITHER LESS THEN ZERO OR GREATER THEN NROW/NCOL.')
        ELSE
                                             DO CONCURRENT(R=ONE:CLIM%NROW, C=ONE:CLIM%NCOL)
                                                       CLIM%REF_ET(C,R) = CLIM%REF_ET_TFR%ARRAY(C,R)
                                             END DO
        END IF
        !
        IF(CLIM%REF_ET_TFR%SFAC%HAS_ALL) THEN
                                             DO CONCURRENT(R=ONE:CLIM%NROW, C=ONE:CLIM%NCOL)
                                                       CLIM%REF_ET(C,R) = CLIM%REF_ET(C,R) * CLIM%REF_ET_TFR%SFAC%ALL
                                             END DO
        END IF
        !
        IF(CLIM%REF_ET_TFR%SFAC%HAS_EX1) THEN
              !
              DO CONCURRENT(R=ONE:CLIM%NROW, C=ONE:CLIM%NCOL, FID_ARRAY(C,R)>Z)
                    !
                    CLIM%REF_ET(C,R) = CLIM%REF_ET(C,R) * CLIM%REF_ET_TFR%SFAC%EX1(FID_ARRAY(C,R))
              END DO
        END IF
    END IF
    !
    ! SET UP POTENTIAL EVAP OF PRECIP
    IF(CLIM%HAS_BARE_REF_ET) THEN  !ONLY CAlLCULATE POTENTIAL PRECIP EVAP IF THERE IS A REFERNCE ET OR BARE EVAP AVAILIBLE
        IF(UPDATE                         .OR.                  &
           CLIM%REF_ET_TFR%TRANSIENT      .OR.                  &
           CLIM%REF_ET_BARE_TFR%TRANSIENT .OR.                  &
          (CLIM%REF_ET_BARE_TFR%SFAC%HAS_EX1.AND.NEW_FID) &
        ) THEN
              !              
              IF(CLIM%REF_ET_BARE_TFR%INUSE) THEN
                                                     IF(CLIM%REF_ET_BARE_TFR%HAS_IXJ) THEN
                                                                                          CALL CLIM%REF_ET_BARE_TFR%IXJ%TO_ARRAY(TWO, ONE, ONE, CLIM%NCOL, CLIM%NROW, CLIM%BARE_POT_EVAP, ERROR)  !(IROW, ICOL, VPOS, DIM1, DIM2, ARR, ERROR)
                                                                                          !
                                                                                          IF(ERROR) CALL STOP_ERROR(OUTPUT=CLIM%LOUT, MSG='FMP CLIMATE BLOCK ERROR. POTENTIAL_EVAPORATION_BARE ARRAY SPECIFED WITH IXJ INPUT, BUT IT CONTAINED A ROW/COLUMN THAT WAS IN INPUT IS EITHER LESS THEN ZERO OR GREATER THEN NROW/NCOL.')
                                                     ELSE
                                                                                          DO CONCURRENT(R=ONE:CLIM%NROW, C=ONE:CLIM%NCOL)
                                                                                                    CLIM%BARE_POT_EVAP(C,R) = CLIM%REF_ET_BARE_TFR%ARRAY(C,R)
                                                                                          END DO
                                                     END IF
                                                     !
                                                     IF(CLIM%REF_ET_BARE_TFR%SFAC%HAS_ALL) THEN
                                                                                          DO CONCURRENT(R=ONE:CLIM%NROW, C=ONE:CLIM%NCOL)
                                                                                                    CLIM%BARE_POT_EVAP(C,R) = CLIM%BARE_POT_EVAP(C,R) * CLIM%REF_ET_BARE_TFR%SFAC%ALL
                                                                                          END DO
                                                     END IF
                                                     !
                                                     IF(CLIM%REF_ET_BARE_TFR%SFAC%HAS_EX1) THEN
                                                           !
                                                           DO CONCURRENT(R=ONE:CLIM%NROW, C=ONE:CLIM%NCOL, FID_ARRAY(C,R)>Z)
                                                                 !
                                                                 CLIM%BARE_POT_EVAP(C,R) = CLIM%BARE_POT_EVAP(C,R) * CLIM%REF_ET_BARE_TFR%SFAC%EX1(FID_ARRAY(C,R))
                                                           END DO
                                                     END IF
              ELSE!IF(CLIM%REF_ET_TFR%INUSE) THEN
                                                         DO CONCURRENT(R=ONE:CLIM%NROW, C=ONE:CLIM%NCOL)           !USE REF ET VALUES WHEN IF FALLOW POTENTIAL EVAP NOT SPECIFIED AND PRECIP EXCEEDS REF ET
                                                                   CLIM%BARE_POT_EVAP(C,R) = CLIM%REF_ET(C,R) * CLIM%REF_ET_TO_BARE
                                                         END DO
              END IF
              !
              !CLIM%BARE_POT_EVAP = CLIM%PRECIP
              !
              !IF(CLIM%REF_ET_BARE_TFR%INUSE .AND. CLIM%REF_ET_BARE_TFR%SFAC%HAS_ALL) THEN
              !                                       !
              !                                       DO CONCURRENT (I=ONE:SIZE(CLIM%BARE_POT_EVAP,ONE), J=ONE:SIZE(CLIM%BARE_POT_EVAP,TWO), CLIM%BARE_POT_EVAP(I,J)>CLIM%REF_ET_BARE_TFR%ARRAY(I,J)*CLIM%REF_ET_BARE_TFR%SFAC%ALL)
              !                                             !
              !                                             CLIM%BARE_POT_EVAP(I,J) = CLIM%REF_ET_BARE_TFR%ARRAY(I,J)*CLIM%REF_ET_BARE_TFR%SFAC%ALL
              !                                       END DO
              !ELSEIF(CLIM%REF_ET_BARE_TFR%INUSE) THEN
              !                                       WHERE (CLIM%BARE_POT_EVAP>CLIM%REF_ET_BARE_TFR%ARRAY) 
              !                                           CLIM%BARE_POT_EVAP = CLIM%REF_ET_BARE_TFR%ARRAY
              !                                       END WHERE
              !ELSE!IF(CLIM%REF_ET_TFR%INUSE) THEN
              !                                       WHERE (CLIM%BARE_POT_EVAP>CLIM%REF_ET) 
              !                                           CLIM%BARE_POT_EVAP = CLIM%REF_ET  !USE REF ET VALUES WHEN IF FALLOW POTENTIAL EVAP NOT SPECIFIED AND PRECIP EXCEEDS REF ET
              !                                       END WHERE
              !END IF
        END IF
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE ADD_DIRECT_RECHARGE(CLIM, DPERC)
  CLASS(CLIMATE_DATA),                          INTENT(INOUT):: CLIM
  DOUBLE PRECISION, DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: DPERC
  INTEGER:: DIM1, DIM2, K
    !
    IF (CLIM%HAS_RECHARGE) THEN
                               DO CONCURRENT (K=ONE:CLIM%DIRECT_RECHARGE%N)
                                    DIM1 = CLIM%DIRECT_RECHARGE%DIM(ONE,K)
                                    DIM2 = CLIM%DIRECT_RECHARGE%DIM(TWO,K)
                                    !
                                    DPERC(DIM1,DIM2) = DPERC(DIM1,DIM2) + CLIM%DIRECT_RECHARGE%VAL(K)
                                    !
                               END DO
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE DIRECT_RECHARGE_SFAC_AND_FLUX(CVS, LAI, RECHARGE_AS_FLUX, AREA, FID_ARRAY)
    CLASS (COMPRESSED_VALUE_STORAGE),             INTENT(INOUT):: CVS
    CLASS (LIST_ARRAY_INPUT),                     INTENT(IN   ):: LAI
    LOGICAL,                                      INTENT(IN   ):: RECHARGE_AS_FLUX
    DOUBLE PRECISION, DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: AREA
    INTEGER, DIMENSION(:,:),          CONTIGUOUS, INTENT(IN   ):: FID_ARRAY
    INTEGER:: I,J,K
    !
    IF (CVS%N > Z) THEN
                       !
                       IF(RECHARGE_AS_FLUX) THEN
                                                DO CONCURRENT (K=ONE:CVS%N)
                                                    I = CVS%DIM(ONE,K)
                                                    J = CVS%DIM(TWO,K) 
                                                    CVS%VAL(K) = CVS%VAL(K) * AREA(I,J)
                                                END DO
                       END IF
                       !
                       IF(LAI%SFAC%HAS_ALL) CVS%VAL = CVS%VAL * LAI%SFAC%ALL
                       IF(LAI%SFAC%HAS_EX1) THEN
                                                DO CONCURRENT (K=ONE:CVS%N)
                                                    ASSOCIATE( F => FID_ARRAY( CVS%DIM(ONE,K), CVS%DIM(TWO,K) ) )
                                                            !
                                                            IF(F > Z) CVS%VAL(K) = CVS%VAL(K) * LAI%SFAC%EX1(F)
                                                    END ASSOCIATE
                                                END DO
                       END IF
    END IF
    !
  END SUBROUTINE
  !
END MODULE
!
!#########################################################################################################
!
!!!!!MODULE STORAGE_DATA_FMP_INTERFACE
!!!!!  USE UTIL_INTERFACE,                       ONLY: FILE_IO_ERROR, STOP_ERROR, NUM2STR, ALLOC
!!!!!  USE CONSTANTS
!!!!!  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
!!!!!  USE LIST_ARRAY_INPUT_INTERFACE,        ONLY: LIST_ARRAY_INPUT, LIST_ARRAY_INPUT_INT
!!!!!  USE ULOAD_AND_SFAC_INTERFACE
!!!!!  USE FMP_DIMENSION_INTERFACE,           ONLY: FMP_DIMENSION
!!!!!  IMPLICIT NONE
!!!!!  PRIVATE
!!!!!  PUBLIC:: STORAGE_DATA, INITIALIZE_STORAGE_DATA
!!!!!  !
!!!!!  TYPE STORAGE_DATA
!!!!!      INTEGER:: IOUT=Z, LOUT=Z
!!!!!      INTEGER:: NROW, NCOL
!!!!!      LOGICAL:: HAS_STOR = FALSE
!!!!!      LOGICAL:: HAS_EVAP = FALSE
!!!!!      LOGICAL:: HAS_INFL = FALSE
!!!!!      LOGICAL:: TFR_READ   = FALSE
!!!!!      DOUBLE PRECISION,    DIMENSION(:),ALLOCATABLE:: X
!!!!!      !
!!!!!      
!!!!!      !
!!!!!      TYPE(LIST_ARRAY_INPUT):: PRECIP_TFR
!!!!!      !
!!!!!      CONTAINS
!!!!!      !
!!!!!      PROCEDURE, PASS(STOR):: NEXT     => SETUP_NEXT_STRESS_PERIOD
!!!!!      FINAL:: DEALLOCATE_CLIMATE_FINAL
!!!!!  END TYPE
!!!!!  !
!!!!!  CONTAINS
!!!!!  !
!!!!!  SUBROUTINE DEALLOCATE_CLIMATE_FINAL(STOR)
!!!!!  TYPE(STORAGE_DATA)::STOR
!!!!!  CALL DEALLOCATE_CLIMATE(STOR)
!!!!!  END SUBROUTINE
!!!!!  !
!!!!!  PURE ELEMENTAL SUBROUTINE DEALLOCATE_CLIMATE(STOR)
!!!!!  CLASS(STORAGE_DATA), INTENT(INOUT)::STOR
!!!!!  !
!!!!!  IF(ALLOCATED(STOR%REF_ET))      DEALLOCATE(STOR%REF_ET)
!!!!!  IF(ALLOCATED(STOR%PRECIP))      DEALLOCATE(STOR%PRECIP)
!!!!!  IF(ALLOCATED(STOR%BARE_POT_EVAP)) DEALLOCATE(STOR%BARE_POT_EVAP)
!!!!!  !
!!!!!  END SUBROUTINE
!!!!!  !  
!!!!!  SUBROUTINE INITIALIZE_STORAGE_DATA( BL, STOR, LINE, FDIM )
!!!!!    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL   !DATA BLOCK
!!!!!    CLASS(STORAGE_DATA),         INTENT(INOUT):: STOR
!!!!!    CHARACTER(*),                INTENT(INOUT):: LINE
!!!!!    TYPE(FMP_DIMENSION),         INTENT(IN   ):: FDIM
!!!!!    CHARACTER(5):: ERROR
!!!!!    INTEGER:: I, LLOC, ISTART, ISTOP, IERR, NROW, NCOL
!!!!!    REAL:: R
!!!!!    !
!!!!!    WRITE(BL%IOUT,'(/A/)') 'CLIMATE BLOCK FOUND AND NOW LOADING PROPERTIES'
!!!!!    !
!!!!!    STOR%IOUT = BL%IOUT
!!!!!    STOR%LOUT = BL%IOUT
!!!!!    NROW = FDIM%NROW
!!!!!    NCOL = FDIM%NCOL
!!!!!    STOR%NROW = NROW 
!!!!!    STOR%NCOL = NCOL
!!!!!    !
!!!!!    ERROR='ERROR'
!!!!!    ALLOCATE(STOR%PRECIP( NCOL, NROW ), SOURCE=DZ)
!!!!!    !
!!!!!    CALL BL%MAKE_SCRATCH_FILE()
!!!!!    !
!!!!!    READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
!!!!!    !
!!!!!    DO WHILE (IERR == Z)
!!!!!      !
!!!!!      LLOC=ONE
!!!!!      CALL URWORD(LINE,LLOC,ISTART,ISTOP,ONE,I,R,BL%IOUT,BL%IU)
!!!!!      !
!!!!!      SELECT CASE ( LINE(ISTART:ISTOP) )
!!!!!
!!!!!      CASE ("LOCATION")
!!!!!                        WRITE(BL%IOUT,'(A)') '   LOCATION               KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN 2D ARRAY OF CROP IDs.'
!!!!!                        IF(CDAT%FRACTION) CALL STOP_ERROR(LINE,BL%IU,BL%IOUT,'FMP CROP BLOCK ERROR. YOU CAN NOT HAVE BOTH THE FRACTION KEYWORD AND LOCATION KEYWORD DURING THE SAME SIMULATION. PLEASE SELECT IF YOU ARE USING CROP ID LOCATIONS OR FRACTIONS AS YOUR INPUT.')
!!!!!                        CALL CDAT%CID%INIT('CID',       LLOC, LINE, BL%IOUT, BL%SCRATCH, Z, Z, NROW, NCOL, BL%SCRATCH)
!!!!!                        !CALL CDAT%CID%NEXT()
!!!!!                        ALLOCATE(CDAT%CRPID(NCOL,NROW), SOURCE=Z)
!!!!!      CASE ("REFERENCE_ET")
!!!!!                        WRITE(BL%IOUT,'(A)') '   REFERENCE_ET                 KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN ARRAY OF REFERENCE ET VALUES.'
!!!!!                        STOR%HAS_REF_ET = TRUE
!!!!!                        CALL STOR%REF_ET_TFR%INIT('ETR',  LLOC, LINE, BL%IOUT, BL%IU, Z, Z, NROW, NCOL, SCRATCH=BL%SCRATCH)
!!!!!                        !CALL STOR%REF_ET_TFR%NEXT()  --AUTOCALLED!
!!!!!                        !
!!!!!                        ALLOCATE(STOR%REF_ET(NCOL,NROW))
!!!!!      CASE ("POTENTIAL_EVAPORATION_FALLOW","POTENTIAL_EVAPORATION_BARE")
!!!!!                        WRITE(BL%IOUT,'(A)') '   POTENTIAL_EVAPORATION_BARE KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN ARRAY OF REFERENCE EVAPORATION VALUES FOR BARE SOIL.'
!!!!!                        STOR%HAS_REF_ET = TRUE
!!!!!                        CALL STOR%REF_ET_BARE_TFR%INIT('ETR_BARE',  LLOC, LINE, BL%IOUT, BL%IU, Z, Z, NROW, NCOL, SCRATCH=BL%SCRATCH)
!!!!!                        !CALL STOR%REF_ET_BARE_TFR%NEXT()
!!!!!                        !
!!!!!      CASE ("PRECIPITATION")
!!!!!                        WRITE(BL%IOUT,'(A)') '   PRECIPITATION                KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN ARRAY OF PRECIPITATION VALUES.'
!!!!!                        STOR%HAS_PRECIP = TRUE
!!!!!                        CALL STOR%PRECIP_TFR%INIT('PRCP', LLOC, LINE, BL%IOUT, BL%IU, Z, Z, NROW, NCOL, SCRATCH=BL%SCRATCH)
!!!!!                        !CALL STOR%PRECIP_TFR%NEXT()
!!!!!      CASE DEFAULT
!!!!!                        WRITE(BL%IOUT,'(/3A /,A /, A//)') 'WARNING: FMP CLIMATE BLOCK FOUND UNKNOWN KEYWORD "',LINE(ISTART:ISTOP),'"  ON LINE:', TRIM(LINE), '***KEYWORD WILL BE IGNORED***'
!!!!!                        
!!!!!      END SELECT
!!!!!      !
!!!!!      READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
!!!!!      !
!!!!!    END DO
!!!!!    !
!!!!!    IF(.NOT. STOR%HAS_PRECIP) WRITE(STOR%LOUT,'(A)') 'FMP CLIMATE BLOCK WARNING: DID NOT FIND "PRECIPITATION" KEYWORD. PRECIPITATION IS ASSUMED TO BE ZERO FOR ENTIRE MODEL.' !CALL STOP_ERROR(OUTPUT=STOR%LOUT, MSG='FMP CLIMATE BLOCK ERROR. YOU MUST SPECIFY "PRECIPITATION" KEYWORD EVEN WHEN THERE IS NO PRECIPITATION (IF THAT IS THE CASE THEN SET IT TO CONSTANT 0.0).'
!!!!!    !
!!!!!  END SUBROUTINE 
!!!!!  !
!!!!!  SUBROUTINE SETUP_NEXT_STRESS_PERIOD(STOR, FID_ARRAY, TRANSIENT_FID)
!!!!!    !
!!!!!    CLASS(STORAGE_DATA),                 INTENT(INOUT):: STOR
!!!!!    INTEGER, DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: FID_ARRAY
!!!!!    LOGICAL,                             INTENT(IN   ):: TRANSIENT_FID
!!!!!    LOGICAL:: UPDATE
!!!!!    !
!!!!!    IF(STOR%TFR_READ) THEN
!!!!!        !
!!!!!        UPDATE = FALSE
!!!!!        !
!!!!!        CALL STOR%REF_ET_TFR%NEXT()
!!!!!        CALL STOR%PRECIP_TFR%NEXT()
!!!!!        !
!!!!!        CALL STOR%REF_ET_BARE_TFR%NEXT()
!!!!!        !
!!!!!    ELSE
!!!!!        !
!!!!!        UPDATE = TRUE
!!!!!        !
!!!!!        STOR%HAS_BARE_REF_ET = STOR%HAS_REF_ET .OR. STOR%REF_ET_BARE_TFR%INUSE
!!!!!        !
!!!!!        IF(  STOR%HAS_REF_ET .AND. .NOT. STOR%REF_ET_BARE_TFR%INUSE) THEN
!!!!!              !
!!!!!              WRITE(STOR%LOUT,'(/A/)') 'FMP CLIMATE BLOCK WARNING: DID NOT FIND "POTENTIAL_EVAPORATION_FALLOW" KEYWORD. FALLOW/BARE LAND POTENTIAL EVAPORATION IS ASSUMED TO BE EQUAL TO SPECIFIED REFERENCE ET FROM "REFERENCE_ET" KEYWORD.'
!!!!!              !
!!!!!        ELSEIF(.NOT. STOR%HAS_BARE_REF_ET) THEN
!!!!!              !
!!!!!              WRITE(STOR%LOUT,'(/A/)') 'FMP CLIMATE BLOCK WARNING: DID NOT FIND "POTENTIAL_EVAPORATION_FALLOW" KEYWORD OR REFERENCE_ET" KEYWORD. PROGRAM WILL TERMINATE IF THERE ARE ANY CROPS THAT BECOME FALLOW OR BARE LAND AS A RESULT OF FRACTIONS OF CROPS WITHIN A CELL.'
!!!!!        END IF
!!!!!        !
!!!!!        IF (STOR%HAS_BARE_REF_ET) ALLOCATE(STOR%BARE_POT_EVAP(STOR%NCOL,STOR%NROW))
!!!!!        !
!!!!!        STOR%TFR_READ = TRUE
!!!!!    END IF
!!!!!    !
!!!!!    IF(STOR%HAS_PRECIP .AND. (STOR%PRECIP_TFR%TRANSIENT .OR. UPDATE .OR. TRANSIENT_FID)) THEN
!!!!!                                        STOR%PRECIP = STOR%PRECIP_TFR%ARRAY
!!!!!       IF(STOR%PRECIP_TFR%SFAC%HAS_ALL) STOR%PRECIP = STOR%PRECIP * STOR%PRECIP_TFR%SFAC%ALL
!!!!!       !
!!!!!       WHERE(FID_ARRAY<ONE) STOR%PRECIP = DZ
!!!!!    END IF
!!!!!    !
!!!!!    IF(STOR%HAS_REF_ET .AND. (STOR%REF_ET_TFR%TRANSIENT .OR. UPDATE)) THEN
!!!!!                                        STOR%REF_ET = STOR%REF_ET_TFR%ARRAY
!!!!!       IF(STOR%REF_ET_TFR%SFAC%HAS_ALL) STOR%REF_ET = STOR%REF_ET * STOR%REF_ET_TFR%SFAC%ALL  !HAS_ALL IS NEVER TRUE WHEN REF_ET IS NOT ALLOCATED
!!!!!    END IF
!!!!!    !
!!!!!    ! SET UP POTENTIAL EVAP OF PRECIP
!!!!!    IF(STOR%HAS_BARE_REF_ET) THEN  !ONLY CAlLCULATE POTENTIAL PRECIP EVAP IF THERE IS A REFERNCE ET OR BARE EVAP AVAILIBLE
!!!!!        IF(UPDATE                    .OR. &
!!!!!           STOR%REF_ET_TFR%TRANSIENT .OR. &
!!!!!           STOR%REF_ET_BARE_TFR%TRANSIENT   ) THEN
!!!!!              !              
!!!!!              IF(STOR%REF_ET_BARE_TFR%INUSE) THEN
!!!!!                                                     IF(STOR%REF_ET_BARE_TFR%SFAC%HAS_ALL) THEN
!!!!!                                                         STOR%BARE_POT_EVAP = STOR%REF_ET_BARE_TFR%ARRAY * STOR%REF_ET_BARE_TFR%SFAC%ALL
!!!!!                                                     ELSE
!!!!!                                                         STOR%BARE_POT_EVAP = STOR%REF_ET_BARE_TFR%ARRAY
!!!!!                                                     END IF
!!!!!              ELSE!IF(STOR%REF_ET_TFR%INUSE) THEN
!!!!!                                                         STOR%BARE_POT_EVAP = STOR%REF_ET  !USE REF ET VALUES WHEN IF FALLOW POTENTIAL EVAP NOT SPECIFIED AND PRECIP EXCEEDS REF ET
!!!!!              END IF
!!!!!              !
!!!!!        END IF
!!!!!    END IF
!!!!!    !
!!!!!  END SUBROUTINE
!!!!!END MODULE
!
!#########################################################################################################
!
MODULE ALLOTMENT_DATA_FMP_INTERFACE
  !
  USE FMP_DIMENSION_INTERFACE,           ONLY: FMP_DIMENSION
  !
  USE UTIL_INTERFACE,                    ONLY: FILE_IO_ERROR, STOP_ERROR, WARNING_MESSAGE, &
                                               PARSE_WORD, PARSE_WORD_UP
  USE NUM2STR_INTERFACE,                 ONLY: NUM2STR
  USE CONSTANTS
  USE ALLOC_INTERFACE,                   ONLY: ALLOC
  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
  USE LIST_ARRAY_INPUT_INTERFACE,        ONLY: LIST_ARRAY_INPUT, LIST_ARRAY_INPUT_INT
  USE ULOAD_AND_SFAC_INTERFACE
  USE WARNING_TYPE_INSTRUCTION,          ONLY: WARNING_TYPE
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: ALLOTMENT_DATA, INITIALIZE_ALLOTMENT_DATA
  !
  TYPE ALLOTMENT_DATA
      INTEGER:: IOUT=Z, LOUT=Z, NFARM=Z
      INTEGER:: SW_ALLOTMENT_TYPE= Z
      INTEGER:: GW_ALLOTMENT_TYPE= Z
      LOGICAL:: HAS_GW_ALLOTMENT = FALSE
      LOGICAL:: HAS_SW_ALLOTMENT = FALSE
      LOGICAL:: TFR_READ   = FALSE
      DOUBLE PRECISION,    DIMENSION(:),ALLOCATABLE:: GW_ALLOTMENT !VOLUME FOR SP
      DOUBLE PRECISION,    DIMENSION(:),ALLOCATABLE:: GW_RATE_LIM  !VOLUME RATE LIM BASED ON GW_ALLOTMENT FOR TS
      DOUBLE PRECISION,    DIMENSION(:),ALLOCATABLE:: SW_ALLOTMENT !VOLUME FOR SP
      DOUBLE PRECISION,    DIMENSION(:),ALLOCATABLE:: SW_RATE_LIM  !VOLUME RATE LIM BASED ON SW_ALLOTMENT FOR TS
      !
      TYPE(LIST_ARRAY_INPUT):: GW_ALLOTMENT_TFR
      TYPE(LIST_ARRAY_INPUT):: SW_ALLOTMENT_TFR
      !
      CONTAINS
      !
      PROCEDURE, PASS(ALOT):: NEXT     => SETUP_NEXT_STRESS_PERIOD
      FINAL:: DEALLOCATE_ALLOTMENT_FINAL
  END TYPE
  !
  CONTAINS
  !
  SUBROUTINE DEALLOCATE_ALLOTMENT_FINAL(ALOT)
  TYPE(ALLOTMENT_DATA)::ALOT
  CALL DEALLOCATE_ALLOTMENT(ALOT)
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_ALLOTMENT(ALOT)
  CLASS(ALLOTMENT_DATA), INTENT(INOUT)::ALOT
  !
  IF(ALLOCATED(ALOT%GW_ALLOTMENT))      DEALLOCATE(ALOT%GW_ALLOTMENT)
  IF(ALLOCATED(ALOT%GW_RATE_LIM ))      DEALLOCATE(ALOT%GW_RATE_LIM )
  IF(ALLOCATED(ALOT%SW_ALLOTMENT))      DEALLOCATE(ALOT%SW_ALLOTMENT)
  IF(ALLOCATED(ALOT%SW_RATE_LIM ))      DEALLOCATE(ALOT%SW_RATE_LIM )
  
  !
  END SUBROUTINE
  !  
  SUBROUTINE INITIALIZE_ALLOTMENT_DATA( BL, ALOT, LINE, FDIM )
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL   !DATA BLOCK
    CLASS(ALLOTMENT_DATA),       INTENT(INOUT):: ALOT
    CHARACTER(*),                INTENT(INOUT):: LINE
    TYPE(FMP_DIMENSION),         INTENT(IN   ):: FDIM
    CHARACTER(5):: ERROR
    CHARACTER(6):: BYFARM
    LOGICAL:: EOF
    INTEGER:: LLOC, ISTART, ISTOP
    TYPE(WARNING_TYPE):: WARN_MSG
    !
    CALL WARN_MSG%INIT()
    !
    WRITE(BL%IOUT,'(/A/)') 'ALLOTMENT BLOCK FOUND AND NOW LOADING PROPERTIES'
    !
    ALOT%IOUT = BL%IOUT
    ALOT%LOUT = BL%IOUT
    ALOT%NFARM = FDIM%NFARM
    BYFARM = 'BYWBS'
    !
    ERROR='ERROR'
    !
    CALL BL%MAKE_SCRATCH_FILE()
    !
    !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
    CALL BL%READ_SCRATCH(EOF, LINE)
    !
    DO WHILE (.NOT. EOF)
      !
      LLOC=ONE
      CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
      !
      SELECT CASE ( LINE(ISTART:ISTOP) )
      CASE ("SURFACE_WATER", "SURFACE")
                        IF(LINE(ISTART:ISTOP) == "SURFACE") CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP) !MOVE PAST "WATER"
                        !
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        SELECT CASE ( LINE(ISTART:ISTOP) )
                        CASE ("RATE"  ); ALOT%SW_ALLOTMENT_TYPE = Z
                        CASE ("VOLUME"); ALOT%SW_ALLOTMENT_TYPE = ONE
                        CASE ("HEIGHT"); ALOT%SW_ALLOTMENT_TYPE = TWO
                        CASE DEFAULT;    CALL STOP_ERROR(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP ALLOTMENT BLOCK ERROR. FOUND KETYWORD "SURFACE_WATER" (OR "SURFACE WATER")'//NL//'WHICH MUST BE FOLLOWED BY EITHER "HEIGHT", "VOLUME", OR "RATE".'//NL//'CHECK BLOCK FOR COMPLETENESS (viz. "SURFACE_WATER HEIGHT" or "SURFACE_WATER VOLUME" or "SURFACE_WATER RATE")')
                        END SELECT
                        !
                        WRITE(BL%IOUT,'(3A)') '   SURFACE_WATER ',LINE(ISTART:ISTOP),' KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND LIST INPUT OF SURFACE WATER ALLOTMENTS BY WBS.'
                        !
                        ALOT%HAS_SW_ALLOTMENT = TRUE
                        !
                        CALL ALOT%SW_ALLOTMENT_TFR%INIT('SW_ALOT',  LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM, ONE, Z, Z, FDIM%NFARM, BYFARM, SCRATCH=BL%SCRATCH)
                        !
                        ALLOCATE(ALOT%SW_ALLOTMENT(FDIM%NFARM))
                        ALLOCATE(ALOT%SW_RATE_LIM (FDIM%NFARM))
      CASE ("GROUNDWATER")
                        !
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        SELECT CASE ( LINE(ISTART:ISTOP) )
                        CASE ("RATE"  ); ALOT%GW_ALLOTMENT_TYPE = Z
                        CASE ("VOLUME"); ALOT%GW_ALLOTMENT_TYPE = ONE
                        CASE ("HEIGHT"); ALOT%GW_ALLOTMENT_TYPE = TWO
                        CASE DEFAULT;    CALL STOP_ERROR(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP ALLOTMENT BLOCK ERROR. FOUND KETYWORD "GROUNDWATER"'//NL//'WHICH MUST BE FOLLOWED BY EITHER "VOLUME" OR "RATE".'//NL//'CHECK BLOCK FOR COMPLETENESS (viz. "GROUNDWATER VOLUME" or "GROUNDWATER RATE")')
                        END SELECT
                        !
                        WRITE(BL%IOUT,'(3A)') '   GROUNDWATER ',LINE(ISTART:ISTOP),' KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND LIST INPUT OF SURFACE WATER ALLOTMENTS BY WBS.'
                        !
                        ALOT%HAS_GW_ALLOTMENT = TRUE
                        !
                        CALL ALOT%GW_ALLOTMENT_TFR%INIT('GW_ALOT',  LLOC, LINE, BL%IOUT, BL%IU, FDIM%NFARM, ONE, Z, Z, FDIM%NFARM, BYFARM, SCRATCH=BL%SCRATCH)
                        !
                        ALLOCATE(ALOT%GW_ALLOTMENT(FDIM%NFARM))
                        ALLOCATE(ALOT%GW_RATE_LIM (FDIM%NFARM))
      CASE DEFAULT
                        CALL WARN_MSG%ADD('FOUND UNKNOWN KEYWORD "'//LINE(ISTART:ISTOP)//'" ***IT WILL BE IGNORED***'//BLN)
      END SELECT
      !
      !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
      CALL BL%READ_SCRATCH(EOF, LINE)
      !
    END DO
    !
    CALL WARN_MSG%CHECK(HED='FMP ALLOTMENT BLOCK'//NL,INFILE=BL%IU,OUTPUT=BL%IOUT,INLINE=TRUE,CMD_PRINT=TRUE,TAIL=NL)
    !
  END SUBROUTINE 
  !
  SUBROUTINE SETUP_NEXT_STRESS_PERIOD(ALOT, IRR_AREA, PERTIM)
    !
    CLASS(ALLOTMENT_DATA),                      INTENT(INOUT):: ALOT
    DOUBLE PRECISION, DIMENSION(:), CONTIGUOUS, INTENT(IN   ):: IRR_AREA!(NFARM)
    DOUBLE PRECISION,                           INTENT(IN   ):: PERTIM
    INTEGER::I
    LOGICAL:: UPDATE
    !
    IF(ALOT%TFR_READ) THEN
        UPDATE = FALSE
        CALL ALOT%SW_ALLOTMENT_TFR%NEXT()
        CALL ALOT%GW_ALLOTMENT_TFR%NEXT()
    ELSE
        UPDATE = TRUE
        ALOT%TFR_READ = TRUE
    END IF
    !
    IF(ALOT%HAS_SW_ALLOTMENT) THEN
          !
          ALOT%SW_ALLOTMENT = ALOT%SW_ALLOTMENT_TFR%LIST
          !
          IF(ALOT%SW_ALLOTMENT_TFR%SFAC%HAS_ALL) ALOT%SW_ALLOTMENT = ALOT%SW_ALLOTMENT * ALOT%SW_ALLOTMENT_TFR%SFAC%ALL
          IF(ALOT%SW_ALLOTMENT_TFR%SFAC%HAS_EX1) ALOT%SW_ALLOTMENT = ALOT%SW_ALLOTMENT * ALOT%SW_ALLOTMENT_TFR%SFAC%EX1
          !
          IF(ALOT%SW_ALLOTMENT_TYPE == TWO) ALOT%SW_ALLOTMENT = ALOT%SW_ALLOTMENT * IRR_AREA
          !
          DO CONCURRENT (I=ONE:ALOT%NFARM, ALOT%SW_ALLOTMENT(I) < DZ) 
                                                                  ALOT%SW_ALLOTMENT(I) = INF
          END DO
          !
          DO CONCURRENT (I=ONE:ALOT%NFARM)
              IF(ALOT%SW_ALLOTMENT(I) > D100) THEN
                  ALOT%SW_RATE_LIM (I) = INF
                  !
              ELSEIF(ALOT%SW_ALLOTMENT_TYPE > Z) THEN  !By SP
                  !
                  ALOT%SW_RATE_LIM (I) = ALOT%SW_ALLOTMENT(I) / PERTIM
              ELSE
                 ALOT%SW_RATE_LIM (I) = ALOT%SW_ALLOTMENT(I)
                 ALOT%SW_ALLOTMENT(I) = ALOT%SW_ALLOTMENT(I) * PERTIM
              END IF
          END DO
    END IF
    !
    IF(ALOT%HAS_GW_ALLOTMENT) THEN
          !
          ALOT%GW_ALLOTMENT = ALOT%GW_ALLOTMENT_TFR%LIST
          !
          IF(ALOT%GW_ALLOTMENT_TFR%SFAC%HAS_ALL) ALOT%GW_ALLOTMENT = ALOT%GW_ALLOTMENT * ALOT%GW_ALLOTMENT_TFR%SFAC%ALL
          IF(ALOT%GW_ALLOTMENT_TFR%SFAC%HAS_EX1) ALOT%GW_ALLOTMENT = ALOT%GW_ALLOTMENT * ALOT%GW_ALLOTMENT_TFR%SFAC%EX1
          !
          IF(ALOT%GW_ALLOTMENT_TYPE == TWO) ALOT%GW_ALLOTMENT = ALOT%GW_ALLOTMENT * IRR_AREA
          !
          DO CONCURRENT (I=ONE:ALOT%NFARM)
              IF(ALOT%GW_ALLOTMENT(I)  < DZ) THEN
                  ALOT%GW_ALLOTMENT(I) = DNEG !INF  --NOTE THAT FWEL ROUTINES SKIP ALLOTMENTS WHEN <0
                  ALOT%GW_RATE_LIM (I) = DNEG
                  !
              ELSEIF(ALOT%GW_ALLOTMENT_TYPE > Z) THEN  !By SP
                  !
                  ALOT%GW_RATE_LIM (I) = ALOT%GW_ALLOTMENT(I) / PERTIM
              ELSE
                 ALOT%GW_RATE_LIM (I) = ALOT%GW_ALLOTMENT(I)
                 ALOT%GW_ALLOTMENT(I) = ALOT%GW_ALLOTMENT(I) * PERTIM
              END IF
          END DO
    END IF
    !
  END SUBROUTINE
END MODULE
!
!#########################################################################################################
!
MODULE CROP_DATA_FMP_INTERFACE
  !
  USE    FMP_DIMENSION_INTERFACE, ONLY: FMP_DIMENSION
  USE     WBS_DATA_FMP_INTERFACE, ONLY:     WBS_DATA
  USE CLIMATE_DATA_FMP_INTERFACE, ONLY: CLIMATE_DATA
  USE    SOIL_DATA_FMP_INTERFACE, ONLY:    SOIL_DATA
  !
  USE, INTRINSIC:: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN 
  USE GLOBAL,       ONLY: HNEW, HNEW_OLD, HOLD, UPLAY, UPLAY_IDX, LENUNI, WTABLE
  USE GWFBASMODULE, ONLY: HDRY
  !
  USE CONSTANTS
  USE UTIL_INTERFACE,                   ONLY: FILE_IO_ERROR, STOP_ERROR, WARNING_MESSAGE, &
                                              PARSE_WORD_UP, SET_NEAR_ZERO, NEAR_ZERO, NOT_NEAR_ZERO, &
                                              GET_NUMBER, GET_INTEGER, RELAX_IT, SET_ARRAY
  USE NUM2STR_INTERFACE,                ONLY: NUM2STR
  USE ALLOC_INTERFACE,                  ONLY: ALLOC
  USE GENERIC_OUTPUT_FILE_INSTRUCTION,  ONLY: GENERIC_OUTPUT_FILE
  USE GENERIC_BLOCK_READER_INSTRUCTION, ONLY: GENERIC_BLOCK_READER
  USE IXJ_INSTRUCTION,                  ONLY: IXJ_SINGLE_ENTRY!, IXJ_STRUCTURE
  USE LIST_ARRAY_INPUT_INTERFACE,       ONLY: LIST_ARRAY_INPUT, LIST_ARRAY_INPUT_INT
  USE WARNING_TYPE_INSTRUCTION,         ONLY: WARNING_TYPE
  USE ULOAD_AND_SFAC_INTERFACE
  USE SORT_INTERFACE
  !
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: CROP_DATA, INITIALIZE_CROP_DATA
  !
  !TYPE PSI_VEC
  !    DOUBLE PRECISION,DIMENSION(4):: PSI
  !END TYPE
  !
  TYPE CROP_PROP  !FALLOW FRACTION?
      INTEGER:: N=Z, ID, LD
      !LOGICAL:: FRACTION =.FALSE.
      INTEGER,         DIMENSION(:,:),ALLOCATABLE:: RC
      INTEGER,         DIMENSION(:),  ALLOCATABLE:: T_CONCEPT !0 - No T, 1 Root Pressure, 2 Linear Uptake, 3 No 
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: ROOT
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: FRAC
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: Kc
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: CF
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: CU
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: FTR  
      !DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: FEP
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: FEI
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: DEMAND
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: DEMAND_EXT
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: DEMAND_EXT_INI
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: ADMD
      !DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: CON_PRECIP_FRAC
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: FIESWP 
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: FIESWI
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: PSI
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: CIR
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: CIR_INI
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: RNOFF
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: DPERC
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: RNOFF_Peff
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: RNOFF_EXT
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: DPERC_EXT
      !
      INTEGER,         DIMENSION(:),  ALLOCATABLE:: GW_INTER
      LOGICAL,         DIMENSION(:),  ALLOCATABLE:: NOT_FALLOW 
      LOGICAL,         DIMENSION(:),  ALLOCATABLE:: NOT_FALLOW_SP
      !
      INTEGER,         DIMENSION(:),  ALLOCATABLE:: FID
      INTEGER,         DIMENSION(:),  ALLOCATABLE:: IRR
      INTEGER,         DIMENSION(:),  ALLOCATABLE:: FALLOW_RANK
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: EFF  !IRRIGATION EFFECIENCY
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: ADRF  !FRACTION OF EXTRA IRRIGATION THAT BECOMES RUNOFF
      !DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: EFL  !EVAPORATIVE LOSS FRACTION
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: EGW, TGW, EGWA, TGWA, TPPOT, EPPOT,EP, TSURF, TI, TP, ANOX_LOSS, SOIL_LOSS, PRECIP, TI_BAK
      !DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: PRECIP_POT_TRAN
      !DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: PRECIP_POT_EVAP
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: AREA
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: GSE
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: SS  !GSE - ROOT
      !DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: PSIA
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: LXX   !GSE - ROOT - CAP  -- Lower Extinction Elevation
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: XX    !GSE - CAP
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: UXX   !Upper Extinction Elevation
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: MXX   !Middle Extinction Elevation
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: CECT
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: THI, THD  !TRANSPIRATION INDEPENDENT OF HEAD AND DEPENDENT ON HEAD...USED FOR FD EQUATIONS
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: EHI, EHD
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: POND
      !
      CONTAINS
      !
      GENERIC::              COPY_INPUT => COPY_CROP_INPUT_TO_CROP_PROP,COPY_CROP_INPUT_TO_CROP_PROP_INT
      PROCEDURE, PASS(CPR):: SETUP_UXX_MXX => CALC_CROP_OPTIMAL_UPTAKE_PRESSURE!(CPR, SOIL, MLT, ONLY_K)
      PROCEDURE, PASS(CPR):: DESTROY    => DEALLOCATE_CROP_PROP
      !
      PROCEDURE, PASS(CPR), PRIVATE:: COPY_CROP_INPUT_TO_CROP_PROP
      PROCEDURE, PASS(CPR), PRIVATE:: COPY_CROP_INPUT_TO_CROP_PROP_INT
      FINAL:: DEALLOCATE_CROP_PROP_FINAL
      END TYPE
      !
  TYPE CROP_DATA
      INTEGER:: NCROP = Z, NIRRG=Z
      INTEGER:: NROW, NCOL
      INTEGER:: NCROP_ELEV
      INTEGER:: CROP_NAME_LEN
      INTEGER:: IOUT=Z, LOUT=Z
      INTEGER:: ITER_CALC_EGW_TGW_LOCK = inf_I
      INTEGER:: ITER_AVE_HEAD = inf_I
      LOGICAL:: HAS_AVE_HEAD = FALSE
      DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: AVE_HEAD
      !LOGICAL:: FRACTION = FALSE
      LOGICAL:: MULTI_CROP_CELLS    = FALSE
      LOGICAL:: TFR_READ            = FALSE
      LOGICAL:: CHECK_BARE          = FALSE
      LOGICAL:: GW_ROOT_INTERACTION = TRUE
      LOGICAL:: HAS_Kc              = FALSE
      LOGICAL:: HAS_POND            = FALSE
      LOGICAL:: HAS_PSI             = FALSE
      LOGICAL:: HAS_Pe              = FALSE
      LOGICAL:: HAS_DEMAND_EXT      = FALSE
      LOGICAL:: DEMAND_EXT_FLUX     = FALSE
      !LOGICAL:: PCF_IS_FRAC         = TRUE
      INTEGER,             DIMENSION(:,:),ALLOCATABLE:: CRPID
      TYPE(CROP_PROP),     DIMENSION(:),  ALLOCATABLE:: CROP
      DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: BARE_FRAC, BARE_GSE, BARE_FRAC_RUNOFF, BARE_TOT_PRECEP, BARE_PRECEP_EXCESS, BARE_RNOFF_Peff, BARE_EVAP, BARE_POT_EVAP, BARE_EVAP_EHI, BARE_EVAP_EHD, BARE_EVAP_PRECIP!, BARE_FRAC_PRECIP !BARE/FALLOW FRACTION of PRECIP to RUNOFF
      DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: TTOT, ETOT, TGWA, EGWA
      CHARACTER(20),       DIMENSION(:),  ALLOCATABLE:: CROP_NAME  !OPTIONAL
      INTEGER,             DIMENSION(:),  ALLOCATABLE:: CROP_SCAPE_ID
      !
      DOUBLE PRECISION:: MIN_BARE=DZ      !MINIMUM BARE FRACTION ALLOWED
      DOUBLE PRECISION:: MLT              !CONVERSION FROM MODEL UNIT TO CM
      DOUBLE PRECISION:: RELAX_FACT = UNO !RELAXATION FACTOR LOADED IN CROP BLOCK AND APPLIED BETWEEN TWO ITERATIOSN FOR DETERMINING GROUNDWATER ROOT CROP INTERACTION
      DOUBLE PRECISION:: RELAX            !RELAXATION FACTOR APPLIED BETWEEN TWO ITERATIOSN FOR DETERMINING GROUNDWATER ROOT CROP INTERACTION
      !DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: CIR
      !DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: ARRAY
      !DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: LIST
      !
      TYPE(LIST_ARRAY_INPUT_INT):: CID
      TYPE(LIST_ARRAY_INPUT_INT):: IRR
      TYPE(LIST_ARRAY_INPUT_INT):: GW_INTER
      TYPE(LIST_ARRAY_INPUT_INT):: PRINT_CROP
      TYPE(LIST_ARRAY_INPUT_INT):: FEI_CHECK
      TYPE(LIST_ARRAY_INPUT_INT):: ZERO_CU_TO_BARE
      TYPE(LIST_ARRAY_INPUT):: ROOT
      TYPE(LIST_ARRAY_INPUT):: FRAC
      TYPE(LIST_ARRAY_INPUT):: Kc
      TYPE(LIST_ARRAY_INPUT):: CF
      TYPE(LIST_ARRAY_INPUT):: FTR  
      TYPE(LIST_ARRAY_INPUT):: FEI
      !TYPE(LIST_ARRAY_INPUT):: CON_PRECIP_FRAC 
      TYPE(LIST_ARRAY_INPUT):: FIESWP 
      TYPE(LIST_ARRAY_INPUT):: FIESWI
      TYPE(LIST_ARRAY_INPUT):: PSI
      TYPE(LIST_ARRAY_INPUT):: POND
      TYPE(LIST_ARRAY_INPUT):: ADMD
      !
      TYPE(LIST_ARRAY_INPUT_INT):: GSE_CID
      !TYPE(LIST_ARRAY_INPUT_INT):: GSE_SFR
      TYPE(LIST_ARRAY_INPUT)::     SPEC_GSE
      TYPE(LIST_ARRAY_INPUT)::     GSE_OFFSET
      !TYPE(LIST_ARRAY_INPUT):: DEMAND
      !TYPE(LIST_ARRAY_INPUT):: FEP
      !
      TYPE(GENERIC_OUTPUT_FILE):: OUT_BYFARMCROP
      TYPE(GENERIC_OUTPUT_FILE):: OUT_BYFARM
      TYPE(GENERIC_OUTPUT_FILE):: OUT_BYCROP
      TYPE(GENERIC_OUTPUT_FILE):: OUT_DETAIL
      TYPE(GENERIC_OUTPUT_FILE):: OUT_ALL
      TYPE(GENERIC_OUTPUT_FILE):: OUT_BARE
      TYPE(GENERIC_OUTPUT_FILE):: OUT_INPUT
      !TYPE(GENERIC_OUTPUT_FILE):: OUT_ROOT
      !
      CONTAINS
      !
      PROCEDURE, PASS(CDAT):: PARSE_CROP_ROW_COL
      PROCEDURE, PASS(CDAT):: NEXT                 => SETUP_NEXT_STRESS_PERIOD
      PROCEDURE, PASS(CDAT):: NEXT_TS              => SETUP_NEXT_TIME_STEP
      PROCEDURE, PASS(CDAT):: SETUP_CROP_EFFICIENCY
      PROCEDURE, PASS(CDAT):: COPY_AND_SETUP_IRRIGATION => COPY_AND_SETUP_IRRIGATION_INPUT_TO_CROP_PROP
      PROCEDURE, PASS(CDAT):: CALC_WBS_IRRIGATED_AREA
      PROCEDURE, PASS(CDAT):: CALC_EGW_TGW
      PROCEDURE, PASS(CDAT):: CALC_CIR_DEMAND
      PROCEDURE, PASS(CDAT):: INIT_EXTERNAL_DEMAND !SET TO ZERO
      PROCEDURE, PASS(CDAT):: ADD_EXTERNAL_DEMAND!(DMD,I,K,F,USE_AREA)
      PROCEDURE, PASS(CDAT):: SET_EXTERNAL_DEMAND_INI
      PROCEDURE, PASS(CDAT):: ADD_CROP_DEMAND_TO_ARRAY
      PROCEDURE, PASS(CDAT):: ADD_CROP_ADDED_DEMAND_BYWBS
      PROCEDURE, PASS(CDAT):: SET_WBS_ADDED_DEMAND!(WBS)
      PROCEDURE, PASS(CDAT):: NOT_FALLOW_RESET
      PROCEDURE, PASS(CDAT):: APPLY_DEFICIENCY_SCENARIO
      PROCEDURE, PASS(CDAT):: CALC_INEFFICIENT_LOSSES
      PROCEDURE, PASS(CDAT):: UPDATE_TWGA_EGWA_BARE_EVAP
      PROCEDURE, PASS(CDAT):: CALC_TTOT_ETOT_TGWA_EGWA_TOTALS
      PROCEDURE, PASS(CDAT):: CALC_WBS_EFFICIENCY
      PROCEDURE, PASS(CDAT):: SUBTRACT_TGWA_EGWA_FROM_FNRCH!(WBS)
      !
      PROCEDURE, PASS(CDAT):: PRINT_OUT_BYFARM_BYCROP
      PROCEDURE, PASS(CDAT):: PRINT_OUT_BYFARM!(WBS, KPER, KSTP, DELT, DYEAR, DATE)
      PROCEDURE, PASS(CDAT):: PRINT_OUT_BYCROP!(WBS, KPER, KSTP, DELT, DYEAR, DATE)
      PROCEDURE, PASS(CDAT):: PRINT_OUT_DETAIL_CROP!(WBS, KPER, KSTP, DELT, DYEAR, DATE)
      PROCEDURE, PASS(CDAT):: PRINT_OUT_BARE!(WBS, KPER, KSTP, DELT, DYEAR, DATE)
      PROCEDURE, PASS(CDAT):: PRINT_OUT_INPUT!(WBS, KPER, KSTP)
      PROCEDURE, PASS(CDAT):: PRINT_OUT_ALL_CROP
      !
      !PROCEDURE, PASS(CDAT):: SET_PRECIP_POTENTIAL => SETUP_CROP_PRECIP_POTENTIAL
      FINAL:: DEALLOCATE_CROP_DATA_FINAL
  END TYPE
  !
  CONTAINS
  !
  SUBROUTINE DEALLOCATE_CROP_DATA_FINAL(CDAT)
    TYPE(CROP_DATA)::CDAT
    !
    IF(ALLOCATED(CDAT%CROP) ) DEALLOCATE(CDAT%CROP)
    !
    IF(ALLOCATED(CDAT%CRPID)) DEALLOCATE(CDAT%CRPID)
    !
    IF(ALLOCATED(CDAT%CROP_NAME)    ) DEALLOCATE(CDAT%CROP_NAME)
    IF(ALLOCATED(CDAT%CROP_SCAPE_ID)) DEALLOCATE(CDAT%CROP_SCAPE_ID)
    !
    IF(ALLOCATED(CDAT%BARE_FRAC         )) DEALLOCATE(CDAT%BARE_FRAC)
    IF(ALLOCATED(CDAT%BARE_GSE          )) DEALLOCATE(CDAT%BARE_GSE)
    IF(ALLOCATED(CDAT%BARE_FRAC_RUNOFF  )) DEALLOCATE(CDAT%BARE_FRAC_RUNOFF)
    IF(ALLOCATED(CDAT%BARE_PRECEP_EXCESS)) DEALLOCATE(CDAT%BARE_PRECEP_EXCESS)
    IF(ALLOCATED(CDAT%BARE_RNOFF_Peff)   ) DEALLOCATE(CDAT%BARE_RNOFF_Peff)
    IF(ALLOCATED(CDAT%BARE_TOT_PRECEP)   ) DEALLOCATE(CDAT%BARE_TOT_PRECEP)
    IF(ALLOCATED(CDAT%BARE_POT_EVAP)     ) DEALLOCATE(CDAT%BARE_POT_EVAP)
    IF(ALLOCATED(CDAT%BARE_EVAP    )     ) DEALLOCATE(CDAT%BARE_EVAP)
    IF(ALLOCATED(CDAT%BARE_EVAP_EHI)     ) DEALLOCATE(CDAT%BARE_EVAP_EHI)
    IF(ALLOCATED(CDAT%BARE_EVAP_EHD)     ) DEALLOCATE(CDAT%BARE_EVAP_EHD)
    IF(ALLOCATED(CDAT%BARE_EVAP_PRECIP)  ) DEALLOCATE(CDAT%BARE_EVAP_PRECIP)
    IF(ALLOCATED(CDAT%TTOT)              ) DEALLOCATE(CDAT%TTOT)
    IF(ALLOCATED(CDAT%ETOT)              ) DEALLOCATE(CDAT%ETOT)
    IF(ALLOCATED(CDAT%TGWA)              ) DEALLOCATE(CDAT%TGWA)
    IF(ALLOCATED(CDAT%EGWA)              ) DEALLOCATE(CDAT%EGWA)
    !IF(ALLOCATED(CDAT%BARE_FRAC_PRECIP)) DEALLOCATE(CDAT%BARE_FRAC_PRECIP)
    !
    IF(ALLOCATED(CDAT%AVE_HEAD)        ) DEALLOCATE(CDAT%AVE_HEAD)
    !
  END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_CROP_PROP_FINAL(CPR)
    TYPE(CROP_PROP)::CPR
    !
    CALL DEALLOCATE_CROP_PROP(CPR)
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_CROP_PROP(CPR)
    CLASS(CROP_PROP), INTENT(INOUT)::CPR
    CPR%N=Z
    IF(ALLOCATED(CPR%RC             ))  DEALLOCATE(CPR%RC             )
    IF(ALLOCATED(CPR%T_CONCEPT      ))  DEALLOCATE(CPR%T_CONCEPT      )
    IF(ALLOCATED(CPR%ROOT           ))  DEALLOCATE(CPR%ROOT           )
    IF(ALLOCATED(CPR%FRAC           ))  DEALLOCATE(CPR%FRAC           )
    IF(ALLOCATED(CPR%Kc             ))  DEALLOCATE(CPR%Kc             )
    IF(ALLOCATED(CPR%CF             ))  DEALLOCATE(CPR%CF             )
    IF(ALLOCATED(CPR%CU             ))  DEALLOCATE(CPR%CU             )
    IF(ALLOCATED(CPR%FTR            ))  DEALLOCATE(CPR%FTR            )
    IF(ALLOCATED(CPR%FEI            ))  DEALLOCATE(CPR%FEI            )
    IF(ALLOCATED(CPR%DEMAND         ))  DEALLOCATE(CPR%DEMAND         )
    IF(ALLOCATED(CPR%ADRF           ))  DEALLOCATE(CPR%ADRF           )
    IF(ALLOCATED(CPR%DEMAND_EXT     ))  DEALLOCATE(CPR%DEMAND_EXT     )
    IF(ALLOCATED(CPR%DEMAND_EXT_INI ))  DEALLOCATE(CPR%DEMAND_EXT_INI )
    !IF(ALLOCATED(CPR%CON_PRECIP_FRAC))  DEALLOCATE(CPR%CON_PRECIP_FRAC)
    IF(ALLOCATED(CPR%FIESWP         ))  DEALLOCATE(CPR%FIESWP         )
    IF(ALLOCATED(CPR%FIESWI         ))  DEALLOCATE(CPR%FIESWI         )
    IF(ALLOCATED(CPR%PSI            ))  DEALLOCATE(CPR%PSI            )
    IF(ALLOCATED(CPR%CIR            ))  DEALLOCATE(CPR%CIR            )
    IF(ALLOCATED(CPR%CIR_INI        ))  DEALLOCATE(CPR%CIR_INI        )
    IF(ALLOCATED(CPR%RNOFF          ))  DEALLOCATE(CPR%RNOFF          )
    IF(ALLOCATED(CPR%DPERC          ))  DEALLOCATE(CPR%DPERC          )
    IF(ALLOCATED(CPR%RNOFF_EXT      ))  DEALLOCATE(CPR%RNOFF_EXT      )
    IF(ALLOCATED(CPR%RNOFF_Peff     ))  DEALLOCATE(CPR%RNOFF_Peff     )
    IF(ALLOCATED(CPR%DPERC_EXT      ))  DEALLOCATE(CPR%DPERC_EXT      )
    IF(ALLOCATED(CPR%GW_INTER       ))  DEALLOCATE(CPR%GW_INTER       )
    IF(ALLOCATED(CPR%NOT_FALLOW     ))  DEALLOCATE(CPR%NOT_FALLOW     )
    IF(ALLOCATED(CPR%NOT_FALLOW_SP  ))  DEALLOCATE(CPR%NOT_FALLOW_SP  )
    IF(ALLOCATED(CPR%FID            ))  DEALLOCATE(CPR%FID            )
    IF(ALLOCATED(CPR%IRR            ))  DEALLOCATE(CPR%IRR            )
    IF(ALLOCATED(CPR%FALLOW_RANK    ))  DEALLOCATE(CPR%FALLOW_RANK    )
    IF(ALLOCATED(CPR%EFF            ))  DEALLOCATE(CPR%EFF            )
    IF(ALLOCATED(CPR%ADRF           ))  DEALLOCATE(CPR%ADRF           )
    !IF(ALLOCATED(CPR%EFL            ))  DEALLOCATE(CPR%EFL            )
    IF(ALLOCATED(CPR%EGW            ))  DEALLOCATE(CPR%EGW            )
    IF(ALLOCATED(CPR%TGW            ))  DEALLOCATE(CPR%TGW            )
    IF(ALLOCATED(CPR%EGWA           ))  DEALLOCATE(CPR%EGWA           )
    IF(ALLOCATED(CPR%TGWA           ))  DEALLOCATE(CPR%TGWA           )
    IF(ALLOCATED(CPR%TPPOT          ))  DEALLOCATE(CPR%TPPOT          )
    IF(ALLOCATED(CPR%EPPOT          ))  DEALLOCATE(CPR%EPPOT          )
    IF(ALLOCATED(CPR%EP             ))  DEALLOCATE(CPR%EP             )
    IF(ALLOCATED(CPR%PRECIP         ))  DEALLOCATE(CPR%PRECIP         )
    IF(ALLOCATED(CPR%TSURF          ))  DEALLOCATE(CPR%TSURF          )
    IF(ALLOCATED(CPR%TI             ))  DEALLOCATE(CPR%TI             )
    IF(ALLOCATED(CPR%TI_BAK         ))  DEALLOCATE(CPR%TI_BAK         )
    IF(ALLOCATED(CPR%TP             ))  DEALLOCATE(CPR%TP             )
    IF(ALLOCATED(CPR%ANOX_LOSS      ))  DEALLOCATE(CPR%ANOX_LOSS      )
    IF(ALLOCATED(CPR%SOIL_LOSS      ))  DEALLOCATE(CPR%SOIL_LOSS      )
    IF(ALLOCATED(CPR%AREA           ))  DEALLOCATE(CPR%AREA           )
    IF(ALLOCATED(CPR%GSE            ))  DEALLOCATE(CPR%GSE            )
    IF(ALLOCATED(CPR%SS             ))  DEALLOCATE(CPR%SS             )
    IF(ALLOCATED(CPR%LXX            ))  DEALLOCATE(CPR%LXX            )
    IF(ALLOCATED(CPR%XX             ))  DEALLOCATE(CPR%XX             )
    IF(ALLOCATED(CPR%UXX            ))  DEALLOCATE(CPR%UXX            )
    IF(ALLOCATED(CPR%MXX            ))  DEALLOCATE(CPR%MXX            )
    IF(ALLOCATED(CPR%CECT           ))  DEALLOCATE(CPR%CECT           )
    IF(ALLOCATED(CPR%THI            ))  DEALLOCATE(CPR%THI            )
    IF(ALLOCATED(CPR%THD            ))  DEALLOCATE(CPR%THD            )
    IF(ALLOCATED(CPR%EHI            ))  DEALLOCATE(CPR%EHI            )
    IF(ALLOCATED(CPR%EHD            ))  DEALLOCATE(CPR%EHD            )
    IF(ALLOCATED(CPR%POND           ))  DEALLOCATE(CPR%POND           )
    IF(ALLOCATED(CPR%ADMD           ))  DEALLOCATE(CPR%ADMD           )
    !
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_CROP_DATA( BL, CDAT, LINE, FDIM, HAS_SFR )  !NFARM, IFID
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL   !DATA BLOCK
    CLASS(CROP_DATA),            INTENT(INOUT):: CDAT
    CHARACTER(*),                INTENT(INOUT):: LINE
    CLASS(FMP_DIMENSION),        INTENT(IN   ):: FDIM
    LOGICAL,                     INTENT(IN   ):: HAS_SFR
    !INTEGER,                     INTENT(IN   ):: NFARM
    !INTEGER, DIMENSION(:,:),     INTENT(IN   ):: IFID
    INTEGER, DIMENSION(3):: CDIM
    CHARACTER(5):: ERROR
    LOGICAL:: EOF
    INTEGER:: I, LLOC, ISTART, ISTOP, IU, NROW, NCOL, ELV_NROW, PAD !Z, ONE, 
    !CHARACTER(20), DIMENSION(:), ALLOCATABLE:: CROPNAME, CTMP
    !CHARACTER(20):: NAME
    CHARACTER(6):: BYFARM, BYCROP
    CHARACTER(10):: BYIRRIGATE
    !CHARACTER(4), PARAMETER:: LIST  = 'LIST'
    !CHARACTER(5), PARAMETER:: ARRAY = 'ARRAY'
    !CHARACTER(6), PARAMETER:: STATICKEY = 'STATIC'
    !CHARACTER(9), PARAMETER:: TRANSIENT = 'TRANSIENT'
    TYPE(WARNING_TYPE):: WARN
    LOGICAL:: BINARY, HAS_ADDED
    !
    CALL WARN%INIT()
    !
    WRITE(BL%IOUT,'(/A/)') 'CROP BLOCK FOUND AND NOW LOADING PROPERTIES'
    !
    BYFARM = 'BYWBS'
    BYCROP = 'BYCROP'
    BYIRRIGATE = 'BYIRRIGATE'
    HAS_ADDED = FALSE
    !
    !Z = 0
    !ONE=1 
    !TRUE = .TRUE.
    !FALSE= .FALSE.
    NCOL = FDIM%NCOL
    NROW = FDIM%NROW
    ELV_NROW   = NROW
    CDAT%NROW  = NROW
    CDAT%NCOL  = NCOL
    CDAT%NIRRG = FDIM%NIRRG
    CDAT%NCROP = FDIM%NCROP
    CDAT%NCROP_ELEV = FDIM%NCROP_ELEV
    CDAT%IOUT  = BL%IOUT
    CDAT%LOUT  = BL%IOUT
    CDAT%CHECK_BARE = FALSE
    CDAT%HAS_DEMAND_EXT  = FALSE
    CDAT%DEMAND_EXT_FLUX = FALSE
    !CDAT%PCF_IS_FRAC     = TRUE
    CDAT%HAS_Kc = FALSE
    CDAT%ITER_CALC_EGW_TGW_LOCK = inf_I
    CDAT%ITER_AVE_HEAD = inf_I
    !
    ALLOCATE(CDAT%TTOT(NCOL,NROW), CDAT%ETOT(NCOL,NROW), CDAT%TGWA(NCOL,NROW), CDAT%EGWA(NCOL,NROW), SOURCE=DZ) !AUTOALLOCATES ALL TO ZERO
    ALLOCATE(CDAT%BARE_FRAC(NCOL,NROW), SOURCE=DZ)
    !
    SELECT CASE (LENUNI)
    CASE(ONE);          CDAT%MLT = 30.48D0  !FOOT
    CASE(TWO);          CDAT%MLT = 100D0    !METER
    CASE(THREE);        CDAT%MLT = 1D0      !CENTIMETER
    CASE DEFAULT;       CDAT%MLT = 1D0      !UNKNOWN
    END SELECT
    !
    CDAT%RELAX_FACT= UNO
    ERROR='ERROR'
    !
    IF(CDAT%NCROP==Z) THEN
        !WRITE(BL%IOUT, '(A)') 'WARNING: NCROP = 0, ARE YOU SURE YOU WANT TO USE FMP WITHOUT ANY CROPS?'
        CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP NCROP = 0, ARE YOU SURE YOU WANT TO USE FMP WITHOUT ANY CROPS???',INLINE=TRUE)
        RETURN
    END IF
    !
    !
    CALL BL%START()
    !
    EOF = TRUE  !USE AS FLAG IF KEYWORD IS FOUND
    CDAT%MULTI_CROP_CELLS = FALSE
    DO I=ONE, BL%NLINE
                    LLOC=ONE
                    CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP)
                    IF (BL%LINE(ISTART:ISTOP)=='MULTI_LAND_USE_PER_CELL' .OR. BL%LINE(ISTART:ISTOP)=='MULTIPLE_LAND_USE_PER_CELL') THEN
                        CDAT%MULTI_CROP_CELLS = TRUE
                        IF(.NOT. EOF) CALL STOP_ERROR(BL%LINE,BL%IU,BL%IOUT,'FMP CROP BLOCK ERROR. YOU MAY ONLY SPECIFY "SINGLE_LAND_USE_PER_CELL" OR "MULTIPLE_LAND_USE_PER_CELL", BUT NOT BOTH DURING THE SAME SIMULATION.')
                        EOF = FALSE
                    ELSEIF(BL%LINE(ISTART:ISTOP)=='SINGLE_LAND_USE_PER_CELL') THEN
                        CDAT%MULTI_CROP_CELLS = FALSE
                        IF(.NOT. EOF) CALL STOP_ERROR(BL%LINE,BL%IU,BL%IOUT,'FMP CROP BLOCK ERROR. YOU MAY ONLY SPECIFY "SINGLE_LAND_USE_PER_CELL" OR "MULTIPLE_LAND_USE_PER_CELL", BUT NOT BOTH DURING THE SAME SIMULATION.')
                        EOF = FALSE
                    END IF
                    !
                    CALL BL%NEXT()
    END DO
    !
    IF(EOF) CALL WARNING_MESSAGE(INFILE=BL%IU, OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK FAILED TO IDENTIFY KEYWORD "SINGLE_LAND_USE_PER_CELL" OR "MULTIPLE_LAND_USE_PER_CELL".'//BLN//'IT WILL ASSUME THE KEYWORD "SINGLE_LAND_USE_PER_CELL" AND REQUIRES SPECIFYING LAND USE/CROP ID "LOCATION"s.')
    !
    IF(CDAT%MULTI_CROP_CELLS) THEN
        CDAT%MIN_BARE = NEARZERO_12
    ELSE
        CDAT%MIN_BARE = inf
    END IF
    !
    IF(CDAT%NCROP_ELEV < ONE) CDAT%NCROP_ELEV = CDAT%NCROP
    !
    IF(CDAT%MULTI_CROP_CELLS) THEN
                          NROW     = CDAT%NCROP * NROW !LOAD IN NCROP SETS OF NROWS
                          ELV_NROW = CDAT%NCROP_ELEV * ELV_NROW 
                          CDIM = [3,1,0]
    ELSE
                          CDIM = [2,1,0]
    END IF
    !
    !
    ALLOCATE(CDAT%CROP(CDAT%NCROP))
    DO CONCURRENT(I=ONE:CDAT%NCROP); CDAT%CROP(I)%ID = I
    END DO
    !
    IF (CDAT%MULTI_CROP_CELLS) THEN
        DO CONCURRENT(I=ONE:CDAT%NCROP); CDAT%CROP(I)%LD = ONE + ( (I-ONE) * FDIM%NROW )
        END DO
    ELSE
        CDAT%CROP%LD = ONE
    END IF
    !
    PAD = LEN(NUM2STR(CDAT%NCROP))
    ALLOCATE( CDAT%CROP_NAME(CDAT%NCROP) )
    DO I=ONE, CDAT%NCROP
        CDAT%CROP_NAME(I) = 'CROP_'//NUM2STR(I,PAD,TRUE)
    END DO
    CDAT%CROP_NAME_LEN = MAX(FIVE+PAD,9)
    !
    CALL BL%MAKE_SCRATCH_FILE()
    !
    !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
    CALL BL%READ_SCRATCH(EOF, LINE)
    !
    IF(CDAT%NCROP > Z) THEN
    DO WHILE (.NOT. EOF)
      !
      LLOC=ONE
      CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
      !
      SELECT CASE ( LINE(ISTART:ISTOP) )
      !CASE ("NCROP")
      !                  CYCLE
      CASE ("CROP_NAME", "NAME")
                        WRITE(BL%IOUT,'(A)') '        NAME              KEYWORD FOUND. NOW USING ULOAD TO READ IN LIST OF CROP NAMES.'
                        IU = Z
                        CALL ULOAD(CDAT%CROP_NAME, LLOC, LINE, BL%IOUT, BL%IU, IU, SCRATCH=BL%SCRATCH)
                        !
                        DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP_NAME_LEN<LEN_TRIM(CDAT%CROP_NAME(I)) );  CDAT%CROP_NAME_LEN = LEN_TRIM(CDAT%CROP_NAME(I))
                        END DO
      CASE ("CROPSCAPE")
                        WRITE(BL%IOUT,'(A)') '   CROPSCAPE              KEYWORD FOUND. NOW USING ULOAD TO READ IN LIST OF CROPSCAPE IDs THAT REFER TO EACH CROP.'
                        IU = Z
                        ALLOCATE(CDAT%CROP_SCAPE_ID(CDAT%NCROP))
                        CALL ULOAD(CDAT%CROP_SCAPE_ID, LLOC, LINE, BL%IOUT, BL%IU, IU, SCRATCH=BL%SCRATCH)
      CASE ("LOCATION","CID")
                        WRITE(BL%IOUT,'(A)') '   LOCATION (CID)         KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN 2D ARRAY OF CROP IDs.'
                        !
                        IF(CDAT%MULTI_CROP_CELLS) CALL STOP_ERROR(LINE,BL%IU,BL%IOUT,'FMP CROP BLOCK ERROR. YOU CAN NOT USE THE KEYWORD "LOCATION" WHEN USING THE KEYWORD "MULTI_LAND_USE_PER_CELL". INSTEAD THE LOCATION IS INFERED FROM THE KEYWORD "LAND_USE_AREA_FRACTION".')
                        !
                        CALL CDAT%CID%INIT('CID',       LLOC, LINE, BL%IOUT, BL%IU, Z, Z, NROW, NCOL, BL%SCRATCH, CDIM=[3,0,0])
                        !
                        ALLOCATE(CDAT%CRPID(NCOL,NROW), SOURCE=Z)
      CASE("SINGLE_LAND_USE_PER_CELL","MULTI_LAND_USE_PER_CELL","MULTIPLE_LAND_USE_PER_CELL")
                                     CONTINUE ! DO NOTHING
      CASE ("LAND_USE_AREA_FRACTION")
                        !
                        IF(CDAT%MULTI_CROP_CELLS) THEN
                            WRITE(BL%IOUT,'(A)') '   LAND_USE_AREA_FRACTION  KEYWORD FOUND. MULTIPLE CROP PER CELL INPUT REQUIRES ARRAY STYLE ONLY. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN 2D ARRAY OF CROP FRACTIONS (NOTE THAT ARRAY IS [NCROP*NROW,NCOL]).'
                            CALL CDAT%FRAC%INIT('MULTI_FRAC', LLOC, LINE, BL%IOUT, BL%IU,          Z,   Z, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                        ELSE
                            WRITE(BL%IOUT,'(A)') '   LAND_USE_AREA_FRACTION KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN 2D ARRAY OF CROP FRACTIONS (NOTE THAT ARRAY IS [NROW,NCOL]).'
                            CALL CDAT%FRAC%INIT('SINGLE_FRAC', LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                        END IF
      CASE ("MAX_ITERATION_CALCULATE_INITIAL_EVAPOTRANSPIRATION")
                        WRITE(BL%IOUT,'(A)') '   MAX_ITERATION_CALCULATE_INITIAL_EVAPOTRANSPIRATION KEYWORD FOUND. NOW LOADING LOADING THE OUTER ITERATION THAT RESULTS IN STOPPING THE INITIAL ESTIMATE OF LAND USE ET.'
                        !
                        CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,CDAT%ITER_CALC_EGW_TGW_LOCK,  MSG='FMP CROP BLOCK "" FAILED TO LOAD THE ACTUAL VALUE.')
      CASE ("ITERATION_USE_AVERAGE_HEAD_FOR_EVAPOTRANSPIRATION")
                        WRITE(BL%IOUT,'(A)') '   ITERATION_START_USE_AVERAGE_HEAD_EVAPOTRANSPIRATION KEYWORD FOUND. NOW LOADING LOADING THE OUTHER ITERATION THAT RESULTS IN STOPPING THE INITIAL ESTIMATE OF LAND USE ET.'
                        !
                        CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,CDAT%ITER_AVE_HEAD,  MSG='FMP CROP BLOCK "" FAILED TO LOAD THE ACTUAL VALUE.')
                        ALLOCATE(CDAT%AVE_HEAD(CDAT%NCOL,CDAT%NROW), SOURCE=DZ)
      CASE ("MIN_BARE_FRACTION")
                        WRITE(BL%IOUT,'(A)') '   MIN_BARE_FRACTION      KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN 2D ARRAY OF CROP FRACTIONS (NOTE THAT ARRAY IS (NROW*NCROP,NCOL).'
                        !
                        CALL GET_NUMBER(LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,CDAT%MIN_BARE,  MSG='FMP CROP BLOCK "MIN_BARE_FRACTION" FAILED TO LOAD THE ACTUAL VALUE.')
      CASE ("IRRIGATION")
                        WRITE(BL%IOUT,'(A)') '   IRRIGATION             KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD, THEN CROP IRRIGATION TYPES.'
                        IF(CDAT%NIRRG > Z) THEN
                            CALL CDAT%IRR%INIT('IRR',       LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, BL%SCRATCH)
                            !
                        ELSE
                            CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK: FOUND KEYWORD "IRRIGATION" WHEN NIRRIGATE = 0. THIS LINE WILL BE IGNORED AND THE IRRIGATION FLAG SET TO 0 FOR ALL CROPS.',CMD_PRINT=TRUE)
                        END IF
                        !
      CASE ("ROOT","ROOT_DEPTH","ROOT_PRESSURE") !ALLOW FOR SPACE BETWEEN ROOT DEPTH AND ROOT PRESSURE
                        !
                        IF(LINE(ISTART:ISTOP) == "ROOT") CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        !
                        SELECT CASE ( LINE(ISTART:ISTOP) )
                        CASE('DEPTH',"ROOT_DEPTH")
                                        WRITE(BL%IOUT,'(A)') '   ROOT_DEPTH             KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                                        CALL CDAT%ROOT%INIT('ROOT',     LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM, NONEG=TRUE)
                                        !CALL CDAT%ROOT%NEXT()
                        CASE('PRESSURE',"ROOT_PRESSURE")
                                        WRITE(BL%IOUT,'(A)') '   ROOT_PRESSURE          KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST OF ROOT PRESSURES.'
                                        CALL CDAT%PSI%INIT('PSI',       LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, FOUR, Z, Z, Z,'n', CDAT%NCROP, BYCROP,Z,'n', SCRATCH=BL%SCRATCH)
                                        !CALL CDAT%PSI%NEXT()
                        CASE DEFAULT
                                        CALL STOP_ERROR(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP CROP ERROR. FOUND KETYWORD "ROOT" WHICH MUST BE FOLLOWED BY EITHER "DEPTH" OR "PRESSURE".'//NL//'CHECK BLOCK FOR COMPLETENESS (viz. "ROOT DEPTH" or "ROOT PRESSURE")')
                        END SELECT
                        !
      CASE ("CROP_COEFFICIENT", "CROP_COEFICIENT")
                        WRITE(BL%IOUT,'(A)') '   CROP_COEFFICIENT       KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        CALL CDAT%Kc%INIT('Kc',         LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM) !, NONEG=TRUE)
                        CDAT%HAS_Kc = TRUE
                        !
      CASE ("CONSUMPTIVE_USE")
                        WRITE(BL%IOUT,'(A)') '   CONSUMPTIVE_USE        KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        CALL CDAT%CF%INIT('CF',         LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM) !, NONEG=TRUE)
                        !
                        !
      CASE ("ZERO_CONSUMPTIVE_USE_BECOMES_BARE_SOIL")
                        WRITE(BL%IOUT,'(A)') '   ZERO_CONSUMPTIVE_USE_BECOMES_BARE_SOIL KEYWORD FOUND. CHECKING FOR "STATIC", "TRANSIENT", OR "LIST" KEYWORD. IF NOT FOUND THEN OPTION IS APPLIED TO ALL CROPS.'
                        !
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        SELECT CASE(LINE(ISTART:ISTOP))
                        CASE("STATIC","TRANSIENT","LIST")
                                   LLOC = ISTART
                                   CALL CDAT%ZERO_CU_TO_BARE%INIT('CU_TO_BARE',  LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z, SCRATCH=BL%SCRATCH)
                        CASE DEFAULT
                                   CALL CDAT%ZERO_CU_TO_BARE%INIT('CU_TO_BARE', ONE,         BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
                        END SELECT
                        !
      CASE ("ADDED_DEMAND","ADMD")
                        WRITE(BL%IOUT,'(A)') '   ADDED_DEMAND (ADMD)     KEYWORD FOUND. NOW LOADING LENGTH (OR FLUX) OR RATE KEYWORDS THEN STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        !
                        IF(CDAT%HAS_DEMAND_EXT) CALL STOP_ERROR(OUTPUT=CDAT%LOUT, MSG='FMP CROP BLOCK ERROR. YOU MAY ONLY SPECIFY KEYWORD "ADDED_DEMAND" ONCE, SO YOU MAY ONLY SIMULATE WITH EITHER THE KEYWORD "LENGTH" OR "RATE", BUT NOT BOTH AT ONCE. IF YOU NEED TO SIMULATE BOTH THEN USE THE KEYWORD "ADDED_CROP_DEMAND" IN THE WBS BLOCK, WHICH CAN BE SPECIFIED TWICED, ONE WITH THE KEYWORD "LENGTH" AND ANOTHER WITH THE KEYWORD "RATE".')
                        !
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        SELECT CASE ( LINE(ISTART:ISTOP) )
                        CASE("LENGTH","FLUX")
                                               CALL CDAT%ADMD%INIT('ADMD',       LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, FDIM%NFARM, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, LISTARRAY=TRUE, CDIM=CDIM, NONEG=TRUE)
                                               CDAT%DEMAND_EXT_FLUX = TRUE
                        CASE("RATE")
                                               CALL CDAT%ADMD%INIT('ADMD',       LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, FDIM%NFARM, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, LISTARRAY=TRUE, CDIM=CDIM, NONEG=TRUE)
                                               CDAT%DEMAND_EXT_FLUX = FALSE
                        CASE DEFAULT;          CALL STOP_ERROR(OUTPUT=CDAT%LOUT, MSG='FMP CROP BLOCK ERROR. IF YOU SPECIFY KEYWORD "ADDED_DEMAND", YOU MUST FOLLOW IT WITH THE KEYWORD "LENGTH" OR "RATE"'//NL//'TO INDICATE ADDED DEMAND IS LENGTH PER TIME OR VOLUME PER TIME.')
                        END SELECT
                        !
                        CDAT%HAS_DEMAND_EXT = TRUE
                        !
      CASE ("TRANSPIRATION_FRACTION","FTR")
                        WRITE(BL%IOUT,'(A)') '   TRANSPIRATION_FRACTION (FTR)           KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        CALL CDAT%FTR%INIT('FTR',       LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                        !
      CASE ("EVAPORATION_IRRIGATION_FRACTION","FEI")
                        WRITE(BL%IOUT,'(A)') '   EVAPORATION_IRRIGATION_FRACTION (FEI)  KEYWORD FOUND. FIRST CHECKING "BY_IRRIGATE" OR "BY_CROP" FLAG, THEN LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        IF(CDAT%NIRRG > Z) THEN
                           !
                           CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                           !
                           SELECT CASE ( LINE(ISTART:ISTOP) )
                           CASE('BYIRRIGATE', 'BY_IRRIGATE','BYIRRIGATION',"BY_IRRIGATION")
                                           WRITE(BL%IOUT,'(3x 4A)') LINE(ISTART:ISTOP),' KEYWORD FOUND, SO IF USING LIST STYLE FOR EVAPORATION_IRRIGATION_FRACTION (FEI), THEN IT WILL EXPECT TO LOAD ', NUM2STR(CDAT%NIRRG), ' (NIRRIGATE) RECORDS.'
                                           CALL CDAT%FEI%INIT('FEI_BYIRR',      LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                           CASE('BYCROP',"BY_CROP")
                                           WRITE(BL%IOUT,'(3x 4A)') LINE(ISTART:ISTOP),' KEYWORD FOUND, SO IF USING LIST STYLE FOR EVAPORATION_IRRIGATION_FRACTION (FEI), THEN IT WILL EXPECT TO LOAD ', NUM2STR(CDAT%NCROP), ' (NCROP) RECORDS.'
                                           CALL CDAT%FEI%INIT('FEI_BYCROP',      LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                           CASE DEFAULT
                                           WRITE(BL%IOUT,'(3x 3A)') '"BY_IRRIGATE" OR "BY_CROP" FLAG NOT FOUND, ASSUMING IT IS NOT SPECIFIED AND WILL USE "BY_CROP", SO IF USING LIST STYLE FOR EVAPORATION_IRRIGATION_FRACTION (FEI), THEN IT WILL EXPECT TO LOAD ', NUM2STR(CDAT%NCROP), ' (NCROP) RECORDS.'
                                           LLOC = ISTART
                                           CALL CDAT%FEI%INIT('FEI_BYCROP',      LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                           END SELECT
                        ELSE
                            CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK: FOUND KEYWORD "EVAPORATION_IRRIGATION_FRACTION" WHEN NIRRIGATE = 0. THIS LINE WILL BE IGNORED AND THE EVAPORATION_IRRIGATION_FRACTION SET TO 0.0 FOR ALL CROPS.',CMD_PRINT=TRUE)
                        END IF
                        !!!WRITE(BL%IOUT,'(A)') '   EVAPORATION_IRRIGATION_FRACTION (FEI)  KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        !!!IF(CDAT%NIRRG > Z) THEN
                        !!!    CALL CDAT%FEI%INIT('FEI',       LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                        !!!ELSE
                        !!!    CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK: FOUND KEYWORD "EVAPORATION_IRRIGATION_FRACTION" WHEN NIRRIGATE = 0. THIS LINE WILL BE IGNORED AND THE EVAPORATION_IRRIGATION_FRACTION SET TO 0.0 FOR ALL CROPS.',CMD_PRINT=TRUE)
                        !!!END IF
                        !
                        !
      CASE ("EVAPORATION_IRRIGATION_FRACTION_SUM_ONE_CORRECTION")
                        WRITE(BL%IOUT,'(A)') '   EVAPORATION_IRRIGATION_FRACTION_SUM_ONE_CORRECTION KEYWORD FOUND. CHECKING FOR "STATIC", "TRANSIENT", OR "LIST" KEYWORD. IF NOT FOUND THEN OPTION IS APPLIED TO ALL CROPS.'
                        !
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        SELECT CASE(LINE(ISTART:ISTOP))
                        CASE("STATIC","TRANSIENT","LIST")
                                   LLOC = ISTART
                                   CALL CDAT%FEI_CHECK%INIT('FEI_CHECK',  LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z, SCRATCH=BL%SCRATCH)
                        CASE DEFAULT
                                   CALL CDAT%FEI_CHECK%INIT('FEI_CHECK', ONE,         BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
                        END SELECT
                        !
      CASE ("SURFACEWATER_LOSS_FRACTION_PRECIPITATION","FIESWP")
                        WRITE(BL%IOUT,'(A)') '   SURFACEWATER_LOSS_FRACTION_PRECIPITATION (FIESWP) KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        CALL CDAT%FIESWP%INIT('FIESWP', LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP, SCRATCH=BL%SCRATCH, CDIM=CDIM, NONEG=TRUE)
                        !
      CASE ("SURFACEWATER_LOSS_FRACTION_IRRIGATION","FIESWI")
                        WRITE(BL%IOUT,'(A)') '   SURFACEWATER_LOSS_FRACTION_IRRIGATION (FIESWI)    KEYWORD FOUND. FIRST CHECKING "BY_IRRIGATE" OR "BY_CROP" FLAG, THEN LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        IF(CDAT%NIRRG > Z) THEN
                           !
                           CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                           !
                           SELECT CASE ( LINE(ISTART:ISTOP) )
                           CASE('BYIRRIGATE', 'BY_IRRIGATE','BYIRRIGATION',"BY_IRRIGATION")
                                           WRITE(BL%IOUT,'(3x 4A)') LINE(ISTART:ISTOP),' KEYWORD FOUND, SO IF USING LIST STYLE FOR SURFACEWATER_LOSS_FRACTION_IRRIGATION (FIESWI), THEN IT WILL EXPECT TO LOAD ', NUM2STR(CDAT%NIRRG), ' (NIRRIGATE) RECORDS.'
                                           CALL CDAT%FIESWI%INIT('FIESWI_BYIRR', LLOC, LINE, BL%IOUT, BL%IU, CDAT%NIRRG, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                           CASE('BYCROP',"BY_CROP")
                                           WRITE(BL%IOUT,'(3x 4A)') LINE(ISTART:ISTOP),' KEYWORD FOUND, SO IF USING LIST STYLE FOR SURFACEWATER_LOSS_FRACTION_IRRIGATION (FIESWI), THEN IT WILL EXPECT TO LOAD ', NUM2STR(CDAT%NCROP), ' (NCROP) RECORDS.'
                                           CALL CDAT%FIESWI%INIT('FIESWI_BYCROP', LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                           CASE DEFAULT
                                           WRITE(BL%IOUT,'(3x 3A)') '"BY_IRRIGATE" OR "BY_CROP" FLAG NOT FOUND, ASSUMING IT IS NOT SPECIFIED AND WILL USE "BY_CROP", SO IF USING LIST STYLE FOR SURFACEWATER_LOSS_FRACTION_IRRIGATION (FIESWI), THEN IT WILL EXPECT TO LOAD ', NUM2STR(CDAT%NCROP), ' (NCROP) RECORDS.'
                                           LLOC = ISTART
                                           CALL CDAT%FIESWI%INIT('FIESWI_BYCROP', LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                           END SELECT
                        ELSE
                            CALL WARNING_MESSAGE(INFILE=BL%IU, OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK: FOUND KEYWORD "SURFACEWATER_LOSS_FRACTION_IRRIGATION" WHEN NIRRIGATE = 0. THIS LINE WILL BE IGNORED AND THE SURFACEWATER_LOSS_FRACTION_IRRIGATION SET TO 0.0 FOR ALL CROPS.',CMD_PRINT=TRUE)
                        END IF
      !
      !!!CASE ("PRECIP_CONSUMPTION_FRACTION", "PRECIPITATION_CONSUMPTION_FRACTION", "PCF")
      !!!                  WRITE(BL%IOUT,'(A)') '   PRECIPITATION_CONSUMPTION_FRACTION (PCF)       KEYWORD FOUND. FIRST CHECKING "BY_LENGTH" OR "BY_FRAC" KEYWORD. IF NOT PRESENT THEN DEFAULT TO "BY_FRAC".'
      !!!                  !
      !!!                  CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
      !!!                  !
      !!!                  SELECT CASE ( LINE(ISTART:ISTOP) )
      !!!                  CASE('BYLENGTH', 'BY_LENGTH','BYHEIGHT',"BY_HEIGHT")
      !!!                                  WRITE(BL%IOUT,'(3x 4A)') LINE(ISTART:ISTOP),' KEYWORD FOUND, SO IF USING LIST STYLE FOR SURFACEWATER_LOSS_FRACTION_IRRIGATION (FIESWI), THEN IT WILL EXPECT TO LOAD ', NUM2STR(CDAT%NIRRG), ' (NIRRIGATE) RECORDS.'
      !!!                                  CALL CDAT%CON_PRECIP_FRAC%INIT('PCF', LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM, NONEG=TRUE)
      !!!                                  CDAT%PCF_IS_FRAC = FALSE
      !!!                  CASE('BYFRAC',"BY_FRAC","BYFRACTION","BY_FRACTION")
      !!!                                  WRITE(BL%IOUT,'(3x 4A)') LINE(ISTART:ISTOP),' KEYWORD FOUND, SO IF USING LIST STYLE FOR SURFACEWATER_LOSS_FRACTION_IRRIGATION (FIESWI), THEN IT WILL EXPECT TO LOAD ', NUM2STR(CDAT%NCROP), ' (NCROP) RECORDS.'
      !!!                                  CALL CDAT%CON_PRECIP_FRAC%INIT('PCF', LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM, NONEG=TRUE)
      !!!                  CASE DEFAULT
      !!!                                  WRITE(BL%IOUT,'(3x 3A)') '"BY_LENGTH" OR "BY_FRAC" FLAG NOT FOUND, ASSUMING IT IS NOT SPECIFIED AND WILL USE "BY_FRAC".'
      !!!                                  LLOC = ISTART
      !!!                                  CALL CDAT%CON_PRECIP_FRAC%INIT('PCF', LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM, NONEG=TRUE)
      !!!                  END SELECT
      !!!                  !
      CASE ("GW_ROOT","GROUNDWATER_ROOT_INTERACTION") 
                        WRITE(BL%IOUT,'(A)') '   GROUNDWATER_ROOT_INTERACTION             KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        CALL CDAT%GW_INTER%INIT('GWRT',LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, BL%SCRATCH)
                        !
      CASE ("RELAXATION_FACTOR_HEAD_CHANGE")
                        WRITE(BL%IOUT,'(A)') '   GROUNDWATER_ROOT_RELAXATION_FACTOR       KEYWORD FOUND. NOW LOADING NUMBER BETWEEN 0 AND 1 WITH ULOAD.'
                        IU = Z
                        CALL ULOAD(CDAT%RELAX_FACT, LLOC, LINE, BL%IOUT, BL%IU, IU, SCRATCH=BL%SCRATCH)
                        !
      CASE ("POND_DEPTH")
                        WRITE(BL%IOUT,'(A)') '   POND_DEPTH             KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        CDAT%HAS_POND = TRUE
                        CALL CDAT%POND%INIT('POND',     LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, NONEG=TRUE)
                        !
      CASE ("SPECIFY_PRINT_ALL_CROP","SPECIFY_PRINT_ALL_CROPS")
                        WRITE(BL%IOUT,'(A)') '   SPECIFY_PRINT_CROP     KEYWORD FOUND. NOW USING ULOAD TO READ IN LIST OF CROP NAMES.'
                        IU = Z
                        CALL CDAT%PRINT_CROP%INIT('PRINT_CROP',LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z, BL%SCRATCH)
                        !
      CASE ("PRINT")
                        BINARY = FALSE
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        IF(LINE(ISTART:ISTOP) == 'BINARY') THEN
                            BINARY = TRUE
                            CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        END IF
                        !
                        SELECT CASE ( LINE(ISTART:ISTOP) )
                        CASE ("BYCROP")
                                          CALL CDAT%OUT_BYCROP%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("BYWBS","BYFARM")
                                          CALL CDAT%OUT_BYFARM%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("BYWBS_BYCROP", "BYWBSBYCROP","BYWBSCROP","BYFARM_BYCROP", "BYFARMBYCROP")
                                          CALL CDAT%OUT_BYFARMCROP%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("ALL_VERBOSE")
                                          CALL CDAT%OUT_DETAIL%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=1)
                        CASE ("ALL")
                                          CALL CDAT%OUT_ALL%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=1)
                        CASE ("BARE")
                                          CALL CDAT%OUT_BARE%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("INPUT")
                                          CALL CDAT%OUT_INPUT%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        !CASE ("ROOT")
                        !                  CALL CDAT%OUT_ROOT%OPEN(LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11)
                        !
                        CASE DEFAULT;     CALL STOP_ERROR(LINE,BL%IU,BL%IOUT,'FMP CROP BLOCK KEYWORD ERROR. IDENTIFIED KEYWORD "PRINT", BUT THE NEXT WORD WAS NOT IDENTIFIED.'//NL//'WORDS EXPECTED ARE: "BYFARM", "BYCROP", "BYFARM_BYCROP", "ALL", "ALL_VERBOSE, "BARE", "INPUT"')
                        END SELECT
                        !
      CASE ("CROPS_THAT_SPECIFY_SURFACE_ELEVATION")
                        WRITE(BL%IOUT,'(A)') '   CROPS_THAT_SPECIFY_SURFACE_ELEVATION KEYWORD FOUND. NOW LOADING LIST OF "NCROP_SPECIFIED_ELEVATIONS" CROP IDs (CID/LOCATIONs). IF THE CROP ID IS 0 (ZERO) THEN THE ELEVATION IS BARE LAND, OTHERWISE IT IS THE CROP ID SPECIFIED.)'
                        IF(FDIM%NCROP_ELEV < ONE) CALL WARNING_MESSAGE(INFILE=BL%IU, OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK: FOUND KEYWORD "CROPS_THAT_SPECIFY_SURFACE_ELEVATION" WHEN IN THE GLOBAL DIMENSION BLOCK THERE IS "NCROP_SPECIFIED_ELEVATIONS" = 0 (OR IT WAS NOT SPECIFIED). IT WILL BE ASSUMED THAT THIS VALUE IS NCROP, WHICH MAY CAUSE INPUT TO RAISE AN ERROR IF YOU DO NOT HAVE A LIST LENGTH OF NCROP INPUT.',INLINE=TRUE)
                        !
                        CALL CDAT%GSE_CID%INIT('GSE_CROPS',LLOC, LINE, BL%IOUT, BL%SCRATCH, CDAT%NCROP_ELEV, ONE, Z, Z, SCRATCH=BL%SCRATCH, NO_TRANSIENT=TRUE)
                        !
      CASE ("CROP_SURFACE_ELEVATION")
                        WRITE(BL%IOUT,'(A)') '   CROP_SURFACE_ELEVATION KEYWORD FOUND. NOW LOADING 2D ARRAY OF CROP ELEVATIONS. NOTE IF USING "MULTI_CROP_FRACTION" KEYWORD THEN ARRAY IS (NROW*NCROP_SPECIFIED_ELEVATIONS,NCOL).'
                        IF(FDIM%NCROP_ELEV < ONE) CALL WARNING_MESSAGE(INFILE=BL%IU, OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK: FOUND KEYWORD "CROP_SURFACE_ELEVATION" WHEN IN THE GLOBAL DIMENSION BLOCK THERE IS "NCROP_SPECIFIED_ELEVATIONS" = 0 (OR IT WAS NOT SPECIFIED). IT WILL BE ASSUMED THAT THIS VALUE IS NCROP, WHICH MAY CAUSE INPUT TO RAISE AN ERROR IF YOU ARE USING "FRACTIONS" AND NOT LOADING AN NCROP*NROW BY NCOL ARRAY.',INLINE=TRUE)
                        !
                        CALL CDAT%SPEC_GSE%INIT('GSE_SPEC',LLOC, LINE, BL%IOUT, BL%SCRATCH, Z, Z, ELV_NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP, SCRATCH=BL%SCRATCH, NO_TRANSIENT=TRUE)
                        !
      CASE ("CROP_SURFACE_ELEVATION_OFFSET")
                        WRITE(BL%IOUT,'(A)') '   CROP_SURFACE_ELEVATION_OFFSET KEYWORD FOUND. NOW LOADING LIST OF "NCROP_SPECIFIED_ELEVATIONS" ELEVATIONS TO OFFSET. (POSITIVE INDICATES MOVING SURFACE_ELEVATION UPWARD.)'
                        IF(FDIM%NCROP_ELEV < ONE) CALL WARNING_MESSAGE(INFILE=BL%IU, OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK: FOUND KEYWORD "CROP_SURFACE_ELEVATION_OFFSET" WHEN IN THE GLOBAL DIMENSION BLOCK THERE IS "NCROP_SPECIFIED_ELEVATIONS" = 0 (OR IT WAS NOT SPECIFIED). IT WILL BE ASSUMED THAT THIS VALUE IS NCROP, WHICH MAY CAUSE INPUT TO RAISE AN ERROR IF YOU DO NOT HAVE A LIST LENGTH OF NCROP INPUT.',INLINE=TRUE)
                        !
                        CALL CDAT%GSE_OFFSET%INIT('GSE_OFFSET',LLOC, LINE, BL%IOUT, BL%SCRATCH, CDAT%NCROP_ELEV, ONE, Z, Z, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP, SCRATCH=BL%SCRATCH, NO_TRANSIENT=TRUE)
                        !
      !CASE ("CROP_SURFACE_ELEVATION_FROM_SFR")
      !                  WRITE(BL%IOUT,'(A)') '   CROP_SURFACE_ELEVATION_FROM_SFR KEYWORD FOUND. NOW LOADING LIST OF "NCROP_SPECIFIED_ELEVATIONS" CROP IDs THAT WILL USE SFR TO GET ITS SURFACE ELEVATIONS.'
      !                  IF(FDIM%NCROP_ELEV < ONE) CALL WARNING_MESSAGE(INFILE=BL%IU, OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK: FOUND KEYWORD "CROP_SURFACE_ELEVATION_FROM_SFR" WHEN IN THE GLOBAL DIMENSION BLOCK THERE IS "NCROP_SPECIFIED_ELEVATIONS" = 0 (OR IT WAS NOT SPECIFIED). IT WILL BE ASSUMED THAT THIS VALUE IS NCROP, WHICH MAY CAUSE INPUT TO RAISE AN ERROR IF YOU DO NOT HAVE A LIST LENGTH OF NCROP INPUT.',INLINE=TRUE)
      !                  !IF(.NOT. CDAT%MULTI_CROP_CELLS) CALL STOP_ERROR(LINE,BL%IU,BL%IOUT,'FMP CROP BLOCK ERROR. CROPS ARE DEFINED AS BY CROP ID (NO FRACTIONS OF CELLS CONTAINING CROPS), SO YOU SHOULD READ IN A CROP LOCATION (CID) ARRAY WITH KEYWORD LOCATION AND REMOVE KEYWORD FRACTION.')
      !                  CALL CDAT%GSE_SFR%INIT('GSE_SFR',LLOC, LINE, BL%IOUT, BL%SCRATCH, CDAT%NCROP_ELEV, ONE, Z, Z, SCRATCH=BL%SCRATCH, NO_TRANSIENT=TRUE)
      !                  !
      CASE DEFAULT
                        CALL WARN%ADD('FOUND UNKNOWN KEYWORD "'//LINE(ISTART:ISTOP)//'" ***IT WILL BE IGNORED***'//BLN)
                        
      END SELECT
      !
      !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
      CALL BL%READ_SCRATCH(EOF, LINE)
      !
    END DO
    !
    CALL WARN%CHECK(HED='FMP CROP BLOCK'//NL,INFILE=BL%IU,OUTPUT=BL%IOUT,INLINE=TRUE,CMD_PRINT=TRUE,TAIL=NL, INIT=TRUE)
    !
    END IF
    !
    IF(CDAT%MULTI_CROP_CELLS) THEN
        WRITE(CDAT%IOUT,'(//A)') 'LAND USE/CROP MODEL ALLLOWS FOR MORE THEN ONE CROP PER MODEL CELL. THIS MODIFIES ARRAY INPUT TO EXPECT A SIZE OF NCROP*NROW x NCOL (ONE ARRAY PER CROP THAT IS READ AS ONE GIANT ARRAY)'
    ELSE
        WRITE(CDAT%IOUT,'(//A)') 'LAND USE/CROP MODEL SPECIFIES AT MOST ONE CROP PER MODEL CELL. THE CROP LOCATION IS IDENTIFIED WTIH THE KEYWORD LOCATION.'
    END IF
    WRITE(CDAT%IOUT,'(//A/)' )'CROP PROPERTIES LOADED: '
    IF( CDAT%CID%INUSE       ) WRITE(CDAT%IOUT,'(A)') 'CROP ID (LOCATION)'
    IF(CDAT%MULTI_CROP_CELLS) THEN
        IF( CDAT%FRAC%INUSE ) WRITE(CDAT%IOUT,'(A)') 'LAND_USE_AREA_FRACTION WITH MULTIPLE_LAND_USE_PER_CELL IS READ AS AS NCROP*NROW x NCOL FRACTION ARRAYS'
    ELSE
        IF( CDAT%FRAC%INUSE ) WRITE(CDAT%IOUT,'(A)') 'LAND_USE_AREA_FRACTION WITH SINGLE_LAND_USE_PER_CELL DEFINES THE FRACTION OF AREA THAT EACH CROP OCCUPIES'
    END IF
    IF( CDAT%IRR%INUSE       ) WRITE(CDAT%IOUT,'(A)') 'IRRIGATION FLAG'
    IF( CDAT%ROOT%INUSE      ) WRITE(CDAT%IOUT,'(A)') 'ROOT DEPTH'
    IF( CDAT%PSI%INUSE       ) WRITE(CDAT%IOUT,'(A)') 'ROOT PRESSURES'
    IF( CDAT%Kc%INUSE        ) WRITE(CDAT%IOUT,'(A)') 'CROP COEFFICIENT'
    IF( CDAT%CF%INUSE        ) WRITE(CDAT%IOUT,'(A)') 'CONSUMPTIVE USE QUANTITY'
    IF( CDAT%FTR%INUSE       ) WRITE(CDAT%IOUT,'(A)') 'FRACTION OF TRANSPIRATION'
    IF( CDAT%FEI%INUSE       ) WRITE(CDAT%IOUT,'(A)') 'FRACTION OF EVAPORATION FROM IRRIGATION'
    IF( CDAT%FIESWP%INUSE    ) WRITE(CDAT%IOUT,'(A)') 'FRACTION OF INEFFICIENT LOSSES FROM PRECIPITATION'
    IF( CDAT%FIESWI%INUSE    ) WRITE(CDAT%IOUT,'(A)') 'FRACTION OF INEFFICIENT LOSSES FROM IRRIGATION'
    IF( CDAT%GW_INTER%INUSE  ) WRITE(CDAT%IOUT,'(A)') 'ROOT-GROUNDWATER INTERACTION FLAG'
    IF( CDAT%POND%INUSE      ) WRITE(CDAT%IOUT,'(A)') 'PONDING WATER DEPTH BEFORE PLANT DEATH/DROWNING'
    IF( CDAT%ADMD%INUSE      ) WRITE(CDAT%IOUT,'(A)') 'ADDED_DEMAND THAT IS ADDITIONALLY DEMANDED WATER FOR IRRIGATED CROP THAT BECOMES EITHER DEEP PEROCOLATION OR RUNOFF'
    IF( CDAT%GSE_CID%INUSE   ) WRITE(CDAT%IOUT,'(A)') 'CROP IDs THAT WILL HAVE THEIR GSE SPECIFIED AND NOT USE THE GLOBAL DIMENSION SURFACE_ELEVATION.'
    IF( CDAT%SPEC_GSE%INUSE  ) WRITE(CDAT%IOUT,'(A)') 'HAS SPECIFIED FOR CERTAIN CROPS THEIR SURFACE_ELEVATIONS.'
    IF( CDAT%GSE_OFFSET%INUSE) WRITE(CDAT%IOUT,'(A)') 'HAS SPECIFIED FOR CERTAIN CROPS THEIR AN OFFSET FROM THE GLOBAL DIMENSION SURFACE_ELEVATION.'
    !IF( CDAT%GSE_SFR%INUSE   ) WRITE(CDAT%IOUT,'(A)') 'HAS SPECIFIED CROPS LOCATED IN CELL WITH SFR SEGMENT/REACH USE THE ELEVATION SPECIFIED BY SFR.'
    
    WRITE(CDAT%IOUT,'(//A/)')'CROP PROPERTIES NOT USED IN SIMULATION: '
    !
    IF( .NOT. CDAT%CID%INUSE .AND. .NOT. CDAT%MULTI_CROP_CELLS) WRITE(CDAT%IOUT,'(A)') 'CROP ID (LOCATION)'
    !
    IF( .NOT. CDAT%FRAC%INUSE      ) WRITE(CDAT%IOUT,'(A)') 'LAND_USE_AREA_FRACTION'
    IF( .NOT. CDAT%IRR%INUSE       ) WRITE(CDAT%IOUT,'(A)') 'IRRIGATION FLAG'
    IF( .NOT. CDAT%ROOT%INUSE      ) WRITE(CDAT%IOUT,'(A)') 'ROOT DEPTH'
    IF( .NOT. CDAT%PSI%INUSE       ) WRITE(CDAT%IOUT,'(A)') 'ROOT PRESSURES'
    IF( .NOT. CDAT%Kc%INUSE        ) WRITE(CDAT%IOUT,'(A)') 'CROP COEFFICIENT'
    IF( .NOT. CDAT%CF%INUSE        ) WRITE(CDAT%IOUT,'(A)') 'CONSUMPTIVE USE QUANTITY'
    IF( .NOT. CDAT%FTR%INUSE       ) WRITE(CDAT%IOUT,'(A)') 'FRACTION OF TRANSPIRATION'
    IF( .NOT. CDAT%FEI%INUSE       ) WRITE(CDAT%IOUT,'(A)') 'FRACTION OF EVAPORATION FROM IRRIGATION'
    IF( .NOT. CDAT%FIESWP%INUSE    ) WRITE(CDAT%IOUT,'(A)') 'FRACTION OF INEFFICIENT LOSSES FROM PRECIPITATION'
    IF( .NOT. CDAT%FIESWI%INUSE    ) WRITE(CDAT%IOUT,'(A)') 'FRACTION OF INEFFICIENT LOSSES FROM IRRIGATION'
    IF( .NOT. CDAT%GW_INTER%INUSE  ) WRITE(CDAT%IOUT,'(A)') 'ROOT-GROUNDWATER INTERACTION FLAG, AUTOMATICALLY SETTING FOR FULL GROUNDWATER_ROOT INTERACTION (LEVEL 2)'
    IF( .NOT. CDAT%POND%INUSE      ) WRITE(CDAT%IOUT,'(A)') 'PONDING WATER DEPTH BEFORE PLANT DEATH/DROWNING'
    IF( .NOT. CDAT%ADMD%INUSE      ) WRITE(CDAT%IOUT,'(A)') 'ADDED_DEMAND THAT IS ADDITIONALLY DEMANDED WATER FOR IRRIGATED CROP THAT BECOMES EITHER DEEP PEROCOLATION OR RUNOFF'
    IF( .NOT. CDAT%GSE_CID%INUSE   ) WRITE(CDAT%IOUT,'(A)') 'CROP IDs THAT WILL HAVE THEIR GSE SPECIFIED AND NOT USE THE GLOBAL DIMENSION SURFACE_ELEVATION.'
    IF( .NOT. CDAT%SPEC_GSE%INUSE  ) WRITE(CDAT%IOUT,'(A)') 'HAS SPECIFIED FOR CERTAIN CROPS THEIR SURFACE_ELEVATIONS.'
    IF( .NOT. CDAT%GSE_OFFSET%INUSE) WRITE(CDAT%IOUT,'(A)') 'HAS SPECIFIED FOR CERTAIN CROPS THEIR AN OFFSET FROM THE GLOBAL DIMENSION SURFACE_ELEVATION.'
    !IF( .NOT. CDAT%GSE_SFR%INUSE   ) WRITE(CDAT%IOUT,'(A)') 'HAS SPECIFIED CROPS LOCATED IN CELL WITH SFR SEGMENT/REACH USE THE ELEVATION SPECIFIED BY SFR.'
    !
    WRITE(CDAT%IOUT,'(/2A/)') 'RELAXATION FACTOR APPLIED TO THE PICARD/NETWON ITERATION HEAD CHANGE WHEN DETERMINING GROUNDWATER-ROOT UPTAKE IS: ', NUM2STR(CDAT%RELAX_FACT)
    !
    ! Set up minimum bare fraction of area
    !
    IF( .NOT. CDAT%FRAC%INUSE .AND. CDAT%MIN_BARE > NEAR_inf ) CDAT%MIN_BARE=UNO         !NEVER IS NEEDED
    IF(       CDAT%Kc%INUSE   .AND. CDAT%MIN_BARE > NEAR_inf ) CDAT%MIN_BARE=NEARZERO_12 !KNOWN THAT ETR IS DEFINED
    !
    IF(CDAT%MIN_BARE<NEARZERO_30 ) CDAT%MIN_BARE=NEARZERO_30
    IF(CDAT%MIN_BARE<UNO) THEN
        WRITE(CDAT%IOUT,'(/2A, /A/)') 'MINIMUM BARE FRACTION IS: ', NUM2STR(CDAT%MIN_BARE),'ANY FRACTIONS LESS THAN THIS WILL BE AUTOMATICALLY SET TO ZERO.'
    ELSEIF(CDAT%MIN_BARE < NEAR_inf) THEN
        WRITE(CDAT%IOUT,'(4(/A), /)') 'MINIMUM BARE FRACTION IS GREATER THAN 1.0,','SO SOIL EVAPORATION, DEEP PERCOLATION, AND SURFACE RUNOFF ON BAR SOIL/FALLOW CROPS WILL NOT BE CALCULATED.','PRECIPITATION THAT FALLS ON BARE SOIL/FALLOW CROPS IS REMOVED FROM MODEL.','THIS EFFECTS CELLS WITH CROP IDs EQUAL TO ZERO OR CROP FRACTIONS DO NOT SUM TO ONE FOR A MODEL CELL.'
    END IF
    !
    !CALL CDAT%PARSE_CROP_ROW_COL()  !POPULATE CDAT%CROP%RC
    !CALL CDAT%SETUP_FID(IFID)      !POPULATE CDAT%CROP%FID
    !
    IF(.NOT. CDAT%GSE_CID%INUSE .AND. (CDAT%SPEC_GSE%INUSE .OR. CDAT%GSE_OFFSET%INUSE)) THEN !.OR. CDAT%GSE_SFR%INUSE
        CALL WARNING_MESSAGE(INFILE=BL%IU, OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK: FAILED TO FIND TO FIND KEYWORD "CROPS_THAT_SPECIFY_SURFACE_ELEVATION" WHEN ONE OF THE CUSTOM ELEVATION KEYWORDS WERE USED. IT WILL BE ASSUMED THERE IS A ONE TO ONE MAPPYING OF CROP IDs TO THE CUSTOM ELEVATIONS. THIS WILL RESULT IN ALL CROPS USING CUSTOM ELEVATIONS (e.g ALL CROPS ARE MATCHED TO ARRAY INPUT AND FOR LIST INPUT THE FIRST RECORD IS FOR CROP 1, SECOND RECORD IS CROP 2...AND SO FORTH.',INLINE=TRUE)
        !
        CALL CDAT%GSE_CID%INIT('GSE_CROPS', ONE, BL%IOUT, BL%SCRATCH, CDAT%NCROP_ELEV, ONE, Z, Z)
        DO CONCURRENT (I=ONE:CDAT%NCROP_ELEV); CDAT%GSE_CID%LIST(I) = I
        END DO
    END IF
    !
    IF (CDAT%Kc%INUSE .AND. CDAT%CF%INUSE)  CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FYI - FMP CROP BLOCK: CROP COEFICIENTS AND CROP CONSUMPTIVE USE ARE BOTH SPECIFIED IN BLOCK.'//NL//'THESE TWO VALUES ARE ADDED TO GET THE FINAL CONSUMPTIVE USE. IN OTHERWORDS THIS MEANS:'//BLN//'CUfinal = CU*AREA + Kc*ETref*AREA',INLINE=TRUE)
      !WRITE(BL%IOUT,'(/,3(A/),/)') 'FMP CROP BLOCK WARNING: CROP COEFICIENTS AND CROP CONSUMPTIVE USE ARE BOTH SPECIFIED IN BLOCK.','THESE TWO VALUES ARE ADDED TO GET THE FINAL CONSUMPTIVE USE THIS MEANS:','CUfinal = CU*AREA + Kc*ETref*AREA'
    !
    !   (CDAT%MULTI_CROP_CELLS .AND. CDAT%FRAC%TRANSIENT)
    IF( .NOT. CDAT%MULTI_CROP_CELLS .AND. .NOT. CDAT%CID%INUSE ) CALL WARN%ADD(NL//'FMP CROP BLOCK: WHEN KEYWORD "SINGLE_LAND_USE_PER_CELL" IS USED, THEN WHEN NCROP > 0 THE KEYWORD "LOCATION" MUST BE DEFINED TO INDICATE THE LOCATION OF CROPS.'//NL)
    !
    IF(.NOT. CDAT%GW_INTER%INUSE) THEN
        CDAT%GW_ROOT_INTERACTION = TRUE
        !
        CALL CDAT%GW_INTER%INIT('GWRT',5, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL)  !DEFUALT TO FULL INTERACTION
    END IF
    !
    IF(.NOT. CDAT%ROOT%INUSE .AND. CDAT%GW_ROOT_INTERACTION)  CALL WARN%ADD(NL//'FMP CROP ERROR. THERE IS INTERACTION BETWEEN THE THE CROP ROOTS AND GROUNDWATER LEVEL TO CALCULATE TRANSPIRATION (DEFAULT BEHAIVOR).'//NL//'THIS REQUIRES THE CROP ROOT DEPTH TO BE SPECIFRIED WITH "ROOT DEPTH" OR "ROOT_DEPTH" KEYWORD IN CROP BLOCK.'//NL//'EITHER SPECIFY ROOT DEPTHS OR USE KEYWORD "GROUNDWATER_ROOT_INTERACTION"'//NL//'AND SET ALL VALUES TO ONE TO DISABLE ANY GROUNDWATER ROOT INTERACTION'//NL//'(THUS NEGATING THE NEED FOR SPECIFYING ROOT DEPTHS).'//NL)
    !
    CALL WARN%CHECK(INFILE=BL%IU,OUTPUT=CDAT%LOUT, KILL=TRUE) !FOUND FATAL ERRORS
    !
    IF( .NOT. CDAT%CF%INUSE   .AND. .NOT. CDAT%Kc%INUSE  ) CALL WARN%ADD(NL//'FMP CROP BLOCK: FAILED TO LOCATE "CROP_COEFFICIENT" OR "CONSUMPTIVE_USE" KEYWORD IN CROP BLOCK, POTENTIAL CONSUMPTIVE USE IS SET TO ZERO FOR ALL TIME                                       (i.e. CONSUMPTIVE_USE=0.0)'//NL)
    !
    IF( .NOT. CDAT%IRR%INUSE    .AND.     CDAT%NIRRG > Z ) CALL WARN%ADD(NL//'FMP CROP BLOCK: FAILED TO LOCATE "IRRIGATION" KEYWORD IN CROP BLOCK, EVEN THOUGH NIRRIGATE > 0, IT WILL BE AUTOMATICALLY SET TO 0 FOR ALL CROPS                                            (i.e. IRRIGATION=0)'//NL)
    IF( .NOT. CDAT%FEI%INUSE    .AND.     CDAT%NIRRG > Z ) CALL WARN%ADD(NL//'FMP CROP BLOCK: FAILED TO LOCATE "EVAPORATION_IRRIGATION_FRACTION" (OR "FEI") KEYWORD IN CROP BLOCK, EVEN THOUGH NIRRIGATE > 0, IT WILL BE AUTOMATICALLY SET TO -1 FOR ALL CROPS           (i.e. FEI=1-FTR)'//NL)
    !
    IF( .NOT. CDAT%FTR%INUSE    )                          CALL WARN%ADD(NL//'FMP CROP BLOCK: FAILED TO LOCATE "TRANSPIRATION_FRACTION" (OR "FTR") KEYWORD IN CROP BLOCK, THIS WILL AUTOMATICALLY BE SET TO ZERO MAKING THE ENTIRE MODEL BARE SOIL                       (i.e. FTR=0.0).'//NL)
    IF( .NOT. CDAT%FIESWI%INUSE .AND.     CDAT%NIRRG > Z ) CALL WARN%ADD(NL//'FMP CROP BLOCK: FAILED TO LOCATE "SURFACEWATER_LOSS_FRACTION_IRRIGATION" (OR "FIESWI") KEYWORD IN CROP BLOCK, EVEN THOUGH NIRRIGATE > 0, IT WILL BE AUTOMATICALLY SET TO 0.0 FOR ALL CROPS TO FORCE ALL EXCESS IRRIGATED WATER TO INFILTRATE (i.e. FIESWI=0.0)'//NL)
    IF( .NOT. CDAT%FIESWP%INUSE )                          CALL WARN%ADD(NL//'FMP CROP BLOCK: FAILED TO LOCATE "SURFACEWATER_LOSS_FRACTION_PRECIPITATION" (OR "FIESWP") KEYWORD IN CROP BLOCK, IT WILL BE AUTOMATICALLY SET TO 1.0 FOR ALL CROPS, IF SFR IS NOT AVAILIBLE THEN IT WILL BE AUTOMATICALLY SET TO 0.0 (IF SFR := FIESWP=1.0, ELSE FIESWP=0.0)'//NL)
    !
    CALL WARN%CHECK(INFILE=BL%IU,OUTPUT=CDAT%LOUT) !FOUND WARNINGS
    !
    IF(CDAT%PSI%INUSE) THEN
        WRITE(CDAT%IOUT,'(//8x A/,A/)') '--- FMP CROP CONSUMPTIVE USE WILL USE CONCEPT ONE ---','--- FMP WILL USE 4 POINT ROOT PRESSURES AND SOIL PROPERTIES TO DETERMINE CROP TRANPIRATION AND ROOT UPTAKE --'
    ELSE
        WRITE(CDAT%IOUT,'(//8x A/,A/)') '--- FMP CROP CONSUMPTIVE USE WILL USE CONCEPT TWO ---','--- FMP WILL USE GROUDNWATER LEVEL TO DETERMINE CROP TRANPIRATION AND ROOT UPTAKE --'
    END IF
    !
    IF( .NOT. CDAT%CF%INUSE .AND. .NOT. CDAT%Kc%INUSE  )   CALL CDAT%CF%INIT('CF', DZ, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
    !
    IF( .NOT.       CDAT%IRR%INUSE ) THEN
                                     CALL CDAT%IRR%INIT('IRR', Z, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL)
    END IF
    !
    IF( .NOT.       CDAT%FEI%INUSE ) CALL CDAT%FEI%INIT('FEI_BYCROP', DNEG, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
    !    
    IF( .NOT.    CDAT%FIESWP%INUSE .AND. HAS_SFR) CALL CDAT%FIESWP%INIT('FIESWP', 0.8D0, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
    IF( .NOT.    CDAT%FIESWP%INUSE              ) CALL CDAT%FIESWP%INIT('FIESWP',    DZ, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
    !
    IF( .NOT.    CDAT%FIESWI%INUSE ) CALL CDAT%FIESWI%INIT('FIESWI_BYCROP', DZ, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
    !
    IF(.NOT. CDAT%PRINT_CROP%INUSE ) CALL CDAT%PRINT_CROP%INIT('PRINT_CROP', ONE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
    !
    !IF(.NOT. CDAT%FEI_CHECK%INUSE ) CALL CDAT%FEI_CHECK%INIT('FEI_CHECK', Z,         BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
    !
    IF(.NOT.       CDAT%ADMD%INUSE ) THEN
                            CALL CDAT%ADMD%INIT('ADMD', DZ, BL%IOUT, BL%IU, CDAT%NCROP, FDIM%NFARM, Z, Z, LISTARRAY=TRUE)
                            CDAT%DEMAND_EXT_FLUX = FALSE
    END IF
    !
    !!!IF( .NOT.    CDAT%CON_PRECIP_FRAC%INUSE ) CALL CDAT%CON_PRECIP_FRAC%INIT('PCF', UNO, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
    !
  END SUBROUTINE 
  !
  SUBROUTINE SETUP_NEXT_TIME_STEP(CDAT, WBS)
    CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),     INTENT(INOUT):: WBS
    !
    IF(CDAT%NCROP > Z) CALL CDAT%SETUP_CROP_EFFICIENCY(WBS,TRUE)
    !
    CDAT%RELAX = CDAT%RELAX_FACT
    !
  END SUBROUTINE
  !
  SUBROUTINE SETUP_NEXT_STRESS_PERIOD(CDAT, WBS, CLIM, SOIL, LOAD)
    !
    !  NOTE THAT WBS%IRR_AREA, AND WBS%CROP ARE POPULATED HERE!
    !
    CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),     INTENT(INOUT):: WBS
    TYPE(CLIMATE_DATA), INTENT(IN   ):: CLIM
    TYPE(SOIL_DATA),    INTENT(IN   ):: SOIL
    LOGICAL, OPTIONAL,  INTENT(IN   ):: LOAD !WHEN NOT PRESENT SET TRUE..THIS ALLOWS THE SUBROUTINE TO BE CALLED WITH OUT RUNNING THE NEXT() METHODS. THUS REINITIALIZTING ALL THE ARRAYS VALUES
    DOUBLE PRECISION:: P
    INTEGER:: I, K, R, C
    LOGICAL:: UPDATE, LOAD_NEXT, NEW_IRR!, HAS_CON_PRECIP_FRAC
    TYPE(WARNING_TYPE):: WRN
    CHARACTER(:),ALLOCATABLE:: ERROR
    LOGICAL, DIMENSION(CDAT%NCROP):: PRNT
    !
    ERROR = NL
    !
    CALL WRN%INIT()
    !
    IF(CDAT%NCROP == Z) THEN !-----------------------------------------------------------------------------------------------------------
        IF( .NOT. ALLOCATED(CDAT%ETOT)) THEN
            !
            CDAT%CHECK_BARE = CLIM%HAS_BARE_REF_ET
            CDAT%NCOL = WBS%NCOL
            CDAT%NROW = WBS%NROW
            !
            IF(CDAT%CHECK_BARE .AND. (.NOT. SOIL%HAS_SOIL .OR. .NOT. SOIL%HAS_FRINGE))  THEN
                CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP. EITHER NSOIL = 0 OR CAPILARY FRINGE WAS NOT SPECIFIED IN SOIL BLOCK, YET THE CLIMATE BLOCK SPECIFIED EITHER REFERENCE ET AND/OR BARE SOIL EVAPORATION INDICATING SIMULATION OF BARE SOIL EVAPORATION. THIS WILL BE DISABLED BECAUSE IT REQUIRES A CAPILARY FRINGE FOR EVAPORATION CALCULATIONS.')
                CDAT%CHECK_BARE = FALSE
            END IF
            !
            ALLOCATE(CDAT%TTOT(CDAT%NCOL,CDAT%NROW), CDAT%TGWA(CDAT%NCOL,CDAT%NROW),CDAT%ETOT(CDAT%NCOL,CDAT%NROW), CDAT%EGWA(CDAT%NCOL,CDAT%NROW), SOURCE=DZ) !AUTO ALLOCATES ALL TO ZERO
            !
            IF(CDAT%CHECK_BARE) ALLOCATE(CDAT%BARE_FRAC(CDAT%NCOL,CDAT%NROW), CDAT%BARE_FRAC_RUNOFF(CDAT%NCOL, CDAT%NROW), SOURCE=DZ)  !, CDAT%BARE_FRAC_PRECIP(CDAT%NCOL, CDAT%NROW)
        END IF
        !
        IF(.NOT. CDAT%TFR_READ) THEN
            CDAT%TFR_READ = TRUE
            WBS%IRR_AREA = DZ
        END IF
        !
        IF(CDAT%CHECK_BARE) THEN
                                CALL WBS%SETUP_FALLOW_FRACTION_ARRAY(WBS%BARE_FRAC_RUNOFF, CDAT%BARE_FRAC_RUNOFF, TRUE)
                                !CALL WBS%SETUP_FALLOW_FRACTION_ARRAY(WBS%BARE_FRAC_PRECIP, CDAT%BARE_FRAC_PRECIP, TRUE)
                                !
                                WHERE (WBS%FID_ARRAY > Z) 
                                                     CDAT%BARE_FRAC = UNO
                                                    !CDAT%BARE_FRAC_PRECIP = UNO
                                ELSEWHERE
                                                     CDAT%BARE_FRAC = DZ
                                                     !CDAT%BARE_FRAC_PRECIP = DZ
                                END WHERE
                                !
                                ! SET UP BARE ELEVATIONS
                                CALL SETUP_CROP_ELEVATION(CDAT, WBS)
        END IF
        !
    ELSE!--------------------------------------------------------------------------------------------------------------------------------
        !
        IF(CDAT%TFR_READ) THEN
            !
            IF(PRESENT(LOAD)) THEN; LOAD_NEXT = LOAD
            ELSE;                   LOAD_NEXT = TRUE
            END IF
            !
            IF(LOAD_NEXT) THEN  !FIRST INITIALIZED IN INIT ROUTINE FOR SP1 DUE TO POTENTIAL STATIC FLAG
                              CALL CDAT%CID   %NEXT()
                              CALL CDAT%FRAC  %NEXT()
                              CALL CDAT%IRR   %NEXT()
                              CALL CDAT%ROOT  %NEXT()
                              CALL CDAT%Kc    %NEXT()  !MUST BE BEFORE CF%NEXT
                              CALL CDAT%CF    %NEXT()
                              CALL CDAT%FTR   %NEXT()
                              CALL CDAT%FEI   %NEXT()
                              CALL CDAT%FIESWP%NEXT()
                              CALL CDAT%FIESWI%NEXT()
                              CALL CDAT%PSI   %NEXT()
                              CALL CDAT%POND  %NEXT()
                              CALL CDAT%ADMD  %NEXT()
                              CALL CDAT%GW_INTER       %NEXT()
                              CALL CDAT%PRINT_CROP     %NEXT()
                              CALL CDAT%FEI_CHECK      %NEXT()
                              !!!CALL CDAT%CON_PRECIP_FRAC%NEXT()
                              CALL CDAT%ZERO_CU_TO_BARE%NEXT()
                              !
                              UPDATE = CDAT%CID%TRANSIENT .OR. (CDAT%MULTI_CROP_CELLS .AND. CDAT%FRAC%TRANSIENT) .OR. WBS%NEW_FID
            ELSE
                              UPDATE = FALSE
            END IF
            !
            !
        ELSE
            CDAT%HAS_PSI = FALSE
            !
            IF(CDAT%PSI%INUSE) THEN
                IF(CDAT%PSI%TRANSIENT .OR. ANY(NOT_NEAR_ZERO(CDAT%PSI%ARRAY,NEARZERO_12))) CDAT%HAS_PSI = TRUE
            END IF
            !
            IF (CDAT%Kc%INUSE         .AND. .NOT.CLIM%HAS_REF_ET     )  CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG='FMP CROP ERROR. "COEFFICIENT" KEYWORD FOUND IN CROP BLOCK, WHICH REQUIRES "REFERENCE_ET" TO BE SPECIFIED IN THE CLIMATE BLOCK. PLEASE INCLUDE REFERENCE ET OR SWITCH TO SPECIFYING CUNSUMPTIVE USE VALUES WITH "CONSUMPTIVE" KEYWORD.')
            IF (CDAT%MULTI_CROP_CELLS .AND. .NOT.CLIM%HAS_BARE_REF_ET)  CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG='FMP CROP ERROR. CROP BLOCK SPECIFIED KEYWORD "FRACTION" WHICH REQUIRES THAT THE CLIMATE BLOCK SPECIFY EITHER A THE KEYWORD "REFERENCE_ET" OR "POTENTIAL_EVAPORATION_FALLOW" SO THAT EVAPORATION OF PRECIPITATION AND/OR GROUNDWATER OVER BARE/FALLOW LAND CAN BE CALCULATED.')
            !
            IF(CDAT%MIN_BARE > NEAR_inf .AND. CLIM%HAS_BARE_REF_ET) THEN
                CDAT%MIN_BARE = NEARZERO_12  ! Enable MIN_BARE if undefined and BARE_REF_ET is defined
                WRITE(CDAT%IOUT,'(/2A, /A/)') 'MINIMUM BARE FRACTION IS: ', NUM2STR(CDAT%MIN_BARE),'ANY FRACTIONS LESS THAN THIS WILL BE AUTOMATICALLY SET TO ZERO.'
            END IF
            !
            IF(.NOT. SOIL%HAS_SOIL)  CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG='FMP CROP ERROR. CROP BLOCK IN USE BUT SOIL BLOCK WAS EITHER NOT SPECIFIED OR NSOIL = 0, YOU MUST SPECIFY AT LEAST ONE SOIL TYPE AND A CAPILARY FRINGE WHERE EVER THERE IS A CROP GROWN.')
            IF(.NOT. SOIL%HAS_FRINGE)CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG='FMP CROP ERROR. CROP BLOCK IN USE BUT SOIL BLOCK DID NOT SPECIFY A "CAPILLARY_FRINGE". YOU MUST SPECIFY AT LEAST ONE SOIL TYPE AND A CAPILARY FRINGE WHERE EVER THERE IS A CROP GROWN.')
            !
            IF(      SOIL%HAS_SOIL_COEF .AND. CDAT%HAS_PSI) THEN; WRITE(CDAT%LOUT,'(/A,/A/)') 'SOIL COEFICENTS AND CROP STRESS RESPONSE PRESSURES SPECIFIED.','FMP CROP CONSUMPTIVE USE CONCEPT ONE WILL BE USED'
            ELSE;                                                 WRITE(CDAT%LOUT,'(/A,/A/)') 'EITHER SOIL COEFICENTS AND/OR CROP STRESS RESPONSE PRESSURES --NOT-- SPECIFIED.','FMP CROP CONSUMPTIVE USE CONCEPT TWO WILL BE USED'
            END IF
            IF(.NOT. SOIL%HAS_SOIL_COEF .AND. CDAT%HAS_PSI) CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG='FMP SOIL AND CROP ERROR. CROP BLOCK SPECIFIED THE FOUR WATER STRESS RESPONSE FUNCTION PRESSURES (PSI1, PSI2, PSI3, PSI4) WITH KEYWORD "ROOT PRESSURE", BUT SOIL BLOCK DID NOT CONTAIN THE "COEFFICIENT" KEYWORD TO SPECIFY THE SOIL COEFICIENTS A, B, C, D, AND E (OR WITH KEYWORDS "SILT", "SANDYLOAM", OR "SILTYCLAY").')
            IF(CDAT%HAS_POND            .AND. CDAT%HAS_PSI) CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK SPECIFIED "POND" KEYWORD AND THE FOUR WATER STRESS RESPONSE FUNCTION PRESSURES (PSI1, PSI2, PSI3, PSI4) WITH KEYWORD "ROOT PRESSURE" WHICH INDICATES CONCEPT 1.'//NL//'POND DEPTH IS ONLY APPLIED TO CROPS THAT USE CONCEPT 2'//NL//'WHICH OCCURS ONLY WHEN ALL FOUR PRESSURES SET TO ZERO'//NL//'(viz. [PSI1, PSI2, PSI3, PSI4] = [0,0,0,0]).', INLINE=TRUE)
            !WRITE(CDAT%LOUT,'(/A,/A/)')  'FMP CROP WARNING. CROP BLOCK SPECIFIED "POND" KEYWORD AND THE FOUR WATER STRESS RESPONSE FUNCTION PRESSURES (PSI1, PSI2, PSI3, PSI4) WITH KEYWORD "ROOT PRESSURE" WHICH INDICATES CONCEPT 1.','POND DEPTH IS ONLY APPLIED TO CROPS THAT USE CONCEPT 2, WHICH OCCURS ONLY WHEN ALL FOUR PRESSURES SET TO ZERO (viz. [PSI1, PSI2, PSI3, PSI4] = [0,0,0,0]).' !CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG='FMP CROP ERROR. CROP BLOCK SPECIFIED "POND" KEYWORD AND THE FOUR WATER STRESS RESPONSE FUNCTION PRESSURES (PSI1, PSI2, PSI3, PSI4) WITH KEYWORD "ROOT PRESSURE". THESE TWO FEATURES CAN NOT BE TURNED ON AT THE SAME TIME. PLEASE REMOVE THE PONDING DEPTH OR ROOT PRESSURES.')
            !IF(      SOIL%HAS_SOIL_COEF .AND. .NOT. CDAT%PSI%INUSE) CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG='FMP SOIL AND CROP ERROR. SOIL BLOCK SPECIFIED SOIL COEFICIENTS WITH "COEFFICIENT" KEYWORD WHICH REQUIRES THAT CROP BLOCK INCLUDE "ROOT PRESSURE" KEYWORD TO SEPCIFY THE FOUR WATER STRESS RESPONSE FUNCTION PRESSURES (PSI1, PSI2, PSI3, PSI4).')
            !
            CDAT%TFR_READ = TRUE
            UPDATE        = TRUE
            LOAD_NEXT     = TRUE
            !
            IF(CDAT%MIN_BARE .GE. UNO) CDAT%BARE_FRAC  = DZ  !NEVER SIMULATE BARE SOIL
            !
            IF(CLIM%HAS_PRECIP)  CDAT%HAS_Pe = CLIM%HAS_Pe
            !
        END IF
        !
        ! SET UP EACH CROPS ROW/COL FOR COMPRESSED STORAGE
        ! SET FARM ID LOCATION BY CROP  --MUST BE DONE AFTER POPULATING ROW/COL BECAUSE THERE MAYBE SFAC USING BYFARM IN COPY_INPUT
        IF(UPDATE) THEN
            !
            CALL PARSE_CROP_ROW_COL(CDAT, WBS%FID_ARRAY, WBS%NEW_FID)  !POPULATE CDAT%CROP%RC AND CDAT%CRPID
            !
            CALL SETUP_CROP_WBS_ID(CDAT, WBS)
            !
            ! CHECK FOR FALLOW CELLS AND NO ET_REF
            IF(.NOT. CDAT%MULTI_CROP_CELLS .AND. .NOT. CLIM%HAS_BARE_REF_ET) THEN
                !
                DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%CRPID(C,R) < Z ) 
                                CALL WRN%ADD(NUM2STR(R,-10)//' '//NUM2STR(C,-10)//NL)
                END DO
                IF (WRN%RAISED) CALL WRN%CHECK(HED='FMP CROP ERROR. CROP BLOCK SPECIFIED KEYWORD "LOCATION" LOADED AN ARRAY WITH A NEGATIVE CROP ID TO INDICATE FALLOW/BARE LAND.'//NL//  &
                                                   'THIS REQUIRES THAT THE CLIMATE BLOCK SPECIFY EITHER A THE KEYWORD "REFERENCE_ET" OR "POTENTIAL_EVAPORATION_FALLOW"'//NL//             &
                                                   'SO THAT EVAPORATION OF PRECIPITATION AND/OR GROUNDWATER OVER BARE/FALLOW LAND CAN BE CALCULATED.'//NL//                               &
                                                   'THE FOLLOWING ARE THE PROBLEM CROPS:'//NL// &
                                                   'CROP ROW       COLUMN',                     &
                                                    OUTPUT=CDAT%LOUT, TAIL=NL, NO_NL=TRUE ,KILL=TRUE)
                
            END IF
        END IF
        !
        NEW_IRR = FALSE
        IF( UPDATE .OR. (CDAT%IRR%TRANSIENT .AND. LOAD_NEXT) )  CALL CDAT%COPY_AND_SETUP_IRRIGATION(NEW_IRR)
        !
        IF( UPDATE .OR. (CDAT%GW_INTER%TRANSIENT .AND. LOAD_NEXT) ) CALL CDAT%CROP%COPY_INPUT(CDAT%GW_INTER)
        !
        IF( UPDATE .OR. (CDAT%FRAC  %TRANSIENT .AND. LOAD_NEXT) ) CALL CDAT%CROP%COPY_INPUT(CDAT%FRAC  )
        IF( UPDATE .OR. (CDAT%PSI   %TRANSIENT .AND. LOAD_NEXT) ) CALL CDAT%CROP%COPY_INPUT(CDAT%PSI   )
        IF( UPDATE .OR. (CDAT%FIESWP%TRANSIENT .AND. LOAD_NEXT) ) CALL CDAT%CROP%COPY_INPUT(CDAT%FIESWP)
        !
        IF( UPDATE .OR. (CDAT%FIESWI%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%FIESWI%SFAC%HAS_EX3) &
                   .OR. (NEW_IRR .AND. 'FIESWI_BYIRR' == CDAT%FIESWI%TYP)                                     ) CALL CDAT%CROP%COPY_INPUT(CDAT%FIESWI)
        !
        IF( UPDATE .OR. (CDAT%ROOT  %TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%ROOT  %SFAC%HAS_EX3) ) CALL CDAT%CROP%COPY_INPUT(CDAT%ROOT  )
        IF( UPDATE .OR. (CDAT%Kc    %TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%Kc    %SFAC%HAS_EX3) ) CALL CDAT%CROP%COPY_INPUT(CDAT%Kc    )
        IF( UPDATE .OR. (CDAT%CF    %TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%CF    %SFAC%HAS_EX3) ) CALL CDAT%CROP%COPY_INPUT(CDAT%CF    )
        IF( UPDATE .OR. (CDAT%POND  %TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%POND  %SFAC%HAS_EX3) ) CALL CDAT%CROP%COPY_INPUT(CDAT%POND  )
        !
        IF( UPDATE .OR. (CDAT%FTR%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%FTR%SFAC%HAS_EX3)  ) CALL CDAT%CROP%COPY_INPUT(CDAT%FTR   )
        IF( UPDATE .OR. (CDAT%FTR%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%FTR%SFAC%HAS_EX3) &
                   .OR. (CDAT%FEI%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%FEI%SFAC%HAS_EX3) &
                   .OR. (NEW_IRR .AND. 'FEI_BYIRR' == CDAT%FIESWI%TYP)                                   ) CALL CDAT%CROP%COPY_INPUT(CDAT%FEI   )
        !
        IF( UPDATE .OR. (CDAT%ADMD%TRANSIENT.AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%ADMD%SFAC%HAS_EX3) ) CALL CDAT%CROP%COPY_INPUT(CDAT%ADMD  )
        !
        !!!HAS_CON_PRECIP_FRAC = CDAT%CON_PRECIP_FRAC%INUSE
        !!!!
        !!!IF(HAS_CON_PRECIP_FRAC) THEN
        !!!   IF( UPDATE .OR. (CDAT%CON_PRECIP_FRAC%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%CON_PRECIP_FRAC%SFAC%HAS_EX3) ) THEN
        !!!       !
        !!!       CALL CDAT%CROP%COPY_INPUT(CDAT%CON_PRECIP_FRAC)
        !!!       !
        !!!       IF(CDAT%PCF_IS_FRAC ) THEN
        !!!           DO CONCURRENT ( I=ONE:CDAT%NCROP     ) 
        !!!           DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )  
        !!!                                                 IF    ( CDAT%CROP(I)%CON_PRECIP_FRAC(K) > UNO         ) THEN
        !!!                                                         CDAT%CROP(I)%CON_PRECIP_FRAC(K) = UNO
        !!!                                                 ELSEIF( CDAT%CROP(I)%CON_PRECIP_FRAC(K) <  NEARZERO_15) THEN
        !!!                                                         CDAT%CROP(I)%CON_PRECIP_FRAC(K) =  DZ
        !!!                                                 END IF
        !!!           END DO 
        !!!           END DO
        !!!       ELSE
        !!!           DO CONCURRENT ( I=ONE:CDAT%NCROP     ) 
        !!!           DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
        !!!                                                 IF    ( CDAT%CROP(I)%CON_PRECIP_FRAC(K) > UNO) THEN
        !!!                                                         CDAT%CROP(I)%CON_PRECIP_FRAC(K) = UNO
        !!!                                                 ELSEIF( CDAT%CROP(I)%CON_PRECIP_FRAC(K) <  NEGNEARZERO_15) THEN
        !!!                                                         CDAT%CROP(I)%CON_PRECIP_FRAC(K) =  D100
        !!!                                                 ELSEIF( CDAT%CROP(I)%CON_PRECIP_FRAC(K) <     NEARZERO_15) THEN
        !!!                                                         CDAT%CROP(I)%CON_PRECIP_FRAC(K) =  DZ
        !!!                                                 END IF
        !!!           END DO 
        !!!           END DO
        !!!       END IF
        !!!   END IF
        !!!END IF
        !
        !
        ! CHECK IF ROOT PRESSURES ARE IN DESCENDING ORDER. IF NOT THEN SORT AND WARN
        !
        IF( CDAT%PSI%INUSE .AND. (UPDATE .OR. (CDAT%PSI%TRANSIENT .AND. LOAD_NEXT)) ) THEN
              
              DO I=ONE, CDAT%NCROP
                 IF(CDAT%CROP(I)%N > Z) THEN
                     ASSOCIATE( PSI => CDAT%CROP(I)%PSI )
                         !
                         DO CONCURRENT ( K=ONE:FOUR, ABS(PSI(K))<NEARZERO_12 ); PSI(K) = DZ
                         END DO
                         !
                         IF( ANY(PSI .NE. DZ) ) THEN  
                                  DO K = ONE, THREE
                                        IF(PSI(K) < PSI(K+1)) THEN
                                            ERROR = ERROR//'ROOT PRESSURES (PSI) ARE NOT IN DESCENDING ORDER FOR CROP '//NUM2STR(I,-8)//' THEY WILL BE SORTED TO BE IN DECENDING ORDER (PLEASE CHECK YOUR INPUT).'//NL
                                            CALL SORT(FOUR, PSI)
                                            EXIT
                                        END IF
                                  END DO
                         END IF
                     END ASSOCIATE
                 END IF
              END DO
              !
              IF (ERROR.NE.NL) THEN
                  CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG=ERROR)
                  ERROR = NL
              END IF
        END IF
        !
        ! ALLOCATE NECESSARY ARRAYS
        IF (UPDATE) THEN
              DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N>Z )
                  IF( .NOT. ALLOCATED(CDAT%CROP(I)%AREA) .OR. CDAT%CROP(I)%N .NE. SIZE(CDAT%CROP(I)%AREA) ) THEN
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%T_CONCEPT, CDAT%CROP(I)%N)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%AREA,   CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%CECT,   CDAT%CROP(I)%N)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%CIR_INI,CDAT%CROP(I)%N, SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%CIR,    CDAT%CROP(I)%N, SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%EFF,    CDAT%CROP(I)%N, SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%RNOFF,  CDAT%CROP(I)%N, SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%DPERC,  CDAT%CROP(I)%N, SRC=DZ)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%RNOFF_EXT, CDAT%CROP(I)%N, SRC=DZ)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%DPERC_EXT,CDAT%CROP(I)%N, SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%ADRF,     CDAT%CROP(I)%N, SRC=TENTH)  !NOTE THAT THE DEFAULT IS 0.1
                                                                  !CALL ALLOC(CDAT%CROP(I)%EFL,    CDAT%CROP(I)%N, SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%DEMAND, CDAT%CROP(I)%N, SRC=DZ)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%DEMAND_EXT,     CDAT%CROP(I)%N, SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%DEMAND_EXT_INI, CDAT%CROP(I)%N, SRC=DZ)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%EGW,    CDAT%CROP(I)%N,     SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%TGW,    CDAT%CROP(I)%N,     SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%EGWA,   CDAT%CROP(I)%N,     SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%TGWA,   CDAT%CROP(I)%N,     SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%TSURF,  CDAT%CROP(I)%N,     SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%TI,     CDAT%CROP(I)%N,     SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%TP,     CDAT%CROP(I)%N,     SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%ANOX_LOSS,CDAT%CROP(I)%N,   SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%SOIL_LOSS,CDAT%CROP(I)%N,   SRC=DZ)
                                                                  !
                                                                  !CALL ALLOC(CDAT%CROP(I)%TSUR,  CDAT%CROP(I)%N)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%TPPOT,   CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%EPPOT,   CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%EP,      CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%PRECIP,  CDAT%CROP(I)%N)
                                                                  !CALL ALLOC(CDAT%CROP(I)%PSIA,  CDAT%CROP(I)%N)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%GSE,   CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%SS,    CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%LXX,   CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%XX,    CDAT%CROP(I)%N)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%THI,   CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%THD,   CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%EHI,   CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%EHD,   CDAT%CROP(I)%N)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%NOT_FALLOW, CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%NOT_FALLOW_SP, CDAT%CROP(I)%N)
                                                                  !
                                                                  IF(CDAT%HAS_Pe) CALL ALLOC(CDAT%CROP(I)%RNOFF_Peff,CDAT%CROP(I)%N, SRC=DZ)
                                                                  !
                                                                  !CALL ALLOC(CDAT%CROP(I)%GW_INTER, CDAT%CROP(I)%N)
                                                                  !
                                                                  IF(CDAT%HAS_PSI) THEN
                                                                                       CALL ALLOC(CDAT%CROP(I)%UXX, CDAT%CROP(I)%N)
                                                                                       CALL ALLOC(CDAT%CROP(I)%MXX, CDAT%CROP(I)%N)
                                                                  END IF
                                                                  !
                                                                  IF(CDAT%ITER_CALC_EGW_TGW_LOCK < inf_I) CALL ALLOC(CDAT%CROP(I)%TI_BAK, CDAT%CROP(I)%N, SRC=DZ)
                                                                  !
                                                                  ! THESE REQUIRE INITIALIZATION
                                                                  CDAT%CROP(I)%EHI = DZ
                                                                  CDAT%CROP(I)%EHD = DZ
                                                                  CDAT%CROP(I)%THI = DZ
                                                                  CDAT%CROP(I)%THD = DZ
                  END IF
              END DO
              !
              ! SET UP CROP AREA
              !
              IF(CDAT%FRAC%INUSE) THEN
                               DO CONCURRENT ( I=ONE:CDAT%NCROP     ) 
                               DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )  
                                                                     CDAT%CROP(I)%AREA(K) = WBS%AREA(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K)) * CDAT%CROP(I)%FRAC(K)
                               END DO; END DO
              ELSE             
                               DO CONCURRENT ( I=ONE:CDAT%NCROP     ) 
                               DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N ) 
                                                                     CDAT%CROP(I)%AREA(K) = WBS%AREA(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K))
                               END DO; END DO
              END IF
        END IF
        !
        ! SET UP ROOT-GROUNDWATER INTERACTION FLAG
        !
        IF( UPDATE .OR. (CDAT%GW_INTER%TRANSIENT .AND. LOAD_NEXT) ) THEN
            !
            CDAT%GW_ROOT_INTERACTION = FALSE
            GW_ROOT: DO I=ONE, CDAT%NCROP
                     DO K=ONE, CDAT%CROP(I)%N
                         IF(CDAT%CROP(I)%GW_INTER(K) > ONE) THEN
                               CDAT%GW_ROOT_INTERACTION = TRUE
                               EXIT GW_ROOT
                         END IF
                     END DO
                     END DO GW_ROOT
            !
            IF(.NOT. CDAT%ROOT%INUSE .AND. CDAT%GW_ROOT_INTERACTION)  THEN  !CHECK IF ROOT DEPTH IS REQUIRED
                IF(CDAT%HAS_PSI) THEN
                    ERROR = 'FMP CROP ERROR. THERE IS INTERACTION BETWEEN THE THE CROP ROOTS AND GROUNDWATER LEVEL TO CALCULATE TRANSPIRATION (DEFAULT BEHAIVOR).'//NL// &
                            'THAT IS "GROUNDWATER_ROOT_INTERACTION" = 2, 3, 4, OR 5 FOR SOME OF THE CROPS. --NOTE 5 IS THE DEFAULT WHEN NOT SPECIFIED.'//NL//  &
                            'THIS REQUIRES THE CROP ROOT DEPTH TO BE SPECIFRIED WITH "ROOT DEPTH" OR "ROOT_DEPTH" KEYWORD IN CROP BLOCK FOLLOWED BY EACH CROPS ROOT DEPTH THAT IS GREATER THAN ZERO (>0).'//NL// &
                            'EITHER SPECIFY POSITIVE NON-ZERO ROOT DEPTHS OR USE KEYWORD "GROUNDWATER_ROOT_INTERACTION" AND SET IT TO ONE TO INDICATE THERE IS NO GROUNDWATER ROOT INTERACTION.'
                    CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG=ERROR)
                ELSE
                    CALL CDAT%ROOT%INIT('ROOT', DZ, CDAT%IOUT, Z, CDAT%NCROP, ONE, Z, Z)
                    CALL CDAT%CROP%COPY_INPUT(CDAT%ROOT  )
                END IF
            END IF
        END IF
        !
        IF( CDAT%HAS_PSI .AND. CDAT%GW_ROOT_INTERACTION .AND. &
                                                        (     &
            UPDATE                                   .OR.     &
           (CDAT%GW_INTER%TRANSIENT .AND. LOAD_NEXT) .OR.     & 
           (CDAT%ROOT    %TRANSIENT .AND. LOAD_NEXT) .OR.     &
           (NEW_IRR .AND. CDAT%ROOT%SFAC%HAS_EX3)        )    &
          ) THEN
            !
            PRNT = FALSE
            IF(CDAT%HAS_PSI) THEN
               ROOT_LOOP: DO I=ONE,CDAT%NCROP
                            IF(ANY(NOT_NEAR_ZERO(CDAT%PSI%ARRAY(:,I),NEARZERO_12))) THEN 
                               DO K=ONE,CDAT%CROP(I)%N
                                     IF(CDAT%CROP(I)%GW_INTER(K) > ONE .AND. CDAT%CROP(I)%ROOT(K) .LE. DZ ) THEN
                                         PRNT(I) = TRUE
                                         CYCLE ROOT_LOOP
                                     END IF
                               END DO 
                            END IF
                          END DO ROOT_LOOP
               IF(ANY(PRNT)) THEN
                   ERROR='FMP CROP -- CHECK FOR VALID ROOT DEPTHS FOUND CROPS THAT HAD EITHER ZER0 OR LESS THAN ZER0 ROOT DEPTHS,'//NL//'WHICH IS NOT ALLOWED WHEN THERE IS A GROUNDWATER-ROOT INTERACTION FLAG GREATER THAN ONE (>1)'//NL//'THAT IS "GROUNDWATER_ROOT_INTERACTION" = 2, 3, 4, OR 5. --NOTE 5 IS THE DEFAULT WHEN NOT SPECIFIED.'//NL//'THE FOLLOWING IS A LIST OF CROPS THAT CONTAINED A ROOT DEPTH LESS THAN OR EQUAL TO ZER0 AND A GROUNDWATER_ROOT_INTERACTION GREATER THAN ONE:'//BLN//' CROP_ID '//BLN
                   DO I=ONE,CDAT%NCROP
                       IF(PRNT(I)) ERROR = ERROR//NUM2STR(I,-8)//NL
                   END DO
                   CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG=ERROR)
               END IF
            END IF
        END IF
        !
        !IF (UPDATE .AND. CDAT%GW_INTER%INUSE) THEN
        !   IF(CDAT%GW_INTER%LISTLOAD) THEN
        !       DO CONCURRENT ( I=ONE:CDAT%NCROP ); CDAT%CROP(I)%GW_INTER = CDAT%GW_INTER%LIST(I)
        !       END DO
        !   ELSE
        !                      DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
        !                      DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N ) 
        !                                                               R = CDAT%CROP(I)%RC(ONE,K) + CDAT%CROP(I)%LD - ONE  !LD=1 FOR NORMAL NROWxNCOL ARRAYS OTHERWISE IT POINTS TO THE CORRECT ROW FOR SPECIFIC CROW DUE TO FRACTIONAL LOADING.
        !                                                               C = CDAT%CROP(I)%RC(TWO,K)
        !                                                               CDAT%CROP(I)%GW_INTER(K) = CDAT%GW_INTER%ARRAY(C,R)
        !       END DO; END DO
        !   END IF
        !ELSEIF(UPDATE) THEN
        !       DO CONCURRENT ( I=ONE:CDAT%NCROP ); CDAT%CROP(I)%GW_INTER = TWO  !NOT SPECIFIED SO DO FULL INTERACTION
        !       END DO
        !END IF
        !
        IF(UPDATE .AND. WBS%HAS_WATERSTACK) CALL SETUP_CROP_FALLOW_RANK(CDAT, WBS)
        !
        ! CALCULATE CONSUMPTIVE USE IF USED. CALCULATE CROP COEFICIENTS*ETR IF USED
        !
        IF (UPDATE .OR. ((CDAT%Kc%TRANSIENT .OR. CDAT%CF%TRANSIENT) .AND. LOAD_NEXT) .OR. CLIM%REF_ET_TFR%TRANSIENT .OR. CLIM%REF_ET_BARE_TFR%TRANSIENT .OR. (NEW_IRR .AND. CDAT%Kc%SFAC%HAS_EX3) .OR. (NEW_IRR .AND. CDAT%CF%SFAC%HAS_EX3) ) THEN
            !
            DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N>Z ) 
                                                                CDAT%CROP(I)%NOT_FALLOW_SP = TRUE  ! IF WATER STACKING IS ALLOWED SETUP RANKING. BY DEFAULT ALL CROPS ARE NOT CONSIDERD FALLOWED
            END DO
            !
            IF (CDAT%CF%INUSE) THEN
                  DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
                  DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )   !, CDAT%CROP(I)%N>Z
                                                    !
                                                    IF(CDAT%CROP(I)%CF(K) > NEARZERO_30) THEN
                                                             CDAT%CROP(I)%CU(K) = CDAT%CROP(I)%CF(K) * CDAT%CROP(I)%AREA(K)
                                                    ELSE
                                                             CDAT%CROP(I)%CU(K) = DZ
                                                    END IF
                  END DO; END DO
            ELSE
                  DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N>Z ) 
                                                             CDAT%CROP(I)%CU = DZ
                  END DO
            END IF
            !
            IF     (CDAT%Kc%INUSE .AND. CDAT%ZERO_CU_TO_BARE%INUSE) THEN
                  DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
                  DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N ) !  CU + Kc * Area* ETR
                                                    IF( (CDAT%CROP(I)%Kc(K) < NEARZERO_30 .AND. CDAT%CROP(I)%CU(K) < NEARZERO_30) ) THEN  ! CROP HAS BEEN FALLOWED -- .OR. CDAT%CROP(I)%FTR(K) < NEARZERO_30
                                                        IF(CDAT%ZERO_CU_TO_BARE%LIST(I) == ONE) THEN
                                                            CDAT%CROP(I)%CU(K) = CDAT%CROP(I)%AREA(K) * CLIM%BARE_POT_EVAP(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K))  !CLIM%REF_ET(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K))
                                                            !CDAT%CROP(I)%FTR(K) = DZ
                                                        ELSE
                                                            CDAT%CROP(I)%CU(K)  = DZ
                                                            !CDAT%CROP(I)%FTR(K) = DZ
                                                            WRN%RAISED = TRUE
                                                        END IF
                                                        CDAT%CROP(I)%NOT_FALLOW_SP(K) = FALSE
                                                    ELSE
                                                        CDAT%CROP(I)%CU(K) = CDAT%CROP(I)%CU(K) + ( CDAT%CROP(I)%Kc(K) * CDAT%CROP(I)%AREA(K) * CLIM%REF_ET(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K)) )
                                                    END IF   
                  END DO; END DO
            ELSEIF (CDAT%Kc%INUSE) THEN
                  DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
                  DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N ) !  CU + Kc * Area* ETR
                                                    IF( (CDAT%CROP(I)%Kc(K) < NEARZERO_30 .AND. CDAT%CROP(I)%CU(K) < NEARZERO_30) ) THEN  ! CROP HAS BEEN FALLOWED -- .OR. CDAT%CROP(I)%FTR(K) < NEARZERO_30
                                                        CDAT%CROP(I)%CU(K)  = DZ
                                                        !CDAT%CROP(I)%FTR(K) = DZ
                                                        CDAT%CROP(I)%NOT_FALLOW_SP(K) = FALSE
                                                        WRN%RAISED = TRUE
                                                    ELSE
                                                        CDAT%CROP(I)%CU(K) = CDAT%CROP(I)%CU(K) + ( CDAT%CROP(I)%Kc(K) * CDAT%CROP(I)%AREA(K) * CLIM%REF_ET(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K)) )
                                                    END IF   
                  END DO; END DO
            ELSEIF(CLIM%HAS_BARE_REF_ET .AND. CDAT%ZERO_CU_TO_BARE%INUSE) THEN
                  DO CONCURRENT (I=ONE:CDAT%NCROP)
                  DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%CU(K) < NEARZERO_30 ) ! CROP HAS BEEN FALLOWED  -- .OR. CDAT%CROP(I)%FTR(K) < NEARZERO_30
                                                       IF(CDAT%ZERO_CU_TO_BARE%LIST(I) == ONE) THEN
                                                            CDAT%CROP(I)%CU(K) = CDAT%CROP(I)%AREA(K) * CLIM%BARE_POT_EVAP(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K))       !CLIM%REF_ET(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K))
                                                            !CDAT%CROP(I)%FTR(K) = DZ
                                                        ELSE
                                                            CDAT%CROP(I)%CU(K)  = DZ
                                                            !CDAT%CROP(I)%FTR(K) = DZ
                                                            WRN%RAISED = TRUE
                                                        END IF
                                                        CDAT%CROP(I)%NOT_FALLOW_SP(K) = FALSE
                  END DO; END DO
            ELSE
                  DO CONCURRENT (I=ONE:CDAT%NCROP)
                  DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%CU(K) < NEARZERO_30 ) ! .OR. CDAT%CROP(I)%FTR(K) < NEARZERO_30
                      !CALL WRN%ADD(NUM2STR(I,-8)//' '//NUM2STR(CDAT%CROP(I)%RC(ONE,K),-10)//' '//NUM2STR(CDAT%CROP(I)%RC(TWO,K),-10)//NL)
                      CDAT%CROP(I)%CU(K)  = DZ
                      !CDAT%CROP(I)%FTR(K) = DZ
                      CDAT%CROP(I)%NOT_FALLOW_SP(K) = FALSE
                      WRN%RAISED = TRUE
                  END DO; END DO
                  !CALL WRN%CHECK(HED='FMP CROP WARNING. FOUND EITHER A CONSUMPTIVE USE (CU) LESS THEN OR EQUAL TO ZERO.'//NL// &
                  !                       'THIS INDICATES THAT THE CROP IS FALLOWED OR BAREN LAND.'//NL//                                          &
                  !                       'HOWEVER, NEITHER A BARE SOIL POTENTIAL EVAPORATION (PAN EVAPORATION) OR REFERENCE ET WAS SPECIFIED.'//NL// &
                  !                       'THIS PREVENTS ANY BARE SOIL EVAPORATION CALCULATION.'//NL//                                                &
                  !                       'THIS WARNING IS TO POINT OUT THAT THE FOLLOWING CROPs WILL NOT HAVE ANY EVAPORATION OR TRANPIRATION ACROSS THE SPECIFIED ROW AND COLUMN.'//BLN// &
                  !                       ' CROP_ID ROW        COLUMN',  &
                  !                       OUTPUT=CDAT%LOUT, TAIL=NL, INIT=TRUE)
            END IF
            IF (WRN%RAISED) THEN
                WRN%RAISED = FALSE
                CALL WARNING_MESSAGE(OUTPUT=CDAT%IOUT, &
                                     MSG='FMP CROP WARNING. Found one or more crops (or crop locations) that had, one or both, its Consumptive Use (CU) and its Crop Coefficient (KC) less then or equal to zero.'//NL// &
                                     'NO EVAPORATION OR TRANSPIRATION CAN OCCUR AT THE LOCATIONS WITH ZERO VALUES.'//NL//                                          &
                                     'If you wish to have these converted to bare soil evaporation calculation then you must specify "ZERO_CONSUMPTIVE_USE_BECOMES_BARE_SOIL" for the crop with a zero value'//NL// &
                                     'and either inlcude in the input "POTENTIAL_EVAPORATION_BARE" or "REFERENCE_ET".'//BLN//'This is just a warning in case input intentially does not want to allow any evapotranspiration at specific locations in the model.')
            END IF
        END IF
        !
        ! -----------------------------------------------------
        DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N>Z ) 
                                                            CDAT%CROP(I)%NOT_FALLOW    = CDAT%CROP(I)%NOT_FALLOW_SP
        END DO
        ! -----------------------------------------------------
        !
        ! CALCULATE ADDITIONAL DEMAND AS VOLUME IF SPECIFIED AS FLUX
        !
        IF(CDAT%DEMAND_EXT_FLUX) THEN
           IF( UPDATE .OR. (CDAT%ADMD%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%ADMD%SFAC%HAS_EX3) ) THEN
               DO CONCURRENT ( I=ONE:CDAT%NCROP     ) 
               DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
                    CDAT%CROP(I)%ADMD(K) = CDAT%CROP(I)%ADMD(K) * CDAT%CROP(I)%AREA(K)
               END DO; END DO
           END IF
        END IF
        !
        ! IF DEMAND NEAR ZERO, SET TO ZERO TO IMPROVE SIMULATION SPEED
        !
        IF(CDAT%HAS_DEMAND_EXT) THEN
           IF( UPDATE .OR. (CDAT%ADMD%TRANSIENT.AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%ADMD%SFAC%HAS_EX3) ) THEN
               DO CONCURRENT (I=ONE:CDAT%NCROP)
               DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, NEAR_ZERO(CDAT%CROP(I)%ADMD(K), NEARZERO_10) )
                     CDAT%CROP(I)%ADMD(K) = DZ
               END DO; END DO
           END IF
        END IF
        !
        !###########################################################################################################
        ! CHECK FOR BAD INPUT EFF>1, FTR>1, FTR+FEI  (EFFICIENCIES)
        !
        IF(UPDATE .OR. NEW_IRR) THEN
                  DO I=ONE, CDAT%NCROP
                  DO K=ONE, CDAT%CROP(I)%N
                      IF( CDAT%CROP(I)%IRR(K) > CDAT%NIRRG .OR. CDAT%CROP(I)%IRR(K) < Z ) THEN
                                                                                R = CDAT%CROP(I)%RC(ONE,K)
                                                                                C = CDAT%CROP(I)%RC(TWO,K)
                                                                                CALL WRN%ADD(BLNK//NUM2STR(I,-8)//NUM2STR(R,-10)//' '//NUM2STR(C,-10)//NUM2STR(CDAT%CROP(I)%IRR(K),-10)//NL)
                      END IF
                  END DO; END DO
                  IF (WRN%RAISED) CALL WRN%CHECK(HED='FMP CROP ERROR. IRRIGATION FLAG GREATER THAN GLOBAL DIMENSION "NIRRIGATE" OR LESS THAN ZERO (NEGATIVE INTEGER),'//NL// &
                                                     'THIS WILL RESULT IN A BAD INDEX FOR THE EFFICIENCY ARRAY. PLEASE SET THE IRRIGATION FLAG BETWEEN 0 AND '//NUM2STR(CDAT%NIRRG)//BLN//  &
                                                     'INPUT MUST BE FIXED TO CONTINUE SIMULATION.'      //BLN//  &
                                                     'HERE IS A LIST OF CROPS AND THEIR IRRIGATION FLAG'//BLN//  &
                                                     ' CROP_ID ROW        COLUMN    IRR_FLAG',                   &
                                                      OUTPUT=CDAT%LOUT, TAIL=NL, NO_NL=TRUE ,KILL=TRUE)
        END IF
        !
        IF(UPDATE .OR. (CDAT%FTR%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%FTR%SFAC%HAS_EX3)) THEN
                  PRNT = TRUE
                  DO CONCURRENT (I=ONE:CDAT%NCROP)
                  DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FTR(K) > UNO )
                                                                          CDAT%CROP(I)%FTR(K) = UNO
                                                                       IF(CDAT%CROP(I)%FTR(K) > NEAR_ONE) THEN
                                                                              IF(PRNT(I)) ERROR = ERROR//BLNK//NUM2STR(I,-8)//'  FRACTION OF TRANPIRATION (FTR) > 1.0, RESET TO 1.0'//NL
                                                                              PRNT(I) = FALSE
                                                                       END IF
                  END DO; END DO
                  !
                  PRNT = TRUE
                  DO CONCURRENT (I=ONE:CDAT%NCROP)
                  DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FTR(K) < DZ )
                                                              CDAT%CROP(I)%FTR(K)  = DZ
                                                              IF(PRNT(I)) ERROR = ERROR//BLNK//NUM2STR(I,-8)//'  FRACTION OF TRANPIRATION (FTR) < 0.0, RESET TO 0.0'//NL
                                                              PRNT(I) = FALSE
                  END DO; END DO
        END IF
        !
        IF(UPDATE .OR. ((CDAT%FTR%TRANSIENT.OR.CDAT%FEI%TRANSIENT) .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%FTR%SFAC%HAS_EX3) .OR. (NEW_IRR .AND. CDAT%FEI%SFAC%HAS_EX3) .OR. (NEW_IRR .AND. 'FEI_BYIRR' == CDAT%FEI%TYP) ) THEN !CORRECTION FOR NEGATIVE FEI
                  !PRNT = TRUE
                  DO CONCURRENT (I=ONE:CDAT%NCROP)
                  DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FEI(K)  < DZ )
                                                                          CDAT%CROP(I)%FEI(K)  = UNO - CDAT%CROP(I)%FTR(K)
                                                                          !IF(PRNT(I)) ERROR = ERROR//BLNK//NUM2STR(I,-8)//'  FRACTION OF EVAPORATION FROM IRRIGATION (FEI) < 0.0, SO IT WAS SET TO 1 - FRACTION OF TRANPIRATION (FTR)'//NL
                                                                          !PRNT(I) = FALSE
                  END DO; END DO
                  !
                  IF(CDAT%FEI_CHECK%INUSE) THEN
                  !  PRNT = TRUE
                    DO CONCURRENT (I=ONE:CDAT%NCROP, CDAT%FEI_CHECK%LIST(I) == ONE ) !CHECK IF FTR + FEI > 1
                    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FTR(K) + CDAT%CROP(I)%FEI(K) > NEAR_ONE )
                                                                        CDAT%CROP(I)%FEI(K) = UNO - CDAT%CROP(I)%FTR(K) 
                                                                        !
                                                                        IF(CDAT%CROP(I)%FEI(K) < DZ) CDAT%CROP(I)%FEI(K) = DZ
                                                                        !
                                                                        !P = CDAT%CROP(I)%FTR(K) + CDAT%CROP(I)%FEI(K)
                                                                        !CDAT%CROP(I)%FTR(K) = CDAT%CROP(I)%FTR(K) / P
                                                                        !CDAT%CROP(I)%FEI(K) = CDAT%CROP(I)%FEI(K) / P
                                                                        !IF(PRNT(I)) ERROR = ERROR//BLNK//NUM2STR(I,-8)//'  FRACTION OF TRANPIRATION (FTR) + FRACTION OF EVAPORATION FROM IRRIGATION (FEI) > 1.0, PROPERTIES SCALED TO MAKE SUM EQUAL TO 1.0'//NL
                                                                        !PRNT(I) = FALSE
                    END DO; END DO
                  END IF
        END IF
        !
        IF(UPDATE .OR. (CDAT%FIESWP%TRANSIENT .AND. LOAD_NEXT)) THEN
                  PRNT = TRUE
                  DO CONCURRENT (I=ONE:CDAT%NCROP)
                  DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FIESWP(K) < DZ )
                                                                          CDAT%CROP(I)%FIESWP(K) = DZ
                                                                          IF(PRNT(I)) ERROR = ERROR//BLNK//NUM2STR(I,-8)//'  FRACTION OF INEFFICIENT LOSSES FROM PRECIP (FIESWP) < 0.0, RESET TO 0.0'//NL
                                                                          PRNT(I) = FALSE
                  END DO; END DO
                  !
                  PRNT = TRUE
                  DO CONCURRENT (I=ONE:CDAT%NCROP)
                  DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FIESWP(K) > UNO )
                                                                          CDAT%CROP(I)%FIESWP(K) = UNO
                                                                       IF(CDAT%CROP(I)%FIESWP(K) > NEAR_ONE) THEN
                                                                              IF(PRNT(I)) ERROR = ERROR//BLNK//NUM2STR(I,-8)//'  FRACTION OF INEFFICIENT LOSSES FROM PRECIP (FIESWP) < 1.0, RESET TO 1.0'//NL
                                                                              PRNT(I) = FALSE
                                                                       END IF
                  END DO; END DO
        END IF
        !
        IF(UPDATE .OR. (CDAT%FIESWI%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%FIESWI%SFAC%HAS_EX3)) THEN
                  PRNT = TRUE
                  DO CONCURRENT (I=ONE:CDAT%NCROP)
                  DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FIESWI(K) < DZ )
                                                                          CDAT%CROP(I)%FIESWI(K)  = DZ
                                                                          IF(PRNT(I)) ERROR = ERROR//BLNK//NUM2STR(I,-8)//'  FRACTION OF INEFFICIENT LOSSES FROM IRRIGATION (FIESWI) < 0.0, RESET TO 0.0'//NL
                                                                          PRNT(I) = FALSE
                  END DO; END DO
                  !
                  PRNT = TRUE
                  DO CONCURRENT (I=ONE:CDAT%NCROP)
                  DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FIESWI(K) > UNO )
                                                                          CDAT%CROP(I)%FIESWI(K) = UNO
                                                                       IF(CDAT%CROP(I)%FIESWI(K) > NEAR_ONE) THEN
                                                                              IF(PRNT(I)) ERROR = ERROR//BLNK//NUM2STR(I,-8)//'  FRACTION OF INEFFICIENT LOSSES FROM IRRIGATION (FIESWI) < 1.0, RESET TO 1.0'//NL
                                                                              PRNT(I) = FALSE
                                                                       END IF
                  END DO; END DO
        END IF
        !
        IF (UPDATE .OR. (CDAT%GW_INTER%TRANSIENT .AND. LOAD_NEXT)) THEN
                  DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
                  DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
                                                              SELECT CASE (CDAT%CROP(I)%GW_INTER(K))
                                                              !
                                                              CASE( Z, ONE, TWO, THREE, FOUR, FIVE );  CONTINUE
                                                              CASE DEFAULT
                                                                         CDAT%CROP(I)%GW_INTER(K) = FIVE
                                                                         IF(PRNT(I)) ERROR = ERROR//BLNK//NUM2STR(I,-8)//'  GROUNDWATER_ROOT_INTERACTION MUST BE SET TO 0, 1, 2, 3, 4 or 5 NOW SET TO 5'//NL
                                                                         PRNT(I) = FALSE
                                                              END SELECT
                  END DO; END DO
        END IF
        !
        IF (ERROR.NE.NL) THEN
                 ERROR='FMP CROP -- CHECK FOR VALID PROPERTY VALUES THE FOLLOWING WERE ADJUSTED TO BE CORRECT:'//BLN//' CROP_ID   ISSUE'//ERROR
                 CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG=ERROR)
                 ERROR = NL
        END IF
        !
        IF(UPDATE .OR. WBS%EFF_TFR%TRANSIENT .OR. NEW_IRR) THEN
                  CALL SETUP_CROP_EFFICIENCY(CDAT, WBS, FALSE)  !ONLY CALLED FOR CHECKING PURPOSES (FALSE)
                  !
                  DO CONCURRENT ( I=ONE:CDAT%NCROP )
                  DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%EFF(K) <= DZ .AND. CDAT%CROP(I)%IRR(K) > Z )
                                                        R = CDAT%CROP(I)%FID(K)
                                                        C = CDAT%CROP(I)%IRR(K)
                                                        CALL WRN%ADD(NUM2STR(I,-8)//NUM2STR(R,-8)//NUM2STR(C,-8)//NL)
                                                        !CDAT%CROP(I)%EFF(K) = DZ
                                                        CDAT%CROP(I)%IRR(K) = Z
                  END DO
                  END DO
                  IF (WRN%RAISED) CALL WRN%CHECK(HED='FMP CROP WARNING EFFICIENCY <= 0.0 WITH IRRIGATION > 0'//NL//'*** IRRIGATION FOR CROP TURNED OFF DUE TO ZERO EFFECIENCY! ***'//BLN// &
                                                     ' CROP_ID ROW        COLUMN',                   &
                                                      OUTPUT=CDAT%LOUT, TAIL=NL, NO_NL=TRUE, INIT=TRUE)
                  !
                  DO CONCURRENT ( I=ONE:CDAT%NCROP )
                  DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%EFF(K) > UNO .AND. CDAT%CROP(I)%IRR(K) > Z )
                                                        !CDAT%CROP(I)%EFF(K) = UNO
                                                     IF(CDAT%CROP(I)%EFF(K) > NEAR_ONE) THEN
                                                            R = CDAT%CROP(I)%FID(K)
                                                            C = CDAT%CROP(I)%IRR(K)
                                                            CALL WRN%ADD(NUM2STR(I,-8)//NUM2STR(R,-8)//NUM2STR(C,-8)//NL)
                                                     END IF
                  END DO
                  END DO
                  IF (WRN%RAISED) CALL WRN%CHECK(HED='FMP CROP WARNING EFFICIENCY > 1.0, '//NL//'EFFICIENCY RESET TO 1.0'//BLN// &
                                                     ' CROP_ID ROW        COLUMN',                   &
                                                      OUTPUT=CDAT%LOUT, TAIL=NL, NO_NL=TRUE, INIT=TRUE)
        END IF
        !
        ! SET ADRF AND CHECK FOR INPUT ERROR
        IF(WBS%ADRF_TFR%INUSE) THEN
          IF(UPDATE .OR. WBS%ADRF_TFR%TRANSIENT .OR. (NEW_IRR .AND. WBS%ADRF_TFR%SFAC%HAS_EX3)) THEN
                    !
                    DO CONCURRENT   ( I=ONE:CDAT%NCROP,    CDAT%CROP(I)%N > Z )
                      DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
                          !
                          IF (CDAT%CROP(I)%IRR(K)>Z) THEN !                                           FID                 COL                    ROW             IRRIGATION TYPE
                                                          CDAT%CROP(I)%ADRF(K) = WBS%ADRF_TFR%GET( CDAT%CROP(I)%FID(K),CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K),CDAT%CROP(I)%IRR(K) )
                                                          !
                                                          IF(CDAT%CROP(I)%ADRF(K) .NE. CDAT%CROP(I)%ADRF(K)) CDAT%CROP(I)%ADRF(K) = DZ
                          ELSE
                                                          CDAT%CROP(I)%ADRF(K) = DZ
                          END IF
                      END DO
                      !
                      CALL CROP_INPUT_APPLY_SFAC( CDAT%CROP(I)%ADRF, WBS%ADRF_TFR%SFAC, CDAT%CROP(I)%N, I, CDAT%CROP(I)%FID, CDAT%CROP(I)%IRR )
                      !
                    END DO
                    !
                    !CHECK FOR BAD ADRF VALUES
                    DO CONCURRENT ( I=ONE:CDAT%NCROP )
                    DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%ADRF(K) < DZ .AND. CDAT%CROP(I)%IRR(K) > Z )
                                                          CDAT%CROP(I)%ADRF(K) = DZ
                                                          IF(CDAT%CROP(I)%ADRF(K) < NEGNEARZERO_10) THEN
                                                             R = CDAT%CROP(I)%FID(K)
                                                             C = CDAT%CROP(I)%IRR(K)
                                                             CALL WRN%ADD(NUM2STR(I,-8)//NUM2STR(R,-8)//NUM2STR(C,-8)//NL)
                                                          END IF
                    END DO
                    END DO
                    IF (WRN%RAISED) CALL WRN%CHECK(HED='FMP CROP WARNING ADDITIONAL_IRRIGATION_RUNOFF_FRACTION < 0.0, '//NL//'ADDITIONAL_IRRIGATION_RUNOFF_FRACTION RESET TO 0.0'//BLN// &
                                                       ' CROP_ID ROW        COLUMN',                   &
                                                        OUTPUT=CDAT%LOUT, TAIL=NL, NO_NL=TRUE, INIT=TRUE)
                    !
                    DO CONCURRENT ( I=ONE:CDAT%NCROP )
                    DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%ADRF(K) > UNO .AND. CDAT%CROP(I)%IRR(K) > Z )
                                                          CDAT%CROP(I)%ADRF(K) = UNO
                                                          IF(CDAT%CROP(I)%ADRF(K) > NEAR_ONE) THEN 
                                                              R = CDAT%CROP(I)%FID(K)
                                                              C = CDAT%CROP(I)%IRR(K)
                                                              CALL WRN%ADD(NUM2STR(I,-8)//NUM2STR(R,-8)//NUM2STR(C,-8)//NL)
                                                          END IF
                    END DO
                    END DO
                    IF (WRN%RAISED) CALL WRN%CHECK(HED='FMP CROP WARNING ADDITIONAL_IRRIGATION_RUNOFF_FRACTION > 1.0, '//NL//'ADDITIONAL_IRRIGATION_RUNOFF_FRACTION RESET TO 1.0'//BLN// &
                                                       ' CROP_ID ROW        COLUMN',                   &
                                                        OUTPUT=CDAT%LOUT, TAIL=NL, NO_NL=TRUE, INIT=TRUE)
          END IF
        !ELSEIF(UPDATE) THEN
        !    DO CONCURRENT( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z ); CDAT%CROP(I)%ADRF = TENTH  !AUTOMATICALLY SET TO 0.1
        !    END DO
        END IF
        !
        IF (UPDATE .OR. (CDAT%ADMD%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%ADMD%SFAC%HAS_EX3)) THEN
              DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z )
              DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%ADMD(K) .NE. DZ .AND. CDAT%CROP(I)%IRR(K) == Z )
                                                R = CDAT%CROP(I)%RC(ONE,K)
                                                C = CDAT%CROP(I)%RC(TWO,K)
                                                CALL WRN%ADD(NUM2STR(I,-8)//BLNK//NUM2STR(CDAT%CROP(I)%FID(K),-8)//BLNK//NUM2STR(R,-8)//BLNK//NUM2STR(C,-8)//BLNK//NUM2STR(CDAT%CROP(I)%ADMD(K))//NL)
                                                CDAT%CROP(I)%ADMD(K) = DZ
              END DO
              END DO
              IF (WRN%RAISED) CALL WRN%CHECK(HED='FMP CROP -- CHECK FOR VALID "ADDED_DEMAND" HAD CROPS WITH DEMANDS THAT DO NOT HAVE AN IRRIGATION TYPE'//NL// &
                                                 'SPECIFICALLY IT HAD "IRRIGATION=0" SO NO WAY TO SATISFY THE ADDITIONAL DEMAND.'//NL// &
                                                 'THE FOLLOWING CROPS HAD THEIR "ADDED_DEMAND" SET TO ZER0 DUE TO IRRIGATION=0:'//BLN// &
                                                 ' CROP_ID   WBS     ROW      COLUMN   ADDED_DEMAND',                   &
                                                  OUTPUT=CDAT%LOUT, TAIL=NL, NO_NL=TRUE, INIT=TRUE)
        END IF
        !
        IF(WBS%HAS_CROP_FLUX .OR. WBS%HAS_CROP_VOLR) THEN
           IF(UPDATE .OR. WBS%CROP_VOLR_TFR%TRANSIENT .OR. WBS%CROP_FLUX_TFR%TRANSIENT .OR. NEW_IRR) THEN
               !
               CALL CHECK_WBS_ADDED_DEMAND(CDAT,WBS)  !THE ADDED DEMAND IS ACTUALLY ADDED IN THE FMP_MAIN
               !
           END IF
        END IF
        !
        !!!IF(WBS%EFL_TFR%INUSE) THEN
        !!!  IF(UPDATE .OR. WBS%EFL_TFR%TRANSIENT) THEN
        !!!            !
        !!!            DO CONCURRENT   ( I=ONE:CDAT%NCROP,    CDAT%CROP(I)%N > Z )
        !!!              DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
        !!!                  !
        !!!                  IF (CDAT%CROP(I)%IRR(K)>Z) THEN !                                           FID                 COL                    ROW             IRRIGATION TYPE
        !!!                                                  CDAT%CROP(I)%EFL(K) = WBS%EFL_TFR%GET( CDAT%CROP(I)%FID(K),CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K),CDAT%CROP(I)%IRR(K) )
        !!!                                                  !
        !!!                                                  IF(CDAT%CROP(I)%EFL(K) .NE. CDAT%CROP(I)%EFL(K)) CDAT%CROP(I)%EFL(K) = DZ
        !!!                  ELSE
        !!!                                                  CDAT%CROP(I)%EFL(K) = DZ
        !!!                  END IF
        !!!              END DO
        !!!              !
        !!!              CALL CROP_INPUT_APPLY_SFAC( CDAT%CROP(I)%EFL, WBS%EFL_TFR%SFAC, CDAT%CROP(I)%N, I, CDAT%CROP(I)%FID, CDAT%CROP(I)%IRR )
        !!!              !
        !!!            END DO
        !!!            !
        !!!            DO CONCURRENT ( I=ONE:CDAT%NCROP )
        !!!            DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%EFL(K) < DZ .AND. CDAT%CROP(I)%IRR(K) > Z )
        !!!                                                  CDAT%CROP(I)%EFL(K) = DZ
        !!!                                                  R = CDAT%CROP(I)%FID(K)
        !!!                                                  C = CDAT%CROP(I)%IRR(K)
        !!!                                                  ERROR = ERROR//BLNK//NUM2STR(I,-8)//NUM2STR(R,-8)//NUM2STR(C,-8)//'  EFFICIENCY < 0.0, RESET TO 0.0'//NL
        !!!            END DO
        !!!            END DO
        !!!            !
        !!!            IF (ERROR.NE.NL)  ERROR = ERROR//BLN
        !!!  END IF
        !!!  !
        !!!  IF (ERROR.NE.NL) THEN
        !!!           ERROR='FMP CROP -- CHECK FOR VALID EVAPORATION_LOSS_FRACTION REQUIED THE FOLLOWING TO BE SET TO ZERO BECAUSE THEY WERE NEGATIVE VALUES:'//BLN//' CROP_ID    WBS  IRR   ISSUE'//ERROR
        !!!           CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG=ERROR)
        !!!           ERROR = NL
        !!!  END IF
        !!!ELSEIF(UPDATE) THEN
        !!!    DO CONCURRENT( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z ); CDAT%CROP(I)%EFL = DZ
        !!!    END DO
        !!!END IF
        !
        !###########################################################################################################
        !
        ! SET UP TRANSPIRATION MODEL USED -----
        !
        IF( UPDATE                           &
                .OR. WBS%EFF_TFR%TRANSIENT   &
                .OR. CDAT%FTR%TRANSIENT      &
                .OR. NEW_IRR                 &
                .OR. CDAT%GW_INTER%TRANSIENT &
                .OR. CDAT%PSI%TRANSIENT      &
                .OR. CDAT%CF%TRANSIENT       &
                .OR. CDAT%Kc%TRANSIENT       &
          ) THEN
            !
            ! REUSING PRNT VARIABLE TO FOR IF CROP HAS ROOT PRESSURES
            PRNT = FALSE
            IF(CDAT%HAS_PSI) THEN
               DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z )
                   IF(ANY(CDAT%CROP(I)%PSI .NE. DZ)) THEN
                       PRNT(I)=TRUE
                   ELSE
                       PRNT(I)=FALSE
                   END IF
                   !IF(ALL(NEAR_ZERO(CDAT%CROP(I)%PSI, NEARZERO_12))) THEN
                   !                                                      PRNT(I)=FALSE
                   !ELSE
                   !                                                      PRNT(I)=TRUE
                   !END IF
               END DO
            END IF
            !
            DO CONCURRENT (I=ONE:CDAT%NCROP)
            DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)
                ! 0 = No T/No CU
                ! 1 = No GW Interaction/Full CU from Surf/No  Anoxia/Soil Stress Reducation, No  Root-Groundwater Uptake  
                ! 2 = No GW Uptake/ HAS Anoxia/Soil Stress Reducation, No  Root-Groundwater Uptake  
                ! 3 = No Anoxia/No Soil Stress - But has GW Uptake
                ! 4 = No Anoxia - But has Soil Stress and GW Uptake
                ! 5 = Full Interaction HAS Anoxia/Soil Stress Reducation, HAS Root-Groundwater Uptake  
                !
                ! 100 = Linear Crop Model (CONCEPT 2)
                ! 200 = Empirical Steady State Model (Concept 1)
                !
                ! Sum indicates crop T
                IF(.NOT. CDAT%CROP(I)%NOT_FALLOW_SP(K) .OR.   &
                         CDAT%CROP(I)%GW_INTER(K) == Z .OR.   &
                         CDAT%CROP(I)%FTR(K)      == DZ ) THEN    !No Crop/Bare land/No CU
                                                          CDAT%CROP(I)%T_CONCEPT(K) = Z
                ELSEIF(CDAT%CROP(I)%GW_INTER(K) == ONE) THEN    !No Crop-Root GW Interaction -- Full CU
                                                          CDAT%CROP(I)%T_CONCEPT(K) = ONE
                ELSEIF(PRNT(I)) THEN  !HAS PSI
                                                          CDAT%CROP(I)%T_CONCEPT(K) = 200 + CDAT%CROP(I)%GW_INTER(K) !Uses root pressurews
                ELSE
                                                          CDAT%CROP(I)%T_CONCEPT(K) = 100 + CDAT%CROP(I)%GW_INTER(K)     !uses linear model
                END IF
                !
            END DO; END DO
        END IF
        !
        !###########################################################################################################
        !
        !
        ! CALCULATE CECT = FEI/FTR
        !
        IF( UPDATE .OR. (CDAT%FTR%TRANSIENT.OR.CDAT%FEI%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. (CDAT%FTR%SFAC%HAS_EX3 .OR. CDAT%FEI%SFAC%HAS_EX3)) ) THEN
              DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
              DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
                                                                      IF(CDAT%CROP(I)%FTR(K) > DZ) THEN
                                                                          CDAT%CROP(I)%CECT(K) = CDAT%CROP(I)%FEI(K)/CDAT%CROP(I)%FTR(K)  !RATIO USED BY A NUMBER OF CALCULATIONS, KEEP IN MEMORY FOR SPEED
                                                                      ELSE
                                                                          CDAT%CROP(I)%CECT(K) = DZ
                                                                      END IF
              END DO; END DO
        END IF
        !
        !###########################################################################################################
        !
        !
        ! CALCULATE EGW, TGW
        !
        !===== FOR CROP CONDITIONS:                                                             ====================
        !        CALCULATE POTENTIAL TRANSPIRATORY AND EVAPORATIVE CONSUMPTIVE USE, AS WELL AS
        !        MAXIMUM TRANSPIRATION AND MAXIMUM EVAPORATION FROM GROUNDWATER.
        !       FOR NON-CROP FALLOW CONDITIONS:
        !        SET POTENTIAL TRANSPIRATION = 0, AND POTENTIAL EVAPORATION EQUAL TO
        !         PRECIPTIATION OR REFERENCE ET, WHICH EVER IS LESS.
        !       (if consumptive use and precipitation were read for every stress period; however
        !        if calculated as time step averages --> AD ROUTINE)
        !        Note: the 2D-CU array and therefore also the max.-TGW array ignores
        !              small scale 'no-flow and constant head details,' because
        !              net-recharge will not be calculated for such cells.
        !
        DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
        DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
            !
            IF(CDAT%CROP(I)%T_CONCEPT(K) == Z) THEN
               CDAT%CROP(I)%TGW(K) = DZ
            ELSE
               CDAT%CROP(I)%TGW(K) = CDAT%CROP(I)%FTR(K)  * CDAT%CROP(I)%CU(K) 
               !
               IF(CDAT%CROP(I)%TGW(K) < NEARZERO_15) CDAT%CROP(I)%TGW(K) = DZ
            END IF
            !
            !CDAT%CROP(I)%EGW(K) = (UNO - CDAT%CROP(I)%FTR(K)) * CDAT%CROP(I)%CU(K)
            !CDAT%CROP(I)%EGW(K) = CDAT%CROP(I)%CU(K) - CDAT%CROP(I)%TGW(K)
            !
            !IF(CDAT%CROP(I)%EGW(K) < NEARZERO_15) CDAT%CROP(I)%EGW(K) = DZ
            !
        END DO; END DO
        !
        !WBS%TPRECIP = DZ
        !WBS%EPRECIP = DZ
        IF(CLIM%HAS_PRECIP) THEN
            !
            DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
            DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
                           CDAT%CROP(I)%PRECIP(K) = CLIM%PRECIP(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K)) * CDAT%CROP(I)%AREA(K)
            END DO
            END DO
            !
            IF(CDAT%HAS_Pe) THEN
               DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
               DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
                              !
                              P = CLIM%PRECIP_EFFECTIVE(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K)) * CDAT%CROP(I)%AREA(K)
                              !
                              IF (CDAT%CROP(I)%PRECIP(K) - P > NEARZERO_15) THEN
                                  !
                                  CDAT%CROP(I)%RNOFF_Peff(K) = CDAT%CROP(I)%PRECIP(K) - P  !Excess precip from effective table
                                  CDAT%CROP(I)%PRECIP(K) = P                               !Precip that is consumable is less
                              ELSE
                                  CDAT%CROP(I)%RNOFF_Peff(K) = DZ
                              END IF
               END DO
               END DO
            END IF
            !                               !Parse precipit for consumption
            DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
            DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
                !
                P = CDAT%CROP(I)%PRECIP(K)
                !
                IF( CDAT%CROP(I)%T_CONCEPT(K) == Z ) THEN
                    CDAT%CROP(I)%TPPOT(K) = DZ
                ELSE
                    CDAT%CROP(I)%TPPOT(K) = CDAT%CROP(I)%FTR(K) * P
                END IF
                
                CDAT%CROP(I)%EPPOT(K) = P - CDAT%CROP(I)%TPPOT(K)
                !
                IF(CDAT%CROP(I)%TPPOT(K) > CDAT%CROP(I)%TGW(K)) CDAT%CROP(I)%TPPOT(K) = CDAT%CROP(I)%TGW(K)
                !
                IF(CDAT%CROP(I)%TPPOT(K) < NEARZERO_15) CDAT%CROP(I)%TPPOT(K) = DZ
                IF(CDAT%CROP(I)%EPPOT(K) < NEARZERO_15) CDAT%CROP(I)%EPPOT(K) = DZ
                !
            END DO; END DO
            !!!DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
            !!!DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
            !!!    !
            !!!    P = CLIM%PRECIP(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K)) * CDAT%CROP(I)%AREA(K)
            !!!    !
            !!!    IF(P < NEARZERO_15) P = DZ
            !!!    !
            !!!    CDAT%CROP(I)%PRECIP(K) = P
            !!!    !
            !!!    IF(HAS_CON_PRECIP_FRAC) THEN
            !!!          !
            !!!          IF    (CDAT%CROP(I)%CON_PRECIP_FRAC(K) < NEARZERO_15 .OR. P < NEARZERO_15 ) THEN
            !!!                                                                    P = DZ
            !!!          ELSEIF(CDAT%PCF_IS_FRAC) THEN
            !!!                                   IF(CDAT%CROP(I)%CON_PRECIP_FRAC(K) < SUB_ONE_5) THEN
            !!!                                          !
            !!!                                          P = P * CDAT%CROP(I)%CON_PRECIP_FRAC(K)  !ADJUST TO ONLY ALLOW FOR CONSUMABLE PRECIP
            !!!                                          !
            !!!                                          IF( P < NEARZERO_15 ) P = DZ
            !!!                                   END IF
            !!!          ELSEIF(CDAT%CROP(I)%CON_PRECIP_FRAC(K) < D29) THEN
            !!!              DTMP = CDAT%CROP(I)%CON_PRECIP_FRAC(K) * CDAT%CROP(I)%AREA(K)  !PRECIP CONSUMPTION POTENTIAL
            !!!              !
            !!!              IF(P > DTMP) P = DTMP
            !!!          END IF
            !!!    END IF
            !!!    !
            !!!    CDAT%CROP(I)%TPPOT(K) = CDAT%CROP(I)%FTR(K) * P
            !!!    CDAT%CROP(I)%EPPOT(K) = P - CDAT%CROP(I)%TPPOT(K)
            !!!    !
            !!!    IF(CDAT%CROP(I)%TPPOT(K) > CDAT%CROP(I)%TGW(K)) CDAT%CROP(I)%TPPOT(K) = CDAT%CROP(I)%TGW(K)
            !!!    !IF(CDAT%CROP(I)%EPPOT(K) > CDAT%CROP(I)%EGW(K)) CDAT%CROP(I)%EPPOT(K) = CDAT%CROP(I)%EGW(K)
            !!!    !
            !!!    !CDAT%CROP(I)%TPPOT(K) = MIN( P *        CDAT%CROP(I)%FTR(K),  CDAT%CROP(I)%TGW(K) ) 
            !!!    !CDAT%CROP(I)%EPPOT(K) = MIN( P * (UNO - CDAT%CROP(I)%FTR(K)), CDAT%CROP(I)%EGW(K) )
            !!!    !
            !!!    IF(CDAT%CROP(I)%TPPOT(K) < NEARZERO_15) CDAT%CROP(I)%TPPOT(K) = DZ
            !!!    IF(CDAT%CROP(I)%EPPOT(K) < NEARZERO_15) CDAT%CROP(I)%EPPOT(K) = DZ
            !!!    !
            !!!END DO; END DO
        ELSE
            DO CONCURRENT ( I=ONE:CDAT%NCROP)
                !
                CDAT%CROP(I)%TPPOT     = DZ 
                CDAT%CROP(I)%EPPOT     = DZ
                CDAT%CROP(I)%PRECIP    = DZ
                ! 
            END DO
        END IF
        !
        ! SET BARE LAND (FALLOW) FRACTIONS --REQUIRES FRAC TO BE POPULATED
        IF (UPDATE .AND. CDAT%MIN_BARE < UNO) THEN
              !
              CDAT%BARE_FRAC = UNO
              IF(CDAT%FRAC%INUSE) THEN
                               DO CONCURRENT (I=ONE:CDAT%NCROP    )
                               DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)
                                     !
                                     R = CDAT%CROP(I)%RC(ONE,K)
                                     C = CDAT%CROP(I)%RC(TWO,K)
                                     !
                                     CDAT%BARE_FRAC(C,R) = CDAT%BARE_FRAC(C,R) - CDAT%CROP(I)%FRAC(K)
                               END DO; END DO
                               !0.000001
                               DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%BARE_FRAC(C,R) < CDAT%MIN_BARE .OR. WBS%FID_ARRAY(C,R) < ONE )
                                     !
                                     IF(CDAT%BARE_FRAC(C,R) < NEGNEARZERO_3) CALL WRN%ADD(NUM2STR(R,-5)//' '//NUM2STR(C,-5)//' '//NUM2STR(UNO-CDAT%BARE_FRAC(C,R))//NL)
                                     !
                                     CDAT%BARE_FRAC(C,R) = DZ
                               END DO
                               IF (WRN%RAISED) CALL WRN%CHECK(HED='FMP CROP FRACTION FOR A ROW/COLUMN HAD A SUM GREATER THEN ONE ACROSS ALL CROPS.'//NL// &
                                                                  'THE FALLOW/BARE PORTION IS ASSUMED TO BE ZERO AND THE FOLLOWING ARE THE PROBLEM MODEL CELLS:'//BLN// &
                                                                  'ROW   COL   SUMMED_FRACTION',                   &
                                                                   OUTPUT=CDAT%LOUT, TAIL=NL, NO_NL=TRUE, INIT=TRUE)
              ELSE             
                               DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%CRPID(C,R) > Z .OR. WBS%FID_ARRAY(C,R) < ONE );   CDAT%BARE_FRAC(C,R) = DZ
                               END DO
              END IF
              !
              IF(CLIM%HAS_BARE_REF_ET) THEN
                                           CDAT%CHECK_BARE = ANY(CDAT%BARE_FRAC > DZ)
              ELSE
                                           CDAT%CHECK_BARE = FALSE
              END IF
              !
        ELSEIF(.NOT. CLIM%HAS_BARE_REF_ET) THEN
            CDAT%CHECK_BARE = FALSE
            !CDAT%BARE_FRAC  = DZ
        END IF
        !
        !
        ! CALCULATE CROP ELEVATIONS  --REQUIRES CDAT%CHECK_BARE FLAG
        !
        IF(UPDATE) CALL SETUP_CROP_ELEVATION(CDAT, WBS)
        !
        IF(UPDATE .OR. (CDAT%ROOT%TRANSIENT.AND.LOAD_NEXT) .OR. SOIL%CAPILLARY_TFR%TRANSIENT .OR. (NEW_IRR .AND. CDAT%ROOT%SFAC%HAS_EX3) ) THEN
           DO CONCURRENT (I=ONE:CDAT%NCROP)
           DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)  
                                                                   R = CDAT%CROP(I)%RC(ONE,K)
                                                                   C = CDAT%CROP(I)%RC(TWO,K)
                                                                   !
                                                                   CDAT%CROP(I)%SS(K)   = CDAT%CROP(I)%GSE(K) - CDAT%CROP(I)%ROOT(K)
                                                                   CDAT%CROP(I)%LXX(K)  = CDAT%CROP(I)%GSE(K) - CDAT%CROP(I)%ROOT(K) - SOIL%CAPILLARY_FRINGE(C,R)
                                                                   CDAT%CROP(I)%XX(K)   = CDAT%CROP(I)%GSE(K) - SOIL%CAPILLARY_FRINGE(C,R)
                                                                   !CDAT%CROP(I)%PSIA(K) = SOIL%CAPILLARY_FRINGE(C,R)
                                                                   !
           END DO; END DO
        END IF
        !
        IF(CDAT%HAS_PSI) CALL CDAT%CROP%SETUP_UXX_MXX(SOIL,CDAT%MLT)
        !
    END IF !-------------------------------------------------------------------------------------------------------------------------------- IF(CDAT%NCROP == Z) THEN ; ELSE ; END IF
    !
    !
    IF(CDAT%CHECK_BARE) THEN
         !
         IF(.NOT. ALLOCATED(CDAT%BARE_PRECEP_EXCESS) ) THEN
             !
             ALLOCATE( CDAT%BARE_PRECEP_EXCESS (CDAT%NCOL,CDAT%NROW), &
                       CDAT%BARE_TOT_PRECEP    (CDAT%NCOL,CDAT%NROW), &
                       CDAT%BARE_POT_EVAP      (CDAT%NCOL,CDAT%NROW), &
                       CDAT%BARE_EVAP          (CDAT%NCOL,CDAT%NROW), &
                       CDAT%BARE_EVAP_EHI      (CDAT%NCOL,CDAT%NROW), &
                       CDAT%BARE_EVAP_EHD      (CDAT%NCOL,CDAT%NROW), &
                       CDAT%BARE_EVAP_PRECIP   (CDAT%NCOL,CDAT%NROW), &
                       CDAT%BARE_FRAC_RUNOFF   (CDAT%NCOL,CDAT%NROW), &
                       !CDAT%BARE_FRAC_PRECIP(CDAT%NCOL,CDAT%NROW), &
                                                                   SOURCE=DZ)
             !
             IF(CDAT%HAS_Pe) ALLOCATE(CDAT%BARE_RNOFF_Peff(CDAT%NCOL,CDAT%NROW), SOURCE=DZ)
         ELSE
             CDAT%BARE_EVAP_EHI = DZ
             CDAT%BARE_EVAP_EHD = DZ
             CDAT%BARE_EVAP     = DZ
         END IF
         !
         CALL WBS%SETUP_FALLOW_FRACTION_ARRAY(WBS%BARE_FRAC_RUNOFF,CDAT%BARE_FRAC_RUNOFF,UPDATE)       !POPULATES ARRAY OF FRACTIONS OF RUNOFF TO DP FOR BARE/FALLOW LAND
         !CALL WBS%SETUP_FALLOW_FRACTION_ARRAY(WBS%BARE_FRAC_PRECIP,CDAT%BARE_FRAC_PRECIP,UPDATE) 
         !
         IF(CLIM%HAS_PRECIP) THEN
                             CDAT%BARE_TOT_PRECEP = CDAT%BARE_FRAC * WBS%AREA * CLIM%PRECIP
                             !
                             WHERE(CDAT%BARE_TOT_PRECEP < DZ); CDAT%BARE_TOT_PRECEP = DZ
                             END WHERE
                             !
                             IF(CDAT%HAS_Pe) THEN
                                DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL)
                                    !
                                    P = CLIM%PRECIP_EFFECTIVE(C,R) * CDAT%BARE_FRAC(C,R) * WBS%AREA(C,R)
                                    !
                                    IF (CDAT%BARE_TOT_PRECEP(C,R) - P > NEARZERO_15) THEN
                                        !
                                        CDAT%BARE_RNOFF_Peff(C,R) = CDAT%BARE_TOT_PRECEP(C,R) - P  !Excess precip from effective table
                                        CDAT%BARE_TOT_PRECEP(C,R) = P                              !Precip that is consumable is less
                                    ELSE
                                        CDAT%BARE_RNOFF_Peff(C,R) = DZ
                                    END IF
                                END DO
                             END IF
         ELSE
                             CDAT%BARE_TOT_PRECEP = DZ
         END IF
         !
         CDAT%BARE_POT_EVAP  = CDAT%BARE_FRAC * WBS%AREA * CLIM%BARE_POT_EVAP
         !
         WHERE(CDAT%BARE_POT_EVAP < DZ); CDAT%BARE_POT_EVAP = DZ
         END WHERE
         !
         DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL)
            !
            IF(CDAT%BARE_FRAC(C,R) > DZ) THEN
                  !
                  P = CDAT%BARE_TOT_PRECEP(C,R) ! * CDAT%BARE_FRAC_PRECIP(C,R)  !Precip availible for consumption
                  IF(P < DZ) P = DZ
                  !
                  IF(P > CDAT%BARE_POT_EVAP(C,R)) THEN  !Precip availible for consumption greater then potential evap
                      !
                      CDAT%BARE_PRECEP_EXCESS(C,R)  = CDAT%BARE_TOT_PRECEP(C,R) - CDAT%BARE_POT_EVAP(C,R)
                      IF(CDAT%BARE_PRECEP_EXCESS(C,R) < NEARZERO_12) CDAT%BARE_PRECEP_EXCESS(C,R) = DZ
                      !
                      CDAT%BARE_EVAP_PRECIP(C,R)    = CDAT%BARE_POT_EVAP(C,R)
                      CDAT%BARE_POT_EVAP(C,R)       = DZ
                  ELSE
                      CDAT%BARE_PRECEP_EXCESS(C,R) = DZ
                      CDAT%BARE_EVAP_PRECIP(C,R)   = P
                      CDAT%BARE_POT_EVAP(C,R)      = CDAT%BARE_POT_EVAP(C,R) - P
                  END IF
                  !
            ELSE
                      CDAT%BARE_PRECEP_EXCESS(C,R) = DZ
                      CDAT%BARE_EVAP_PRECIP(C,R)   = DZ
                      CDAT%BARE_POT_EVAP(C,R)      = DZ
            END IF
         END DO
    !ELSE
    !    CDAT%BARE_PRECEP_EXCESS    = DZ
    !    CDAT%BARE_POT_EVAP  = DZ
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE PARSE_CROP_ROW_COL(CDAT, FID, NEW_FID)
    !USE, INTRINSIC:: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN
    CLASS(CROP_DATA),                    INTENT(INOUT):: CDAT
    INTEGER, DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: FID
    LOGICAL,                             INTENT(IN   ):: NEW_FID
    INTEGER:: I, J, K, NR, NC, LD, ID, N, M, P  !LD = LEADING DIMENSION
    !DOUBLE PRECISION:: NaN
    LOGICAL:: REALLOCATE, UPDATE_CID
    TYPE(WARNING_TYPE):: WRN
    !
    !TOL = 1D-30
    NC = CDAT%NCOL
    NR = CDAT%NROW
    CALL WRN%INIT()
    !
    UPDATE_CID = FALSE
    IF(.NOT. CDAT%MULTI_CROP_CELLS) THEN
                                IF (NEW_FID) THEN
                                                       UPDATE_CID = TRUE
                                ELSEIF(CDAT%CID%HAS_IXJ) THEN
                                                 ASSOCIATE(DIM => CDAT%CID%IXJ%N, DAT => CDAT%CID%IXJ%DAT)
                                                          !
                                                          UPDATE_CID = FALSE
                                                          !
                                                          DO P=ONE, DIM
                                                                K = DAT(P)%I(1)
                                                                I = DAT(P)%I(2)
                                                                J = DAT(P)%I(3)
                                                                !
                                                                IF(K .NE. CDAT%CRPID(J,I)) THEN
                                                                    UPDATE_CID = TRUE
                                                                    EXIT
                                                                END IF
                                                          END DO
                                                 END ASSOCIATE
                                    
                                ELSE
                                                       UPDATE_CID = ANY(CDAT%CID%ARRAY .NE. CDAT%CRPID)
                                END IF
    END IF
    !
    IF(CDAT%MULTI_CROP_CELLS) THEN
        !
        !NaN = IEEE_VALUE(NaN, IEEE_QUIET_NAN)
        !WHERE ( CDAT%FRAC%ARRAY < NEARZERO_30 ) CDAT%FRAC%ARRAY = DZ !NaN  !-NEARZERO_30 < CDAT%FRAC%ARRAY .AND. 
        !
        IF(CDAT%FRAC%HAS_IXJ) THEN
          !
          ASSOCIATE(DIM => CDAT%FRAC%IXJ%N, POS=>CDAT%FRAC%IXJ%P, DAT => CDAT%FRAC%IXJ%DAT)
             !
             DO P=ONE, DIM
                 IF    (DAT(P)%X(1) < NEARZERO_30) THEN
                                                                DAT(P)%X(1) = DZ
                 ELSEIF(DAT(P)%X(1) > UNO        ) THEN
                                                                DAT(P)%X(1) = UNO
                 END IF
             END DO
             !
             DO CONCURRENT (ID=ONE:CDAT%NCROP)
                !
                N   = Z  !CURRENT COUNT OF CROP ID WITH FID>0
                M   = Z  !TOTAL COUNT OF CROP ID
                !
                DO P=ONE, DIM
                    IF(     DAT(P)%I(1) == ID .AND. DAT(P)%X(1) > DZ) THEN
                        I = DAT(P)%I(2) 
                        J = DAT(P)%I(3)
                        M = M + ONE
                        !
                        IF(FID(J,I) > Z) N = N + ONE
                    END IF
                END DO
                !
                REALLOCATE = N .NE. CDAT%CROP(ID)%N
                CDAT%CROP(ID)%N = N
                !
                IF( N > Z) THEN 
                               IF ( REALLOCATE ) THEN
                                                     CALL DEALLOCATE_CROP_PROP(CDAT%CROP(ID))
                                                     !
                                                     CDAT%CROP(ID)%N = N                              !DEALLOCATE_CROP_PROP MADE CDAT%CROP(ID)%N = 0, HAVE TO RESET IT
                                                     ALLOCATE(CDAT%CROP(ID)%RC(TWO,CDAT%CROP(ID)%N))
                                                     !ALLOCATE(CDAT%CROP(ID)%FRAC(CDAT%CROP(ID)%N))
                                                     !
                                                     CALL ALLOC(CDAT%CROP(ID)%FRAC, N)
                               END IF
                               !
                               CALL CDAT%FRAC%IXJ%START_ID(ID, ONE) !Sets IXJ%P to correct location, which is also equal to POS
                               !
                               K = Z
                               DO LD = ONE, M     ! M IS TOTAL COUNT OF ID  
                                   I = DAT(POS)%I(2) 
                                   J = DAT(POS)%I(3)
                                   IF(FID(J,I) > Z .AND. DAT(POS)%X(1) > DZ) THEN
                                                        K=K+ONE
                                                        CDAT%CROP(ID)%RC(ONE,K) = I
                                                        CDAT%CROP(ID)%RC(TWO,K) = J
                                                        CDAT%CROP(ID)%FRAC(K)   = DAT(POS)%X(1)
                                   ELSEIF(DAT(POS)%X(1) > DZ) THEN
                                                        CALL WRN%ADD(NUM2STR(ID,-5)//' '//NUM2STR(I,-10)//' '//NUM2STR(J,-10)//NL)
                                   END IF
                                   !
                                   CALL CDAT%FRAC%IXJ%NEXT_ID(ID, ONE)
                               END DO
                ELSE   ! NO CROPS FOUND, SO NO ALLOCATION!
                               CALL DEALLOCATE_CROP_PROP(CDAT%CROP(ID))
                END IF
             END DO
          END ASSOCIATE
        ELSE
           DO CONCURRENT (J=ONE:SIZE(CDAT%FRAC%ARRAY,TWO), I=ONE:SIZE(CDAT%FRAC%ARRAY,ONE), CDAT%FRAC%ARRAY(I,J).NE.DZ)
                 IF    (CDAT%FRAC%ARRAY(I,J) < NEARZERO_30) THEN
                                                                CDAT%FRAC%ARRAY(I,J) = DZ
                 ELSEIF(CDAT%FRAC%ARRAY(I,J) > UNO ) THEN
                                                                CDAT%FRAC%ARRAY(I,J) = UNO
                 END IF
           END DO
           !
           DO CONCURRENT (ID=ONE:CDAT%NCROP)  ! FRAC_LOOP
              !
              LD = CDAT%CROP(ID)%LD - ONE 
              !CDAT%CROP(ID)%ID = ID
              !LD = (ID-ONE)*NR
              !
              !N = Z
              !DO CONCURRENT(J=1:NC, I=1:NR, CDAT%FRAC%ARRAY(J,LD+I) == CDAT%FRAC%ARRAY(J,LD+I) )
              !                N = N + ONE
              !END DO
              N = COUNT( CDAT%FRAC%ARRAY(:, LD+ONE:LD+NR) >= NEARZERO_30 .AND.  FID > Z)  !CDAT%FRAC%ARRAY(:,LD:LD+NR)==CDAT%FRAC%ARRAY(:,LD:LD+NR)
              !
              REALLOCATE = N .NE. CDAT%CROP(ID)%N
              CDAT%CROP(ID)%N = N
              !
              IF( N > Z) THEN 
                             IF ( REALLOCATE ) THEN
                                                   CALL DEALLOCATE_CROP_PROP(CDAT%CROP(ID))
                                                   !
                                                   CDAT%CROP(ID)%N = N                              !DEALLOCATE_CROP_PROP MADE CDAT%CROP(ID)%N = 0, HAVE TO RESET IT
                                                   ALLOCATE(CDAT%CROP(ID)%RC(TWO,CDAT%CROP(ID)%N))
                                                   !ALLOCATE(CDAT%CROP(ID)%FRAC(CDAT%CROP(ID)%N))
                             END IF
                             !
                             K = 0
                             DO CONCURRENT(I=ONE:NR, J=ONE:NC, CDAT%FRAC%ARRAY(J,LD+I) > NEARZERO_30)
                                 IF(FID(J,I) > Z) THEN
                                                      K=K+ONE
                                                      CDAT%CROP(ID)%RC(ONE,K) = I
                                                      CDAT%CROP(ID)%RC(TWO,K) = J
                                                      !CDAT%CROP%FRAC(K) = CDAT%FRAC%ARRAY(J,LD+I)
                                 ELSE
                                                      !CDAT%FRAC%ARRAY(J,LD+I) = DZ  --NEED TO HOLD VALUE INCASE OF REPEAT
                                                      CALL WRN%ADD(NUM2STR(ID,-5)//' '//NUM2STR(I,-10)//' '//NUM2STR(J,-10)//NL)
                                                      
                                 END IF
                             END DO
              ELSE   ! NO CROPS FOUND, SO NO ALLOCATION!
                             CALL DEALLOCATE_CROP_PROP(CDAT%CROP(ID))
              END IF
           END DO !FRAC_LOOP
        END IF
        !
    ELSEIF(UPDATE_CID) THEN
        !
        IF(CDAT%CID%HAS_IXJ) THEN
            !
            CALL SET_ARRAY(NC, NR,  Z, CDAT%CRPID)
            !
            ASSOCIATE(DIM => CDAT%FRAC%IXJ%N, DAT => CDAT%FRAC%IXJ%DAT)
                     !
                     DO P=ONE, DIM
                           K = DAT(P)%I(1)
                           I = DAT(P)%I(2)
                           J = DAT(P)%I(3)
                           !
                           IF(Z < K .AND. K <= CDAT%NCROP) CDAT%CRPID(J,I) = K
                           !
                     END DO
            END ASSOCIATE
        ELSE
            DO CONCURRENT(I=ONE:NR, J=ONE:NC)
                IF(CDAT%CID%ARRAY(J,I) > CDAT%NCROP) THEN
                                                         CDAT%CRPID(J,I)     = Z
                                                         CDAT%CID%ARRAY(J,I) = Z
                ELSEIF(CDAT%CID%ARRAY(J,I) .NE. Z) THEN
                                                         CDAT%CRPID(J,I) = CDAT%CID%ARRAY(J,I)
                ELSE
                                                         CDAT%CRPID(J,I) = Z
                END IF
            END DO
        END IF
        !
        DO CONCURRENT(I=ONE:NR, J=ONE:NC, FID(J,I)==Z .AND. CDAT%CRPID(J,I) > Z)
               !
               CALL WRN%ADD(NUM2STR(CDAT%CRPID(J,I),-5)//' '//NUM2STR(I,-10)//' '//NUM2STR(J,-10)//NL)
               CDAT%CRPID(J,I) = Z
        END DO
        !
        CID_LOOP: DO CONCURRENT (ID=ONE:CDAT%NCROP)
           !
           !CDAT%CROP(ID)%ID = ID
           N  = COUNT(ID == CDAT%CRPID)
           !
           REALLOCATE = N .NE. CDAT%CROP(ID)%N
           CDAT%CROP(ID)%N = N
           !
           IF( N > Z ) THEN
                           !
                           IF(REALLOCATE) THEN 
                               CALL DEALLOCATE_CROP_PROP(CDAT%CROP(ID))
                               CDAT%CROP(ID)%N = N
                               ALLOCATE(CDAT%CROP(ID)%RC(TWO,CDAT%CROP(ID)%N))
                           END IF
                           !
                           K = 0
                           DO CONCURRENT(I=ONE:NR, J=ONE:NC, ID == CDAT%CRPID(J,I))
                               K=K+ONE
                               CDAT%CROP(ID)%RC(ONE,K) = I
                               CDAT%CROP(ID)%RC(TWO,K) = J
                           END DO
           ELSE   ! NO CROPS FOUND, SO NO ALLOCATION!
                          CALL DEALLOCATE_CROP_PROP(CDAT%CROP(ID))
           END IF
        END DO CID_LOOP
    END IF
    !
    IF (WRN%RAISED) THEN
        CALL WRN%CHECK(HED='FMP CROP: FOUND CROP IDs THAT ARE GREATER THAN ZERO LOCATED IN CELLS THAT HAVE WBS ID EQUAL TO ZERO.'//NL//     &
                                                     'TO FIX THIS PROBLEM THE CROP ID IS SET TO ZERO OR ITS FRACTION IS SET TO 0.0'//BLN//   &
                                                     'THE FOLLOWING IS A LIST OF THE PROBLEM CELLS LOADED AND SET TO ZERO:'//NL//            &
                                                     'CROP  ROW     COLUMN',                                                                 &
                                                      OUTPUT=CDAT%LOUT,TAIL=NL,NO_NL=TRUE)
        !CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP: FOUND CROP IDs THAT ARE GREATER THAN ZERO LOCATED IN CELLS THAT HAVE FARM ID EQUAL TO ZERO.'//NL//  &
        !                                             'TO FIX THIS PROBLEM THE CROP ID IS SET TO ZERO OR ITS FRACTION IS SET TO 0.0'//BLN//                         &
        !                                             'THE FOLLOWING IS A LIST OF THE PROBLEM CELLS LOADED AND SET TO ZERO:'//NL//                                  &
        !                                             'CROP  ROW     COLUMN'//ERROR)
        !WRITE(CDAT%LOUT,'(4(/ A), A /)')'FMP CROP: FOUND CROP IDs THAT ARE GREATER THAN ZERO LOCATED IN CELLS THAT HAVE FARM ID EQUAL TO ZERO.', &
        !                                             'TO FIX THIS PROBLEM THE CROP ID IS SET TO ZERO OR ITS FRACTION IS SET TO 0.0','THE FOLLOWING IS A LIST OF THE PROBLEM CELLS LOADED AND SET TO ZERO:', &
        !                                             'CROP  ROW     COLUMN',  ERROR
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SETUP_CROP_WBS_ID(CDAT, WBS)
    !
    CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),     INTENT(INOUT):: WBS
    INTEGER:: I, K, F
    INTEGER,DIMENSION(WBS%NFARM):: CNT
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP)
                                    CALL ALLOC(CDAT%CROP(I)%FID, CDAT%CROP(I)%N)
    END DO
    !
    CNT = Z
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP)
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)
          !                                                     COL                   ROW
          CDAT%CROP(I)%FID(K) = WBS%FID_TFR%GET(Z, CDAT%CROP(I)%RC(TWO,K), CDAT%CROP(I)%RC(ONE,K), Z)
          !
          IF(CDAT%CROP(I)%FID(K) > Z) CNT(CDAT%CROP(I)%FID(K)) = CNT(CDAT%CROP(I)%FID(K)) + ONE
          !
    END DO
    END DO
    !
    DO CONCURRENT (F=ONE:WBS%NFARM)
        IF(CNT(F)>Z) THEN
            CALL ALLOC(WBS%CROP(F)%PNT, FOUR, CNT(F))
            WBS%CROP(F)%N = CNT(F)
        ELSE
            WBS%CROP(F)%N = Z
        END IF
    END DO
    !
    CNT = Z
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP)
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FID(K) > Z)
          !
          F = CDAT%CROP(I)%FID(K) 
          
          !
          CNT(F) = CNT(F) + ONE
          !
          WBS%CROP(F)%PNT(ONE,  CNT(F)) = I
          WBS%CROP(F)%PNT(TWO,  CNT(F)) = K
          WBS%CROP(F)%PNT(THREE,CNT(F)) = CDAT%CROP(I)%RC(ONE,K)
          WBS%CROP(F)%PNT(FOUR, CNT(F)) = CDAT%CROP(I)%RC(TWO,K)
    END DO; END DO
    !    
  END SUBROUTINE
  !
  PURE SUBROUTINE SETUP_CROP_EFFICIENCY(CDAT, WBS, RANGE_CHECK)
    !
    CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),INTENT(IN   ):: WBS
    LOGICAL,       INTENT(IN   ):: RANGE_CHECK
    INTEGER:: I, K
    !
    DO CONCURRENT   ( I=ONE:CDAT%NCROP,    CDAT%CROP(I)%N > Z )
      DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
          !
          IF (CDAT%CROP(I)%IRR(K)>Z) THEN !                                           FID                 COL                    ROW             IRRIGATION TYPE
                                          CDAT%CROP(I)%EFF(K) = WBS%EFF_TFR%GET( CDAT%CROP(I)%FID(K),CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K),CDAT%CROP(I)%IRR(K) )
                                          !
                                          IF(CDAT%CROP(I)%EFF(K) .NE. CDAT%CROP(I)%EFF(K)) CDAT%CROP(I)%EFF(K) = DZ
          ELSE
                                          CDAT%CROP(I)%EFF(K) = DZ
          END IF
      END DO
      !
      CALL CROP_INPUT_APPLY_SFAC( CDAT%CROP(I)%EFF, WBS%EFF_TFR%SFAC, CDAT%CROP(I)%N, I, CDAT%CROP(I)%FID, CDAT%CROP(I)%IRR )
      !
    END DO
    !
    IF(RANGE_CHECK) THEN
                  !
                  DO CONCURRENT ( I=ONE:CDAT%NCROP )
                  DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%IRR(K) > Z )
                                 !
                                 IF(    CDAT%CROP(I)%EFF(K) <  DZ) THEN
                                                                        CDAT%CROP(I)%EFF(K) = DZ
                                 ELSEIF(CDAT%CROP(I)%EFF(K) >  UNO) THEN
                                                                        CDAT%CROP(I)%EFF(K) = UNO
                                 END IF
                  END DO
                  END DO
    END IF
    !    
  END SUBROUTINE
  !
  PURE SUBROUTINE SETUP_CROP_ELEVATION(CDAT, WBS)
    !
    CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),     INTENT(IN   ):: WBS
    INTEGER:: I, K, LD, R, C
    DOUBLE PRECISION:: TMP
    DOUBLE PRECISION,DIMENSION(:,:),ALLOCATABLE:: ARR
    !
    IF(CDAT%CHECK_BARE) THEN  !ONLY DO THIS FOR FIRST CALL OF NEXT() ROUTINE
          IF(.NOT.ALLOCATED(CDAT%BARE_GSE)) THEN
                                                ALLOCATE(CDAT%BARE_GSE(CDAT%NCOL, CDAT%NROW)); CDAT%BARE_GSE = WBS%GSE
          ELSEIF(CDAT%SPEC_GSE%TRANSIENT .OR. CDAT%GSE_OFFSET%TRANSIENT)  THEN
                                                         CDAT%BARE_GSE = WBS%GSE
          END IF
    END IF
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP    )
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)  
                                                            CDAT%CROP(I)%GSE(K) = WBS%GSE(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K))
    END DO; END DO
    !
    !
    IF(CDAT%SPEC_GSE%INUSE) THEN
          DO CONCURRENT (I=Z:CDAT%NCROP)
              LD = Z
              DO K=ONE, CDAT%NCROP_ELEV
                  IF(CDAT%GSE_CID%LIST(K)==I) THEN
                      LD = K
                      EXIT
                  END IF
              END DO
              !
              IF (LD > Z) THEN
                  IF(CDAT%MULTI_CROP_CELLS) THEN
                     LD = (LD-ONE) * CDAT%NROW  !NOTE LD=0 FOR R,C = 1,1
                  ELSE
                     LD = Z
                  END IF
                  IF (I > Z) THEN
                         !
                         DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N)  
                                                               R = CDAT%CROP(I)%RC(ONE,K)
                                                               C = CDAT%CROP(I)%RC(TWO,K)
                                                               CDAT%CROP(I)%GSE(K) = CDAT%SPEC_GSE%ARRAY(C,R+LD)
                                                               CALL CROP_INPUT_APPLY_SFAC_SINGLE(CDAT%CROP(I)%GSE(K), CDAT%SPEC_GSE%SFAC, I, CDAT%CROP(I)%FID(K) )
                         END DO
                  ELSEIF (CDAT%CHECK_BARE .AND. I == Z ) THEN
                                                               CDAT%BARE_GSE = CDAT%SPEC_GSE%ARRAY(:,LD+ONE:LD+CDAT%NROW)
                                                               CALL CROP_INPUT_APPLY_SFAC_SINGLE(CDAT%BARE_GSE, CDAT%SPEC_GSE%SFAC, Z, WBS%FID_ARRAY )
                  END IF
              END IF
          END DO
    END IF
    !
    IF(CDAT%GSE_OFFSET%INUSE) THEN
          DO CONCURRENT (I=Z:CDAT%NCROP)
              LD = Z
              DO K=ONE, CDAT%NCROP_ELEV
                  IF(CDAT%GSE_CID%LIST(K)==I) THEN
                      LD = K
                      EXIT
                  END IF
              END DO
              !
              IF (LD > Z) THEN
                  IF (I > Z) THEN
                         !
                         DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N) 
                                                               TMP = CDAT%GSE_OFFSET%LIST(LD)
                                                               CALL CROP_INPUT_APPLY_SFAC_SINGLE(TMP, CDAT%GSE_OFFSET%SFAC, I, CDAT%CROP(I)%FID(K) )
                                                               CDAT%CROP(I)%GSE(K) = CDAT%CROP(I)%GSE(K) + TMP
                         END DO
                  ELSEIF (CDAT%CHECK_BARE .AND. I == Z ) THEN
                                                               ALLOCATE(ARR, MOLD=CDAT%BARE_GSE)
                                                               ARR = CDAT%GSE_OFFSET%LIST(LD)
                                                               CALL CROP_INPUT_APPLY_SFAC_SINGLE(ARR, CDAT%GSE_OFFSET%SFAC, Z, WBS%FID_ARRAY )
                                                               CDAT%BARE_GSE = CDAT%BARE_GSE + ARR
                                                               DEALLOCATE(ARR)
                  END IF
              END IF
          END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SETUP_CROP_FALLOW_RANK(CDAT, WBS)
    !
    CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
    TYPE(WBS_DATA), INTENT(IN   ):: WBS
    INTEGER:: I, K, NORANK
    !
    NORANK = HUGE(NORANK) - ONE
    !
    DO CONCURRENT   ( I=ONE:CDAT%NCROP     )
      DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
          !                                                              FID                 COL                ROW                CROP
              CDAT%CROP(I)%FALLOW_RANK(K) = WBS%FALLOW_RANK_TFR%GET( CDAT%CROP(I)%FID(K),CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K),I )
          IF (CDAT%CROP(I)%FALLOW_RANK(K) < ONE) CDAT%CROP(I)%FALLOW_RANK(K) = NORANK
      END DO
      !
    END DO
    !    
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_CROP_INPUT_TO_CROP_PROP(CPR, CPI)
  CLASS(CROP_PROP),       INTENT(INOUT):: CPR
  TYPE(LIST_ARRAY_INPUT), INTENT(IN   ):: CPI
  INTEGER:: K, ID, LD  ! LD => LEADING DIMENSION
  !
  IF (CPR%N > Z .AND. CPI%INUSE) THEN
     !
     ID = CPR%ID
     LD = CPR%LD
     !
     SELECT CASE(CPI%TYP)
     CASE('ROOT'  )
                    CALL ALLOC(CPR%ROOT, CPR%N)  !IF ROOT ALREADY ALLOCATED AND OVERDIMENSIONED, DONT BOTHER REALLOCATING
                    IF(CPI%LISTLOAD) THEN
                                         CPR%ROOT = CPI%LIST(ID)
                    ELSEIF(CPI%HAS_IXJ) THEN
                        CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%ROOT, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                    ELSE
                        CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%ROOT, CPI%ARRAY(:,LD:))
                    END IF
                    !    CROP_INPUT_APPLY_SFAC(SFAC, PROP, N, CID, FID, [IRR])
                    CALL CROP_INPUT_APPLY_SFAC( CPR%ROOT, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
                    !
                    WHERE( CPR%ROOT < NEARZERO_30 );  CPR%ROOT = NEARZERO_30   !THIS IS TO PREVENT ANY DIV/0 ERRORS
                    END WHERE
                    
     CASE('MULTI_FRAC')
                    !
                    IF(.NOT. CPI%HAS_IXJ) THEN !ASSUMES THAT PARSE_CROP_ROW_COL SET UP FRACTIONS ALREADY
                        CALL ALLOC(CPR%FRAC, CPR%N)
                        CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%FRAC, CPI%ARRAY(:,LD:))
                    END IF
                    !
                    CALL CROP_INPUT_APPLY_SFAC( CPR%FRAC, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
     CASE('SINGLE_FRAC')
                    CALL ALLOC(CPR%FRAC, CPR%N)
                    !
                    IF(CPI%LISTLOAD) THEN
                                         CPR%FRAC = CPI%LIST(ID)
                    ELSEIF(CPI%HAS_IXJ) THEN
                        CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%FRAC, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                    ELSE
                        CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%FRAC, CPI%ARRAY(:,LD:))
                    END IF
                    !
                    CALL CROP_INPUT_APPLY_SFAC( CPR%FRAC, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
     CASE('Kc'    )
                    CALL ALLOC(CPR%Kc, CPR%N);  CALL ALLOC(CPR%CU, CPR%N)
                    !
                    IF(CPI%LISTLOAD) THEN
                                         CPR%Kc = CPI%LIST(ID)
                    ELSEIF(CPI%HAS_IXJ) THEN
                        CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%Kc, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                    ELSE
                        CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%Kc, CPI%ARRAY(:,LD:))
                    END IF
                    !
                    CALL CROP_INPUT_APPLY_SFAC( CPR%Kc, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
     CASE('CF'    )
                    CALL ALLOC(CPR%CF, CPR%N);  CALL ALLOC(CPR%CU, CPR%N)
                    !
                    IF(CPI%LISTLOAD) THEN
                                         CPR%CF = CPI%LIST(ID)
                    ELSEIF(CPI%HAS_IXJ) THEN
                        CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%CF, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                    ELSE
                        CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%CF, CPI%ARRAY(:,LD:))
                    END IF 
                    !
                    CALL CROP_INPUT_APPLY_SFAC(CPR%CF, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
     CASE('FTR' )
                    CALL ALLOC(CPR%FTR, CPR%N)
                    IF(CPI%LISTLOAD) THEN
                                         CPR%FTR = CPI%LIST(ID)
                    ELSEIF(CPI%HAS_IXJ) THEN
                        CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%FTR, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                    ELSE
                        CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%FTR, CPI%ARRAY(:,LD:))
                    END IF
                    !
                    CALL CROP_INPUT_APPLY_SFAC(CPR%FTR, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
     !!!CASE('FEI'   )
     !!!               CALL ALLOC(CPR%FEI, CPR%N)
     !!!               IF(CPI%LISTLOAD) THEN
     !!!                                    CPR%FEI = CPI%LIST(ID)
     !!!               ELSEIF(CPI%HAS_IXJ) THEN
     !!!                   CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%FEI, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
     !!!               ELSE
     !!!                   CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%FEI, CPI%ARRAY(:,LD:))
     !!!               END IF
     !!!               !
     !!!               CALL CROP_INPUT_APPLY_SFAC(CPR%FEI, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
     CASE('FEI_BYCROP')
                    CALL ALLOC(CPR%FEI, CPR%N)
                    IF(CPI%LISTLOAD) THEN
                                         CPR%FEI = CPI%LIST(ID)
                    ELSEIF(CPI%HAS_IXJ) THEN
                        CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%FEI, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                    ELSE
                        CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%FEI, CPI%ARRAY(:,LD:))
                    END IF
                    !FEI_BYCROP FEI_BYIRR
                    CALL CROP_INPUT_APPLY_SFAC(CPR%FEI, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
     CASE('FEI_BYIRR')
                    CALL ALLOC(CPR%FEI, CPR%N)
                    IF(CPI%LISTLOAD) THEN
                                    DO CONCURRENT(K=ONE:CPR%N)
                                                     IF(CPR%IRR(K) > Z) THEN
                                                         CPR%FEI(K) = CPI%LIST(CPR%IRR(K))
                                                     ELSE
                                                         CPR%FEI(K) = DZ
                                                     END IF
                                    END DO
                    ELSEIF(CPI%HAS_IXJ) THEN
                        CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%FEI, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                    ELSE
                        CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%FEI, CPI%ARRAY(:,LD:))
                    END IF
                    ! 
                    CALL CROP_INPUT_APPLY_SFAC(CPR%FEI, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
     CASE('FIESWP')
                    CALL ALLOC(CPR%FIESWP, CPR%N)
                    IF(CPI%LISTLOAD) THEN
                                         CPR%FIESWP = CPI%LIST(ID)
                    ELSEIF(CPI%HAS_IXJ) THEN
                        CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%FIESWP, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                    ELSE
                        CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%FIESWP, CPI%ARRAY(:,LD:))
                    END IF
                    !
                    CALL CROP_INPUT_APPLY_SFAC( CPR%FIESWP, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
     CASE('FIESWI_BYCROP')
                    CALL ALLOC(CPR%FIESWI, CPR%N)
                    IF(CPI%LISTLOAD) THEN
                                         CPR%FIESWI = CPI%LIST(ID)
                    ELSEIF(CPI%HAS_IXJ) THEN
                        CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%FIESWI, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                    ELSE
                        CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%FIESWI, CPI%ARRAY(:,LD:))
                    END IF
                    !FIESWI_BYCROP FIESWI_BYIRR
                    CALL CROP_INPUT_APPLY_SFAC(CPR%FIESWI, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
     CASE('FIESWI_BYIRR')
                    CALL ALLOC(CPR%FIESWI, CPR%N)
                    IF(CPI%LISTLOAD) THEN
                                    DO CONCURRENT(K=ONE:CPR%N)
                                                     IF(CPR%IRR(K) > Z) THEN
                                                         CPR%FIESWI(K) = CPI%LIST(CPR%IRR(K))
                                                     ELSE
                                                         CPR%FIESWI(K) = DZ
                                                     END IF
                                    END DO
                    ELSEIF(CPI%HAS_IXJ) THEN
                        CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%FIESWI, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                    ELSE
                        CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%FIESWI, CPI%ARRAY(:,LD:))
                    END IF
                    ! 
                    CALL CROP_INPUT_APPLY_SFAC(CPR%FIESWI, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
     !CASE('PCF')
     !               CALL ALLOC(CPR%CON_PRECIP_FRAC, CPR%N)
     !               IF(CPI%LISTLOAD) THEN
     !                                    CPR%CON_PRECIP_FRAC = CPI%LIST(ID)
     !               ELSEIF(CPI%HAS_IXJ) THEN
     !                   CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%CON_PRECIP_FRAC, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
     !               ELSE
     !                   CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%CON_PRECIP_FRAC, CPI%ARRAY(:,LD:))
     !               END IF
     !               !
     !               CALL CROP_INPUT_APPLY_SFAC(CPR%CON_PRECIP_FRAC, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
     CASE('PSI'   )
                    IF(.NOT. ALLOCATED(CPR%PSI)) ALLOCATE(CPR%PSI(4))
                    CPR%PSI = CPI%ARRAY(:,ID)
                    CALL CROP_INPUT_APPLY_SFAC(CPR%PSI, CPI%SFAC, 4, ID )
     CASE('POND')
                    CALL ALLOC(CPR%POND, CPR%N)
                    CPR%POND = CPI%LIST(ID)
                    CALL CROP_INPUT_APPLY_SFAC(CPR%POND, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
     CASE('ADMD')
                    CALL ALLOC(CPR%ADMD, CPR%N)
                    IF(CPI%LISTARRAY) THEN
                                         DO CONCURRENT(K=ONE:CPR%N)
                                              CPR%ADMD(K) = CPI%ARRAY(CPR%FID(K), ID)
                                         END DO
                    ELSEIF(CPI%HAS_IXJ) THEN
                        CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%ADMD, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                    ELSE
                        CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%ADMD, CPI%ARRAY(:,LD:))
                    END IF
                    !
                    CALL CROP_INPUT_APPLY_SFAC(CPR%ADMD, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
                    !
     END SELECT
  END IF
  !
  END SUBROUTINE
  !
  PURE SUBROUTINE CROP_INPUT_APPLY_SFAC(PROP, SFAC, N, CID, FID, IRR)
    DOUBLE PRECISION, DIMENSION(N),  INTENT(INOUT):: PROP
    !
    TYPE(SFAC_DATA),                 INTENT(IN   ):: SFAC
    INTEGER,                         INTENT(IN   ):: N
    INTEGER,                         INTENT(IN   ):: CID
    INTEGER, DIMENSION(N), OPTIONAL, INTENT(IN   ):: FID
    INTEGER, DIMENSION(N), OPTIONAL, INTENT(IN   ):: IRR
    INTEGER:: I
    !
    IF (SFAC%HAS_ALL) PROP = PROP * SFAC%ALL
    !
    IF (SFAC%HAS_EX1) THEN  ! SCALE BYFARM
          DO CONCURRENT (I=ONE:N, FID(I)>Z)
                      PROP(I) = PROP(I) * SFAC%EX1(FID(I))
          END DO
    END IF
    !
    IF (SFAC%HAS_EX2) PROP = PROP * SFAC%EX2(CID)  !SCALE BYCROP
    !
    IF (SFAC%HAS_EX3) THEN  ! SCALE BYIRRIGAT
          DO CONCURRENT (I=ONE:N, IRR(I)>Z)
                      PROP(I) = PROP(I) * SFAC%EX3(IRR(I))  !CODE EXPECTS USER PASSES IRR IF THERE IS A CHANCE OF EX3
          END DO
    END IF
    !
  END SUBROUTINE
  !
  ELEMENTAL SUBROUTINE CROP_INPUT_APPLY_SFAC_SINGLE(PROP, SFAC, CID, FID, IRR)
    DOUBLE PRECISION, INTENT(INOUT):: PROP
    !
    TYPE(SFAC_DATA),   INTENT(IN   ):: SFAC
    INTEGER,           INTENT(IN   ):: CID
    INTEGER,           INTENT(IN   ):: FID
    INTEGER, OPTIONAL, INTENT(IN   ):: IRR
    !
    IF (SFAC%HAS_ALL)             PROP = PROP * SFAC%ALL
    !
    IF (SFAC%HAS_EX1 .AND. FID>Z) PROP = PROP * SFAC%EX1(FID)  ! SCALE BYFARM
    !
    IF (SFAC%HAS_EX2 .AND. CID>Z) PROP = PROP * SFAC%EX2(CID)  !SCALE BYCROP
    !
    IF (SFAC%HAS_EX3 .AND. IRR>Z) PROP = PROP * SFAC%EX3(IRR)  !CODE EXPECTS USER PASSES IRR IF THERE IS A CHANCE OF EX3
    !
  END SUBROUTINE
  !
!!!  PURE SUBROUTINE CROP_INPUT_CAS_TO_PROP(N, ID, RC, PROP, CAS)
!!!    INTEGER,                            INTENT(IN ):: N, ID
!!!    INTEGER,          DIMENSION(TWO,N), INTENT(IN ):: RC
!!!    DOUBLE PRECISION, DIMENSION(N),     INTENT(OUT):: PROP
!!!    CLASS(COMPRESSED_ARRAY_STORAGE),    INTENT(IN ):: CAS
!!!    INTEGER:: I, J, K, M
!!!    LOGICAL:: FOUND
!!!    !
!!!    I=CAS%FIND_IDX(ID)  !SHOULD NEVER BE ZERO -- WHICH INDICATES NOT FOUND!!!
!!!    !
!!!    IF(I==Z) THEN
!!!        PROP = DZ
!!!    ELSE
!!!        DO CONCURRENT (K=ONE:N)
!!!            !
!!!            FOUND = FALSE
!!!            !
!!!            IF(K<=CAS%LOC(I)%N) THEN    !SHOULD BE ONE-ONE RELATIONSHIP, BUT CHECK ANYWAYS
!!!                  J = CAS%LOC(I)%VEC(K)
!!!                  IF(CAS%ROW(J)==RC(ONE,K) .AND. CAS%COL(J)==RC(TWO,K)) THEN
!!!                      PROP(K) = CAS%VAL( J )
!!!                      FOUND = TRUE
!!!                  END IF
!!!            END IF
!!!            !
!!!            IF(.NOT. FOUND) THEN
!!!                  DO M=ONE, CAS%LOC(I)%N
!!!                        J=CAS%LOC(I)%VEC(M)
!!!                        IF(CAS%ROW(J)==RC(ONE,K) .AND. CAS%COL(J)==RC(TWO,K)) THEN
!!!                            PROP(K) = CAS%VAL( J )
!!!                            FOUND = TRUE
!!!                            EXIT
!!!                        END IF
!!!                  END DO
!!!            END IF
!!!            !
!!!            IF(.NOT. FOUND) PROP(K) = DZ
!!!            !    
!!!        END DO
!!!    END IF
!!!    !
!!!  END SUBROUTINE
  !
  PURE SUBROUTINE CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, N, RC, PROP, DIM1, NREC, NDAT, DAT)
    INTEGER,                                  INTENT(IN ):: ID, N
    INTEGER,                DIMENSION(TWO,N), INTENT(IN ):: RC
    DOUBLE PRECISION,       DIMENSION(N),     INTENT(OUT):: PROP
    INTEGER,                                  INTENT(IN ):: DIM1, NREC, NDAT
    TYPE(IXJ_SINGLE_ENTRY), DIMENSION(NDAT),  INTENT(IN ):: DAT  !COULD USE (IN), BUT SINCE CUR=> COMPILER  CAN NOT HONOR IN STATUS
    !
    INTEGER:: K,P
    !
    PROP = DZ
    !
    IF    (DIM1 == 2) THEN
                          DO CONCURRENT(K=1:N, P=ONE:NREC, RC(1,K) == DAT(P)%I(2) .AND. RC(2,K) == DAT(P)%I(3))
                              !
                              PROP(K) = PROP(K) + DAT(P)%X(1)
                              !
                          END DO
    ELSEIF(DIM1 == 3) THEN
                          DO CONCURRENT(K=1:N, P=ONE:NREC, ID == DAT(P)%I(1) .AND. RC(1,K) == DAT(P)%I(2) .AND. RC(2,K) == DAT(P)%I(3))
                              !
                              PROP(K) = PROP(K) + DAT(P)%X(1)
                              !
                          END DO
                          !
                          !DO K=1, N
                          !DO P=ONE, NREC
                          !    IF(ID == DAT(P)%I(1) .AND. RC(1,K) == DAT(P)%I(2) .AND. RC(2,K) == DAT(P)%I(3))  PROP(K) = PROP(K) + DAT(P)%X(1)
                          !END DO
                          !END DO
    END IF
    !
  END SUBROUTINE
  !
  !!!PURE RECURSIVE SUBROUTINE RECORD_3WAY_SEARCH(CUR, I, NREC, I1, I2, I3, VAL)
  !!!  TYPE(IXJ_SINGLE_ENTRY), INTENT(IN   ):: CUR  
  !!!  INTEGER,                INTENT(INOUT):: I
  !!!  INTEGER,                INTENT(IN   ):: NREC, I1, I2, I3
  !!!  DOUBLE PRECISION,       INTENT(INOUT):: VAL
  !!!  !
  !!!  IF(I <= NREC) THEN
  !!!      IF( I1 == CUR%I(1) .AND. I2 == CUR%I(2) .AND. I3 == CUR%I(3) ) THEN
  !!!          VAL = CUR%X(1)
  !!!      ELSE
  !!!          I = I + ONE
  !!!          CALL RECORD_3WAY_SEARCH(CUR%NXT, I, NREC, I1, I2, I3, VAL)
  !!!      END IF
  !!!  END IF
  !!!  !
  !!!END SUBROUTINE
  !!!!
  !!!PURE RECURSIVE SUBROUTINE RECORD_2WAY_SEARCH(CUR, I, NREC, I1, I2, VAL)
  !!!  TYPE(IXJ_SINGLE_ENTRY), INTENT(IN   ):: CUR  
  !!!  INTEGER,                        INTENT(INOUT):: I
  !!!  INTEGER,                        INTENT(IN   ):: NREC, I1, I2
  !!!  DOUBLE PRECISION,               INTENT(INOUT):: VAL
  !!!  !
  !!!  IF(I <= NREC) THEN
  !!!      IF( I1 == CUR%I(1) .AND. I2 == CUR%I(2) ) THEN
  !!!          VAL = CUR%X(1)
  !!!      ELSE
  !!!          I = I + ONE
  !!!          CALL RECORD_2WAY_SEARCH(CUR%NXT, I, NREC, I1, I2, VAL)
  !!!      END IF
  !!!  END IF
  !!!  !
  !!!END SUBROUTINE
  !
!!!  PURE SUBROUTINE CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, N, RC, PROP, DIM1, NREC, HED_REC) !USE IF STACK OVERFLOW OCCURS
!!!    INTEGER,                                INTENT(IN   ):: ID, N
!!!    INTEGER,          DIMENSION(TWO,N),     INTENT(IN   ):: RC
!!!    DOUBLE PRECISION, DIMENSION(N),         INTENT(OUT  ):: PROP
!!!    INTEGER,                                INTENT(IN   ):: DIM1, NREC
!!!    TYPE(IXJ_SINGLE_ENTRY), TARGET, INTENT(INOUT):: HED_REC  !COULD USE (IN), BUT SINCE CUR=> COMPILER  CAN NOT HONOR IN STATUS
!!!    !
!!!    TYPE(IXJ_SINGLE_ENTRY), POINTER:: CUR
!!!    INTEGER:: I,J
!!!    !
!!!    PROP = DZ
!!!    !
!!!    IF(DIM1 == 2) THEN
!!!        DO I=1, N
!!!            !
!!!            CUR => HED_REC
!!!            !
!!!            DO J=1, NREC
!!!                IF( RC(1,I) == CUR%I(1) .AND. RC(2,I) == CUR%I(2) ) THEN
!!!                    PROP(I) = CUR%X(1)
!!!                    EXIT
!!!                END IF
!!!                CUR => CUR%NXT 
!!!            END DO
!!!        END DO
!!!    ELSEIF(DIM1 == 3) THEN
!!!        DO I=1, N
!!!            !
!!!            CUR => HED_REC
!!!            !
!!!            DO J=1, NREC
!!!                IF( ID == CUR%I(1) .AND. RC(1,I) == CUR%I(2) .AND. RC(2,I) == CUR%I(3) ) THEN
!!!                    PROP(I) = CUR%X(1)
!!!                    EXIT
!!!                END IF
!!!                CUR => CUR%NXT 
!!!            END DO
!!!        END DO
!!!    END IF
!!!    !
!!!  END SUBROUTINE
  !
  PURE SUBROUTINE CROP_INPUT_ARRAY_TO_PROP(N, RC, PROP, ARRAY)
    INTEGER,                            INTENT(IN ):: N
    INTEGER,          DIMENSION(TWO,N), INTENT(IN ):: RC
    DOUBLE PRECISION, DIMENSION(N),     INTENT(OUT):: PROP
    DOUBLE PRECISION, DIMENSION(:,:),   INTENT(IN ):: ARRAY
    CONTIGUOUS:: ARRAY
    INTEGER:: K
    !
    DO CONCURRENT (K=ONE:N)
                         PROP(K) = ARRAY( RC(TWO,K), RC(ONE,K) )  !NOTE ARRAY IS STORED AS NCOL, NROW
    END DO
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_CROP_INPUT_TO_CROP_PROP_INT(CPR, CPI)
  CLASS(CROP_PROP),      INTENT(INOUT):: CPR
  TYPE(LIST_ARRAY_INPUT_INT), INTENT(IN   ):: CPI
  INTEGER:: ID, LD  ! LD => LEADING DIMENSION
  !
  IF (CPR%N > Z .AND. CPI%INUSE) THEN
     !
     ID = CPR%ID
     LD = CPR%LD
     !
     SELECT CASE(CPI%TYP)
     !!!CASE('IRR'    )
     !!!            CALL ALLOC(CPR%IRR, CPR%N)
     !!!            IF(CPI%LISTLOAD) THEN
     !!!                                    CPR%IRR = CPI%LIST(ID)
     !!!            ELSEIF(CPI%HAS_IXJ) THEN
     !!!                CONTINUE
     !!!            ELSE
     !!!                CALL CROP_INPUT_ARRAY_TO_PROP_INT(CPR%N,   CPR%RC, CPR%IRR, CPI%ARRAY(:,LD:))
     !!!            END IF
     CASE('GWRT'   )
                 CALL ALLOC(CPR%GW_INTER, CPR%N)
                 IF(CPI%LISTLOAD) THEN
                                         CPR%GW_INTER = CPI%LIST(ID)
                 ELSEIF(CPI%HAS_IXJ) THEN
                     CONTINUE
                 ELSE
                     CALL CROP_INPUT_ARRAY_TO_PROP_INT(CPR%N,   CPR%RC, CPR%GW_INTER, CPI%ARRAY(:,LD:))
                 END IF
     END SELECT
  END IF
  !
  END SUBROUTINE
  !
  PURE SUBROUTINE COPY_AND_SETUP_IRRIGATION_INPUT_TO_CROP_PROP(CDAT, NEW_IRR)
  CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
  LOGICAL,            INTENT(INOUT):: NEW_IRR 
  INTEGER:: I,K,IRR,LD  ! LD => LEADING DIMENSION
  LOGICAL:: NEW_ALLOC
  !
  NEW_IRR = FALSE
  !
  DO I=ONE, CDAT%NCROP
   !
   CALL ALLOC(CDAT%CROP(I)%IRR, CDAT%CROP(I)%N, NEW_ALLOC=NEW_ALLOC)
   !
   IF(CDAT%CROP(I)%N > Z ) THEN
     !
     IF( NEW_ALLOC ) NEW_IRR = TRUE
     !  
     IF(CDAT%IRR%LISTLOAD) THEN
         IF(NEW_ALLOC) THEN !NOTE ENTIRE VECTOR SHOULD BE SAME VALUE
             !
             CDAT%CROP(I)%IRR = CDAT%IRR%LIST(I)
             !
         ELSEIF(CDAT%CROP(I)%IRR(ONE) .NE. CDAT%IRR%LIST(I)) THEN !NOTE ENTIRE VECTOR SHOULD BE SAME VALUE
             !
             NEW_IRR = TRUE
             !
             CDAT%CROP(I)%IRR = CDAT%IRR%LIST(I)
         END IF
     ELSE
         IF (CDAT%MULTI_CROP_CELLS) THEN
             LD = CDAT%CROP(I)%LD - ONE
             !
             DO  K=ONE, CDAT%CROP(I)%N
                 !
                 IRR = CDAT%IRR%ARRAY( CDAT%CROP(I)%RC(TWO,K), LD+CDAT%CROP(I)%RC(ONE,K) )
                 !
                 IF(.NOT. NEW_IRR) NEW_IRR = CDAT%CROP(I)%IRR(K) .NE. IRR
                 !
                 CDAT%CROP(I)%IRR(K) = IRR
             END DO
         ELSE
             DO  K=ONE, CDAT%CROP(I)%N
                 !
                 IRR = CDAT%IRR%ARRAY( CDAT%CROP(I)%RC(TWO,K), CDAT%CROP(I)%RC(ONE,K) )
                 !
                 IF(.NOT. NEW_IRR) NEW_IRR = CDAT%CROP(I)%IRR(K) .NE. IRR
                 !
                 CDAT%CROP(I)%IRR(K) = IRR
             END DO
         END IF
     END IF
   END IF
  END DO
  !
  END SUBROUTINE
  !
!!!  PURE SUBROUTINE CROP_INPUT_CAS_TO_PROP_INT(N, ID, RC, PROP, CAS)
!!!    INTEGER,                             INTENT(IN ):: N, ID
!!!    INTEGER,          DIMENSION(TWO,N),  INTENT(IN ):: RC
!!!    INTEGER, DIMENSION(N),               INTENT(OUT):: PROP
!!!    CLASS(COMPRESSED_ARRAY_STORAGE_INT), INTENT(IN ):: CAS
!!!    INTEGER:: I, J, K, M
!!!    LOGICAL:: FOUND
!!!    !
!!!    I=CAS%FIND_IDX(ID)  !SHOULD NEVER BE ZERO -- WHICH INDICATES NOT FOUND!!!
!!!    !
!!!    IF(I==Z) THEN
!!!        PROP = Z
!!!    ELSE
!!!        DO CONCURRENT (K=ONE:N)
!!!            !
!!!            FOUND = FALSE
!!!            !
!!!            IF(K<=CAS%LOC(I)%N) THEN    !SHOULD BE ONE-ONE RELATIONSHIP, BUT CHECK ANYWAYS
!!!                  J = CAS%LOC(I)%VEC(K)
!!!                  IF(CAS%ROW(J)==RC(ONE,K) .AND. CAS%COL(J)==RC(TWO,K)) THEN
!!!                      PROP(K) = CAS%VAL( J )
!!!                      FOUND = TRUE
!!!                  END IF
!!!            END IF
!!!            !
!!!            IF(.NOT. FOUND) THEN
!!!                  DO M=ONE, CAS%LOC(I)%N
!!!                        J=CAS%LOC(I)%VEC(M)
!!!                        IF(CAS%ROW(J)==RC(ONE,K) .AND. CAS%COL(J)==RC(TWO,K)) THEN
!!!                            PROP(K) = CAS%VAL( J )
!!!                            FOUND = TRUE
!!!                            EXIT
!!!                        END IF
!!!                  END DO
!!!            END IF
!!!            !
!!!            IF(.NOT. FOUND) PROP(K) = Z
!!!            !    
!!!        END DO
!!!    END IF
!!!    !
!!!  END SUBROUTINE
  !
  PURE SUBROUTINE CROP_INPUT_ARRAY_TO_PROP_INT(N, RC, PROP, ARRAY)
    INTEGER,                          INTENT(IN ):: N
    INTEGER,          DIMENSION(TWO,N), INTENT(IN ):: RC
    INTEGER, DIMENSION(N),            INTENT(OUT):: PROP
    INTEGER, DIMENSION(:,:),          INTENT(IN ):: ARRAY
    CONTIGUOUS:: ARRAY
    INTEGER:: K
    !
    DO CONCURRENT (K=ONE:N)
                         PROP(K) = ARRAY( RC(TWO,K), RC(ONE,K) )  !NOTE ARRAY IS STORED AS NCOL, NROW
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_WBS_IRRIGATED_AREA(CDAT,WBS)
    !
    CLASS(CROP_DATA), INTENT(IN   ):: CDAT
    TYPE(WBS_DATA),   INTENT(INOUT):: WBS
    INTEGER:: I, K
    !
    WBS%IRR_AREA = DZ
    DO CONCURRENT (I=ONE:CDAT%NCROP)
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%IRR(K) > Z)
          !
          WBS%IRR_AREA( CDAT%CROP(I)%FID(K) ) = WBS%IRR_AREA( CDAT%CROP(I)%FID(K) ) + CDAT%CROP(I)%AREA(K)
          !
    END DO; END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE CALC_WBS_EFFICIENCY(CDAT,WBS)
    !
    CLASS(CROP_DATA), INTENT(IN   ):: CDAT
    TYPE(WBS_DATA),   INTENT(INOUT):: WBS
    DOUBLE PRECISION, DIMENSION(WBS%NFARM):: CIR, DMD
    INTEGER:: I, K
    !
    WBS%EFF = DZ
    CIR     = DZ
    DMD     = DZ
    DO CONCURRENT (I=ONE:CDAT%NCROP)
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%IRR(K) > Z)
          !
          DMD(CDAT%CROP(I)%FID(K)) = DMD(CDAT%CROP(I)%FID(K)) + CDAT%CROP(I)%DEMAND(K)
          CIR(CDAT%CROP(I)%FID(K)) = CIR(CDAT%CROP(I)%FID(K)) + CDAT%CROP(I)%DEMAND(K) * CDAT%CROP(I)%EFF(K)
          !
    END DO; END DO
    !
    IF(CDAT%HAS_DEMAND_EXT) THEN
          DO CONCURRENT (I=ONE:CDAT%NCROP)
          DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%IRR(K) > Z .AND. CDAT%CROP(I)%DEMAND_EXT(K) > NEARZERO_30)
                !
                DMD(CDAT%CROP(I)%FID(K)) = DMD(CDAT%CROP(I)%FID(K)) + CDAT%CROP(I)%DEMAND_EXT(K)
                CIR(CDAT%CROP(I)%FID(K)) = CIR(CDAT%CROP(I)%FID(K)) + CDAT%CROP(I)%DEMAND_EXT(K) * CDAT%CROP(I)%EFF(K)
                !
          END DO; END DO
    END IF
    !
    ! THIS ALREADY BE CORRECT, BUT RESET JUST TO BE SAFE
    WBS%CROP_DEMAND = DMD
    !
    DO CONCURRENT(I=ONE:WBS%NFARM, CIR(I) > NEARZERO_30);  WBS%EFF(I) = CIR(I)/DMD(I)
    END DO
    !
    END SUBROUTINE
  !
!!!  SUBROUTINE CALC_WBS_EFFICIENCY(CDAT,WBS)
!!!    !
!!!    CLASS(CROP_DATA), INTENT(IN   ):: CDAT
!!!    TYPE(WBS_DATA),   INTENT(INOUT):: WBS
!!!    DOUBLE PRECISION, DIMENSION(WBS%NFARM):: CIR, REDUCED_CIR
!!!    INTEGER:: I, K
!!!    !
!!!    WBS%EFF = DZ
!!!    CIR     = DZ
!!!    REDUCED_CIR = DZ
!!!    DO CONCURRENT (I=ONE:CDAT%NCROP, K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%IRR(K) > Z)
!!!          !
!!!          CIR(CDAT%CROP(I)%FID(K)) = CIR(CDAT%CROP(I)%FID(K)) + CDAT%CROP(I)%CIR(K)
!!!          !
!!!          REDUCED_CIR(CDAT%CROP(I)%FID(K)) = REDUCED_CIR(CDAT%CROP(I)%FID(K)) + CDAT%CROP(I)%DEMAND(K) * CDAT%CROP(I)%EFF(K)
!!!          !
!!!    END DO
!!!    !
!!!    DO CONCURRENT(I=ONE:WBS%NFARM, WBS%CROP_DEMAND(I) > NEARZERO_30)
!!!                                                           IF(WBS%CROP_DEMAND(I) > CIR(I)) THEN
!!!                                                                                                WBS%EFF(I) = CIR(I) / WBS%CROP_DEMAND(I)
!!!                                                           ELSEIF(REDUCED_CIR(I) > NEARZERO_30) THEN
!!!                                                                                                WBS%EFF(I) = REDUCED_CIR(I) / WBS%CROP_DEMAND(I)   !WBS%EFF(I) = (WBS%CROP_DEMAND(I) - CIR(I)) / CIR(I)
!!!                                                           END IF
!!!    END DO
!!!    !
!!!  END SUBROUTINE
  !
  SUBROUTINE UPDATE_TWGA_EGWA_BARE_EVAP(CDAT)  !ALSO CALCS WBS%TPRECIP, WBS%EPRECIP
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    INTEGER:: I, K, C, R
    DOUBLE PRECISION:: HH
    !
    IF(CDAT%NCROP > Z) THEN
          DO CONCURRENT (I=ONE:CDAT%NCROP    )
          DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)   
              R = CDAT%CROP(I)%RC(ONE,K)
              C = CDAT%CROP(I)%RC(TWO,K)
              !
              IF(WTABLE(C,R) > NEAR_ninf) THEN
                  HH = WTABLE(C,R)
                  !
                  CDAT%CROP(I)%TGWA(K) = CDAT%CROP(I)%THI(K) - CDAT%CROP(I)%THD(K) * HH
                  CDAT%CROP(I)%EGWA(K) = CDAT%CROP(I)%EHI(K) - CDAT%CROP(I)%EHD(K) * HH
                  !
                  IF( CDAT%CROP(I)%TGWA(K) < DZ ) CDAT%CROP(I)%TGWA(K) = DZ
                  IF( CDAT%CROP(I)%EGWA(K) < DZ ) CDAT%CROP(I)%EGWA(K) = DZ
              ELSE
                  CDAT%CROP(I)%TGWA(K) = DZ
                  CDAT%CROP(I)%EGWA(K) = DZ
              END IF
          END DO; END DO
    END IF
    !
    IF(CDAT%CHECK_BARE) CALL CALC_BARE_EVAP_PASS(CDAT%NROW,CDAT%NCOL,CDAT%BARE_FRAC,CDAT%BARE_EVAP_EHI,CDAT%BARE_EVAP_EHD, WTABLE, CDAT%BARE_EVAP)  
    !
    !IF(CDAT%CHECK_BARE) THEN
    !      CDAT%BARE_EVAP = DZ
    !      DO CONCURRENT ( I = ONE:UPLAY_IDX%M)
    !          L = UPLAY_IDX%MAT(ONE,  I)
    !          R = UPLAY_IDX%MAT(TWO,  I)
    !          C = UPLAY_IDX%MAT(THREE,I)
    !          CDAT%BARE_EVAP(C,R)  = CDAT%BARE_EVAP_EHI(C,R) - CDAT%BARE_EVAP_EHD(C,R) * HNEW(C,R,L)
    !      END DO
    !      DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%BARE_FRAC(C,R) > DZ .AND. WTABLE(C,R) > NEAR_ninf)
    !              !
    !              CDAT%BARE_EVAP(C,R)  = CDAT%BARE_EVAP_EHI(C,R) - CDAT%BARE_EVAP_EHD(C,R) * WTABLE(C,R)
    !      END DO
    !      !
    !      WHERE(CDAT%BARE_EVAP < DZ);  CDAT%BARE_EVAP = DZ 
    !      END WHERE
    !END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_BARE_EVAP_PASS(NROW,NCOL,BARE_FRAC,BARE_EVAP_EHI,BARE_EVAP_EHD, WT, BARE_EVAP)  
    !
    INTEGER,                                INTENT(IN ):: NCOL,NROW
    DOUBLE PRECISION, DIMENSION(NCOL,NROW), INTENT(IN ):: BARE_FRAC
    DOUBLE PRECISION, DIMENSION(NCOL,NROW), INTENT(IN ):: BARE_EVAP_EHI
    DOUBLE PRECISION, DIMENSION(NCOL,NROW), INTENT(IN ):: BARE_EVAP_EHD
    DOUBLE PRECISION, DIMENSION(NCOL,NROW), INTENT(IN ):: WT
    DOUBLE PRECISION, DIMENSION(NCOL,NROW), INTENT(OUT):: BARE_EVAP
    !
    WHERE(BARE_FRAC > DZ .AND. WT > NEAR_ninf)
             !
             BARE_EVAP = BARE_EVAP_EHI - BARE_EVAP_EHD * WT
    ELSEWHERE
             BARE_EVAP = DZ
    END WHERE
    !
    WHERE(BARE_EVAP < DZ);  BARE_EVAP = DZ
    END WHERE
    !
  END SUBROUTINE
  !
  SUBROUTINE CALC_TTOT_ETOT_TGWA_EGWA_TOTALS(CDAT, WBS, SKIP)  !ALSO CALCS WBS%TPRECIP, WBS%EPRECIP
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    CLASS(WBS_DATA),  INTENT(INOUT):: WBS
    LOGICAL,OPTIONAL, INTENT(IN   ):: SKIP
    INTEGER:: I, K, R, C, F
    !
    WBS%TIRR = DZ
    WBS%EIRR = DZ
    WBS%TPRECIP = DZ
    WBS%EPRECIP = DZ
    !
    WBS%TTOT = DZ
    WBS%TGWA = DZ
    WBS%ETOT = DZ
    WBS%EGWA = DZ
    !
    IF(CDAT%NCROP > Z) THEN
                                CDAT%TTOT = DZ
                                CDAT%TGWA = DZ
                                CDAT%ETOT = DZ
                                CDAT%EGWA = DZ
    ELSEIF(CDAT%CHECK_BARE) THEN
                                CDAT%ETOT = DZ
                                CDAT%EGWA = DZ
    END IF
    !
    IF(PRESENT(SKIP)) THEN; IF(SKIP) RETURN  !PASSED INPUT_CHECK VARIABLE
    END IF
    !
    IF(CDAT%NCROP > Z) THEN
          DO CONCURRENT (I=ONE:CDAT%NCROP)
          DO CONCURRENT (K=ONE:CDAT%CROP(I)%N) 
              !
              R = CDAT%CROP(I)%RC(ONE,K)
              C = CDAT%CROP(I)%RC(TWO,K)
              F = CDAT%CROP(I)%FID(K) 
              !
              !
              !IF (CDAT%CROP(I)%NOT_FALLOW(K)) THEN   !TI = CDAT%CROP(I)%CIR(K)/(UNO + CDAT%CROP(I)%CECT(K))  !NOTE CIR = (CROP%TSUR(K) - CROP%TPPOT(K)) * (UNO + CROP%CECT(K))
              !    !
              !    IF( CDAT%CROP(I)%TPPOT(K) >= CDAT%CROP(I)%TSUR(K) ) THEN
              !       TP = CDAT%CROP(I)%TSUR(K)                          !PLANT CONSUMED ALL ITS TRANSPIRATION FROM PRECIP
              !       TI = DZ
              !    ELSE
              !       TP = CDAT%CROP(I)%TPPOT(K)                         !PLANT CONSUMED ITS FULL PRECIP TRANSPIRATION POTENTIAL
              !       TI = CDAT%CROP(I)%TI(K) - CDAT%CROP(I)%TPPOT(K)
              !    END IF
              !ELSE   !FALLOWED CROP HAS NO TRANSPIRATION
              !       TI = DZ
              !       TP = DZ
              !END IF
              !
              CDAT%TGWA(C,R) = CDAT%TGWA(C,R) + CDAT%CROP(I)%TGWA(K)
              CDAT%TTOT(C,R) = CDAT%TTOT(C,R) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K)   !  CDAT%CROP(I)%TSUR(K) = TI + TP
              !
              CDAT%EGWA(C,R) = CDAT%EGWA(C,R) + CDAT%CROP(I)%EGWA(K)
              CDAT%ETOT(C,R) = CDAT%ETOT(C,R) + CDAT%CROP(I)%EGWA(K) +  CDAT%CROP(I)%EP(K) + CDAT%CROP(I)%TI(K)*CDAT%CROP(I)%CECT(K)   !EI = TI*CECT
              !
              WBS%EIRR(F)    = WBS%EIRR(F)    + CDAT%CROP(I)%TI(K)*CDAT%CROP(I)%CECT(K)
              !
              WBS%TIRR(F)    = WBS%TIRR(F)    + CDAT%CROP(I)%TI(K) 
              WBS%TPRECIP(F) = WBS%TPRECIP(F) + CDAT%CROP(I)%TP(K)
              WBS%EPRECIP(F) = WBS%EPRECIP(F) + CDAT%CROP(I)%EP(K)
          END DO; END DO
    END IF
    !
    IF(CDAT%CHECK_BARE) THEN
          DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%BARE_FRAC(C,R) > DZ)
              CDAT%EGWA(C,R) = CDAT%EGWA(C,R) + CDAT%BARE_EVAP(C,R)
              CDAT%ETOT(C,R) = CDAT%ETOT(C,R) + CDAT%BARE_EVAP(C,R) + CDAT%BARE_EVAP_PRECIP(C,R)
          END DO
          !
          DO CONCURRENT (I=ONE:WBS%NFARM)
          DO CONCURRENT (K=ONE:WBS%FID(I)%Count)
                                                 WBS%EPRECIP(I) = WBS%EPRECIP(I) + CDAT%BARE_EVAP_PRECIP( WBS%FID(I)%RC(TWO,K), WBS%FID(I)%RC(ONE,K) )
          END DO; END DO
    END IF
    !
    IF(CDAT%NCROP > Z) THEN
                                !DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, WBS%FID_ARRAY(C,R) > Z)
                                !    WBS%TTOT( WBS%FID_ARRAY(C,R) ) = WBS%TTOT( WBS%FID_ARRAY(C,R) ) + CDAT%TTOT(C,R)
                                !    WBS%TGWA( WBS%FID_ARRAY(C,R) ) = WBS%TGWA( WBS%FID_ARRAY(C,R) ) + CDAT%TGWA(C,R)
                                !    WBS%ETOT( WBS%FID_ARRAY(C,R) ) = WBS%ETOT( WBS%FID_ARRAY(C,R) ) + CDAT%ETOT(C,R)
                                !    WBS%EGWA( WBS%FID_ARRAY(C,R) ) = WBS%EGWA( WBS%FID_ARRAY(C,R) ) + CDAT%EGWA(C,R)
                                !END DO
                                DO CONCURRENT (I=ONE:WBS%NFARM)
                                DO CONCURRENT (K=ONE:WBS%FID(I)%Count)
                                    R = WBS%FID(I)%RC(ONE,K)
                                    C = WBS%FID(I)%RC(TWO,K)
                                    WBS%TTOT(I) = WBS%TTOT(I) + CDAT%TTOT(C,R)
                                    WBS%TGWA(I) = WBS%TGWA(I) + CDAT%TGWA(C,R)
                                    WBS%ETOT(I) = WBS%ETOT(I) + CDAT%ETOT(C,R)
                                    WBS%EGWA(I) = WBS%EGWA(I) + CDAT%EGWA(C,R)
                                END DO
                                END DO
    ELSEIF(CDAT%CHECK_BARE) THEN
                                DO CONCURRENT (I=ONE:WBS%NFARM)
                                DO CONCURRENT (K=ONE:WBS%FID(I)%Count)
                                    R = WBS%FID(I)%RC(ONE,K)
                                    C = WBS%FID(I)%RC(TWO,K)
                                    WBS%ETOT(I) = WBS%ETOT(I) + CDAT%ETOT(C,R)
                                    WBS%EGWA(I) = WBS%EGWA(I) + CDAT%EGWA(C,R)
                                END DO
                                END DO
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE CALC_EGW_TGW(CDAT, SOIL, KITER)
    !USE UTIL_INTERFACE, ONLY: LRC_TO_CELLID, CELLID_TO_LRC
    !
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    TYPE( SOIL_DATA), INTENT(IN   ):: SOIL
    INTEGER,          INTENT(IN   )::KITER
    DOUBLE PRECISION:: RELAX
    LOGICAL:: NO_HD_TERM
    INTEGER:: I
    !TYPE(GENERIC_OUTPUT_FILE),SAVE:: ET1,ET2,BAR1,BAR2
    !INTEGER, SAVE:: KPER=1,KSTP=0
    !INTEGER:: LLOC, I, K, R, C, ID
    !
    !IF(KITER==3) THEN
    !    KSTP=KSTP+1
    !    IF(KSTP==3) THEN
    !        KPER=KPER+1
    !        KSTP=1
    !    END IF
    !END IF
    !!
    !IF(.NOT. ET1%IS_OPEN) THEN
    !    LLOC = 1
    !    CALL ET1 %OPEN(LLOC,'ET1.txt',CDAT%IOUT,0)
    !    LLOC = 1
    !    CALL ET2 %OPEN(LLOC,'ET2.txt',CDAT%IOUT,0)
    !    LLOC = 1
    !    CALL BAR1%OPEN(LLOC,'BR1.txt',CDAT%IOUT,0)
    !    LLOC = 1
    !    CALL BAR2%OPEN(LLOC,'BR2.txt',CDAT%IOUT,0)
    !    !
    !    CALL ET1 %SET_HEADER(' CROP ID KPER KSTP KITER IRR EGW EGWA TGWA TSURF TI TP EP ANOX SOIL THI THD EHI EHD')
    !    CALL ET2 %SET_HEADER(' CROP ID KPER KSTP KITER IRR EGW EGWA TGWA TSURF TI TP EP ANOX SOIL THI THD EHI EHD')
    !    CALL BAR1%SET_HEADER(' KPER KSTP KITER EVAP  EHI  EHD')
    !    CALL BAR2%SET_HEADER(' KPER KSTP KITER EVAP  EHI  EHD')
    !END IF
    !!
    !IF(KITER>51) THEN
    !    DO I=ONE,CDAT%NCROP    
    !    DO K=ONE,CDAT%CROP(I)%N 
    !                       R = CDAT%CROP(I)%RC(ONE,K)
    !                       C = CDAT%CROP(I)%RC(TWO,K)
    !                       CALL LRC_TO_CELLID(ID, 1, R, C, 1, CDAT%NROW, CDAT%NCOL)
    !                       WRITE(ET2%IU,'(7I8, *(1x ES14.7))') I, CDAT%CROP(I)%FID(K), ID, KPER, KSTP, KITER-1, CDAT%CROP(I)%IRR(K), CDAT%CROP(I)%EGW(K),CDAT%CROP(I)%EGWA(K),CDAT%CROP(I)%TGWA(K),CDAT%CROP(I)%TSURF(K),CDAT%CROP(I)%TI(K),CDAT%CROP(I)%TP(K),CDAT%CROP(I)%EP(K),CDAT%CROP(I)%ANOX_LOSS(K),CDAT%CROP(I)%SOIL_LOSS(K),CDAT%CROP(I)%THI(K),CDAT%CROP(I)%THD(K),CDAT%CROP(I)%EHI(K),CDAT%CROP(I)%EHD(K)
    !    END DO
    !    END DO
    !    IF(CDAT%CHECK_BARE) THEN
    !    DO I=ONE,CDAT%NROW
    !    DO K=ONE,CDAT%NCOL
    !                       WRITE(BAR2%IU,'(1x 3I8, *(1x ES14.7))') KPER, KSTP, KITER-1, CDAT%BARE_EVAP(K,I),CDAT%BARE_EVAP_EHI(K,I),CDAT%BARE_EVAP_EHD(K,I)
    !    END DO
    !    END DO
    !    END IF
    !END IF
    !
    IF(KITER >= CDAT%ITER_AVE_HEAD) THEN
        BLOCK
            INTEGER:: R,C
            DOUBLE PRECISION:: N, M
            N =  UNO / DBLE(KITER - CDAT%ITER_AVE_HEAD + ONE)
            M =  UNO - N
            !N = DBLE(KITER - CDAT%ITER_AVE_HEAD + ONE)
            !M = (N-UNO)/N
            !N = UNO / N
            DO CONCURRENT (R=ONE:CDAT%NROW)
            DO CONCURRENT (C=ONE:CDAT%NCOL, WTABLE(C,R) > NEAR_ninf)
                               CDAT%AVE_HEAD(C,R) = N*WTABLE(C,R) + M*CDAT%AVE_HEAD(C,R)
            END DO
            END DO
        END BLOCK
    ENDIF
    IF(KITER > CDAT%ITER_AVE_HEAD) THEN
        CDAT%HAS_AVE_HEAD = TRUE
    ELSE
        CDAT%HAS_AVE_HEAD = FALSE
    END IF
    !
    IF(    KITER <  CDAT%ITER_CALC_EGW_TGW_LOCK) THEN
                                                     RELAX = CDAT%RELAX
                                                     NO_HD_TERM = FALSE
    ELSEIF(KITER == CDAT%ITER_CALC_EGW_TGW_LOCK) THEN
                                                     RELAX = HALF
                                                     NO_HD_TERM = TRUE
    ENDIF
    !
    IF(KITER <=  CDAT%ITER_CALC_EGW_TGW_LOCK) THEN
        !
        IF(CDAT%NCROP > Z)  CALL CALC_CROP_TRANSPIRATION(CDAT, SOIL, RELAX, NO_HD_TERM)
                            !
                            CALL CALC_EGW(CDAT, SOIL, RELAX, NO_HD_TERM)  !MUST CALL AFTER CALC_CROP_TRANSPIRATION
    END IF
    !
    ! CHECK IF LOCKING TI FOR REST OF TIME STEP
    !
    IF    (KITER == CDAT%ITER_CALC_EGW_TGW_LOCK) THEN
           DO CONCURRENT (I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z ); CDAT%CROP(I)%TI_BAK = CDAT%CROP(I)%TI
           END DO
    ELSEIF(KITER > CDAT%ITER_CALC_EGW_TGW_LOCK) THEN
           DO CONCURRENT (I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z ); CDAT%CROP(I)%TI = CDAT%CROP(I)%TI_BAK
           END DO
    ENDIF
    !
    !IF(KITER>50) THEN
    !    DO I=ONE,CDAT%NCROP    
    !    DO K=ONE,CDAT%CROP(I)%N 
    !                       R = CDAT%CROP(I)%RC(ONE,K)
    !                       C = CDAT%CROP(I)%RC(TWO,K)
    !                       CALL LRC_TO_CELLID(ID, 1, R, C, 1, CDAT%NROW, CDAT%NCOL)
    !                       WRITE(ET1%IU,'(7I8, *(1x ES14.7))') I, CDAT%CROP(I)%FID(K), ID, KPER, KSTP, KITER, CDAT%CROP(I)%IRR(K), CDAT%CROP(I)%EGW(K),CDAT%CROP(I)%EGWA(K),CDAT%CROP(I)%TGWA(K),CDAT%CROP(I)%TSURF(K),CDAT%CROP(I)%TI(K),CDAT%CROP(I)%TP(K),CDAT%CROP(I)%EP(K),CDAT%CROP(I)%ANOX_LOSS(K),CDAT%CROP(I)%SOIL_LOSS(K),CDAT%CROP(I)%THI(K),CDAT%CROP(I)%THD(K),CDAT%CROP(I)%EHI(K),CDAT%CROP(I)%EHD(K)
    !    END DO
    !    END DO
    !    IF(CDAT%CHECK_BARE) THEN
    !    DO I=ONE,CDAT%NROW
    !    DO K=ONE,CDAT%NCOL
    !                       WRITE(BAR1%IU,'(1x 3I8, *(1x ES14.7))') KPER, KSTP, KITER, CDAT%BARE_EVAP(K,I),CDAT%BARE_EVAP_EHI(K,I),CDAT%BARE_EVAP_EHD(K,I)
    !    END DO
    !    END DO
    !    END IF
    !END IF
    !
  END SUBROUTINE
  !
!  SUBROUTINE CALC_EGW(CDAT, WBS, SOIL)
!    !
!    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
!    TYPE(  WBS_DATA), INTENT(IN   ):: WBS
!    TYPE( SOIL_DATA), INTENT(IN   ):: SOIL
!    INTEGER:: I, K, R, C, L
!    DOUBLE PRECISION:: EHI, EHD, PSIA, HH, GSE, EPOT, EPOT_OLD, HO, RELAX_HO, RELAX, EGWA, EGWA_OLD
!    !
!    IF(CDAT%NCROP > Z) THEN
!          !
!          RELAX = CDAT%RELAX
!          IF(RELAX>UNO) RELAX=UNO
!          RELAX_HO = UNO-RELAX
!          IF(RELAX_HO<NEARZERO_6) RELAX_HO = DZ
!          !
!          DO CONCURRENT   ( I=ONE:CDAT%NCROP, K=ONE:CDAT%CROP(I)%N ) 
!              !
!              R = CDAT%CROP(I)%RC(ONE,K)
!              C = CDAT%CROP(I)%RC(TWO,K)
!              L = UPLAY(C,R)
!              !
!              EHI = DZ
!              EHD = DZ
!              EGWA_OLD = DZ
!              EGWA = DZ
!              !
!              IF( CDAT%CROP(I)%EGW(K) < NEARZERO_30 .OR.                                    &        !NO EGW OR ALL EVAP COMES FROM PRECIP
!                  CDAT%CROP(I)%EGW(K) - CDAT%CROP(I)%EPPOT(K) < NEARZERO_30  .OR. L == Z    ) THEN   !L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
!                  CDAT%CROP(I)%EGWA(K) = DZ
!              ELSE!------------------------------------------------------------------------------
!                  HO = HNEW_OLD(C,R,L)
!                  HH = HNEW(C,R,L)
!                  !
!                  GSE  = CDAT%CROP(I)%GSE(K)
!                  EPOT = CDAT%CROP(I)%EGW(K) - CDAT%CROP(I)%EPPOT(K)  !EPOT = EGW-EP
!                  PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!                  !
!                  IF( HO > GSE ) THEN
!                      !
!                      EHI = EPOT*RELAX_HO
!                      EGWA_OLD = EHI
!                      !
!                  ELSEIF(HO < CDAT%CROP(I)%XX(K)) THEN  !GSE-CAP
!                      !
!                      EGWA_OLD = DZ
!                  ELSE
!                      !
!                      EHI = (        EPOT * ( UNO - GSE/PSIA) )*RELAX_HO
!                      EHD = ( DNEG * EPOT / PSIA              )*RELAX_HO
!                      !
!                      EGWA_OLD = EHI - EHD*HO
!                  END IF
!                  !
!                  IF( HH > GSE ) THEN
!                      !
!                      EHI = EHI + EPOT*RELAX
!                      !
!                      EGWA = EPOT*RELAX
!                      !
!                  ELSEIF(HH < CDAT%CROP(I)%XX(K)) THEN  !GSE-CAP
!                      !
!                      EGWA = DZ
!                  ELSE
!                      PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!                      !
!                      EHI = EHI + (        EPOT * ( UNO - GSE/PSIA) )*RELAX
!                      EHD = EHD + ( DNEG * EPOT / PSIA              )*RELAX
!                      !
!                      !CDAT%CROP(I)%EGWA(K) = EHI - EHD*HH
!                      EGWA = ((EPOT*(UNO - GSE/PSIA)) + (HH*EPOT/PSIA ))*RELAX
!                  END IF
!                  !
!                  CDAT%CROP(I)%EGWA(K) = EGWA + EGWA_OLD
!              END IF
!              !
!              CDAT%CROP(I)%EHI(K) = EHI
!              CDAT%CROP(I)%EHD(K) = EHD
!          END DO 
!    END IF
!    !
!    IF(CDAT%CHECK_BARE) THEN
!         !
!         CDAT%BARE_EVAP = DZ
!         !
!         DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%BARE_FRAC(C,R) > DZ)
!              !
!              L = UPLAY(C,R)
!              !
!              EHI = DZ
!              EHD = DZ
!              CDAT%BARE_EVAP(C,R) = DZ
!              !
!              IF( CDAT%BARE_POT_EVAP(C,R) > NEARZERO_30 .AND. L > Z) THEN   !L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
!                  !
!                  HO = HNEW_OLD(C,R,L)
!                  HH = HNEW(C,R,L)
!                  GSE  = CDAT%BARE_GSE(C,R)
!                  EPOT = CDAT%BARE_POT_EVAP(C,R)
!                  PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!                  !
!                  IF( HO > GSE ) THEN
!                      !
!                      EHI = EPOT*RELAX_HO
!                      EGWA_OLD = EHI
!                      !
!                  ELSEIF(HO > GSE - PSIA) THEN  !GSE-CAP
!                      !
!                      EHI = (        EPOT * ( UNO - GSE/PSIA) ) * RELAX_HO
!                      EHD = ( DNEG * EPOT / PSIA              ) * RELAX_HO
!                      !
!                      EGWA_OLD = EHI - EHD*HO
!                  END IF
!                  !
!                  IF( HH > GSE ) THEN
!                      !
!                      EHI = EHI + EPOT*RELAX
!                      EGWA = EHI
!                      !
!                  ELSEIF(HH > GSE - PSIA) THEN  !GSE-CAP
!                      !
!                      EHI = EHI + (        EPOT * ( UNO - GSE/PSIA) ) * RELAX
!                      EHD = EHD + ( DNEG * EPOT / PSIA              ) * RELAX
!                      !
!                      EGWA = EHI - EHD*HH
!                  END IF
!                  CDAT%BARE_EVAP(C,R) = EGWA + EGWA_OLD
!              END IF
!              !
!              CDAT%BARE_EVAP_EHI(C,R) = EHI
!              CDAT%BARE_EVAP_EHD(C,R) = EHD
!         END DO
!    END IF
!    !
!  END SUBROUTINE
!  !
!  SUBROUTINE CALC_EGW(CDAT, WBS, SOIL)
!    !
!    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
!    TYPE(  WBS_DATA), INTENT(IN   ):: WBS
!    TYPE( SOIL_DATA), INTENT(IN   ):: SOIL
!    INTEGER:: I, K, R, C, L
!    DOUBLE PRECISION:: EHI, EHD, PSIA, HH, GSE, EPOT
!    !
!    IF(CDAT%NCROP > Z) THEN
!          !
!          DO CONCURRENT   ( I=ONE:CDAT%NCROP, K=ONE:CDAT%CROP(I)%N ) 
!              !
!              R = CDAT%CROP(I)%RC(ONE,K)
!              C = CDAT%CROP(I)%RC(TWO,K)
!              L = UPLAY(C,R)
!              !
!              EHI = DZ
!              EHD = DZ
!              !
!              IF( CDAT%CROP(I)%EGW(K) < NEARZERO_30 .OR.                                    &        !NO EGW OR ALL EVAP COMES FROM PRECIP
!                  CDAT%CROP(I)%EGW(K) - CDAT%CROP(I)%EPPOT(K) < NEARZERO_30  .OR. L == Z    ) THEN   !L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
!                  CDAT%CROP(I)%EGWA(K) = DZ
!              ELSE!------------------------------------------------------------------------------
!                  HH  = CDAT%RELAX*(HNEW(C,R,L) - HNEW_OLD(C,R,L)) + HNEW_OLD(C,R,L)   !HNEW = HOLD + FRAC*(HNEW-HOLD)
!                  GSE  = CDAT%CROP(I)%GSE(K)
!                  EPOT = CDAT%CROP(I)%EGW(K) - CDAT%CROP(I)%EPPOT(K)  !EPOT = EGW-EP
!                  !
!                  IF( HH > GSE ) THEN
!                      !
!                      EHI = EPOT
!                      CDAT%CROP(I)%EGWA(K) = EHI
!                      !
!                  ELSEIF(HH < CDAT%CROP(I)%XX(K)) THEN  !GSE-CAP
!                      !
!                      CDAT%CROP(I)%EGWA(K) = DZ
!                  ELSE
!                      PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!                      !
!                      EHI =        EPOT * ( UNO - GSE/PSIA)
!                      EHD = DNEG * EPOT / PSIA  
!                      !
!                      CDAT%CROP(I)%EGWA(K) = EHI - EHD*HH
!                  END IF
!              END IF
!              !
!              CDAT%CROP(I)%EHI(K) = EHI
!              CDAT%CROP(I)%EHD(K) = EHD
!          END DO 
!    END IF
!    !
!    IF(CDAT%CHECK_BARE) THEN
!         !
!         CDAT%BARE_EVAP = DZ
!         !
!         DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%BARE_FRAC(C,R) > DZ)
!              !
!              L = UPLAY(C,R)
!              !
!              EHI = DZ
!              EHD = DZ
!              !
!              IF( CDAT%BARE_POT_EVAP(C,R) > NEARZERO_30 .AND. L > Z) THEN   !L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
!                  !
!                  HH  = CDAT%RELAX*(HNEW(C,R,L) - HNEW_OLD(C,R,L)) + HNEW_OLD(C,R,L)   !HNEW = HOLD + FRAC*(HNEW-HOLD)
!                  GSE  = CDAT%BARE_GSE(C,R)
!                  EPOT = CDAT%BARE_POT_EVAP(C,R)
!                  PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!                  !
!                  IF( HH > GSE ) THEN
!                      !
!                      EHI = EPOT
!                      CDAT%BARE_EVAP(C,R) = EHI
!                      !
!                  ELSEIF(HH > GSE - PSIA) THEN  !GSE-CAP
!                      !
!                      EHI =        EPOT * ( UNO - GSE/PSIA)
!                      EHD = DNEG * EPOT / PSIA  
!                      !
!                      CDAT%BARE_EVAP(C,R) = EHI - EHD*HH
!                  END IF
!              END IF
!              !
!              CDAT%BARE_EVAP_EHI(C,R) = EHI
!              CDAT%BARE_EVAP_EHD(C,R) = EHD
!         END DO
!    END IF
!    !
!  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE CALC_CROP_OPTIMAL_UPTAKE_PRESSURE(CPR, SOIL, MLT, ONLY_K)
     !
     CLASS(CROP_PROP),  INTENT(INOUT):: CPR
     TYPE( SOIL_DATA),  INTENT(IN   ):: SOIL
     DOUBLE PRECISION,  INTENT(IN   ):: MLT
     INTEGER, OPTIONAL, INTENT(IN   ):: ONLY_K
     !
     DOUBLE PRECISION:: TPOT, PSI0, PSI1, PSI2, PSI3, XDRY, XWET, DRZ, NEXP
     DOUBLE PRECISION:: PSIWET, PSIDRY, PSI3_CM, PSIWET_CM, PSIDRY_CM
     INTEGER:: K, KK
     !
     IF(CPR%N==Z) RETURN
     !
     KK = Z
     IF(PRESENT(ONLY_K)) KK = ONLY_K
     !
     IF( ANY(NOT_NEAR_ZERO(CPR%PSI, NEARZERO_12)) ) THEN
       !
       PSI0 = DZ;  PSI1 = DZ;  PSI2 = DZ;  PSI3 = DZ
       !
       IF( CPR%PSI(ONE  ) < DZ )  PSI0 = CPR%PSI(ONE  ) * DNEG  !FLIP TO POSITIVE --SAME AS ABSOLUTE VALUE
       IF( CPR%PSI(TWO  ) < DZ )  PSI1 = CPR%PSI(TWO  ) * DNEG 
       IF( CPR%PSI(THREE) < DZ )  PSI2 = CPR%PSI(THREE) * DNEG
       IF( CPR%PSI(FOUR ) < DZ )  PSI3 = CPR%PSI(FOUR ) * DNEG
       !
       PSIWET = (PSI0+PSI1)/DOS    ! EVALUATE PRESSURE HEADS BETWEEN WHICH UPTAKE IS CONSIDERED OPTIMAL
       PSIDRY = (PSI2+PSI3)/DOS
       !
       PSI3_CM   = PSI3  *MLT
       PSIWET_CM = PSIWET*MLT
       PSIDRY_CM = PSIDRY*MLT
       !
       DO CONCURRENT ( K=ONE:CPR%N, KK==Z .OR. KK==K )
         !
         ASSOCIATE(GW_INTER=>CPR%GW_INTER(K), UXX=>CPR%UXX(K), MXX=>CPR%MXX(K), GSE=>CPR%GSE(K), SS=>CPR%SS(K), ROOT=>CPR%ROOT(K), AREA=>CPR%AREA(K), R=>CPR%RC(ONE,K), C=>CPR%RC(TWO,K))
                   !
                   TPOT = CPR%TGW(K)
                   !
                   UXX = GSE   !ONLY CHANGES IF THERE IS GROUNDWATER-ROOT INTERACTION
                   MXX = SS
                   !
                   !   GW_INTER =>
                   ! 0 = No T/No CU
                   ! 1 = No GW Interaction/Full CU from Surf/No  Anoxia/Soil Stress Reducation, No  Root-Groundwater Uptake  
                   ! 2 = No GW Uptake/ HAS Anoxia/Soil Stress Reducation, No  Root-Groundwater Uptake  
                   ! 3 = No Anoxia/No Soil Stress - But has GW Uptake
                   ! 4 = No Anoxia - But has Soil Stress and GW Uptake
                   ! 5 = Full Interaction HAS Anoxia/Soil Stress Reducation, HAS Root-Groundwater Uptake  
                   !
                   IF( AREA > DZ .AND. TPOT > DZ .AND. ANY(GW_INTER == [2,4,5]) ) THEN
                      !
                      !6B1C---CONVERT FLOWRATE OF ORIGINAL MAXIMUM TRANSPIRATION BACK TO FLUX (REASON: UXX AND MXX BELOW ARE FUNCTIONS OF T-FLUX NOT T-FLOWRATE; WITH:
                      !        UXX =    Head Elevation of Upper Extinction of Transpiration due to Anoxia
                      !        MXX =    Head Elevation of Elimination of crop-unproductive Wilting Zone)
                      !
                      !TPOT_AREA = MLT*TPOT/CPR%AREA(K)  !NOTE THIS IS A RATE RATHER THAN VOLUMETRIC RATE  --CONVERTED TO CM/T
                      !
                      !
                      DRZ =  SOIL%COEF(C,R)%A*LOG(ROOT*MLT) + SOIL%COEF(C,R)%B*LOG(MLT*TPOT/AREA) + SOIL%COEF(C,R)%C  !TAKE EXP AFTER USED FOR NEXP CALCULATION
                      NEXP = SOIL%COEF(C,R)%D*DRZ + SOIL%COEF(C,R)%E
                      DRZ  = EXP(DRZ)
                      !
                      IF(DRZ  > PSI3_CM)     DRZ  = PSI3_CM
                      IF(NEXP < NEARZERO_12) NEXP = NEARZERO_12
                      !
                      IF(PSIWET < NEARZERO_12) THEN
                          XWET = DZ
                      ELSE
                          !     
                          !6B1G---SOLVE ANALYTICAL FUNCTION FOR DEPTHS BETWEEN WHICH UPTAKE IS OPTIMAL:
                          !       ANALYTICAL FUNCTION: PSI(DEPTH) = FUNCTION (DRZ,NEXP,PSI3,DEPTH)
                          !                            PSI(DEPTH)   IS SOLVED ITERATIVELY BY BISECTION-METHOD
                          !                                         FOR DEPTH(PSIWET) AND FOR DEPTH(PSIDRY)
                          XWET = RTFUNC(DRZ,PSI3_CM,NEXP,PSIWET_CM) / MLT
                          !
                          IF(XWET.NE.XWET) THEN
                              !CALL WARNING_MESSAGE(OUTPUT=LOUT,MSG='FMP CROP: SOLVING ANALYITICAL WATER STRESS RESPONSE FUNCTION, XWET = PSI(DEPTH) = FUNCTION (DRZ,NEXP,PSI3,DEPTH), WITH BISECTION METHOD FAILED TO IDENTIFY INITIAL GUESS (d1 and d2) THAT ARE ON BOTH SIDES OF THE ROOT. (viz. PSI(d1)*PSI(d2)>0).'//NL// &
                              !                                          'TO KEEP PROGRAM FROM STOPPING THE SOLUTION THE HEAD ELEVATION OF UPPER EXTINCTION OF TRANSPIRATION DUE TO ANOXIA IS ASSUMED TO BE THE GROUND SURFACE.'//NL// &
                              !                                          'THIS PROBLEM OCCURED FOR CROP '//NUM2STR(I)//NL//' LOCATED IN ROW, COL: '//NUM2STR(R)//', '//NUM2STR(C), INLINE=TRUE)
                              XWET = DZ
                          ELSEIF(XWET < DZ)  THEN
                              XWET = DZ
                          END IF
                          !
                      ENDIF
                      !
                      IF    (XWET < NEARZERO_12 ) THEN
                                                 UXX = GSE
                      ELSEIF(XWET > ROOT ) THEN
                                                 UXX = SS
                      ELSEIF(XWET > PSIWET) THEN
                                                 UXX = GSE - PSIWET
                      ELSE
                                                 UXX = GSE - XWET
                      END IF
                      !
                      !
                      XDRY = RTFUNC(DRZ,PSI3_CM,NEXP,PSIDRY_CM) / MLT
                      !
                      !
                      IF(XDRY.NE.XDRY) THEN
                          !WRITE(CDAT%LOUT,'(/A/,A/,6A)') 'FMP CROP WARNING. SOLVING ANALYITICAL WATER STRESS RESPONSE FUNCTION, XDRY = PSI(DEPTH) = FUNCTION (DRZ,NEXP,PSI3,DEPTH), WITH BISECTION METHOD FAILED TO IDENTIFY INITIAL GUESS (d1 and d2) THAT ARE ON BOTH SIDES OF THE ROOT. (viz. PSI(d1)*PSI(d2)>0).', &
                          !                               'TO KEEP PROGRAM FROM STOPPING THE SOLUTION THE HEAD ELEVATION OF ELIMINATION OF CROP-UNPRODUCTIVE WILTING ZONE IS ASSUMED TO BE THE AT THE BOTTOM OF THE ROOT ZONE.', &
                          !                               'THIS PROBLEM OCCURED FOR CROP ',NUM2STR(I),' LOCATED IN ROW, COL: ', NUM2STR(R), ', ', NUM2STR(C)
                          !CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP: SOLVING ANALYITICAL WATER STRESS RESPONSE FUNCTION, XDRY = PSI(DEPTH) = FUNCTION (DRZ,NEXP,PSI3,DEPTH), WITH BISECTION METHOD FAILED TO IDENTIFY INITIAL GUESS (d1 and d2) THAT ARE ON BOTH SIDES OF THE ROOT. (viz. PSI(d1)*PSI(d2)>0).'//NL// &
                          !                                  'TO KEEP PROGRAM FROM STOPPING THE SOLUTION THE HEAD ELEVATION OF ELIMINATION OF CROP-UNPRODUCTIVE WILTING ZONE IS ASSUMED TO BE THE AT THE BOTTOM OF THE ROOT ZONE.'//NL// &
                          !                                  'THIS PROBLEM OCCURED FOR CROP '//NUM2STR(I)//NL//' LOCATED IN ROW, COL: '//NUM2STR(R)//', '//NUM2STR(C), INLINE=TRUE)
                          XDRY = ROOT
                      END IF
                      !
                      IF(XDRY >= ROOT) THEN
                          MXX = SS
                      ELSE
                          MXX = GSE - XDRY      
                      END IF
                      !
                      IF(MXX > UXX) MXX = UXX
                      !
                   END IF
         END ASSOCIATE
       END DO
       !------------------------------------------------------------------------------------------------------------------
     ELSEIF(KK>Z) THEN
           CPR%UXX(KK) = CPR%GSE(KK)
           CPR%MXX(KK) = CPR%SS( KK)
          !---------------------------------------------------------------------------------------------------------------
     ELSE
           CPR%UXX = CPR%GSE
           CPR%MXX = CPR%SS
     END IF
     !
  END SUBROUTINE
  !
  SUBROUTINE CALC_CROP_TRANSPIRATION(CDAT, SOIL, RELAX, NO_HD_TERM)
    !
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    TYPE( SOIL_DATA), INTENT(IN   ):: SOIL
    DOUBLE PRECISION, INTENT(IN   ):: RELAX
    LOGICAL,          INTENT(IN   ):: NO_HD_TERM
    !
    INTEGER:: I, K, R, C, T_CONCEPT
    DOUBLE PRECISION:: TPOT, TGWA, TSURF, ANOX_LOSS, SOIL_LOSS!,UXX, MXX, SS, LXX
    DOUBLE PRECISION:: THI, THD
    DOUBLE PRECISION:: PSIA, PSI0, PSI1, PSI0_PSI1
    DOUBLE PRECISION:: HH, GSE, TPOT_ROOT, GSE_POND, ROOT_POND
    DOUBLE PRECISION:: THI_SAT, THD_SAT, ALPHA
    LOGICAL:: HAS_TRANSPIRATION 
    !
    DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z )
       !
       PSI0 = DZ;  PSI1 = DZ
       !
       IF(CDAT%HAS_PSI) THEN
          !CALL CDAT%CROP%SETUP_UXX_MXX(SOIL,CDAT%MLT)
          PSI0 = CDAT%CROP(I)%PSI(ONE)
          PSI1 = CDAT%CROP(I)%PSI(TWO)
          PSI0_PSI1 = PSI0-PSI1
          IF(PSI0_PSI1 < NEARZERO_12) PSI0_PSI1 = NEARZERO_12
       END IF
       !
       DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
           !
           TPOT      = CDAT%CROP(I)%TGW(K)
           T_CONCEPT = CDAT%CROP(I)%T_CONCEPT(K)
           !
           HAS_TRANSPIRATION = TPOT >= NEARZERO_12 .AND. T_CONCEPT > Z ! .AND. CDAT%CROP(I)%AREA(K) > DZ .AND. CDAT%CROP(I)%NOT_FALLOW(K)
           !
           !########################################################################################
           !
      HAS_T: IF(HAS_TRANSPIRATION) THEN
                  !
                  R = CDAT%CROP(I)%RC(ONE,K)
                  C = CDAT%CROP(I)%RC(TWO,K)
                  !
                  !TSURF = TPOT  !DEFAULT WHEN NO GW INTERACTION
                  !
                  IF(T_CONCEPT > ONE) THEN
                      HH  = WTABLE(C,R)
                      IF(HH > NEAR_ninf) THEN
                          GSE = CDAT%CROP(I)%GSE(K)
                          !
                          IF(CDAT%HAS_AVE_HEAD) THEN
                               HH  = CDAT%AVE_HEAD(C,R)
                          ELSEIF(RELAX < SUB_ONE_5 .OR. NEAR_ONE_5 < RELAX) THEN
                               CALL RELAX_IT(HH, HNEW_OLD(C,R,UPLAY(C,R)), RELAX)  !RELAX*(HNEW(C,R,L) - HNEW_OLD(C,R,L)) + HNEW_OLD(C,R,L)   !HNEW = HOLD + FRAC*(HNEW-HOLD) 
                          END IF
                      ELSE              !IBOUND = Z SO NO ROOT-GROUNDWATER INTERACTION
                          T_CONCEPT = ONE
                      END IF
                  END IF
                  !
     T_CALC:      SELECT CASE(T_CONCEPT)
                  CASE(Z) ! NO T AT ALL!!!
                      !
                      TSURF = DZ
                      !
                      THI = DZ
                      THD = DZ
                      TGWA = DZ
                      ANOX_LOSS = DZ
                      SOIL_LOSS = DZ
                      !
                  CASE(ONE) ! NO ROOT-GROUNDWATER INTERACTION -- FULL CU
                      !
                      TSURF = TPOT
                      !
                      THI   = DZ
                      THD   = DZ
                      TGWA  = DZ
                      ANOX_LOSS = DZ
                      SOIL_LOSS = DZ
                      !
                  CASE(202:205)  ! SOLVE WITH CONCEPT 2
                      !
                      THI = DZ
                      THD = DZ
                      TGWA = DZ
                      TSURF = DZ
                      ANOX_LOSS = DZ
                      SOIL_LOSS = DZ
                      !
                      ASSOCIATE(UXX=>CDAT%CROP(I)%UXX(K), MXX=>CDAT%CROP(I)%MXX(K), SS=>CDAT%CROP(I)%SS(K), LXX=>CDAT%CROP(I)%LXX(K), ROOT=>CDAT%CROP(I)%ROOT(K))
                         !
                         TPOT_ROOT = TPOT / ROOT
                         !
                         IF    (HH >= UXX ) THEN  !HEAD ABOVE CROP ANOXIA LIMIT...PLANT HAS DROWNED!  --LATTER ADD CORRECTION FOR PLANTS THAT DROWNING LIKE RICE/WILLIOWS
                               !
                               !TGWA  = DZ
                               !TSURF = DZ
                               ANOX_LOSS = TPOT
                               !
                         ELSEIF( LXX >= HH ) THEN  !HEAD BELOW LOWER EXTINCTION DEPTH SO NO TGWA (LXX = GSE-ROOT-CAPILARY_FRINGE)
                               !
                               !TGWA  = DZ
                               TSURF      = TPOT_ROOT * (UXX-SS)      !       Tgw-act < Tc-act = Tc-act-max = (TPOT/TRZ)*(UXX-SS) < Tc-pot
                               SOIL_LOSS  = TPOT - TSURF
                               !
                         ELSEIF(UXX  > HH .AND. HH > MXX) THEN !FULL UPTAKE/ANOXI Zone
                               !
                               THI = TPOT_ROOT * UXX   !TGWA = THI - THD*H = (TPOT/ROOT)*(UXX - H)
                               THD = TPOT_ROOT      
                               !
                               TGWA  = THI-THD*HH  !   TPOT_ROOT*(UXX-HH)                      !TACT = Tgw-act < Tgw-act-max < Tc-pot (Tgw-act varies linearly)
                               !TSURF = DZ                                            !       Tgw-act = Tc-act
                               ANOX_LOSS = TPOT_ROOT*(HH-SS)
                               SOIL_LOSS = TPOT - TGWA - ANOX_LOSS
                               !
                         ELSEIF(MXX >= HH .AND. HH >= SS) THEN
                               !
                               THI = TPOT_ROOT*(UXX-MXX)
                               !
                               TGWA  = THI                                            !TACT = Tgw-act = Tgw-act-max < Tc-pot
                               TSURF = TPOT_ROOT*(UXX- HH) - TGWA                     !       Tgw-act < Tc-act (Tc-act varies linearly)
                               SOIL_LOSS  = TPOT - TSURF - TGWA
                               !ANOX_LOSS = DZ
                               !
                         ELSEIF(SS > HH .AND. HH > LXX) THEN
                               !
                               PSIA = SOIL%CAPILLARY_FRINGE(C,R)
                               !
                               THI =      TPOT_ROOT * (UXX-MXX) * (UNO - SS/PSIA)         !
                               THD = DNEG*TPOT_ROOT * (UXX-MXX) / PSIA                                    !IF NONLINEAR: THI & THD SEPARATION COULD BE SKIPPED:
                               !
                               TGWA  = THI-THD*HH                                                   !TACT = Tgw-act < Tgw-act-max < Tc-pot (Tgw-act varies linearly)        !TACT=TMAX*(1-SS/PSIA+HH/PSIA)**2
                               TSURF = TPOT_ROOT * (UXX-SS) - TGWA                            !       Tgw-act < Tc-act = Tc-act-max = (TPOT/TRZ)*(UXX-SS) < Tc-pot
                               SOIL_LOSS  = TPOT - TSURF - TGWA
                               !
                         ENDIF
                         !-------------------------------------------------------------------------------------------------------------------------------------------------------
                         ! EVALUATE ADDITIONAL TRANSPIRATION FROM PLANTS THAT CAN TAKE DROWNING
                         IF( PSI0 > NEARZERO_12 .AND. PSI1 >= DZ ) THEN
                             !
                             !9E2----EVALUATE ACTUAL TRANSPIRATION (FULL UPTAKE) FROM THE SATURATED ROOT ZONE (TGWSAT1)
                             IF( MAX(SS, HH-PSI1) > MIN(GSE, HH) ) THEN
                                                             CONTINUE !TGWSAT1=DZ   --DO NOTHING
                             ELSEIF(HH > GSE) THEN !, THD_SAT
                                                   IF(SS >= HH-PSI1 )THEN
                                                             THI_SAT = TPOT   ! = TGWSAT1 RHSS=RHSS+TGWSAT1
                                                             !
                                                             THI = THI_SAT
                                                             !
                                                             TGWA  = THI  !THI_SAT
                                                             TSURF = DZ
                                                             ANOX_LOSS = DZ
                                                             SOIL_LOSS = DZ
                                                   ELSE!IF(HH-PSI1 > SS)THEN
                                                             THI_SAT = TPOT_ROOT*(GSE+PSI1)
                                                             THD_SAT = TPOT_ROOT
                                                             !                                                                   
                                                             THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
                                                             THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
                                                             !
                                                             TGWA  = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH
                                                             TSURF = DZ
                                                             ANOX_LOSS = TPOT-TGWA
                                                             SOIL_LOSS = DZ
                                                   END IF
                             ELSE!IF(GSE > HH) ==> HH < GSE
                                                   IF(SS >= HH-PSI1)THEN
                                                             THI_SAT = DNEG * TPOT_ROOT * SS  !(TPOT/TRZ)*(TRZ-GSE))
                                                             THD_SAT = DNEG * TPOT_ROOT
                                                             !
                                                             THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
                                                             THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
                                                             !
                                                             TGWA  = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH 
                                                             TSURF = DZ
                                                             SOIL_LOSS = TPOT-TGWA
                                                             ANOX_LOSS = DZ
                                                   ELSE!IF(HH-PSI1 > SS)THEN
                                                             THI_SAT = TPOT_ROOT*PSI1
                                                             !
                                                             THI = THI + THI_SAT
                                                             !
                                                             TGWA  = THI - THD*HH  !TGWA + THI_SAT  !RHSS=RHSS+THISAT1
                                                             TSURF = DZ
                                                             ANOX_LOSS = TPOT-TGWA
                                                             SOIL_LOSS = DZ
                                                   ENDIF
                             END IF
                             !
                             !9E3----EVALUATE ACTUAL TRANSPIRATION (PARTIAL UPTAKE) FROM SATURATED ROOT ZONE (TGWSAT2)
                             IF(MAX(HH-PSI0, SS) > MIN(HH-PSI1, GSE) ) THEN
                                                             CONTINUE !TGWSAT2=DZ   --DO NOTHING
                             ELSEIF(GSE > HH-PSI1) THEN
                                                        IF(HH-PSI0 >= SS)THEN
                                                             THI_SAT = TPOT_ROOT * PSI0_PSI1 / DOS
                                                             !
                                                             THI = THI + THI_SAT                                    !RHSS=RHSS+THISAT1
                                                             !
                                                             TGWA  = THI - THD*HH  !TGWA + THI_SAT 
                                                             TSURF = DZ
                                                             ANOX_LOSS = TPOT-TGWA
                                                             SOIL_LOSS = DZ
                                                        ELSE
                                                             ALPHA   = HALF + (PSI0-HH+SS)/(DOS*PSI0_PSI1)
                                                             THI_SAT = DNEG*TPOT_ROOT*ALPHA*(SS+PSI1)
                                                             THD_SAT = DNEG*TPOT_ROOT*ALPHA
                                                             !
                                                             THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
                                                             THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
                                                             !
                                                             TGWA  = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH  
                                                             TSURF = DZ
                                                             SOIL_LOSS = TPOT-TGWA
                                                             ANOX_LOSS = DZ
                                                        ENDIF
                             ELSE!IF(HH-PSI1 > GSE) THEN
                                                        IF(HH-PSI0 > SS) THEN
                                                             ALPHA   = (GSE-HH+PSI0) / (DOS*PSI0_PSI1)
                                                             THI_SAT = TPOT_ROOT*ALPHA*(GSE+PSI0)
                                                             THD_SAT = TPOT_ROOT*ALPHA
                                                             !
                                                             THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
                                                             THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
                                                             !
                                                             TGWA  = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH    !TGWSAT2=THISAT2-THDSAT2*HH
                                                             TSURF = DZ
                                                             ANOX_LOSS = TPOT-TGWA
                                                             SOIL_LOSS = DZ
                                                        ELSE
                                                             !THI_SAT = TPOT_ROOT * (DOS*PSI0 - CDAT%CROP(I)%ROOT(K)) / (DOS * PSI0_PSI1)  !GSE+SS = -ROOT   --SS = GSE - ROOT  fixed summation
                                                             !THD_SAT = TPOT_ROOT / PSI0_PSI1
                                                             THI_SAT = (DOS*PSI0 + GSE + SS) * TPOT / (DOS * PSI0_PSI1)
                                                             THD_SAT = TPOT / PSI0_PSI1
                                                             !
                                                             THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
                                                             THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
                                                             !
                                                             TGWA  = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH     !TGWSAT2=THISAT2-THDSAT2*HH
                                                             TSURF = DZ
                                                             ANOX_LOSS = TPOT-TGWA
                                                             SOIL_LOSS = DZ
                                                        END IF
                             END IF
                         END IF
                      END ASSOCIATE
                      !
                  CASE(102:105)  !SOLVE WITH CONCEPT 1  --CODE IDENTICAL TOO "SUBROUTINE CONCEPT_TWO_TGW(CDAT, WBS, SOIL)"
                      !
                      SOIL_LOSS = DZ  !THIS IS ALWAYS ZERO FOR CONCEPT 2
                      !
                      IF(CDAT%HAS_POND) THEN
                          GSE_POND = GSE                  + CDAT%CROP(I)%POND(K)
                          ROOT_POND= CDAT%CROP(I)%ROOT(K) + CDAT%CROP(I)%POND(K)
                      ELSE
                          GSE_POND = GSE
                          ROOT_POND= CDAT%CROP(I)%ROOT(K)
                      END IF
                      !
                      IF    (HH >= GSE_POND) THEN  !HEAD ABOVE CROP ANOXIA LIMIT...PLANT HAS DROWNED!   --POND=0 WHEN NOT SPECIFIED
                             !
                             THI = DZ
                             THD = DZ
                             TGWA = DZ
                             TSURF  = DZ
                             ANOX_LOSS=TPOT
                             !
                      ELSEIF(HH >= CDAT%CROP(I)%SS(K) .AND. ROOT_POND > NEARZERO_12) THEN
                             !
                             THI = TPOT * (GSE_POND / ROOT_POND)
                             THD = TPOT / ROOT_POND
                             !
                             TGWA = THI-THD*HH 
                             TSURF  = DZ
                             ANOX_LOSS=TPOT-TGWA
                             !
                      ELSEIF(HH <= CDAT%CROP(I)%LXX(K) ) THEN  !HEAD BELOW LOWER EXTINCTION DEPTH SO NO TGWA (LXX = GSE-ROOT-CAPILARY_FRINGE)
                             !
                             THI  = DZ
                             THD  = DZ
                             TGWA = DZ
                             TSURF  = TPOT
                             ANOX_LOSS=DZ
                             !
                      ELSE                                     ! LXX < HH < SS
                             PSIA = SOIL%CAPILLARY_FRINGE(C,R)
                             !
                             THI = TPOT * (UNO - CDAT%CROP(I)%SS(K)/PSIA) !TPOT * (UNO - CDAT%CROP(I)%SS(K)/PSIA)
                             THD = DNEG*TPOT / PSIA
                             !
                             TGWA      = THI-THD*HH 
                             TSURF     = TPOT - TGWA
                             ANOX_LOSS = DZ
                      END IF
                  CASE DEFAULT
                      WRITE(*,'(A)') 'THIS SHOULD NOT HAPPEN FOR CROP '//NUM2STR(I)//' AT ROW, COL '//NUM2STR(R,-5)//NUM2STR(C,-5)
                      !
                  END SELECT  T_CALC
                  !
                  !########################################################################################
                  !
                  IF(TGWA  > TPOT) THEN
                      THI = THI - (TGWA-TPOT)
                      TGWA  = TPOT
                  END IF
                  IF(TSURF + TGWA > TPOT .AND. TSURF>DZ) TSURF = TPOT - TGWA
                  !
                  IF(NO_HD_TERM) THEN
                      THI = THI - THD*HH
                      THD = DZ
                  END IF
                  !
                  IF(ANOX_LOSS< NEARZERO_12) ANOX_LOSS=DZ
                  IF(SOIL_LOSS< NEARZERO_12) SOIL_LOSS=DZ
                  IF(TSURF    < NEARZERO_12) TSURF=DZ
                  !
                  !CALL SET_NEAR_ZERO(THI, NEARZERO_12)
                  !CALL SET_NEAR_ZERO(THD, NEARZERO_12)
                  IF(NEGNEARZERO_12 < THI .AND. THI < NEARZERO_12) THI = DZ
                  IF(NEGNEARZERO_12 < THD .AND. THD < NEARZERO_12) THD = DZ
                  !
                  IF(TGWA > NEARZERO_12) TGWA = THI - THD*HH  !RECALCULATE TGWA IN CASE IT IS OUT OF SYNC WITH THI AND THD
                  IF(TGWA < NEARZERO_12) THEN
                                         TGWA =DZ
                                         THI = DZ
                                         THD = DZ
                  END IF
                  !
                  ! 0 = No Transpiration            ==> Zeros out any T requirement
                  ! 1 = No Groundwater Interaction  ==> No Root-Groundwater Uptake, No  Anoxia or Stress Reduction, Full CU must be met through surface sources (Precip or Irigiation)
                  ! 2 = Has Anoxia/Soil Stress Loss,                      NO Root-Groundwater Uptake ==> CU Reduced from any anoxia and soil stress, but CU may only be satisfied with surface sources
                  ! 3 = Has Root-Groundwater Uptake,                      NO Anoxia/Soil Stress Loss ==> Anoxia and Soil Stress losses are either added to Root-Groundwater Uptake or surface consumption requirement  (i.e. if there is root-groundwater uptake, then the ammount lossed through anoxia is consumed as root-groundwater uptake. However if there is no root-groundwater uptake then the anoxia is added to the surface sources consumption (Precip or Irigiation) 
                  ! 4 = Has Root-Groundwater Uptake and Soil Stress Loss, NO Anoxia Loss             ==> Anoxia                 losses are either added to Root-Groundwater Uptake or surface consumption requirement  (i.e. if there is root-groundwater uptake, then the ammount lossed through anoxia is consumed as root-groundwater uptake. However if there is no root-groundwater uptake then the anoxia is added to the surface sources consumption (Precip or Irigiation) 
                  ! 5 = Full Interaction  ==> HAS Anoxia/Soil Stress Reducation, HAS Root-Groundwater Uptake  (DEFAULT)
                  !
                  SELECT CASE(CDAT%CROP(I)%GW_INTER(K))
                  CASE(0,1,5)   !CASES THAT DO NOT ALTER TSURF/TGWA
                              CONTINUE
                  CASE(TWO)   !NO GROUNDWATER UPTAKE BUT ANOXIA AND SOIL STRESS
                                       TSURF = TSURF + TGWA
                                       TGWA  = DZ
                                       THI   = DZ
                                       THD   = DZ
                  CASE(THREE) !NO AOXIA NOR SOIL LOSSES
                             IF(ANOX_LOSS > NEARZERO_12 .OR. SOIL_LOSS > NEARZERO_12) THEN
                                IF(TSURF > DZ) THEN
                                    TSURF = TSURF + ANOX_LOSS+SOIL_LOSS
                                ELSE
                                    TGWA  = TGWA  + ANOX_LOSS+SOIL_LOSS
                                    THI   = THI   + ANOX_LOSS+SOIL_LOSS
                                END IF
                             END IF
                             ANOX_LOSS = DZ
                             SOIL_LOSS = DZ
                  CASE(FOUR) !NO ANOXIA LOSSES
                             IF(ANOX_LOSS > NEARZERO_12) THEN
                                IF(TSURF > DZ) THEN
                                    TSURF = TSURF + ANOX_LOSS
                                ELSE
                                    TGWA  = TGWA + ANOX_LOSS
                                    THI   = THI  + ANOX_LOSS
                                    TSURF = DZ
                                END IF
                             END IF
                             ANOX_LOSS = DZ
                  CASE DEFAULT
                      WRITE(*,'(A)') 'THIS SHOULD NOT HAPPEN FOR CROP '//NUM2STR(I)//' AT ROW, COL '//NUM2STR(R,-5)//NUM2STR(C,-5)//' GW_INTER: '//NUM2STR(CDAT%CROP(I)%GW_INTER(K))
                  END SELECT
                  !
                  !
                  !IF(TSURF + TGWA > TPOT) THEN
                  !    IF(TSURF + TGWA > DZ) THEN
                  !        ALPHA = TPOT / (TSURF + TGWA)
                  !        TSURF = TSURF * ALPHA
                  !        TGWA  = TGWA  * ALPHA
                  !    END IF
                  !END IF
                  !
                  CDAT%CROP(I)%THI(K) = THI  !TGWA = THI - THD*H
                  CDAT%CROP(I)%THD(K) = THD
                  !
                  CDAT%CROP(I)%TGWA(K)      = TGWA
                  CDAT%CROP(I)%TSURF(K)     = TSURF
                  CDAT%CROP(I)%ANOX_LOSS(K) = ANOX_LOSS
                  CDAT%CROP(I)%SOIL_LOSS(K) = SOIL_LOSS
                  !
                  IF( CDAT%CROP(I)%IRR(K) > Z) THEN
                      IF( CDAT%CROP(I)%TPPOT(K) < TSURF ) THEN
                           CDAT%CROP(I)%TI(K) = TSURF - CDAT%CROP(I)%TPPOT(K)
                           CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
                      ELSE
                           CDAT%CROP(I)%TI(K) = DZ
                           CDAT%CROP(I)%TP(K) = TSURF
                      END IF
                  ELSE
                      CDAT%CROP(I)%TI(K) = DZ
                      !
                      IF( CDAT%CROP(I)%TPPOT(K) < TSURF ) THEN
                           CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
                      ELSE
                           CDAT%CROP(I)%TP(K) = TSURF
                      END IF
                  END IF
                  !
                  IF(CDAT%CROP(I)%TI(K) < DZ) CDAT%CROP(I)%TI(K) = DZ
                  IF(CDAT%CROP(I)%TP(K) < DZ) CDAT%CROP(I)%TP(K) = DZ
                  !
                  !IF( CDAT%CROP(I)%IRR(K) > Z .AND. CDAT%CROP(I)%TPPOT(K) < TSURF) THEN
                  !    !
                  !    CDAT%CROP(I)%TI(K) = TSURF - CDAT%CROP(I)%TPPOT(K)
                  !    CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
                  !    !
                  !ELSEIF( CDAT%CROP(I)%TPPOT(K) > TSURF ) THEN
                  !    CDAT%CROP(I)%TI(K) = DZ
                  !    CDAT%CROP(I)%TP(K) = TSURF
                  !ELSE
                  !    CDAT%CROP(I)%TI(K) = DZ
                  !    CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
                  !END IF
           ELSE !NO HAS_T
                  CDAT%CROP(I)%THI(K)   = DZ
                  CDAT%CROP(I)%THD(K)   = DZ
                  CDAT%CROP(I)%TGWA(K)  = DZ
                  CDAT%CROP(I)%TSURF(K) = DZ
                  CDAT%CROP(I)%TI(K)    = DZ
                  CDAT%CROP(I)%TP(K)    = DZ
                  CDAT%CROP(I)%ANOX_LOSS(K) = DZ
                  CDAT%CROP(I)%SOIL_LOSS(K) = DZ
           END IF HAS_T
           !
          END DO
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_EGW(CDAT, SOIL, RELAX, NO_HD_TERM) !THIS MUST BE CALLED AFTER T CALCULATION
    !
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    TYPE( SOIL_DATA), INTENT(IN   ):: SOIL
    DOUBLE PRECISION, INTENT(IN   ):: RELAX
    LOGICAL,          INTENT(IN   ):: NO_HD_TERM
    INTEGER:: I, K, R, C
    DOUBLE PRECISION:: FRINGE, EPOT, HH
    !
    IF(CDAT%NCROP > Z) THEN
         !
         DO CONCURRENT (I=ONE:CDAT%NCROP    )
         DO CONCURRENT (K=ONE:CDAT%CROP(I)%N) 
            !
            ASSOCIATE( CU =>CDAT%CROP(I)%CU(K),     IRR =>CDAT%CROP(I)%IRR(K),    GSE=>CDAT%CROP(I)%GSE(K),   &
                       TGWA=>CDAT%CROP(I)%TGWA(K),  CECT=>CDAT%CROP(I)%CECT(K),                               & !P  =>CDAT%CROP(I)%PRECIP(K), 
                       TI =>CDAT%CROP(I)%TI(K),     TP =>CDAT%CROP(I)%TP(K),      EP =>CDAT%CROP(I)%EP(K),    &
                     EPPOT=>CDAT%CROP(I)%EPPOT(K),  EHI=>CDAT%CROP(I)%EHI(K),     EHD=>CDAT%CROP(I)%EHD(K),   &
                     EGWA =>CDAT%CROP(I)%EGWA(K),   EGW=>CDAT%CROP(I)%EGW(K),     FTR=>CDAT%CROP(I)%FTR(K)     ) !<==VARAIBLES SET BY LOOP
                        !
                 R   = CDAT%CROP(I)%RC(ONE,K)
                 C   = CDAT%CROP(I)%RC(TWO,K)
                 !
                 EHI = DZ
                 EHD = DZ
                 !
                 !!!IF(FTR < UNO) THEN
                     !
                     !!!EPPOT = P - TP
                     !!!IF(EPPOT < NEARZERO_12) EPPOT = DZ
                     !
                     IF(IRR > Z) THEN    !Tgw - ETi
                         EGW = CU - TP - TGWA - TI*(UNO + CECT) ! = EP + EGWA
                     ELSE
                         EGW = CU - TP - TGWA
                     END IF
                     !
                     !EGW = CU * (UNO - FTR)   !SCOTT -- FOR CHECKING AGAINST OWHMv1
                     !
                     IF(EGW > CU         ) EGW = CU
                     IF(EGW < NEARZERO_12) EGW = DZ
                     !
                     IF(EGW > EPPOT) THEN !EPPOT IS TOO LARGE -- No Egw
                         EP   = EPPOT
                         EPOT = EGW - EP
                     ELSE
                         EP   = EGW
                         EPOT = DZ
                     END IF
                     !
                     IF(EP < DZ) EP = DZ
                 !!!ELSE
                 !!!    EGW   = DZ 
                 !!!    !!!EPPOT = DZ
                 !!!    EP    = DZ
                 !!!    EPOT  = DZ
                 !!!END IF
                 !
                 IF( EPOT < NEARZERO_12) THEN             !NO EGW OR ALL EVAP COMES FROM PRECIP; L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
                     EPOT = DZ
                     EGWA = DZ
                 ELSEIF(WTABLE(C,R) <= NEAR_ninf ) THEN   !NO EGW OR ALL EVAP COMES FROM PRECIP; L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
                     EPOT = DZ
                     EGWA = DZ
                 ELSE!------------------------------------------------------------------------------
                     !
                     IF(CDAT%HAS_AVE_HEAD) THEN
                          HH  = CDAT%AVE_HEAD(C,R)
                     ELSEIF(SUB_ONE_5 < RELAX .AND. RELAX < NEAR_ONE_5) THEN
                          HH  = WTABLE(C,R) 
                     ELSE
                          CALL RELAX_IT(HH, WTABLE(C,R), HNEW_OLD(C,R,UPLAY(C,R)), RELAX)    !HNEW = HOLD + FRAC*(HNEW-HOLD)
                     END IF
                     !
                     IF( HH > GSE ) THEN
                         !
                         EHI  = EPOT
                         EGWA = EHI
                         !EHD  = DZ
                         !
                     ELSEIF(HH < CDAT%CROP(I)%XX(K)) THEN  !GSE-CAP
                         !
                         !EHI  = DZ
                         !EHD  = DZ
                         EGWA = DZ
                     ELSE
                         FRINGE = SOIL%CAPILLARY_FRINGE(C,R)
                         !
                         EHI =        EPOT * ( UNO - GSE/FRINGE)
                         EHD = DNEG * EPOT / FRINGE  
                         !
                         EGWA = EHI - EHD*HH
                     END IF
                     !
                     IF(EGWA < NEARZERO_12) THEN
                         EHI  = DZ
                         EHD  = DZ
                         EGWA = DZ
                     ELSEIF(NO_HD_TERM) THEN
                         EHI = EHI - EHD*HH
                         EHD = DZ
                     END IF
                     !
                 END IF
            END ASSOCIATE
         END DO; END DO
    END IF
    !
    IF(CDAT%CHECK_BARE) THEN
         !
         DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%BARE_FRAC(C,R) > DZ)
            !
            ASSOCIATE( EBPOT=>CDAT%BARE_POT_EVAP(C,R), GSE=>CDAT%BARE_GSE(C,R),     BARE_FRINGE=>SOIL%CAPILLARY_FRINGE(C,R),    &
                       EHI=>CDAT%BARE_EVAP_EHI(C,R),   EHD=>CDAT%BARE_EVAP_EHD(C,R),       EGWA=>CDAT%BARE_EVAP(C,R)            ) !<==VARAIBLES SET BY LOOP
                       !
                 !
                 EHI  = DZ
                 EHD  = DZ
                 EGWA = DZ
                 !
                 IF( EBPOT > NEARZERO_12 .AND. WTABLE(C,R) > NEAR_ninf) THEN   !L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
                     !
                     IF(CDAT%HAS_AVE_HEAD) THEN
                          HH  = CDAT%AVE_HEAD(C,R)
                     ELSEIF(SUB_ONE_5 < RELAX .AND. RELAX < NEAR_ONE_5) THEN
                          HH  = WTABLE(C,R)
                     ELSE
                          CALL RELAX_IT(HH, WTABLE(C,R), HNEW_OLD(C,R,UPLAY(C,R)), RELAX) 
                     END IF
                     !
                     IF( HH > GSE ) THEN
                         !
                         EHI  = EBPOT
                         !CALL SET_NEAR_ZERO(EHI,NEARZERO_12)
                         IF(NEGNEARZERO_12 < EHI .AND. EHI < NEARZERO_12) EHI = DZ
                         !
                         EGWA = EHI
                         EHD  = DZ
                         !
                     ELSEIF(HH > GSE - BARE_FRINGE) THEN  !GSE-CAP
                         !
                         EHI =        EBPOT * ( UNO - GSE/BARE_FRINGE)
                         EHD = DNEG * EBPOT / BARE_FRINGE  
                         !
                         !CALL SET_NEAR_ZERO(EHI,NEARZERO_12)
                         !CALL SET_NEAR_ZERO(EHD,NEARZERO_12)
                         IF(NEGNEARZERO_12 < EHI .AND. EHI < NEARZERO_12) EHI = DZ
                         IF(NEGNEARZERO_12 < EHD .AND. EHD < NEARZERO_12) EHD = DZ
                         !
                         EGWA = EHI - EHD*HH
                     ELSE
                         EHI  = DZ
                         EHD  = DZ
                     END IF
                 END IF
                 !
                 IF(NO_HD_TERM) THEN
                     EHI = EHI - EHD*HH
                     EHD = DZ
                 END IF
                 !
                 IF(EGWA < NEARZERO_12) THEN
                     EHI  = DZ
                     EHD  = DZ
                     EGWA = DZ
                 END IF
            END ASSOCIATE
         END DO
    END IF
    !
    END SUBROUTINE
  !
!  SUBROUTINE CALC_CROP_TRANSPIRATION(CDAT, WBS, SOIL)
!    !
!    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
!    TYPE(  WBS_DATA), INTENT(IN   ):: WBS
!    TYPE( SOIL_DATA), INTENT(IN   ):: SOIL
!    !
!    INTEGER:: I, K, R, C, L
!    DOUBLE PRECISION:: TGWA
!    DOUBLE PRECISION:: PSIA, PSI0, PSI1, PSI2, PSI3, PSI3_CM, XDRY, XWET
!    DOUBLE PRECISION:: HH, HO, GSE, TPOT, TPOT_ROOT, TPOT_AREA, TSURF, ANOX_STRESS,GSE_POND, ROOT_POND
!    DOUBLE PRECISION:: PSIDRY, PSIWET, PSIWET_CM, PSIDRY_CM, PSI0_PSI1
!    DOUBLE PRECISION:: UXX, MXX, DRZ, NEXP, THI, THD, THI_SAT, THD_SAT, ALPHA, DEL
!    LOGICAL:: HAS_NONZERO_PSI, HAS_TRANSPIRATION 
!    INTEGER:: NPOINT
!    DOUBLE PRECISION:: DPOINT
!    !
!    NPOINT = 1   !10
!    DPOINT = 1D0 !10D0
!    DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z )
!       !
!       PSI0 = DZ;  PSI1 = DZ;  PSI2 = DZ;  PSI3 = DZ
!       !
!       IF(CDAT%HAS_PSI) THEN
!          IF( CDAT%CROP(I)%PSI(ONE  ) < DZ )  PSI0 = CDAT%CROP(I)%PSI(ONE  ) * DNEG  !FLIP TO POSITIVE --SAME AS ABSOLUTE VALUE
!          IF( CDAT%CROP(I)%PSI(TWO  ) < DZ )  PSI1 = CDAT%CROP(I)%PSI(TWO  ) * DNEG 
!          IF( CDAT%CROP(I)%PSI(THREE) < DZ )  PSI2 = CDAT%CROP(I)%PSI(THREE) * DNEG
!          IF( CDAT%CROP(I)%PSI(FOUR ) < DZ )  PSI3 = CDAT%CROP(I)%PSI(FOUR ) * DNEG
!       END IF
!       !
!       DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
!           !
!           R = CDAT%CROP(I)%RC(ONE,K)
!           C = CDAT%CROP(I)%RC(TWO,K)
!           L = UPLAY(C,R)
!           !
!           THI = DZ
!           THD = DZ
!           TGWA = DZ
!           TSURF = DZ
!           ANOX_STRESS = DZ
!           !
!           TPOT = CDAT%CROP(I)%TGW(K)
!           IF(TPOT < NEARZERO_12) TPOT = DZ
!           !
!           HAS_TRANSPIRATION = TPOT > NEARZERO_12 .AND. L > Z .AND. CDAT%CROP(I)%T_CONCEPT(K) > Z .AND. CDAT%CROP(I)%AREA(K) > DZ .AND. CDAT%CROP(I)%NOT_FALLOW(K)
!           !
!           IF(CDAT%CROP(I)%T_CONCEPT(K) > ONE) THEN
!                 GSE = CDAT%CROP(I)%GSE(K)
!                 HO  = HOLD(C,R,L)
!                 HH  = RELAXER(HNEW(C,R,L), HNEW_OLD(C,R,L), CDAT%RELAX)  !CDAT%RELAX*(HNEW(C,R,L) - HNEW_OLD(C,R,L)) + HNEW_OLD(C,R,L)   !HNEW = HOLD + FRAC*(HNEW-HOLD) 
!                 !
!                 IF(NPOINT>ONE) THEN
!                     DEL = (HH-HO)/DPOINT
!                 ELSE
!                     DEL = HH-HO
!                 END IF
!                 !
!           END IF
!           !
!           !########################################################################################
!           !
!      HAS_T: IF(HAS_TRANSPIRATION) THEN
!     T_CALC:      SELECT CASE(CDAT%CROP(I)%T_CONCEPT(K))
!                  CASE(ONE) ! NO ROOT-GROUNDWATER INTERACTION -- FULL CU
!                      !
!                      TSURF = TPOT
!                      !
!                  CASE(202:204)  ! SOLVE WITH CONCEPT 1
!                      !
!                      UXX = CDAT%CROP(I)%UXX(K)
!                      MXX = CDAT%CROP(I)%MXX(K)
!                      TPOT_ROOT =            TPOT / CDAT%CROP(I)%ROOT(K)
!                      !
!                      IF    (HH >= UXX ) THEN  !HEAD ABOVE CROP ANOXIA LIMIT...PLANT HAS DROWNED!  --LATTER ADD CORRECTION FOR PLANTS THAT DROWNING LIKE RICE/WILLIOWS
!                             !
!                             TGWA = DZ
!                             TSURF = DZ
!                             ANOX_STRESS=TPOT
!                             !
!                      ELSEIF( CDAT%CROP(I)%LXX(K) >= HH ) THEN  !HEAD BELOW LOWER EXTINCTION DEPTH SO NO TGWA (LXX = GSE-ROOT-CAPILARY_FRINGE)
!                             !
!                             TGWA = DZ
!                             TSURF  = TPOT_ROOT * (UXX-CDAT%CROP(I)%SS(K))      !       Tgw-act < Tc-act = Tc-act-max = (TPOT/TRZ)*(UXX-SS) < Tc-pot
!                             ANOX_STRESS = TPOT - TSURF
!                             !
!                      ELSEIF(UXX  > HH .AND. HH > MXX) THEN !FULL UPTAKE/ANOXI Zone
!                            !
!                            THI = TPOT_ROOT * UXX   !TGWA = THI - THD*H = (TPOT/ROOT)*(UXX - H)
!                            THD = TPOT_ROOT      
!                            !
!                            TGWA=THI-THD*HH                                           !TACT = Tgw-act < Tgw-act-max < Tc-pot (Tgw-act varies linearly)
!                            TSURF=DZ                                            !       Tgw-act = Tc-act
!                            ANOX_STRESS = TPOT - TGWA
!                            !
!                      ELSEIF(MXX >= HH .AND. HH >= CDAT%CROP(I)%SS(K)) THEN
!                            !
!                            THI = TPOT_ROOT*(UXX-MXX)
!                            !
!                            TGWA = THI                                            !TACT = Tgw-act = Tgw-act-max < Tc-pot
!                            TSURF = TPOT_ROOT*(UXX- HH) - TGWA                     !       Tgw-act < Tc-act (Tc-act varies linearly)
!                            ANOX_STRESS = TPOT - TSURF - TGWA
!                            !
!                      ELSEIF(CDAT%CROP(I)%SS(K) > HH .AND. HH > CDAT%CROP(I)%LXX(K)) THEN
!                            !
!                            PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!                            !
!                            THI=     TPOT_ROOT * (UXX-MXX) * (UNO - CDAT%CROP(I)%SS(K)/PSIA)         !
!                            THD=DNEG*TPOT_ROOT * (UXX-MXX) / PSIA                                    !IF NONLINEAR: THI & THD SEPARATION COULD BE SKIPPED:
!                            !
!                            TGWA = THI-THD*HH                                                   !TACT = Tgw-act < Tgw-act-max < Tc-pot (Tgw-act varies linearly)        !TACT=TMAX*(1-SS/PSIA+HH/PSIA)**2
!                            TSURF = TPOT_ROOT * (UXX-CDAT%CROP(I)%SS(K)) - TGWA                            !       Tgw-act < Tc-act = Tc-act-max = (TPOT/TRZ)*(UXX-SS) < Tc-pot
!                            ANOX_STRESS = TPOT - TSURF - TGWA
!                            !
!                      ENDIF
!                      !-------------------------------------------------------------------------------------------------------------------------------------------------------
!                      ! EVALUATE ADDITIONAL TRANSPIRATION FROM PLANTS THAT CAN TAKE DROWNING
!                      IF( CDAT%CROP(I)%PSI(ONE) > NEARZERO_12 .AND. CDAT%CROP(I)%PSI(TWO) >= DZ ) THEN
!                          !
!                          !
!                          PSI0 = CDAT%CROP(I)%PSI(ONE)
!                          PSI1 = CDAT%CROP(I)%PSI(TWO)
!                          !
!                          PSI0_PSI1 = PSI0-PSI1
!                          IF(PSI0_PSI1 < NEARZERO_12) PSI0_PSI1 = NEARZERO_12
!                          !
!                          !9E2----EVALUATE ACTUAL TRANSPIRATION (FULL UPTAKE) FROM THE SATURATED ROOT ZONE (TGWSAT1)
!                          IF( MAX(CDAT%CROP(I)%SS(K), HH-PSI1) > MIN(GSE, HH) ) THEN
!                                                          CONTINUE !TGWSAT1=DZ   --DO NOTHING
!                          ELSEIF(HH > GSE) THEN !, THD_SAT
!                                                IF(CDAT%CROP(I)%SS(K) >= HH-PSI1 )THEN
!                                                          THI_SAT = TPOT   ! = TGWSAT1 RHSS=RHSS+TGWSAT1
!                                                          !
!                                                          THI = THI_SAT
!                                                          !
!                                                          TGWA = THI  !THI_SAT
!                                                          TSURF=DZ
!                                                          ANOX_STRESS=DZ
!                                                ELSE!IF(HH-PSI1 > CDAT%CROP(I)%SS(K))THEN
!                                                          THI_SAT = TPOT_ROOT*(GSE+PSI1)
!                                                          THD_SAT = TPOT_ROOT
!                                                          !                                                                   
!                                                          THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!                                                          THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!                                                          !
!                                                          TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH
!                                                          TSURF=DZ
!                                                          ANOX_STRESS=TPOT-TGWA
!                                                END IF
!                          ELSE!IF(GSE > HH) ==> HH < GSE
!                                                IF(CDAT%CROP(I)%SS(K) >= HH-PSI1)THEN
!                                                          THI_SAT = DNEG * TPOT_ROOT * CDAT%CROP(I)%SS(K)  !(TPOT/TRZ)*(TRZ-GSE))
!                                                          THD_SAT = DNEG * TPOT_ROOT
!                                                          !
!                                                          THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!                                                          THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!                                                          !
!                                                          TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH 
!                                                          TSURF=DZ
!                                                          ANOX_STRESS=TPOT-TGWA
!                                                ELSE!IF(HH-PSI1 > CDAT%CROP(I)%SS(K))THEN
!                                                          THI_SAT = TPOT_ROOT*PSI1
!                                                          !
!                                                          THI = THI + THI_SAT
!                                                          !
!                                                          TGWA = THI - THD*HH  !TGWA + THI_SAT  !RHSS=RHSS+THISAT1
!                                                          TSURF=DZ
!                                                          ANOX_STRESS=TPOT-TGWA
!                                                ENDIF
!                          END IF
!                          !
!                          !9E3----EVALUATE ACTUAL TRANSPIRATION (PARTIAL UPTAKE) FROM SATURATED ROOT ZONE (TGWSAT2)
!                          IF(MAX(HH-PSI0, CDAT%CROP(I)%SS(K)) > MIN(HH-PSI1, GSE) ) THEN
!                                                          CONTINUE !TGWSAT2=DZ   --DO NOTHING
!                          ELSEIF(GSE > HH-PSI1) THEN
!                                                     IF(HH-PSI0 >= CDAT%CROP(I)%SS(K))THEN
!                                                          THI_SAT = TPOT_ROOT * PSI0_PSI1 / DOS
!                                                          !
!                                                          THI = THI + THI_SAT                                    !RHSS=RHSS+THISAT1
!                                                          !
!                                                          TGWA = THI - THD*HH  !TGWA + THI_SAT 
!                                                          TSURF=DZ
!                                                          ANOX_STRESS=TPOT-TGWA
!                                                     ELSE
!                                                          ALPHA= HALF + (PSI0-HH+CDAT%CROP(I)%SS(K))/(DOS*PSI0_PSI1)
!                                                          THI_SAT = DNEG*TPOT_ROOT*ALPHA*(CDAT%CROP(I)%SS(K)+PSI1)
!                                                          THD_SAT = DNEG*TPOT_ROOT*ALPHA
!                                                          !
!                                                          THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!                                                          THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!                                                          !
!                                                          TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH  
!                                                          TSURF=DZ
!                                                          ANOX_STRESS=TPOT-TGWA
!                                                     ENDIF
!                          ELSE!IF(HH-PSI1 > GSE) THEN
!                                                     IF(HH-PSI0 > CDAT%CROP(I)%SS(K)) THEN
!                                                          ALPHA=(GSE-HH+PSI0) / (DOS*PSI0_PSI1)
!                                                          THI_SAT = TPOT_ROOT*ALPHA*(GSE+PSI0)
!                                                          THD_SAT = TPOT_ROOT*ALPHA
!                                                          !
!                                                          THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!                                                          THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!                                                          !
!                                                          TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH    !TGWSAT2=THISAT2-THDSAT2*HH
!                                                          TSURF=DZ
!                                                          ANOX_STRESS=TPOT-TGWA
!                                                     ELSE
!                                                          !THI_SAT = TPOT_ROOT * (DOS*PSI0 - CDAT%CROP(I)%ROOT(K)) / (DOS * PSI0_PSI1)  !GSE+SS = -ROOT   --SS = GSE - ROOT  fixed summation
!                                                          !THD_SAT = TPOT_ROOT / PSI0_PSI1
!                                                          THI_SAT = (DOS*PSI0 + GSE + CDAT%CROP(I)%SS(K)) * TPOT / (DOS * PSI0_PSI1)
!                                                          THD_SAT = TPOT / PSI0_PSI1
!                                                          !
!                                                          THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!                                                          THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!                                                          !
!                                                          TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH     !TGWSAT2=THISAT2-THDSAT2*HH
!                                                          TSURF=DZ
!                                                          ANOX_STRESS=TPOT-TGWA
!                                                     END IF
!                          END IF
!                      END IF
!                      !
!                  CASE(102:104)  !SOLVE WITH CONCEPT 2  --CODE IDENTICAL TOO "SUBROUTINE CONCEPT_TWO_TGW(CDAT, WBS, SOIL)"
!                      !
!                      IF(CDAT%HAS_POND) THEN
!                          GSE_POND = GSE                  + CDAT%CROP(I)%POND(K)
!                          ROOT_POND= CDAT%CROP(I)%ROOT(K) + CDAT%CROP(I)%POND(K)
!                      ELSE
!                          GSE_POND = GSE
!                          ROOT_POND= CDAT%CROP(I)%ROOT(K)
!                      END IF
!                      !
!                      IF    (HH >= GSE_POND) THEN  !HEAD ABOVE CROP ANOXIA LIMIT...PLANT HAS DROWNED!   --POND=0 WHEN NOT SPECIFIED
!                             !
!                             TGWA = DZ
!                             TSURF  = DZ
!                             ANOX_STRESS=TPOT
!                             !
!                      ELSEIF(HH >= CDAT%CROP(I)%SS(K) ) THEN
!                             !
!                             THI = TPOT * GSE_POND / ROOT_POND
!                             THD = TPOT / ROOT_POND
!                             !
!                             TGWA = THI-THD*HH 
!                             TSURF  = DZ
!                             ANOX_STRESS=TPOT-TGWA
!                             !
!                      ELSEIF(HH <= CDAT%CROP(I)%LXX(K) ) THEN  !HEAD BELOW LOWER EXTINCTION DEPTH SO NO TGWA (LXX = GSE-ROOT-CAPILARY_FRINGE)
!                             !
!                             TGWA = DZ
!                             TSURF  = TPOT
!                             ANOX_STRESS=DZ
!                             !
!                      ELSE
!                             PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!                             !
!                             THI = TPOT - (TPOT*CDAT%CROP(I)%SS(K)/PSIA) !TPOT * (UNO - CDAT%CROP(I)%SS(K)/PSIA)
!                             THD = DNEG*TPOT / PSIA
!                             !
!                             TGWA = THI-THD*HH 
!                             TSURF  = TPOT - TGWA
!                             ANOX_STRESS=DZ
!                      END IF
!                      !
!                  END SELECT  T_CALC
!                  !
!                  !########################################################################################
!                  !
!                  ! 0 = No T/No CU
!                  ! 1 = No GW Interaction/Full CU from Surf/No  Anoxia/Soil Stress Reducation, No  Root-Groundwater Uptake  
!                  ! 2 = No GW Uptake/ HAS Anoxia/Soil Stress Reducation, No  Root-Groundwater Uptake  
!                  ! 3 = No Anoxia - But has GW Uptake
!                  ! 4 = Full Interaction HAS Anoxia/Soil Stress Reducation, HAS Root-Groundwater Uptake  
!                  !
!                  IF(CDAT%CROP(I)%GW_INTER(K) == TWO) THEN !NO GROUNDWATER UPTAKE
!                                                 TSURF = TSURF + TGWA
!                                                 TGWA  = DZ
!                                                 THI   = DZ
!                                                 THD   = DZ
!                  ELSEIF(CDAT%CROP(I)%GW_INTER(K) == THREE .AND. ANOX_STRESS>DZ) THEN
!                      IF(TSURF > DZ) THEN
!                          TSURF = TSURF + ANOX_STRESS
!                      ELSE
!                          TGWA = TGWA + ANOX_STRESS
!                          THI  = THI  + ANOX_STRESS
!                      END IF
!                  END IF
!                  !
!                  !
!                  IF(TSURF > TPOT) TSURF = TPOT
!                  IF(TGWA  > TPOT) TGWA  = TPOT
!                  IF(TSURF + TGWA > TPOT) THEN
!                      IF(TSURF + TGWA > DZ) THEN
!                          ALPHA = TPOT / (TSURF + TGWA)
!                          TSURF = TSURF * ALPHA
!                          TGWA  = TGWA  * ALPHA
!                      END IF
!                  END IF
!                  IF(ABS(TGWA - (THI - THD*HH) ) > NEARZERO_12) THEN
!                          ALPHA = 1D0
!                  END IF
!                  !
!                  CDAT%CROP(I)%THI(K) = THI
!                  CDAT%CROP(I)%THD(K) = THD
!                  !
!                  CDAT%CROP(I)%TGWA(K)        = TGWA
!                  CDAT%CROP(I)%TSURF(K)       = TSURF
!                  CDAT%CROP(I)%ANOXIA_LOSS(K) = ANOX_STRESS
!                  !
!                  IF(CDAT%CROP(I)%ANOXIA_LOSS(K) < NEARZERO_12) CDAT%CROP(I)%ANOXIA_LOSS(K) = DZ
!                  !
!                  IF( CDAT%CROP(I)%IRR(K) > Z .AND. CDAT%CROP(I)%TPPOT(K) < TSURF) THEN
!                      !
!                      CDAT%CROP(I)%TI(K) = TSURF - CDAT%CROP(I)%TPPOT(K)
!                      CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
!                      !
!                  ELSEIF(TSURF < CDAT%CROP(I)%TPPOT(K) ) THEN
!                      CDAT%CROP(I)%TI(K) = DZ
!                      CDAT%CROP(I)%TP(K) = TSURF
!                  ELSE
!                      CDAT%CROP(I)%TI(K) = DZ
!                      CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
!                  END IF
!           ELSE !HAS_T
!                  CDAT%CROP(I)%THI(K)   = DZ
!                  CDAT%CROP(I)%THD(K)   = DZ
!                  CDAT%CROP(I)%TGWA(K)  = DZ
!                  CDAT%CROP(I)%TSURF(K) = DZ
!                  CDAT%CROP(I)%TI(K)    = DZ
!                  CDAT%CROP(I)%TP(K)    = DZ
!                  CDAT%CROP(I)%ANOXIA_LOSS(K) = DZ
!           END IF HAS_T
!           !
!          END DO
!    END DO
!    !
!  END SUBROUTINE
  !
!!!  SUBROUTINE CONCEPT_ONE_TGW(CDAT, WBS, SOIL)
!!!    !
!!!    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
!!!    TYPE(  WBS_DATA), INTENT(IN   ):: WBS
!!!    TYPE( SOIL_DATA), INTENT(IN   ):: SOIL
!!!    !
!!!    INTEGER:: I, K, R, C, L
!!!    DOUBLE PRECISION:: TGWA
!!!    DOUBLE PRECISION:: PSIA, PSI0, PSI1, PSI2, PSI3, PSI3_CM, XDRY, XWET
!!!    DOUBLE PRECISION:: HH, GSE, TPOT, TPOT_ROOT, TPOT_AREA, TSURF, GSE_POND, ROOT_POND
!!!    DOUBLE PRECISION:: PSIDRY, PSIWET, PSIWET_CM, PSIDRY_CM, PSI0_PSI1
!!!    DOUBLE PRECISION:: UXX, MXX, DRZ, NEXP, THI, THD, THI_SAT, THD_SAT, ALPHA
!!!    LOGICAL:: HAS_NONZERO_PSI, HAS_TRANSPIRATION 
!!!    !
!!!    DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z )
!!!          !
!!!          PSI0 = DZ;  PSI1 = DZ;  PSI2 = DZ;  PSI3 = DZ
!!!          !
!!!          IF( CDAT%CROP(I)%PSI(ONE  ) < DZ )  PSI0 = CDAT%CROP(I)%PSI(ONE  ) * DNEG  !FLIP TO POSITIVE --SAME AS ABSOLUTE VALUE
!!!          IF( CDAT%CROP(I)%PSI(TWO  ) < DZ )  PSI1 = CDAT%CROP(I)%PSI(TWO  ) * DNEG 
!!!          IF( CDAT%CROP(I)%PSI(THREE) < DZ )  PSI2 = CDAT%CROP(I)%PSI(THREE) * DNEG
!!!          IF( CDAT%CROP(I)%PSI(FOUR ) < DZ )  PSI3 = CDAT%CROP(I)%PSI(FOUR ) * DNEG
!!!          !
!!!          HAS_NONZERO_PSI =  ANY( ABS(CDAT%CROP(I)%PSI) > NEARZERO_12 ) !PSI0 > DZ .OR. PSI1 > DZ .OR. PSI2 > DZ .OR. PSI3 > DZ
!!!          !
!!!          PSIWET = (PSI0+PSI1)/DOS    ! EVALUATE PRESSURE HEADS BETWEEN WHICH UPTAKE IS CONSIDERED OPTIMAL
!!!          PSIDRY = (PSI2+PSI3)/DOS
!!!          !
!!!          PSI3_CM   = PSI3  *CDAT%MLT
!!!          PSIWET_CM = PSIWET*CDAT%MLT
!!!          PSIDRY_CM = PSIDRY*CDAT%MLT
!!!          !
!!!          DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
!!!              !
!!!              R = CDAT%CROP(I)%RC(ONE,K)
!!!              C = CDAT%CROP(I)%RC(TWO,K)
!!!              L = UPLAY(C,R)
!!!              !
!!!              THI = DZ
!!!              THD = DZ
!!!              TGWA = DZ
!!!              TSURF = DZ
!!!              !
!!!              UXX = CDAT%CROP(I)%GSE(K)
!!!              MXX = CDAT%CROP(I)%SS(K)
!!!              !
!!!              TPOT = CDAT%CROP(I)%TGW(K)
!!!              IF(TPOT < NEARZERO_12) TPOT = DZ
!!!              !
!!!              HAS_TRANSPIRATION = TPOT > NEARZERO_12 .AND. CDAT%CROP(I)%NOT_FALLOW(K) .AND. L > Z
!!!              !
!!!              !########################################################################################
!!!              !
!!!      T_CALC: IF(CDAT%CROP(I)%GW_INTER(K) == Z) THEN  ! NO ROOT-GROUNDWATER INTERACTION
!!!                  !
!!!                  TSURF = TPOT
!!!                  !
!!!              ELSEIF( HAS_TRANSPIRATION .AND. HAS_NONZERO_PSI ) THEN   ! SOLVE WITH CONCEPT 1
!!!                  !
!!!                  HH  = CDAT%RELAX*(HNEW(C,R,L) - HNEW_OLD(C,R,L)) + HNEW_OLD(C,R,L)   !HNEW = HOLD + FRAC*(HNEW-HOLD)
!!!                  GSE = CDAT%CROP(I)%GSE(K)
!!!                  !
!!!                  !6B1C---CONVERT FLOWRATE OF ORIGINAL MAXIMUM TRANSPIRATION BACK TO FLUX (REASON: UXX AND MXX BELOW ARE FUNCTIONS OF T-FLUX NOT T-FLOWRATE; WITH:
!!!                  !        UXX =    Head Elevation of Upper Extinction of Transpiration due to Anoxia
!!!                  !        MXX =    Head Elevation of Elimination of crop-unproductive Wilting Zone)
!!!                  !
!!!                  TPOT_ROOT =            TPOT / CDAT%CROP(I)%ROOT(K)
!!!                  TPOT_AREA = CDAT%MLT * TPOT / CDAT%CROP(I)%AREA(K)  !NOTE THIS IS A RATE RATHER THAN VOLUMETRIC RATE  --CONVERTED TO CM/T
!!!                  !
!!!                  DRZ =  SOIL%COEF(C,R)%A*LOG(CDAT%CROP(I)%ROOT(K)*CDAT%MLT) + SOIL%COEF(C,R)%B*LOG(TPOT_AREA) + SOIL%COEF(C,R)%C  !TAKE EXP AFTER USED FOR NEXP CALCULATION
!!!                  NEXP = SOIL%COEF(C,R)%D*DRZ + SOIL%COEF(C,R)%E
!!!                  DRZ  = EXP(DRZ)
!!!                  !
!!!                  IF(DRZ  > PSI3_CM)     DRZ  = PSI3_CM
!!!                  IF(NEXP < NEARZERO_12) NEXP = NEARZERO_12
!!!                  !
!!!                  IF(PSIWET < NEARZERO_12) THEN
!!!                       XWET = DZ
!!!                  ELSE
!!!                       !     
!!!                       !6B1G---SOLVE ANALYTICAL FUNCTION FOR DEPTHS BETWEEN WHICH UPTAKE IS OPTIMAL:
!!!                       !       ANALYTICAL FUNCTION: PSI(DEPTH) = FUNCTION (DRZ,NEXP,PSI3,DEPTH)
!!!                       !                            PSI(DEPTH)   IS SOLVED ITERATIVELY BY BISECTION-METHOD
!!!                       !                                         FOR DEPTH(PSIWET) AND FOR DEPTH(PSIDRY)
!!!                       XWET = RTFUNC(DRZ,PSI3_CM,NEXP,PSIWET_CM) / CDAT%MLT
!!!                       !
!!!                       IF(XWET.NE.XWET) THEN
!!!                           !WRITE(CDAT%LOUT,'(/A/,A/,6A)') 'FMP CROP WARNING. SOLVING ANALYITICAL WATER STRESS RESPONSE FUNCTION, XWET = PSI(DEPTH) = FUNCTION (DRZ,NEXP,PSI3,DEPTH), WITH BISECTION METHOD FAILED TO IDENTIFY INITIAL GUESS (d1 and d2) THAT ARE ON BOTH SIDES OF THE ROOT. (viz. PSI(d1)*PSI(d2)>0).', &
!!!                           !                               'TO KEEP PROGRAM FROM STOPPING THE SOLUTION THE HEAD ELEVATION OF UPPER EXTINCTION OF TRANSPIRATION DUE TO ANOXIA IS ASSUMED TO BE THE GROUND SURFACE.', &
!!!                           !                               'THIS PROBLEM OCCURED FOR CROP ',NUM2STR(I),' LOCATED IN ROW, COL: ', NUM2STR(R), ', ', NUM2STR(C)
!!!                           CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP: SOLVING ANALYITICAL WATER STRESS RESPONSE FUNCTION, XWET = PSI(DEPTH) = FUNCTION (DRZ,NEXP,PSI3,DEPTH), WITH BISECTION METHOD FAILED TO IDENTIFY INITIAL GUESS (d1 and d2) THAT ARE ON BOTH SIDES OF THE ROOT. (viz. PSI(d1)*PSI(d2)>0).'//NL// &
!!!                                                                     'TO KEEP PROGRAM FROM STOPPING THE SOLUTION THE HEAD ELEVATION OF UPPER EXTINCTION OF TRANSPIRATION DUE TO ANOXIA IS ASSUMED TO BE THE GROUND SURFACE.'//NL// &
!!!                                                                     'THIS PROBLEM OCCURED FOR CROP '//NUM2STR(I)//NL//' LOCATED IN ROW, COL: '//NUM2STR(R)//', '//NUM2STR(C), INLINE=TRUE)
!!!                           XWET = DZ
!!!                       ELSEIF(XWET < DZ)  THEN
!!!                           XWET = DZ
!!!                       END IF
!!!                       !
!!!                  ENDIF
!!!                  !
!!!                  IF    (XWET < NEARZERO_12 ) THEN
!!!                                             UXX = GSE
!!!                  ELSEIF(XWET > CDAT%CROP(I)%ROOT(K) ) THEN
!!!                                             UXX = CDAT%CROP(I)%SS(K)
!!!                  ELSEIF(XWET > PSIWET) THEN
!!!                                             UXX = GSE - PSIWET
!!!                  ELSE
!!!                                             UXX = GSE - XWET
!!!                  END IF
!!!                  !
!!!                  IF    (HH >= UXX ) THEN  !HEAD ABOVE CROP ANOXIA LIMIT...PLANT HAS DROWNED!  --LATTER ADD CORRECTION FOR PLANTS THAT DROWNING LIKE RICE/WILLIOWS
!!!                         !
!!!                         TGWA = DZ
!!!                         TSURF = DZ
!!!                         !
!!!                  ELSEIF( CDAT%CROP(I)%LXX(K) >= HH ) THEN  !HEAD BELOW LOWER EXTINCTION DEPTH SO NO TGWA (LXX = GSE-ROOT-CAPILARY_FRINGE)
!!!                         !
!!!                         TGWA = DZ
!!!                         TSURF  = TPOT_ROOT * (UXX-CDAT%CROP(I)%SS(K))      !       Tgw-act < Tc-act = Tc-act-max = (TPOT/TRZ)*(UXX-SS) < Tc-pot
!!!                         !
!!!                  ELSE ! HAVE TO CALCULATE XDRY FOR FUTHER CHECKS.
!!!                         !
!!!                         IF(HAS_NONZERO_PSI) THEN
!!!                               !
!!!                               XDRY = RTFUNC(DRZ,PSI3_CM,NEXP,PSIDRY_CM) / CDAT%MLT
!!!                               !
!!!                               IF(XDRY.NE.XDRY) THEN
!!!                                   !WRITE(CDAT%LOUT,'(/A/,A/,6A)') 'FMP CROP WARNING. SOLVING ANALYITICAL WATER STRESS RESPONSE FUNCTION, XDRY = PSI(DEPTH) = FUNCTION (DRZ,NEXP,PSI3,DEPTH), WITH BISECTION METHOD FAILED TO IDENTIFY INITIAL GUESS (d1 and d2) THAT ARE ON BOTH SIDES OF THE ROOT. (viz. PSI(d1)*PSI(d2)>0).', &
!!!                                   !                               'TO KEEP PROGRAM FROM STOPPING THE SOLUTION THE HEAD ELEVATION OF ELIMINATION OF CROP-UNPRODUCTIVE WILTING ZONE IS ASSUMED TO BE THE AT THE BOTTOM OF THE ROOT ZONE.', &
!!!                                   !                               'THIS PROBLEM OCCURED FOR CROP ',NUM2STR(I),' LOCATED IN ROW, COL: ', NUM2STR(R), ', ', NUM2STR(C)
!!!                                   CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP: SOLVING ANALYITICAL WATER STRESS RESPONSE FUNCTION, XDRY = PSI(DEPTH) = FUNCTION (DRZ,NEXP,PSI3,DEPTH), WITH BISECTION METHOD FAILED TO IDENTIFY INITIAL GUESS (d1 and d2) THAT ARE ON BOTH SIDES OF THE ROOT. (viz. PSI(d1)*PSI(d2)>0).'//NL// &
!!!                                                                     'TO KEEP PROGRAM FROM STOPPING THE SOLUTION THE HEAD ELEVATION OF ELIMINATION OF CROP-UNPRODUCTIVE WILTING ZONE IS ASSUMED TO BE THE AT THE BOTTOM OF THE ROOT ZONE.'//NL// &
!!!                                                                     'THIS PROBLEM OCCURED FOR CROP '//NUM2STR(I)//NL//' LOCATED IN ROW, COL: '//NUM2STR(R)//', '//NUM2STR(C), INLINE=TRUE)
!!!                                   XDRY = CDAT%CROP(I)%ROOT(K)
!!!                               END IF
!!!                         ELSE
!!!                               XDRY = CDAT%CROP(I)%ROOT(K) !USING CONCEPT TWO BECAUSE ALL PSI ARE SET TO ZERO
!!!                         END IF
!!!                         !
!!!                         IF(XDRY >= CDAT%CROP(I)%ROOT(K)) THEN
!!!                             MXX = CDAT%CROP(I)%SS(K)
!!!                         ELSE
!!!                             MXX = GSE - XDRY      
!!!                         END IF
!!!                         !
!!!                         IF(MXX > UXX) MXX = UXX
!!!                         !
!!!                         IF(UXX  > HH .AND. HH > MXX) THEN
!!!                               !
!!!                               THI = TPOT_ROOT * UXX   !TGWA = THI - THD*H = (TPOT/ROOT)*(UXX - H)
!!!                               THD = TPOT_ROOT      
!!!                               !
!!!                               TGWA=THI-THD*HH                                           !TACT = Tgw-act < Tgw-act-max < Tc-pot (Tgw-act varies linearly)
!!!                               TSURF=DZ                                            !       Tgw-act = Tc-act
!!!                               !
!!!                         ELSEIF(MXX >= HH .AND. HH >= CDAT%CROP(I)%SS(K)) THEN
!!!                               !
!!!                               THI = TPOT_ROOT*(UXX-MXX)
!!!                               !
!!!                               TGWA = THI                                            !TACT = Tgw-act = Tgw-act-max < Tc-pot
!!!                               TSURF = TPOT_ROOT*(UXX- HH) - TGWA                     !       Tgw-act < Tc-act (Tc-act varies linearly)
!!!                               !
!!!                         ELSEIF(CDAT%CROP(I)%SS(K) > HH .AND. HH > CDAT%CROP(I)%LXX(K)) THEN
!!!                               !
!!!                               PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!!!                               !
!!!                               THI=     TPOT_ROOT * (UXX-MXX) * (UNO - CDAT%CROP(I)%SS(K)/PSIA)         !
!!!                               THD=DNEG*TPOT_ROOT * (UXX-MXX) / PSIA                                    !IF NONLINEAR: THI & THD SEPARATION COULD BE SKIPPED:
!!!                               !
!!!                               TGWA = THI-THD*HH                                                   !TACT = Tgw-act < Tgw-act-max < Tc-pot (Tgw-act varies linearly)        !TACT=TMAX*(1-SS/PSIA+HH/PSIA)**2
!!!                               TSURF = TPOT_ROOT * (UXX-CDAT%CROP(I)%SS(K)) - TGWA                            !       Tgw-act < Tc-act = Tc-act-max = (TPOT/TRZ)*(UXX-SS) < Tc-pot
!!!                               !
!!!                         ENDIF
!!!                  END IF
!!!                  !-------------------------------------------------------------------------------------------------------------------------------------------------------
!!!                  ! EVALUATE ADDITIONAL TRANSPIRATION FROM PLANTS THAT CAN TAKE DROWNING
!!!                  IF( CDAT%CROP(I)%PSI(ONE) > NEARZERO_12 .AND. CDAT%CROP(I)%PSI(TWO) >= DZ ) THEN
!!!                      !
!!!                      !
!!!                      PSI0 = CDAT%CROP(I)%PSI(ONE)
!!!                      PSI1 = CDAT%CROP(I)%PSI(TWO)
!!!                      !
!!!                      PSI0_PSI1 = PSI0-PSI1
!!!                      IF(PSI0_PSI1 < NEARZERO_12) PSI0_PSI1 = NEARZERO_12
!!!                      !
!!!                      !9E2----EVALUATE ACTUAL TRANSPIRATION (FULL UPTAKE) FROM THE SATURATED ROOT ZONE (TGWSAT1)
!!!                      IF( MAX(CDAT%CROP(I)%SS(K), HH-PSI1) > MIN(GSE, HH) ) THEN
!!!                                                      CONTINUE !TGWSAT1=DZ   --DO NOTHING
!!!                      ELSEIF(HH > GSE) THEN !, THD_SAT
!!!                                            IF(CDAT%CROP(I)%SS(K) >= HH-PSI1 )THEN
!!!                                                      THI_SAT = TPOT   ! = TGWSAT1 RHSS=RHSS+TGWSAT1
!!!                                                      !
!!!                                                      THI = THI_SAT
!!!                                                      !
!!!                                                      TGWA = THI  !THI_SAT
!!!                                            ELSE!IF(HH-PSI1 > CDAT%CROP(I)%SS(K))THEN
!!!                                                      THI_SAT = TPOT_ROOT*(GSE+PSI1)
!!!                                                      THD_SAT = TPOT_ROOT
!!!                                                      !                                                                   
!!!                                                      THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!!!                                                      THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!!!                                                      !
!!!                                                      TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH  
!!!                                            END IF
!!!                      ELSE!IF(GSE > HH) ==> HH < GSE
!!!                                            IF(CDAT%CROP(I)%SS(K) >= HH-PSI1)THEN
!!!                                                      THI_SAT = DNEG * TPOT_ROOT * CDAT%CROP(I)%SS(K)  !(TPOT/TRZ)*(TRZ-GSE))
!!!                                                      THD_SAT = DNEG * TPOT_ROOT
!!!                                                      !
!!!                                                      THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!!!                                                      THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!!!                                                      !
!!!                                                      TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH  
!!!                                            ELSE!IF(HH-PSI1 > CDAT%CROP(I)%SS(K))THEN
!!!                                                      THI_SAT = TPOT_ROOT*PSI1
!!!                                                      !
!!!                                                      THI = THI + THI_SAT
!!!                                                      !
!!!                                                      TGWA = THI - THD*HH  !TGWA + THI_SAT  !RHSS=RHSS+THISAT1
!!!                                            ENDIF
!!!                      END IF
!!!                      !
!!!                      !9E3----EVALUATE ACTUAL TRANSPIRATION (PARTIAL UPTAKE) FROM SATURATED ROOT ZONE (TGWSAT2)
!!!                      IF(MAX(HH-PSI0, CDAT%CROP(I)%SS(K)) > MIN(HH-PSI1, GSE) ) THEN
!!!                                                      CONTINUE !TGWSAT2=DZ   --DO NOTHING
!!!                      ELSEIF(GSE > HH-PSI1) THEN
!!!                                                 IF(HH-PSI0 >= CDAT%CROP(I)%SS(K))THEN
!!!                                                      THI_SAT = TPOT_ROOT * PSI0_PSI1 / DOS
!!!                                                      !
!!!                                                      THI = THI + THI_SAT                                    !RHSS=RHSS+THISAT1
!!!                                                      !
!!!                                                      TGWA = THI - THD*HH  !TGWA + THI_SAT  
!!!                                                 ELSE
!!!                                                      ALPHA= HALF + (PSI0-HH+CDAT%CROP(I)%SS(K))/(DOS*PSI0_PSI1)
!!!                                                      THI_SAT = DNEG*TPOT_ROOT*ALPHA*(CDAT%CROP(I)%SS(K)+PSI1)
!!!                                                      THD_SAT = DNEG*TPOT_ROOT*ALPHA
!!!                                                      !
!!!                                                      THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!!!                                                      THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!!!                                                      !
!!!                                                      TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH  
!!!                                                 ENDIF
!!!                      ELSE!IF(HH-PSI1 > GSE) THEN
!!!                                                 IF(HH-PSI0 > CDAT%CROP(I)%SS(K)) THEN
!!!                                                      ALPHA=(GSE-HH+PSI0) / (DOS*PSI0_PSI1)
!!!                                                      THI_SAT = TPOT_ROOT*ALPHA*(GSE+PSI0)
!!!                                                      THD_SAT = TPOT_ROOT*ALPHA
!!!                                                      !
!!!                                                      THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!!!                                                      THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!!!                                                      !
!!!                                                      TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH    !TGWSAT2=THISAT2-THDSAT2*HH
!!!                                                 ELSE
!!!                                                      !THI_SAT = TPOT_ROOT * (DOS*PSI0 - CDAT%CROP(I)%ROOT(K)) / (DOS * PSI0_PSI1)  !GSE+SS = -ROOT   --SS = GSE - ROOT  fixed summation
!!!                                                      !THD_SAT = TPOT_ROOT / PSI0_PSI1
!!!                                                      THI_SAT = (DOS*PSI0 + GSE + CDAT%CROP(I)%SS(K)) * TPOT / (DOS * PSI0_PSI1)
!!!                                                      THD_SAT = TPOT / PSI0_PSI1
!!!                                                      !
!!!                                                      THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!!!                                                      THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!!!                                                      !
!!!                                                      TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH     !TGWSAT2=THISAT2-THDSAT2*HH
!!!                                                 END IF
!!!                      END IF
!!!                  END IF
!!!                  !
!!!              ELSEIF( HAS_TRANSPIRATION .AND. .NOT. HAS_NONZERO_PSI) THEN  !SOLVE WITH CONCEPT 2  --CODE IDENTICAL TOO "SUBROUTINE CONCEPT_TWO_TGW(CDAT, WBS, SOIL)"
!!!                  !
!!!                  HH  = CDAT%RELAX*(HNEW(C,R,L) - HNEW_OLD(C,R,L)) + HNEW_OLD(C,R,L)   !HNEW = HOLD + FRAC*(HNEW-HOLD)
!!!                  GSE = CDAT%CROP(I)%GSE(K)
!!!                  !
!!!                  IF(CDAT%HAS_POND) THEN
!!!                      GSE_POND = GSE                  + CDAT%CROP(I)%POND(K)
!!!                      ROOT_POND= CDAT%CROP(I)%ROOT(K) + CDAT%CROP(I)%POND(K)
!!!                  ELSE
!!!                      GSE_POND = GSE
!!!                      ROOT_POND= CDAT%CROP(I)%ROOT(K)
!!!                  END IF
!!!                  !
!!!                  IF    (HH >= GSE_POND) THEN  !HEAD ABOVE CROP ANOXIA LIMIT...PLANT HAS DROWNED!   --POND=0 WHEN NOT SPECIFIED
!!!                         !
!!!                         TGWA = DZ
!!!                         TSURF  = DZ
!!!                         !
!!!                  ELSEIF(HH >= CDAT%CROP(I)%SS(K) ) THEN
!!!                         !
!!!                         THI = TPOT * GSE_POND / ROOT_POND
!!!                         THD = TPOT / ROOT_POND
!!!                         !
!!!                         TGWA = THI-THD*HH 
!!!                         TSURF  = DZ
!!!                         !
!!!                  ELSEIF(HH <= CDAT%CROP(I)%LXX(K) ) THEN  !HEAD BELOW LOWER EXTINCTION DEPTH SO NO TGWA (LXX = GSE-ROOT-CAPILARY_FRINGE)
!!!                         !
!!!                         TGWA = DZ
!!!                         TSURF  = TPOT
!!!                         !
!!!                  ELSE
!!!                         PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!!!                         !
!!!                         THI =      TPOT * (UNO - CDAT%CROP(I)%SS(K)/PSIA)
!!!                         THD = DNEG*TPOT / PSIA
!!!                         !
!!!                         TGWA = THI-THD*HH 
!!!                         TSURF  = TPOT - TGWA
!!!                  END IF
!!!              END IF  T_CALC
!!!              !
!!!              !########################################################################################
!!!              !
!!!              IF(HAS_TRANSPIRATION .AND. CDAT%CROP(I)%GW_INTER(K) == ONE) THEN !NO GROUNDWATER UPTAKE
!!!                                                 TSURF = TSURF + TGWA
!!!                                                 TGWA  = DZ
!!!                                                 THI   = DZ
!!!                                                 THD   = DZ
!!!              END IF
!!!              !
!!!              IF(HAS_TRANSPIRATION) THEN
!!!                  !
!!!                  IF(TSURF > TPOT) TSURF = TPOT
!!!                  IF(TGWA  > TPOT) TGWA  = TPOT
!!!                  IF(TSURF + TGWA > TPOT) THEN
!!!                      IF(TSURF + TGWA > DZ) THEN
!!!                          ALPHA = TPOT / (TSURF + TGWA)
!!!                          TSURF = TSURF * ALPHA
!!!                          TGWA  = TGWA  * ALPHA
!!!                      END IF
!!!                  END IF
!!!                  !
!!!                  !
!!!                  CDAT%CROP(I)%THI(K) = THI
!!!                  CDAT%CROP(I)%THD(K) = THD
!!!                  !
!!!                  !
!!!                  CDAT%CROP(I)%TGWA(K)        = TGWA
!!!                  CDAT%CROP(I)%TSURF(K)       = TSURF
!!!                  CDAT%CROP(I)%ANOXIA_LOSS(K) = TPOT - TSURF - TGWA
!!!                  !
!!!                  IF(CDAT%CROP(I)%ANOXIA_LOSS(K) < NEARZERO_12) CDAT%CROP(I)%ANOXIA_LOSS(K) = DZ
!!!                  !
!!!                  IF( CDAT%CROP(I)%IRR(K) > Z .AND. CDAT%CROP(I)%TPPOT(K) < TSURF) THEN
!!!                      !
!!!                      CDAT%CROP(I)%TI(K) = TSURF - CDAT%CROP(I)%TPPOT(K)
!!!                      CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
!!!              IF(TSURF - CDAT%CROP(I)%TPPOT(K)<DZ) THEN
!!!                  UXX=CDAT%CROP(I)%TPPOT(K)
!!!                  PAUSE
!!!              END IF
!!!                      !
!!!                  ELSEIF(TSURF < CDAT%CROP(I)%TPPOT(K) ) THEN
!!!                      CDAT%CROP(I)%TI(K) = DZ
!!!                      CDAT%CROP(I)%TP(K) = TSURF
!!!                  ELSE
!!!                      CDAT%CROP(I)%TI(K) = DZ
!!!                      CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
!!!                  END IF
!!!              ELSE
!!!                  CDAT%CROP(I)%THI(K)   = DZ
!!!                  CDAT%CROP(I)%THD(K)   = DZ
!!!                  CDAT%CROP(I)%TGWA(K)  = DZ
!!!                  CDAT%CROP(I)%TSURF(K) = DZ
!!!                  CDAT%CROP(I)%TI(K)    = DZ
!!!                  CDAT%CROP(I)%TP(K)    = DZ
!!!                  CDAT%CROP(I)%ANOXIA_LOSS(K) = DZ
!!!              END IF
!!!              !
!!!              CDAT%CROP(I)%UXX(K) = UXX 
!!!              CDAT%CROP(I)%MXX(K) = MXX 
!!!              !
!!!          END DO
!!!    END DO
!!!    !
!!!  END SUBROUTINE
  !
!  SUBROUTINE CONCEPT_TWO_TGW(CDAT, WBS, SOIL)
!    !
!    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
!    TYPE(  WBS_DATA), INTENT(IN   ):: WBS
!    TYPE( SOIL_DATA), INTENT(IN   ):: SOIL
!    !
!    INTEGER:: I, K, R, C, L
!    DOUBLE PRECISION:: HH, GSE, PSIA, TPOT, TSURF, TGWA, ROOT_POND, GSE_POND, ALPHA
!    DOUBLE PRECISION:: THI, THD
!    LOGICAL:: HAS_TRANSPIRATION, HAS_TSURF
!    !
!    DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z )
!          !
!          DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
!              !
!              R = CDAT%CROP(I)%RC(ONE,K)
!              C = CDAT%CROP(I)%RC(TWO,K)
!              L = UPLAY(C,R)
!              !
!              THI = DZ
!              THD = DZ
!              TSURF = DZ
!              TPOT = CDAT%CROP(I)%TGW(K)
!              TGWA = DZ
!              !
!              HAS_TRANSPIRATION = TPOT > NEARZERO_12 .AND. CDAT%CROP(I)%NOT_FALLOW(K) .AND. L > Z
!              !
!      T_CALC: IF(CDAT%CROP(I)%GW_INTER(K) == Z .AND. HAS_TRANSPIRATION) THEN  ! NO ROOT-GROUNDWATER INTERACTION -----
!                  !
!                  TSURF = TPOT
!                  !
!      ELSEIF(HAS_TRANSPIRATION) THEN  ! L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
!                  !
!                  !HO  = HNEW_OLD(C,R,L)
!                  !HH  = HNEW(C,R,L)
!                  !DEL = HNEW(C,R,L) - HO
!                  !HH  = HO + 0.9D0*(HNEW(C,R,L) - HO)
!                  HH  = HNEW(C,R,L) !CDAT%RELAX*(HNEW(C,R,L) - HNEW_OLD(C,R,L)) + HNEW_OLD(C,R,L)   !HNEW = HOLD + FRAC*(HNEW-HOLD)
!                  !
!                  GSE = CDAT%CROP(I)%GSE(K)
!                  !
!                  IF(CDAT%HAS_POND) THEN
!                      GSE_POND = GSE                  + CDAT%CROP(I)%POND(K)
!                      ROOT_POND= CDAT%CROP(I)%ROOT(K) + CDAT%CROP(I)%POND(K)
!                  ELSE
!                      GSE_POND = GSE
!                      ROOT_POND= CDAT%CROP(I)%ROOT(K)
!                  END IF
!                  !
!                  IF    (HH >= GSE_POND) THEN  !HEAD ABOVE CROP ANOXIA LIMIT...PLANT HAS DROWNED!   --POND=0 WHEN NOT SPECIFIED
!                         !
!                         TGWA = DZ
!                         !TSURF  = DZ
!                         HAS_TSURF = FALSE
!                         !
!                  ELSEIF(HH >= CDAT%CROP(I)%SS(K) ) THEN
!                         !
!                         THI = TPOT * GSE_POND / ROOT_POND
!                         THD = TPOT / ROOT_POND
!                         !
!                         TGWA = THI-THD*HH 
!                         !TSURF  = DZ
!                         HAS_TSURF = FALSE
!                         !
!                  ELSEIF(HH <= CDAT%CROP(I)%LXX(K) ) THEN  !HEAD BELOW LOWER EXTINCTION DEPTH SO NO TGWA (LXX = GSE-ROOT-CAPILARY_FRINGE)
!                         !
!                         TGWA = DZ
!                         !TSURF  = TPOT
!                         HAS_TSURF = TRUE
!                         !
!                  ELSE
!                         PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!                         !
!                         THI = TPOT - (TPOT*CDAT%CROP(I)%SS(K)/PSIA) !TPOT * (UNO - CDAT%CROP(I)%SS(K)/PSIA)
!                         THD = DNEG*TPOT / PSIA
!                         !
!                         TGWA = THI-THD*HH 
!                         !TSURF  = TPOT - TGWA
!                         HAS_TSURF = TRUE
!                  END IF
!                  !
!                  IF(CDAT%CROP(I)%GW_INTER(K) == ONE) THEN !NO GROUNDWATER UPTAKE
!                                                     TSURF = TSURF + TGWA
!                                                     TGWA = DZ
!                                                     THI                  = DZ
!                                                     THD                  = DZ
!                  END IF
!              END IF T_CALC !--------------------------------------------------------------------------
!              !
!              IF(HAS_TRANSPIRATION) THEN
!                  !
!                  !IF(TSURF > TPOT) TSURF = TPOT
!                  !IF(TGWA  > TPOT) TGWA  = TPOT
!                  !IF(TSURF + TGWA > TPOT) THEN
!                  !    IF(TSURF + TGWA > DZ) THEN
!                  !        ALPHA = TPOT / (TSURF + TGWA)
!                  !        TSURF = TSURF * ALPHA
!                  !        TGWA  = TGWA  * ALPHA
!                  !    END IF
!                  !END IF
!                  !
!                  CDAT%CROP(I)%THI(K) = RELAXER(THI, CDAT%CROP(I)%THI(K), CDAT%RELAX) ! THI
!                  CDAT%CROP(I)%THD(K) = RELAXER(THD, CDAT%CROP(I)%THD(K), CDAT%RELAX) ! THD
!                  !
!                  CDAT%CROP(I)%TGWA(K)        = RELAXER(TGWA, CDAT%CROP(I)%TGWA(K), CDAT%RELAX) !TGWA
!                  TGWA = CDAT%CROP(I)%TGWA(K)
!                  IF(HAS_TSURF) THEN
!                                    TSURF = TPOT - CDAT%CROP(I)%TGWA(K)
!                  ELSE
!                                    TSURF = DZ
!                  END IF
!                  CDAT%CROP(I)%TSURF(K) = TSURF
!                  !
!                  CDAT%CROP(I)%ANOXIA_LOSS(K) = TPOT - TSURF - TGWA
!                  !
!                  IF(CDAT%CROP(I)%ANOXIA_LOSS(K) < NEARZERO_12) CDAT%CROP(I)%ANOXIA_LOSS(K) = DZ
!                  !
!                  IF( CDAT%CROP(I)%IRR(K) > Z .AND. CDAT%CROP(I)%TPPOT(K) < TSURF ) THEN
!                      !
!                      CDAT%CROP(I)%TI(K) = TSURF - CDAT%CROP(I)%TPPOT(K)
!                      CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
!                      !
!                  ELSEIF(TSURF < CDAT%CROP(I)%TPPOT(K) ) THEN
!                      CDAT%CROP(I)%TI(K) = DZ
!                      CDAT%CROP(I)%TP(K) = TSURF
!                  ELSE
!                      CDAT%CROP(I)%TI(K) = DZ
!                      CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
!                  END IF
!              ELSE
!                  CDAT%CROP(I)%THI(K)   = DZ
!                  CDAT%CROP(I)%THD(K)   = DZ
!                  CDAT%CROP(I)%TGWA(K)  = DZ
!                  CDAT%CROP(I)%TSURF(K) = DZ
!                  CDAT%CROP(I)%TI(K)    = DZ
!                  CDAT%CROP(I)%TP(K)    = DZ
!                  CDAT%CROP(I)%ANOXIA_LOSS(K) = DZ
!              END IF
!          END DO
!    END DO
!    !
!    END SUBROUTINE
  !
!  SUBROUTINE CONCEPT_TWO_TGW(CDAT, WBS, SOIL)
!    !
!    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
!    TYPE(  WBS_DATA), INTENT(IN   ):: WBS
!    TYPE( SOIL_DATA), INTENT(IN   ):: SOIL
!    !
!    INTEGER:: I, K, R, C, L
!    DOUBLE PRECISION:: HH, GSE, PSIA, TPOT, TSURF, TGWA, ROOT_POND, GSE_POND, ALPHA
!    DOUBLE PRECISION:: THI, THD
!    LOGICAL:: HAS_TRANSPIRATION 
!    !
!    DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z )
!          !
!          DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
!              !
!              R = CDAT%CROP(I)%RC(ONE,K)
!              C = CDAT%CROP(I)%RC(TWO,K)
!              L = UPLAY(C,R)
!              !
!              THI = DZ
!              THD = DZ
!              TSURF = DZ
!              TPOT = CDAT%CROP(I)%TGW(K)
!              TGWA = DZ
!              !
!              HAS_TRANSPIRATION = TPOT > NEARZERO_12 .AND. CDAT%CROP(I)%NOT_FALLOW(K) .AND. L > Z
!              !
!      T_CALC: IF(CDAT%CROP(I)%GW_INTER(K) == Z .AND. HAS_TRANSPIRATION) THEN  ! NO ROOT-GROUNDWATER INTERACTION -----
!                  !
!                  TSURF = TPOT
!                  !
!      ELSEIF(HAS_TRANSPIRATION) THEN  ! L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
!                  !
!                  !HO  = HNEW_OLD(C,R,L)
!                  !HH  = HNEW(C,R,L)
!                  !DEL = HNEW(C,R,L) - HO
!                  !HH  = HO + 0.9D0*(HNEW(C,R,L) - HO)
!                  HH  = RELAXER(HNEW(C,R,L), HNEW_OLD(C,R,L), CDAT%RELAX) !CDAT%RELAX*(HNEW(C,R,L) - HNEW_OLD(C,R,L)) + HNEW_OLD(C,R,L)   !HNEW = HOLD + FRAC*(HNEW-HOLD)
!                  !
!                  GSE = CDAT%CROP(I)%GSE(K)
!                  !
!                  IF(CDAT%HAS_POND) THEN
!                      GSE_POND = GSE                  + CDAT%CROP(I)%POND(K)
!                      ROOT_POND= CDAT%CROP(I)%ROOT(K) + CDAT%CROP(I)%POND(K)
!                  ELSE
!                      GSE_POND = GSE
!                      ROOT_POND= CDAT%CROP(I)%ROOT(K)
!                  END IF
!                  !
!                  IF    (HH >= GSE_POND) THEN  !HEAD ABOVE CROP ANOXIA LIMIT...PLANT HAS DROWNED!   --POND=0 WHEN NOT SPECIFIED
!                         !
!                         TGWA = DZ
!                         TSURF  = DZ
!                         !
!                  ELSEIF(HH >= CDAT%CROP(I)%SS(K) ) THEN
!                         !
!                         THI = TPOT * GSE_POND / ROOT_POND
!                         THD = TPOT / ROOT_POND
!                         !
!                         TGWA = THI-THD*HH 
!                         TSURF  = DZ
!                         !
!                  ELSEIF(HH <= CDAT%CROP(I)%LXX(K) ) THEN  !HEAD BELOW LOWER EXTINCTION DEPTH SO NO TGWA (LXX = GSE-ROOT-CAPILARY_FRINGE)
!                         !
!                         TGWA = DZ
!                         TSURF  = TPOT
!                         !
!                  ELSE
!                         PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!                         !
!                         THI = TPOT - (TPOT*CDAT%CROP(I)%SS(K)/PSIA) !TPOT * (UNO - CDAT%CROP(I)%SS(K)/PSIA)
!                         THD = DNEG*TPOT / PSIA
!                         !
!                         TGWA = THI-THD*HH 
!                         TSURF  = TPOT - TGWA
!                  END IF
!                  !
!                  IF(CDAT%CROP(I)%GW_INTER(K) == ONE) THEN !NO GROUNDWATER UPTAKE
!                                                     TSURF = TSURF + TGWA
!                                                     TGWA = DZ
!                                                     THI                  = DZ
!                                                     THD                  = DZ
!                  END IF
!              END IF T_CALC !--------------------------------------------------------------------------
!              !
!              IF(HAS_TRANSPIRATION) THEN
!                  !
!                  IF(TSURF > TPOT) TSURF = TPOT
!                  IF(TGWA  > TPOT) TGWA  = TPOT
!                  IF(TSURF + TGWA > TPOT) THEN
!                      IF(TSURF + TGWA > DZ) THEN
!                          ALPHA = TPOT / (TSURF + TGWA)
!                          TSURF = TSURF * ALPHA
!                          TGWA  = TGWA  * ALPHA
!                      END IF
!                  END IF
!                  !
!                  CDAT%CROP(I)%THI(K) = THI
!                  CDAT%CROP(I)%THD(K) = THD
!                  !
!                  CDAT%CROP(I)%TGWA(K)        = TGWA
!                  CDAT%CROP(I)%TSURF(K)       = TSURF
!                  CDAT%CROP(I)%ANOXIA_LOSS(K) = TPOT - TSURF - TGWA
!                  !
!                  IF(CDAT%CROP(I)%ANOXIA_LOSS(K) < NEARZERO_12) CDAT%CROP(I)%ANOXIA_LOSS(K) = DZ
!                  !
!                  IF( CDAT%CROP(I)%IRR(K) > Z .AND. CDAT%CROP(I)%TPPOT(K) < TSURF ) THEN
!                      !
!                      CDAT%CROP(I)%TI(K) = TSURF - CDAT%CROP(I)%TPPOT(K)
!                      CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
!                      !
!                  ELSEIF(TSURF < CDAT%CROP(I)%TPPOT(K) ) THEN
!                      CDAT%CROP(I)%TI(K) = DZ
!                      CDAT%CROP(I)%TP(K) = TSURF
!                  ELSE
!                      CDAT%CROP(I)%TI(K) = DZ
!                      CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
!                  END IF
!              ELSE
!                  CDAT%CROP(I)%THI(K)   = DZ
!                  CDAT%CROP(I)%THD(K)   = DZ
!                  CDAT%CROP(I)%TGWA(K)  = DZ
!                  CDAT%CROP(I)%TSURF(K) = DZ
!                  CDAT%CROP(I)%TI(K)    = DZ
!                  CDAT%CROP(I)%TP(K)    = DZ
!                  CDAT%CROP(I)%ANOXIA_LOSS(K) = DZ
!              END IF
!          END DO
!    END DO
!    !
!    END SUBROUTINE
    !
  PURE SUBROUTINE CALC_CIR_DEMAND(CDAT)   !WRAPPER TO CALL NEXT SUBROUTINE
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    !
    IF(CDAT%NCROP>Z) CALL CALC_CIR_DEMAND_BY_CROP(CDAT%CROP)
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE CALC_CIR_DEMAND_BY_CROP(CROP)
    CLASS(CROP_PROP), INTENT(INOUT):: CROP
    INTEGER:: K, ID
    !
    ID = CROP%ID
    DO CONCURRENT ( K=ONE:CROP%N )
        !
        !   PRECIP DOES NOT SATISFY NEEDS     NOT FALLOWED CROP         IRRIGATED CROP       
        IF( CROP%TI(K) > NEARZERO_12 ) THEN ! CROP%NOT_FALLOW(K) .AND. CROP%IRR(K) > Z .AND. 
            !
            CROP%CIR(K)    = CROP%TI(K) * (UNO + CROP%CECT(K))  !TI = TSUR-TP ==> (TSUR-TP)*(1+ FEI/FTR) --NOTE THAT IF FTR=0 THEN TGW = 0, SO TSUR =0 WHICH IS < TPPOT SO CONDITION FAILS
            CROP%DEMAND(K) = CROP%CIR(K) / CROP%EFF(K)
        ELSE
            CROP%TI(K)     = DZ
            CROP%CIR(K)    = DZ
            CROP%DEMAND(K) = DZ
        END IF
    END DO
    !
    IF(CROP%N > Z) CROP%CIR_INI = CROP%CIR
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE INIT_EXTERNAL_DEMAND(CDAT)
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    INTEGER:: I, K
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP    )
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)
          IF( CDAT%CROP(I)%IRR(K) > Z .AND. CDAT%CROP(I)%ADMD(K) > NEARZERO_12 ) THEN
                                      CDAT%CROP(I)%DEMAND_EXT(K) = CDAT%CROP(I)%ADMD(K) / CDAT%CROP(I)%EFF(K)
          ELSE
              CDAT%CROP(I)%DEMAND_EXT(K) = DZ
          END IF
    END DO; END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ADD_EXTERNAL_DEMAND(CDAT,DMD,I,K,F,USE_AREA)
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    DOUBLE PRECISION, INTENT(IN):: DMD
    INTEGER,          INTENT(IN):: I,K,F  !SET TO ZERO TO NOT USE
    LOGICAL,          INTENT(IN):: USE_AREA
    INTEGER:: J,KK
    DOUBLE PRECISION:: AREA
    !
    CDAT%HAS_DEMAND_EXT = TRUE
    AREA = UNO
    J=NEG
    KK=NEG
    !
    IF(F>Z) THEN !SEARCH BY FARM
        !
        IF(I<ONE .AND. K<ONE) THEN  !ALL CROP IN FARM F
            DO CONCURRENT (J=ONE:CDAT%NCROP)
            DO CONCURRENT (KK=ONE:CDAT%CROP(J)%N, CDAT%CROP(J)%FID(KK) == F .AND. CDAT%CROP(J)%IRR(KK) > Z )
                                              IF(USE_AREA) AREA = CDAT%CROP(J)%AREA(KK)
                                              CDAT%CROP(J)%DEMAND_EXT(KK) = CDAT%CROP(J)%DEMAND_EXT(KK) + DMD*AREA/CDAT%CROP(J)%EFF(KK)
            END DO; END DO
        ELSEIF(I>Z .AND. K<ONE) THEN !ALL CROP I IN FARM F
            DO CONCURRENT ( KK=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FID(KK) == F .AND. CDAT%CROP(I)%IRR(KK) > Z )
                                              IF(USE_AREA) AREA = CDAT%CROP(I)%AREA(KK)
                                              CDAT%CROP(I)%DEMAND_EXT(KK) = CDAT%CROP(I)%DEMAND_EXT(KK) + DMD*AREA/CDAT%CROP(I)%EFF(KK)
            END DO
        ELSEIF(I<ONE .AND. K>Z) THEN !ALL CROP IN FARM F AT Kth POSITION
            DO CONCURRENT ( J=ONE:CDAT%NCROP, CDAT%CROP(J)%FID(KK) == F .AND. CDAT%CROP(J)%IRR(KK) > Z )
                                              IF(USE_AREA) AREA = CDAT%CROP(J)%AREA(KK)
                                              CDAT%CROP(J)%DEMAND_EXT(KK) = CDAT%CROP(J)%DEMAND_EXT(KK) + DMD*AREA/CDAT%CROP(J)%EFF(KK)
            END DO
        ELSEIF(CDAT%CROP(I)%FID(K) == F .AND. CDAT%CROP(I)%IRR(K) > Z) THEN
            IF(USE_AREA) AREA = CDAT%CROP(I)%AREA(K)
            CDAT%CROP(I)%DEMAND_EXT(K) = CDAT%CROP(I)%DEMAND_EXT(K) + DMD*AREA/CDAT%CROP(I)%EFF(K)
        END IF
        !
    ELSEIF(K>Z) THEN  !SEARCH BY Kth POSITION
        !
        IF(I>Z) THEN  !SPECIFY I AND K
            IF(USE_AREA) AREA = CDAT%CROP(I)%AREA(K)
            IF(CDAT%CROP(I)%IRR(K) > Z) CDAT%CROP(I)%DEMAND_EXT(K) = CDAT%CROP(I)%DEMAND_EXT(K) + DMD*AREA/CDAT%CROP(I)%EFF(K)
        ELSE          !SPECIFY K ONLY
            DO CONCURRENT ( J=ONE:CDAT%NCROP, CDAT%CROP(J)%IRR(K) > Z)
                                              IF(USE_AREA) AREA = CDAT%CROP(J)%AREA(K)
                                              CDAT%CROP(J)%DEMAND_EXT(K) = CDAT%CROP(J)%DEMAND_EXT(K) + DMD*AREA/CDAT%CROP(J)%EFF(K)
            END DO
        END IF
        !
    ELSEIF(I>Z) THEN !SEARCH BY CROP
            DO CONCURRENT ( KK=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%IRR(KK) > Z)
                                              IF(USE_AREA) AREA = CDAT%CROP(I)%AREA(KK)
                                              CDAT%CROP(I)%DEMAND_EXT(KK) = CDAT%CROP(I)%DEMAND_EXT(KK) + DMD*AREA/CDAT%CROP(I)%EFF(KK)
            END DO
    ELSE !ALL ZERO
            DO CONCURRENT (J=ONE:CDAT%NCROP)
            DO CONCURRENT (KK=ONE:CDAT%CROP(J)%N, CDAT%CROP(J)%IRR(KK) > Z)
                                              IF(USE_AREA) AREA = CDAT%CROP(J)%AREA(KK)
                                              CDAT%CROP(J)%DEMAND_EXT(KK) = CDAT%CROP(J)%DEMAND_EXT(KK) + DMD*AREA/CDAT%CROP(J)%EFF(KK)
            END DO; END DO
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE SET_WBS_ADDED_DEMAND(CDAT,WBS)
    !
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),   INTENT(IN   ):: WBS
    INTEGER:: I, K, F
    !
    IF(WBS%HAS_CROP_FLUX) THEN
        DO CONCURRENT (I=ONE:CDAT%NCROP,     WBS%CRP_HAS_ADMD(I)    )
        DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%IRR(K) > Z)
              !
              F = CDAT%CROP(I)%FID(K)
              IF(WBS%WBS_HAS_ADMD(F)) CALL ADD_EXTERNAL_DEMAND(CDAT,WBS%CROP_FLUX(F,I),I,K,F,TRUE)
              !
        END DO; END DO
    END IF
    !
    IF(WBS%HAS_CROP_VOLR) THEN
        DO CONCURRENT (I=ONE:CDAT%NCROP,     WBS%CRP_HAS_ADMD(I)    )
        DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%IRR(K) > Z)
              !
              F = CDAT%CROP(I)%FID(K)
              IF(WBS%WBS_HAS_ADMD(F)) CALL ADD_EXTERNAL_DEMAND(CDAT,WBS%CROP_VOLR(F,I),I,K,F,FALSE)
              !
        END DO; END DO
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE CHECK_WBS_ADDED_DEMAND(CDAT,WBS)
    !
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),   INTENT(IN   ):: WBS
    INTEGER:: I, J, K, F, R, C
    CHARACTER(:),ALLOCATABLE:: WARN
    !
    WARN=NL
    !
    IF(WBS%HAS_CROP_FLUX) THEN
        DO CONCURRENT (F=ONE:WBS%NFARM, WBS%WBS_HAS_ADMD(F) )
        DO CONCURRENT (J=ONE:WBS%CROP(F)%N)
                                                I=WBS%CROP(F)%PNT(ONE,J)
                                                K=WBS%CROP(F)%PNT(TWO,J)
                                                IF(WBS%CROP_FLUX(F,I) .NE. DZ .AND. CDAT%CROP(I)%IRR(K) == Z) THEN
                                                IF(LEN(WARN) < THOU30) THEN
                                                       R = WBS%CROP(F)%PNT(THREE,J)
                                                       C = WBS%CROP(F)%PNT(FOUR, J)
                                                       WARN=WARN//BLNK//NUM2STR(F,-8)//BLNK//NUM2STR(I,-8)//BLNK//NUM2STR(R,-8)//BLNK//NUM2STR(C,-8)//BLNK//NUM2STR(WBS%CROP_FLUX(F,I))//NL
                                                END IF
                                                END IF
        END DO; END DO
          IF (WARN.NE.NL) THEN
                   WARN='FMP WBS AND CROP -- CHECK FOR VALID "ADDED_CROP_DEMAND LENGTH" HAD CROPS WITH DEMANDS THAT DO NOT HAVE AN IRRIGATION TYPE'//NL//'SPECIFICALLY IT HAD "IRRIGATION=0" SO NO WAY TO SATISFY THE ADDITIONAL CROP DEMAND.'//NL// &
                         'THE FOLLOWING FARMS/CROPS WILL NEVER MEET THEIR ADDIONTIONAL DEMANDS BECAUSE IT HAS IRRIGATION=0'//BLN// &
                         '*** NOTE THIS IS JUST A WARNING IN CASE YOU MEANT TO HAVE ADDITIONAL IRRIGATION ***'//BLN// &
                         '  WBS CROP_ID      ROW      COLUMN   ADDED_DEMAND_LENGTH'//WARN
                         !
                   IF(LEN(WARN) >= THOU30) WARN=WARN//NL//'   ***Note that warning message was truncated do to excessive length***'//NL
                   !
                   CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG=WARN)
                   WARN = NL
          END IF
    END IF
    !
    IF(WBS%HAS_CROP_VOLR) THEN
        DO CONCURRENT (F=ONE:WBS%NFARM, WBS%WBS_HAS_ADMD(F) )
        DO CONCURRENT (J=ONE:WBS%CROP(F)%N)
                                                I=WBS%CROP(F)%PNT(ONE,J)
                                                K=WBS%CROP(F)%PNT(TWO,J)
                                                IF(WBS%CROP_VOLR(F,I) .NE. DZ .AND. CDAT%CROP(I)%IRR(K) == Z) THEN
                                                IF(LEN(WARN) < THOU30) THEN
                                                       R = WBS%CROP(F)%PNT(THREE,J)
                                                       C = WBS%CROP(F)%PNT(FOUR, J)
                                                       WARN=WARN//BLNK//NUM2STR(F,-8)//BLNK//NUM2STR(I,-8)//BLNK//NUM2STR(R,-8)//BLNK//NUM2STR(C,-8)//BLNK//NUM2STR(WBS%CROP_FLUX(F,I))//NL
                                                END IF
                                                END IF
        END DO; END DO
        IF (WARN.NE.NL) THEN
                 WARN='FMP WBS AND CROP -- CHECK FOR VALID "ADDED_CROP_DEMAND RATE" HAD CROPS WITH DEMANDS THAT DO NOT HAVE AN IRRIGATION TYPE'//NL//'SPECIFICALLY IT HAD "IRRIGATION=0" SO NO WAY TO SATISFY THE ADDITIONAL CROP DEMAND.'//NL// &
                       'THE FOLLOWING FARMS/CROPS WILL NEVER MEET THEIR ADDIONTIONAL DEMANDS BECAUSE IT HAS IRRIGATION=0'//BLN// &
                       '*** NOTE THIS IS JUST A WARNING IN CASE YOU MEANT TO HAVE ADDITIONAL IRRIGATION ***'//BLN// &
                       '  WBS CROP_ID      ROW      COLUMN   ADDED_DEMAND_RATE'//WARN
                       !
                 IF(LEN(WARN) >= THOU30) WARN=WARN//NL//'   ***Note that warning message was truncated do to excessive length***'//NL
                 !
                 CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG=WARN)
                 WARN = NL
        END IF
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_EXTERNAL_DEMAND_INI(CDAT)
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    INTEGER:: I
    !
    DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z )
                                      CDAT%CROP(I)%DEMAND_EXT_INI = CDAT%CROP(I)%DEMAND_EXT
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE NOT_FALLOW_RESET(CDAT)
    !
    CLASS(CROP_DATA),                             INTENT(INOUT):: CDAT
    INTEGER:: I
    !
    DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N>Z ) 
                                                        CDAT%CROP(I)%NOT_FALLOW    = CDAT%CROP(I)%NOT_FALLOW_SP
    END DO
  END SUBROUTINE
  !
  PURE SUBROUTINE ADD_CROP_DEMAND_TO_ARRAY(CDAT, DIM1, DIM2, ARRAY)
    !
    CLASS(CROP_DATA),                       INTENT(IN ):: CDAT
    INTEGER,                                INTENT(IN):: DIM1,DIM2
    DOUBLE PRECISION, DIMENSION(DIM1,DIM2), INTENT(OUT):: ARRAY
    INTEGER:: I, K
    !
    DO CONCURRENT(I=1:DIM1,K=1:DIM2)
                                   ARRAY(I,K) = DZ
    END DO
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP)
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%DEMAND(K) > DZ)
          !
          ARRAY( CDAT%CROP(I)%RC(TWO,K), CDAT%CROP(I)%RC(ONE,K) ) = ARRAY( CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K) ) + CDAT%CROP(I)%DEMAND(K)
          !
    END DO; END DO
    !
    IF(CDAT%HAS_DEMAND_EXT) THEN
          DO CONCURRENT (I=ONE:CDAT%NCROP)
          DO CONCURRENT (K=ONE:CDAT%CROP(I)%N,   CDAT%CROP(I)%DEMAND_EXT(K) < NEGNEARZERO_30 .OR. CDAT%CROP(I)%DEMAND_EXT(K) > NEARZERO_30 )
                !
                ARRAY( CDAT%CROP(I)%RC(TWO,K), CDAT%CROP(I)%RC(ONE,K) ) = ARRAY( CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K) ) + CDAT%CROP(I)%DEMAND_EXT(K)
                !
          END DO; END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ADD_CROP_ADDED_DEMAND_BYWBS(CDAT, DIM, VEC)
    !
    CLASS(CROP_DATA),                 INTENT(IN   ):: CDAT
    INTEGER,                          INTENT(IN   ):: DIM
    DOUBLE PRECISION, DIMENSION(DIM), INTENT(INOUT):: VEC
    INTEGER:: I, K
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP)
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N,   CDAT%CROP(I)%DEMAND_EXT(K) < NEGNEARZERO_30 .OR. CDAT%CROP(I)%DEMAND_EXT(K) > NEARZERO_30 )
          !
          VEC( CDAT%CROP(I)%FID(K) ) = VEC( CDAT%CROP(I)%FID(K) ) + CDAT%CROP(I)%DEMAND_EXT(K)
          !
    END DO; END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE PRORATE_DEMAND_DEFECICIY(CDAT, WBS, F)
    !
    !  ASSUMES THAT WBS%IRR_AREA IS UP TO DATE WITH CALLING 
    CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),     INTENT(IN   ):: WBS
    INTEGER, INTENT(IN):: F
    !
    INTEGER:: I, J, K, IMPRV
    DOUBLE PRECISION:: QAVF, QAVD, QDEF, QEXC, FRAC1, FRAC2, DMD, DMD2, RATIO
    !
    IF(WBS%IRR_AREA(F) < NEARZERO_30 .OR. WBS%SUPPLY(F)%CROP < NEARZERO_30) THEN  !NO IRRIGATED AREA OR SIMPLY NO SUPPLY --ZERO OUT DEMAND
        !
        DO CONCURRENT(J=ONE:WBS%CROP(F)%N) 
            I=WBS%CROP(F)%PNT(ONE,J)
            K=WBS%CROP(F)%PNT(TWO,J)
            !
            !IF(CDAT%CROP(I)%DEMAND(K) > DZ) CDAT%CROP(I)%TSUR(K) = MIN(CDAT%CROP(I)%TSUR(K), CDAT%CROP(I)%TPPOT(K)) !CDAT%CROP(I)%TSUR(K) - CDAT%CROP(I)%DEMAND(K)*CDAT%CROP(I)%EFF(K)  !Lower TSUR TO MATCH HOW MUCH WATER IS APPLIED PLUS PRECIP.  -- QDEF*CDAT%CROP(I)%EFF(K) IS AMMOUNT OF WATER NO LONGER APPLIED TO PLANT
            !
            CDAT%CROP(I)%TI(K)     = DZ
            CDAT%CROP(I)%CIR(K)    = DZ
            CDAT%CROP(I)%DEMAND(K) = DZ
            CDAT%CROP(I)%DEMAND_EXT(K) = DZ
        END DO    
    ELSE
        SELECT CASE(WBS%PRORATE_DEFICIENCY)
        CASE(Z)
                 IF( WBS%CROP_DEMAND_ADDED(F) > DZ ) THEN
                     DMD = WBS%CROP_DEMAND(F) - WBS%CROP_DEMAND_ADDED(F)  !Remove added part to onyl have Crop DMD
                 ELSE
                     DMD = WBS%CROP_DEMAND(F)
                 END IF
                 DMD2  = WBS%CROP_DEMAND_ADDED(F)
                 !
                 FRAC1 = UNO  !Flag to indicate crop must be reduced
                 FRAC2 = DZ  !Scale for Added DMD
                 !
                 IF(DMD2 < NEARZERO_30) THEN  !No added demand, only adjust Crop
                     !
                     FRAC2 = UNO
                     !
                 ELSEIF(DMD  < NEARZERO_30) THEN  !No crop dmd demand, only just added
                     !
                     FRAC1 = DNEG
                     FRAC2 = WBS%SUPPLY(F)%CROP / WBS%CROP_DEMAND(F)
                     !
                 ELSEIF(DMD < WBS%SUPPLY(F)%CROP) THEN                    !Supply enough to meet some of external dmd and Crop demand
                     !
                     FRAC1 = DNEG                                          !Met all of Crop Demand
                     !
                     RATIO = WBS%SUPPLY(F)%CROP - DMD                     !Supply for Added dmd
                     !
                     IF(RATIO > NEARZERO_30)  FRAC2 = RATIO / DMD2  !Reduce Added Demand by Shortfall
                 END IF
                 !
                 IF( FRAC2 < UNO) THEN
                   DO CONCURRENT(J=ONE:WBS%CROP(F)%N) 
                       I=WBS%CROP(F)%PNT(ONE,J)
                       K=WBS%CROP(F)%PNT(TWO,J)
                       !
                       CDAT%CROP(I)%DEMAND_EXT(K) = FRAC2 * CDAT%CROP(I)%DEMAND_EXT(K)
                       !
                       IF( CDAT%CROP(I)%DEMAND_EXT(K) < NEARZERO_30) CDAT%CROP(I)%DEMAND_EXT(K) = DZ
                   END DO
                 END IF
                 !
                 IF( FRAC1 > DZ ) THEN  ! Flag indicates that Crop must be adjusted
                    !
                    FRAC1 = DZ
                    QDEF = DZ
                    QEXC = DZ
                    !IRR_CROP_AREA = DZ
                    !DO CONCURRENT(J=ONE:WBS%CROP(F)%N)  !GET AREA --MAYBE OUT OF SYNC WITH WBS%IRR_AREA DO TO FALLOWING
                    !    I=WBS%CROP(F)%PNT(ONE,J)
                    !    K=WBS%CROP(F)%PNT(TWO,J)
                    !    !
                    !    IF(CDAT%CROP(I)%NOT_FALLOW(K) .AND. CDAT%CROP(I)%IRR(K) > Z) IRR_CROP_AREA = IRR_CROP_AREA + CDAT%CROP(I)%AREA(K)
                    !END DO
                    !
                    QAVF = WBS%SUPPLY(F)%CROP / WBS%IRR_AREA(F)  !AVERAGE FLOW PER IRRIGATED CROP AREA    / CROP_DEMAND(F)
                    !
                    DO CONCURRENT(J=ONE:WBS%CROP(F)%N) 
                        I=WBS%CROP(F)%PNT(ONE,J)
                        K=WBS%CROP(F)%PNT(TWO,J)
                        !
                        IF(CDAT%CROP(I)%NOT_FALLOW(K) .AND. CDAT%CROP(I)%IRR(K) > Z)  THEN
                            !
                            QAVD = QAVF*CDAT%CROP(I)%AREA(K)
                            !
                            DMD = CDAT%CROP(I)%DEMAND(K) !+ FRAC2*CDAT%CROP(I)%DEMAND_EXT(K)
                            IF ( DMD > QAVD ) THEN
                                                                                          QEXC = QEXC + DMD - QAVD
                            ELSE
                                                                                          QDEF = QDEF + QAVD - DMD
                            END IF
                        END IF
                    END DO
                    !
                    IF(QEXC > DZ) FRAC1 = QDEF/QEXC
                    !
                    DO CONCURRENT(J=ONE:WBS%CROP(F)%N) 
                        I=WBS%CROP(F)%PNT(ONE,J)
                        K=WBS%CROP(F)%PNT(TWO,J)
                        !
                        QAVD = QAVF*CDAT%CROP(I)%AREA(K)
                        !
                             DMD2 = CDAT%CROP(I)%DEMAND(K)
                        IF ( DMD2 > QAVD .AND. CDAT%CROP(I)%NOT_FALLOW(K) .AND. CDAT%CROP(I)%IRR(K) > Z) THEN
                               !
                               !DMD  = FRAC * (CDAT%CROP(I)%DEMAND(K)-QAVD) + QAVD
                               DMD  = FRAC1 * (DMD2-QAVD) + QAVD
                               !
                               RATIO = DZ
                               IF(DMD2>DZ) RATIO = DMD/DMD2
                               IF(RATIO > UNO) RATIO = UNO
                               IF(RATIO < DZ ) RATIO = DZ
                               !
                               DMD = CDAT%CROP(I)%DEMAND(K)     * RATIO
                               !
                               !QDEF = (CDAT%CROP(I)%DEMAND(K) - DMD) * CDAT%CROP(I)%EFF(K) !CIR_DEFICIT
                               !
                               !CIR = (TSUR-TPPOT)*(1+CECT)
                               !TSUR = CIR/(1+CECT) + TPPOT
                               !TSUR_1 - TSUR_2 = (CIR_1-CIR_2)/(1+CECT) = ((DMD_1-DMD_2)*EFF)/(1+CECT)
                               !
                               !CDAT%CROP(I)%TSUR(K) = CDAT%CROP(I)%TSUR(K) - QDEF/(UNO + CDAT%CROP(I)%CECT(K))
                               !
                               IMPRV = WBS%EFF_IMPROVE_TFR%GET( F, CDAT%CROP(I)%RC(TWO,K), CDAT%CROP(I)%RC(ONE,K), CDAT%CROP(I)%IRR(K) )
                               IF( IMPRV == Z ) THEN
                                   CDAT%CROP(I)%CIR(K) = DMD * CDAT%CROP(I)%EFF(K)
                                   CDAT%CROP(I)%TI(K)  = CDAT%CROP(I)%CIR(K)/ (UNO + CDAT%CROP(I)%CECT(K))
                               ELSE
                                   IF(DMD > NEARZERO_30) THEN
                                                    CDAT%CROP(I)%EFF(K) = CDAT%CROP(I)%CIR(K) / DMD
                                                    IF(CDAT%CROP(I)%EFF(K) > UNO) THEN
                                                                                      CDAT%CROP(I)%EFF(K) = UNO
                                                                                      CDAT%CROP(I)%CIR(K) = DMD
                                                                                      CDAT%CROP(I)%TI(K)  = CDAT%CROP(I)%CIR(K)/ (UNO + CDAT%CROP(I)%CECT(K))
                                                    END IF
                                   ELSE
                                                    !CDAT%CROP(I)%EFF(K) = DZ
                                                    CDAT%CROP(I)%TI(K)  = DZ
                                   END IF
                               END IF
                               !
                               IF( CDAT%CROP(I)%TI(K) < NEARZERO_30) THEN
                                   CDAT%CROP(I)%TI(K)     = DZ
                                   CDAT%CROP(I)%CIR(K)    = DZ
                                   CDAT%CROP(I)%DEMAND(K) = DZ
                               ELSE
                                   CDAT%CROP(I)%DEMAND(K) = DMD
                               END IF
                               !
                               !CDAT%CROP(I)%TSUR(K) = CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K)
                               !
                        END IF  !IF <QAVD THEN DEMAND IS FULLY MET AND NO CHANGE IN EFF. PREVIOUS FMP WOULD LOWER DEMAND TO TSUR TO MAKE EFF=1
                    END DO
                 END IF
        CASE(ONE)
                 IF( WBS%CROP_DEMAND_ADDED(F) > DZ ) THEN
                     DMD = WBS%CROP_DEMAND(F) - WBS%CROP_DEMAND_ADDED(F)  !Remove added part to onyl have Crop DMD
                 ELSE
                     DMD = WBS%CROP_DEMAND(F)
                 END IF
                 DMD2  = WBS%CROP_DEMAND_ADDED(F)
                 !
                 FRAC1 = DZ  !Scale for Crop DMD
                 FRAC2 = DZ  !Scale for Added DMD
                 !
                 IF(DMD2 < NEARZERO_30) THEN  !No added demand, only adjust Crop
                     !
                     FRAC1 = WBS%SUPPLY(F)%CROP / WBS%CROP_DEMAND(F)
                     !
                 ELSEIF(DMD  < NEARZERO_30) THEN  !No acropdded demand, only just added
                     !
                     FRAC2 = WBS%SUPPLY(F)%CROP / WBS%CROP_DEMAND(F)
                     !
                 ELSEIF(DMD < WBS%SUPPLY(F)%CROP) THEN                    !Supply enough to meet some of external dmd and Crop demand
                     !
                     FRAC1 = UNO                                          !Met all of Crop Demand
                     !
                     RATIO = WBS%SUPPLY(F)%CROP - DMD                     !Supply for Added dmd
                     !
                     IF(RATIO > NEARZERO_30)  FRAC2 = RATIO / DMD2  !Reduce Added Demand by Shortfall
                     !
                 ELSE !Crop demand is greater than supply
                     !
                     FRAC1 = WBS%SUPPLY(F)%CROP / DMD
                 END IF
                 !
                 DO CONCURRENT(J=ONE:WBS%CROP(F)%N)
                     I=WBS%CROP(F)%PNT(ONE,J)
                     K=WBS%CROP(F)%PNT(TWO,J)
                     !
                     IF(CDAT%CROP(I)%NOT_FALLOW(K) .AND. CDAT%CROP(I)%IRR(K) > Z) THEN
                            !
                            DMD  = CDAT%CROP(I)%DEMAND(K)     * FRAC1
                            DMD2 = CDAT%CROP(I)%DEMAND_EXT(K) * FRAC2
                            !QDEF = (CDAT%CROP(I)%DEMAND(K) - DMD) * CDAT%CROP(I)%EFF(K) !CIR_DEFICIT
                            !
                            !CIR = (TSUR-TPPOT)*(1+CECT)
                            !TSUR = CIR/(1+CECT) + TPPOT
                            !TSUR_1 - TSUR_2 = (CIR_1-CIR_2)/(1+CECT) = ((DMD_1-DMD_2)*EFF)/(1+CECT)
                            !
                            !CDAT%CROP(I)%TSUR(K) = CDAT%CROP(I)%TSUR(K) - QDEF/(UNO + CDAT%CROP(I)%CECT(K))
                            !
                            IMPRV = WBS%EFF_IMPROVE_TFR%GET( F, CDAT%CROP(I)%RC(TWO,K), CDAT%CROP(I)%RC(ONE,K), CDAT%CROP(I)%IRR(K) )
                            IF( IMPRV == Z ) THEN
                                CDAT%CROP(I)%CIR(K) = DMD * CDAT%CROP(I)%EFF(K)
                                CDAT%CROP(I)%TI(K)  = CDAT%CROP(I)%CIR(K)/ (UNO + CDAT%CROP(I)%CECT(K))
                            ELSE
                                IF(DMD > NEARZERO_30) THEN
                                                 CDAT%CROP(I)%EFF(K) = CDAT%CROP(I)%CIR(K) / DMD
                                                 IF(CDAT%CROP(I)%EFF(K) > UNO) THEN
                                                                                   CDAT%CROP(I)%EFF(K) = UNO
                                                                                   CDAT%CROP(I)%CIR(K) = DMD
                                                                                   CDAT%CROP(I)%TI(K)  = CDAT%CROP(I)%CIR(K)/ (UNO + CDAT%CROP(I)%CECT(K))
                                                 END IF
                                ELSE
                                                 !CDAT%CROP(I)%EFF(K) = DZ
                                                 CDAT%CROP(I)%TI(K)  = DZ
                                END IF
                            END IF
                            !
                            IF( CDAT%CROP(I)%TI(K) < NEARZERO_30) THEN
                                CDAT%CROP(I)%TI(K)     = DZ
                                CDAT%CROP(I)%CIR(K)    = DZ
                                CDAT%CROP(I)%DEMAND(K) = DZ
                            ELSE
                                CDAT%CROP(I)%DEMAND(K) = DMD
                            END IF
                            !
                            IF( DMD2 < NEARZERO_30) THEN
                                CDAT%CROP(I)%DEMAND_EXT(K) = DZ
                            ELSE
                                CDAT%CROP(I)%DEMAND_EXT(K) = DMD2
                            END IF
                     END IF
                     !
                 END DO
        END SELECT
    END IF
    !
  END SUBROUTINE
  !
  !!!PURE SUBROUTINE PRORATE_DEMAND_DEFECICIY(CDAT, WBS, F)
  !!!  !
  !!!  !  ASSUMES THAT WBS%IRR_AREA IS UP TO DATE WITH CALLING 
  !!!  CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
  !!!  TYPE(WBS_DATA),     INTENT(IN   ):: WBS
  !!!  INTEGER, INTENT(IN):: F
  !!!  !
  !!!  INTEGER:: I, J, K, IMPRV
  !!!  DOUBLE PRECISION:: QAVF, QAVD, QDEF, QEXC, FRAC, DMD, DMD2, RATIO
  !!!  !
  !!!  IF(WBS%IRR_AREA(F) < NEARZERO_30 .OR. WBS%SUPPLY(F)%CROP < NEARZERO_30) THEN  !NO IRRIGATED AREA OR SIMPLY NO SUPPLY --ZERO OUT DEMAND
  !!!      !
  !!!      DO CONCURRENT(J=ONE:WBS%CROP(F)%N) 
  !!!          I=WBS%CROP(F)%PNT(ONE,J)
  !!!          K=WBS%CROP(F)%PNT(TWO,J)
  !!!          !
  !!!          !IF(CDAT%CROP(I)%DEMAND(K) > DZ) CDAT%CROP(I)%TSUR(K) = MIN(CDAT%CROP(I)%TSUR(K), CDAT%CROP(I)%TPPOT(K)) !CDAT%CROP(I)%TSUR(K) - CDAT%CROP(I)%DEMAND(K)*CDAT%CROP(I)%EFF(K)  !Lower TSUR TO MATCH HOW MUCH WATER IS APPLIED PLUS PRECIP.  -- QDEF*CDAT%CROP(I)%EFF(K) IS AMMOUNT OF WATER NO LONGER APPLIED TO PLANT
  !!!          !
  !!!          CDAT%CROP(I)%TI(K)     = DZ
  !!!          CDAT%CROP(I)%CIR(K)    = DZ
  !!!          CDAT%CROP(I)%DEMAND(K) = DZ
  !!!          CDAT%CROP(I)%DEMAND_EXT(K) = DZ
  !!!      END DO    
  !!!  ELSE
  !!!      SELECT CASE(WBS%PRORATE_DEFICIENCY)
  !!!      CASE(Z)
  !!!               QDEF = DZ
  !!!               QEXC = DZ
  !!!               FRAC = DZ
  !!!               !IRR_CROP_AREA = DZ
  !!!               !DO CONCURRENT(J=ONE:WBS%CROP(F)%N)  !GET AREA --MAYBE OUT OF SYNC WITH WBS%IRR_AREA DO TO FALLOWING
  !!!               !    I=WBS%CROP(F)%PNT(ONE,J)
  !!!               !    K=WBS%CROP(F)%PNT(TWO,J)
  !!!               !    !
  !!!               !    IF(CDAT%CROP(I)%NOT_FALLOW(K) .AND. CDAT%CROP(I)%IRR(K) > Z) IRR_CROP_AREA = IRR_CROP_AREA + CDAT%CROP(I)%AREA(K)
  !!!               !END DO
  !!!               !
  !!!               QAVF = WBS%SUPPLY(F)%CROP / WBS%IRR_AREA(F)  !AVERAGE FLOW PER IRRIGATED CROP AREA    / CROP_DEMAND(F)
  !!!               !
  !!!               DO CONCURRENT(J=ONE:WBS%CROP(F)%N) 
  !!!                   I=WBS%CROP(F)%PNT(ONE,J)
  !!!                   K=WBS%CROP(F)%PNT(TWO,J)
  !!!                   !
  !!!                   IF(CDAT%CROP(I)%NOT_FALLOW(K) .AND. CDAT%CROP(I)%IRR(K) > Z)  THEN
  !!!                       !
  !!!                       QAVD = QAVF*CDAT%CROP(I)%AREA(K)
  !!!                       !
  !!!                       DMD = CDAT%CROP(I)%DEMAND(K) + CDAT%CROP(I)%DEMAND_EXT(K)
  !!!                       IF ( DMD > QAVD ) THEN
  !!!                                                                                     QEXC = QEXC + DMD - QAVD
  !!!                       ELSE
  !!!                                                                                     QDEF = QDEF + QAVD - DMD
  !!!                       END IF
  !!!                   END IF
  !!!               END DO
  !!!               !
  !!!               IF(QEXC > DZ) FRAC = QDEF/QEXC
  !!!               !
  !!!               DO CONCURRENT(J=ONE:WBS%CROP(F)%N) 
  !!!                   I=WBS%CROP(F)%PNT(ONE,J)
  !!!                   K=WBS%CROP(F)%PNT(TWO,J)
  !!!                   !
  !!!                   QAVD = QAVF*CDAT%CROP(I)%AREA(K)
  !!!                   !
  !!!                        DMD2 = CDAT%CROP(I)%DEMAND(K) + CDAT%CROP(I)%DEMAND_EXT(K)
  !!!                   IF ( DMD2 > QAVD .AND. CDAT%CROP(I)%NOT_FALLOW(K) .AND. CDAT%CROP(I)%IRR(K) > Z) THEN
  !!!                          !
  !!!                          !DMD  = FRAC * (CDAT%CROP(I)%DEMAND(K)-QAVD) + QAVD
  !!!                          DMD  = FRAC * (DMD2-QAVD) + QAVD
  !!!                          !
  !!!                          RATIO = DZ
  !!!                          IF(DMD2>DZ) RATIO = DMD/DMD2
  !!!                          IF(RATIO > UNO) RATIO = UNO
  !!!                          IF(RATIO < DZ ) RATIO = DZ
  !!!                          !
  !!!                          DMD = CDAT%CROP(I)%DEMAND(K)     * RATIO
  !!!                          DMD2= CDAT%CROP(I)%DEMAND_EXT(K) * RATIO
  !!!                          !
  !!!                          !QDEF = (CDAT%CROP(I)%DEMAND(K) - DMD) * CDAT%CROP(I)%EFF(K) !CIR_DEFICIT
  !!!                          !
  !!!                          !CIR = (TSUR-TPPOT)*(1+CECT)
  !!!                          !TSUR = CIR/(1+CECT) + TPPOT
  !!!                          !TSUR_1 - TSUR_2 = (CIR_1-CIR_2)/(1+CECT) = ((DMD_1-DMD_2)*EFF)/(1+CECT)
  !!!                          !
  !!!                          !CDAT%CROP(I)%TSUR(K) = CDAT%CROP(I)%TSUR(K) - QDEF/(UNO + CDAT%CROP(I)%CECT(K))
  !!!                          !
  !!!                          IMPRV = WBS%EFF_IMPROVE_TFR%GET( F, CDAT%CROP(I)%RC(TWO,K), CDAT%CROP(I)%RC(ONE,K), CDAT%CROP(I)%IRR(K) )
  !!!                          IF( IMPRV == Z ) THEN
  !!!                              CDAT%CROP(I)%CIR(K) = DMD * CDAT%CROP(I)%EFF(K)
  !!!                              CDAT%CROP(I)%TI(K)  = CDAT%CROP(I)%CIR(K)/ (UNO + CDAT%CROP(I)%CECT(K))
  !!!                          ELSE
  !!!                              IF(DMD > NEARZERO_30) THEN
  !!!                                               CDAT%CROP(I)%EFF(K) = CDAT%CROP(I)%CIR(K) / DMD
  !!!                                               IF(CDAT%CROP(I)%EFF(K) > UNO) THEN
  !!!                                                                                 CDAT%CROP(I)%EFF(K) = UNO
  !!!                                                                                 CDAT%CROP(I)%CIR(K) = DMD
  !!!                                                                                 CDAT%CROP(I)%TI(K)  = CDAT%CROP(I)%CIR(K)/ (UNO + CDAT%CROP(I)%CECT(K))
  !!!                                               END IF
  !!!                              ELSE
  !!!                                               !CDAT%CROP(I)%EFF(K) = DZ
  !!!                                               CDAT%CROP(I)%TI(K)  = DZ
  !!!                              END IF
  !!!                          END IF
  !!!                          !
  !!!                          IF( CDAT%CROP(I)%TI(K) < NEARZERO_30) THEN
  !!!                              CDAT%CROP(I)%TI(K)     = DZ
  !!!                              CDAT%CROP(I)%CIR(K)    = DZ
  !!!                              CDAT%CROP(I)%DEMAND(K) = DZ
  !!!                          ELSE
  !!!                              CDAT%CROP(I)%DEMAND(K) = DMD
  !!!                          END IF
  !!!                          !
  !!!                          IF( DMD2 < NEARZERO_30) THEN
  !!!                              CDAT%CROP(I)%DEMAND_EXT(K) = DZ
  !!!                          ELSE
  !!!                              CDAT%CROP(I)%DEMAND_EXT(K) = DMD2
  !!!                          END IF
  !!!                          !
  !!!                          !CDAT%CROP(I)%TSUR(K) = CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K)
  !!!                          !
  !!!                   END IF  !IF <QAVD THEN DEMAND IS FULLY MET AND NO CHANGE IN EFF. PREVIOUS FMP WOULD LOWER DEMAND TO TSUR TO MAKE EFF=1
  !!!               END DO
  !!!      CASE(ONE)
  !!!               FRAC = WBS%SUPPLY(F)%CROP / WBS%CROP_DEMAND(F)
  !!!               DO CONCURRENT(J=ONE:WBS%CROP(F)%N)
  !!!                   I=WBS%CROP(F)%PNT(ONE,J)
  !!!                   K=WBS%CROP(F)%PNT(TWO,J)
  !!!                   !
  !!!                   IF(CDAT%CROP(I)%NOT_FALLOW(K) .AND. CDAT%CROP(I)%IRR(K) > Z) THEN
  !!!                          !
  !!!                          DMD  = CDAT%CROP(I)%DEMAND(K) * FRAC
  !!!                          DMD2 = CDAT%CROP(I)%DEMAND_EXT(K) * FRAC
  !!!                          !QDEF = (CDAT%CROP(I)%DEMAND(K) - DMD) * CDAT%CROP(I)%EFF(K) !CIR_DEFICIT
  !!!                          !
  !!!                          !CIR = (TSUR-TPPOT)*(1+CECT)
  !!!                          !TSUR = CIR/(1+CECT) + TPPOT
  !!!                          !TSUR_1 - TSUR_2 = (CIR_1-CIR_2)/(1+CECT) = ((DMD_1-DMD_2)*EFF)/(1+CECT)
  !!!                          !
  !!!                          !CDAT%CROP(I)%TSUR(K) = CDAT%CROP(I)%TSUR(K) - QDEF/(UNO + CDAT%CROP(I)%CECT(K))
  !!!                          !
  !!!                          IMPRV = WBS%EFF_IMPROVE_TFR%GET( F, CDAT%CROP(I)%RC(TWO,K), CDAT%CROP(I)%RC(ONE,K), CDAT%CROP(I)%IRR(K) )
  !!!                          IF( IMPRV == Z ) THEN
  !!!                              CDAT%CROP(I)%CIR(K) = DMD * CDAT%CROP(I)%EFF(K)
  !!!                              CDAT%CROP(I)%TI(K)  = CDAT%CROP(I)%CIR(K)/ (UNO + CDAT%CROP(I)%CECT(K))
  !!!                          ELSE
  !!!                              IF(DMD > NEARZERO_30) THEN
  !!!                                               CDAT%CROP(I)%EFF(K) = CDAT%CROP(I)%CIR(K) / DMD
  !!!                                               IF(CDAT%CROP(I)%EFF(K) > UNO) THEN
  !!!                                                                                 CDAT%CROP(I)%EFF(K) = UNO
  !!!                                                                                 CDAT%CROP(I)%CIR(K) = DMD
  !!!                                                                                 CDAT%CROP(I)%TI(K)  = CDAT%CROP(I)%CIR(K)/ (UNO + CDAT%CROP(I)%CECT(K))
  !!!                                               END IF
  !!!                              ELSE
  !!!                                               !CDAT%CROP(I)%EFF(K) = DZ
  !!!                                               CDAT%CROP(I)%TI(K)  = DZ
  !!!                              END IF
  !!!                          END IF
  !!!                          !
  !!!                          IF( CDAT%CROP(I)%TI(K) < NEARZERO_30) THEN
  !!!                              CDAT%CROP(I)%TI(K)     = DZ
  !!!                              CDAT%CROP(I)%CIR(K)    = DZ
  !!!                              CDAT%CROP(I)%DEMAND(K) = DZ
  !!!                          ELSE
  !!!                              CDAT%CROP(I)%DEMAND(K) = DMD
  !!!                          END IF
  !!!                          !
  !!!                          IF( DMD2 < NEARZERO_30) THEN
  !!!                              CDAT%CROP(I)%DEMAND_EXT(K) = DZ
  !!!                          ELSE
  !!!                              CDAT%CROP(I)%DEMAND_EXT(K) = DMD2
  !!!                          END IF
  !!!                   END IF
  !!!                   !
  !!!               END DO
  !!!      END SELECT
  !!!  END IF
  !!!  !
  !!!END SUBROUTINE
  !
  PURE SUBROUTINE APPLY_DEFICIENCY_SCENARIO(CDAT, WBS, F)
    !
    CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),     INTENT(INOUT):: WBS
    INTEGER,            INTENT(IN   ):: F
    INTEGER:: I, K, J, R, C, RANK
    LOGICAL:: UPDATE
    !
    IF(CDAT%NCROP == Z) RETURN
    !
    UPDATE = FALSE
    !DO CONCURRENT   ( F=ONE:WBS%NFARM, WBS%CROP_DEMAND(F) > NEARZERO_10 .AND. WBS%SUPPLY(F)%CROP - WBS%CROP_DEMAND(F) < NEGNEARZERO_10 )  !SKIP WHEN SUPPLY IS CLOSE TO DEMAND  --ADD CHECK FOR WATER STACK FOR ADDING CROP LAND
    IF (WBS%CROP_DEMAND(F) > NEARZERO_10 .AND. WBS%SUPPLY(F)%CROP - WBS%CROP_DEMAND(F) < NEGNEARZERO_10) THEN
        !
        SELECT CASE(WBS%DEFICIENCY%LIST(F))
        !CASE(Z)
        !    CONTINUE  !WATER MAGICALLY FOUND AND APPLIED
        CASE(ONE)
                 UPDATE = TRUE
                 CALL PRORATE_DEMAND_DEFECICIY(CDAT, WBS, F)
        CASE(TWO)
                 UPDATE = TRUE
                 !
                 RANK = Z
                 !
                 DO WHILE (RANK < WBS%MAX_FALLOW_RANK(F) .OR. WBS%CROP_DEMAND(F) > WBS%SUPPLY(F)%CROP)
                    !
                    RANK = RANK + ONE
                    !
                    DO CONCURRENT(J=ONE:WBS%CROP(F)%N)
                          I=WBS%CROP(F)%PNT(ONE,J)
                          K=WBS%CROP(F)%PNT(TWO,J)
                          !
                          IF ( CDAT%CROP(I)%FALLOW_RANK(K) == RANK)  THEN
                               !
                               CDAT%CROP(I)%NOT_FALLOW(K) = FALSE
                               WBS%CROP_DEMAND(F) = WBS%CROP_DEMAND(F) - CDAT%CROP(I)%DEMAND(K) - CDAT%CROP(I)%DEMAND_EXT(K)
                          END IF
                    END DO
                 END DO
                 !
                 WBS%IRR_AREA(F) = DZ               !NEED TO UPDATE IRR_AREA DUE TO FALLOWING
                 DO CONCURRENT(J=ONE:WBS%CROP(F)%N)
                     I=WBS%CROP(F)%PNT(ONE,J)
                     K=WBS%CROP(F)%PNT(TWO,J)
                     !
                     IF(CDAT%CROP(I)%NOT_FALLOW(K) .AND. CDAT%CROP(I)%IRR(K) > Z) WBS%IRR_AREA(F) = WBS%IRR_AREA(F) + CDAT%CROP(I)%AREA(K)
                 END DO
                 !
                 IF ( WBS%CROP_DEMAND(F) > WBS%SUPPLY(F)%CROP ) THEN
                           CALL PRORATE_DEMAND_DEFECICIY(CDAT, WBS, F)
                 END IF
                 !
        END SELECT
        !
        IF (UPDATE) THEN !CALL ADD_CROP_DEMAND_TO_ARRAY(CDAT, WBS%CROP_DEMAND_ARRAY)
           !
           !WHERE(WBS%FID_ARRAY==F);  WBS%CROP_DEMAND_ARRAY = DZ  !UPDATING DEMAND, SO ZERO OUT FARM THAT IS UNDER DEFICIT
           !END WHERE
           DO CONCURRENT (K=ONE:WBS%FID(F)%Count)
                                          WBS%CROP_DEMAND_ARRAY( WBS%FID(F)%RC(TWO,K), WBS%FID(F)%RC(ONE,K) ) = DZ
           END DO
           !CALL POSITION_SET_ARRAY(WBS%NCOL, WBS%NROW, F, WBS%FID_ARRAY, DZ, WBS%CROP_DEMAND_ARRAY) ! --Only minor speed boost over where
           !
           WBS%CROP_DEMAND(F) = DZ
           WBS%CROP_DEMAND_ADDED(F) = DZ
           DO CONCURRENT(J=ONE:WBS%CROP(F)%N)   !CROP POSITION IN WBS
               I=WBS%CROP(F)%PNT(ONE,  J)  !CROP ID
               K=WBS%CROP(F)%PNT(TWO,  J)  !CROP POSITION IN CROP
               R=WBS%CROP(F)%PNT(THREE,J)  !CROP Row
               C=WBS%CROP(F)%PNT(FOUR, J)  !CROP Col
               !
               WBS%CROP_DEMAND_ARRAY(C,R) = WBS%CROP_DEMAND_ARRAY(C,R) + CDAT%CROP(I)%DEMAND(K) + CDAT%CROP(I)%DEMAND_EXT(K)
               !
               WBS%CROP_DEMAND(F) = WBS%CROP_DEMAND(F)+ CDAT%CROP(I)%DEMAND(K) + CDAT%CROP(I)%DEMAND_EXT(K)
               !
               WBS%CROP_DEMAND_ADDED(F) = WBS%CROP_DEMAND_ADDED(F) + CDAT%CROP(I)%DEMAND_EXT(K)
           END DO
        END IF
    END IF
    !    
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_INEFFICIENT_LOSSES(CDAT, WBS, SURF_VK)
    !
    CLASS(CROP_DATA),                             INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),                               INTENT(INOUT):: WBS
    DOUBLE PRECISION, DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: SURF_VK
    INTEGER:: I, K, R, C, L
    DOUBLE PRECISION:: EXCESS, RUNOFF, DPERC_LIMIT
    !
    ! INITIALIZE VECTORS ---------------------------------
    !
    DO CONCURRENT(I=ONE:CDAT%NCROP   )
    DO CONCURRENT(K=ONE:CDAT%CROP(I)%N); CDAT%CROP(I)%RNOFF(K)     = DZ
    END DO; END DO
    !
    DO CONCURRENT(I=ONE:CDAT%NCROP   )
    DO CONCURRENT(K=ONE:CDAT%CROP(I)%N); CDAT%CROP(I)%DPERC(K)     = DZ
    END DO; END DO
    !
    DO CONCURRENT(I=ONE:CDAT%NCROP   )
    DO CONCURRENT(K=ONE:CDAT%CROP(I)%N); CDAT%CROP(I)%RNOFF_EXT(K) = DZ
    END DO; END DO
    !
    DO CONCURRENT(I=ONE:CDAT%NCROP   )
    DO CONCURRENT(K=ONE:CDAT%CROP(I)%N); CDAT%CROP(I)%DPERC_EXT(K) = DZ
    END DO; END DO
    !
    ! END INITIALIZE VECTORS ----------------------------------
    !
    ! IRRIGATION EXCESS
    DO CONCURRENT (I=ONE:CDAT%NCROP)
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%DEMAND(K) > NEARZERO_30 ) ! .AND. CDAT%CROP(I)%NOT_FALLOW(K) .AND. DZ < CDAT%CROP(I)%EFF(K) .AND. CDAT%CROP(I)%EFF(K) < UNO 
          !
          R = CDAT%CROP(I)%RC(ONE,K)
          C = CDAT%CROP(I)%RC(TWO,K)
          !
          EXCESS = CDAT%CROP(I)%DEMAND(K) - CDAT%CROP(I)%CIR(K)   
          !                                                                              !EFF=CIR/DEMAND
          IF(EXCESS < DZ) EXCESS = CDAT%CROP(I)%DEMAND(K) * (UNO - CDAT%CROP(I)%EFF(K))  ! DEMAND - CIR =  DEMAND - DEMAND*EFF = DEMAND*(1-EFF)   --EXCESS<0 FOR DEFICIT SCENARIO
          !
          IF(EXCESS > NEARZERO_30) THEN
                IF(UPLAY(C,R) == Z) THEN  ! ALL LAYERS ARE IBOUND=Z SO NO PERMIABLE MATERIAL TO PERCOLATE INTO
                               CDAT%CROP(I)%RNOFF(K) = EXCESS
                               WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + EXCESS
                ELSE
                     IF(    CDAT%CROP(I)%FIESWI(K) < NEARZERO_30) THEN
                                                               WBS%DPERC(C,R)  = WBS%DPERC(C,R)  + EXCESS
                                                               CDAT%CROP(I)%DPERC(K) = EXCESS
                     ELSEIF(CDAT%CROP(I)%FIESWI(K) >= UNO) THEN!------------------------------------------
                                                               WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + EXCESS
                                                               CDAT%CROP(I)%RNOFF(K) = EXCESS
                     ELSE!--------------------------------------------------------------------------------
                                                               RUNOFF = EXCESS * CDAT%CROP(I)%FIESWI(K)
                                                               !
                                                               WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + RUNOFF
                                                               WBS%DPERC(C,R)  = WBS%DPERC(C,R)  + EXCESS - RUNOFF
                                                               CDAT%CROP(I)%RNOFF(K) = RUNOFF
                                                               CDAT%CROP(I)%DPERC(K) = EXCESS - RUNOFF
                     END IF
                END IF
          END IF
    END DO; END DO
    !
    ! EXTRA IRRIGATION EXCESS
    IF(CDAT%HAS_DEMAND_EXT) THEN
      DO CONCURRENT (I=ONE:CDAT%NCROP)
      DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%DEMAND_EXT(K) > NEARZERO_30)
            !
            R = CDAT%CROP(I)%RC(ONE,K)
            C = CDAT%CROP(I)%RC(TWO,K)
            L = UPLAY(C,R)
            !
            EXCESS = CDAT%CROP(I)%DEMAND_EXT(K) * (UNO - CDAT%CROP(I)%EFF(K))  ! DEMAND - CIR =  DEMAND - DEMAND*EFF = DEMAND*(1-EFF)   --EXCESS<0 FOR DEFICIT SCENARIO
            !
            !INEFFICIENT LOSSED EXTRA WATER
            IF(EXCESS > NEARZERO_30) THEN
                  IF(L == Z) THEN  ! ALL LAYERS ARE IBOUND=Z SO NO PERMIABLE MATERIAL TO PERCOLATE INTO
                                 WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + EXCESS
                  ELSE
                       IF(    CDAT%CROP(I)%FIESWI(K) < NEARZERO_30) THEN
                                                                 WBS%DPERC(C,R)  = WBS%DPERC(C,R)  + EXCESS
                                                                 CDAT%CROP(I)%DPERC_EXT(K) = EXCESS
                       ELSEIF(CDAT%CROP(I)%FIESWI(K) >= UNO) THEN!------------------------------------------
                                                                 WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + EXCESS
                                                                 CDAT%CROP(I)%RNOFF_EXT(K) = EXCESS
                       ELSE!--------------------------------------------------------------------------------
                                                                 RUNOFF = EXCESS * CDAT%CROP(I)%FIESWI(K)
                                                                 !
                                                                 WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + RUNOFF
                                                                 WBS%DPERC(C,R)  = WBS%DPERC(C,R)  + EXCESS - RUNOFF
                                                                 CDAT%CROP(I)%RNOFF_EXT(K) = RUNOFF
                                                                 CDAT%CROP(I)%DPERC_EXT(K) = EXCESS - RUNOFF
                       END IF
                  END IF
            END IF
            !
            !ACTUAL EXTRA WATER
            EXCESS = CDAT%CROP(I)%DEMAND_EXT(K) * CDAT%CROP(I)%EFF(K)  ! CIR =  DEMAND*EFF --EXCESS<0 FOR DEFICIT SCENARIO
            !
            IF(EXCESS > NEARZERO_30) THEN
                  IF(L == Z) THEN  ! ALL LAYERS ARE IBOUND=Z SO NO PERMIABLE MATERIAL TO PERCOLATE INTO
                                                                WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + EXCESS
                                                                CDAT%CROP(I)%RNOFF_EXT(K) = CDAT%CROP(I)%RNOFF_EXT(K) + EXCESS
                  ELSE!----------------------------------------------------------------------------------------------------------------
                       IF(    CDAT%CROP(I)%ADRF(K) < NEARZERO_30) THEN
                                                                WBS%DPERC(C,R)  = WBS%DPERC(C,R)  + EXCESS
                                                                CDAT%CROP(I)%DPERC_EXT(K) = CDAT%CROP(I)%DPERC_EXT(K) + EXCESS
                       ELSEIF(CDAT%CROP(I)%ADRF(K) >= UNO) THEN!-----------------------------------------------------------------------
                                                                WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + EXCESS
                                                                CDAT%CROP(I)%RNOFF_EXT(K) = CDAT%CROP(I)%RNOFF_EXT(K) + EXCESS
                       ELSE!-----------------------------------------------------------------------------------------------------------
                                                                RUNOFF = EXCESS * CDAT%CROP(I)%ADRF(K)
                                                                !
                                                                WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + RUNOFF
                                                                WBS%DPERC(C,R)  = WBS%DPERC(C,R)  + EXCESS - RUNOFF
                                                                CDAT%CROP(I)%RNOFF_EXT(K) = CDAT%CROP(I)%RNOFF_EXT(K) + RUNOFF
                                                                CDAT%CROP(I)%DPERC_EXT(K) = CDAT%CROP(I)%DPERC_EXT(K) + EXCESS - RUNOFF
                       END IF
                  END IF
            END IF
            !
            CDAT%CROP(I)%RNOFF(K) = CDAT%CROP(I)%RNOFF(K) + CDAT%CROP(I)%RNOFF_EXT(K)
            CDAT%CROP(I)%DPERC(K) = CDAT%CROP(I)%DPERC(K) + CDAT%CROP(I)%DPERC_EXT(K)
      END DO; END DO
    END IF
    !
    !PRECIPITATION EXCESS THAT RESULTS FROM EFFECTIVE PRECIPITATION TABLE
    IF(CDAT%HAS_Pe) THEN
            DO CONCURRENT (I=ONE:CDAT%NCROP)
            DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%RNOFF_Peff(K) > DZ)
                  !
                  CDAT%CROP(I)%RNOFF(K) = CDAT%CROP(I)%RNOFF(K) + CDAT%CROP(I)%RNOFF_Peff(K)
            END DO; END DO
            !
            DO CONCURRENT (I=ONE:CDAT%NCROP)
            DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%RNOFF_Peff(K) > DZ)
                  !
                  R = CDAT%CROP(I)%RC(ONE,K)
                  C = CDAT%CROP(I)%RC(TWO,K)
                  !
                  WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + CDAT%CROP(I)%RNOFF_Peff(K)
            END DO; END DO
    END IF
    !
    !PRECIPITATION EXCESS
    DO CONCURRENT (I=ONE:CDAT%NCROP    )
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)
          !
          R = CDAT%CROP(I)%RC(ONE,K)
          C = CDAT%CROP(I)%RC(TWO,K)
          !
          !             P                       - EP                   - TP
          EXCESS = CDAT%CROP(I)%PRECIP(K) - CDAT%CROP(I)%EP(K) - CDAT%CROP(I)%TP(K)
          !
          IF(EXCESS  > NEARZERO_15) THEN
                !
                IF(UPLAY(C,R) == Z) THEN  ! ALL LAYERS ARE IBOUND=Z SO NO PERMIABLE MATERIAL TO PERCOLATE INTO
                                                             WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + EXCESS
                                                             CDAT%CROP(I)%RNOFF(K) = CDAT%CROP(I)%RNOFF(K) + EXCESS
                ELSE!-----------------------------------------------------------------------------------------------------
                    IF(    CDAT%CROP(I)%FIESWP(K) < NEARZERO_30) THEN
                                                             WBS%DPERC(C,R)  = WBS%DPERC(C,R)  + EXCESS
                                                             CDAT%CROP(I)%DPERC(K) = CDAT%CROP(I)%DPERC(K) + EXCESS
                    ELSEIF(CDAT%CROP(I)%FIESWP(K) >= UNO) THEN!-----------------------------------------------------------
                                                              WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + EXCESS
                    ELSE!-------------------------------------------------------------------------------------------------
                                                              RUNOFF = EXCESS * CDAT%CROP(I)%FIESWP(K)
                                                              !
                                                              WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + RUNOFF
                                                              WBS%DPERC(C,R)  = WBS%DPERC(C,R)  + EXCESS - RUNOFF
                                                              CDAT%CROP(I)%RNOFF(K) = CDAT%CROP(I)%RNOFF(K) + RUNOFF
                                                              CDAT%CROP(I)%DPERC(K) = CDAT%CROP(I)%DPERC(K) + EXCESS - RUNOFF
                    END IF
                END IF
          END IF
    END DO; END DO
    !
    !CHECK IF ANY DEEP PERCOLATION EXCEDES SURFACE LEAKAGE LIMIT (SURF_VK).
    !  IF IT DOES, THEN SHIFT TO RUNOFF AS REJECTED INFILTRATION
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP)
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)
          !
          R = CDAT%CROP(I)%RC(ONE,K)
          C = CDAT%CROP(I)%RC(TWO,K)
          !
          IF(SURF_VK(C,R) < D10) THEN
                                  DPERC_LIMIT = SURF_VK(C,R) * CDAT%CROP(I)%AREA(K)
                                  !
                                  IF(CDAT%CROP(I)%DPERC(K) > DPERC_LIMIT) THEN
                                      !
                                      RUNOFF = CDAT%CROP(I)%DPERC(K) - DPERC_LIMIT
                                      !
                                      CDAT%CROP(I)%DPERC(K) = DPERC_LIMIT
                                      !
                                      CDAT%CROP(I)%RNOFF(K) = CDAT%CROP(I)%RNOFF(K) + RUNOFF
                                      !
                                      WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + RUNOFF
                                      WBS%DPERC(C,R)  = WBS%DPERC(C,R)  - RUNOFF
                                      !
                                  END IF
          END IF
    END DO; END DO
    !
    !PRECIPITATION OVER FALLOW/BARE LAND
    IF(CDAT%CHECK_BARE) THEN
          DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%BARE_PRECEP_EXCESS(C,R) > DZ )
                !
                IF(UPLAY(C,R) == Z) THEN  ! ALL LAYERS ARE IBOUND=Z SO NO PERMIABLE MATERIAL TO PERCOLATE INTO
                               WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + CDAT%BARE_PRECEP_EXCESS(C,R)
                ELSE
                               RUNOFF = CDAT%BARE_PRECEP_EXCESS(C,R) * CDAT%BARE_FRAC_RUNOFF(C,R)  !RUNOFF
                               EXCESS = CDAT%BARE_PRECEP_EXCESS(C,R) - RUNOFF                      !DPERC
                               !
                               IF(SURF_VK(C,R) < D10 .AND. EXCESS > NEARZERO_15) THEN
                                                                                  DPERC_LIMIT = SURF_VK(C,R) * CDAT%BARE_FRAC(C,R) * WBS%AREA(C,R)
                                                                                  !
                                                                                  IF(EXCESS > DPERC_LIMIT) THEN
                                                                                                           RUNOFF = RUNOFF + EXCESS - DPERC_LIMIT
                                                                                                           EXCESS = DPERC_LIMIT
                                                                                  END IF
                               END IF
                               !
                               IF(RUNOFF > NEARZERO_15) WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + RUNOFF
                               !
                               IF(EXCESS > NEARZERO_15) WBS%DPERC(C,R)  = WBS%DPERC(C,R)  + EXCESS
                END IF
          END DO
          !
          !PRECIPITATION EXCESS THAT RESULTS FROM EFFECTIVE PRECIPITATION TABLE
          IF(CDAT%HAS_Pe) THEN
                  DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%BARE_RNOFF_Peff(C,R) > DZ )
                      !
                      WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + CDAT%BARE_RNOFF_Peff(C,R)
                  END DO
          END IF
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SUBTRACT_TGWA_EGWA_FROM_FNRCH(CDAT, WBS)
    !
    ! ASSUMES THAT 
    CLASS(CROP_DATA),   INTENT(IN   ):: CDAT
    TYPE(WBS_DATA),     INTENT(INOUT):: WBS
    !
    IF(CDAT%NCROP > Z) THEN
                                WBS%FNRCH = WBS%FNRCH - CDAT%EGWA - CDAT%TGWA
    ELSEIF(CDAT%CHECK_BARE) THEN
                                WBS%FNRCH = WBS%FNRCH - CDAT%EGWA
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_BYFARM(CDAT, WBS, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(CROP_DATA),INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),  INTENT(IN   ):: WBS
    INTEGER,         INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,INTENT(IN   ):: DELT
    DOUBLE PRECISION,INTENT(IN   ):: DYEAR
    CHARACTER(*),    INTENT(IN   ):: DATE
    INTEGER:: IU, F, I, J, K, R, C
    DOUBLE PRECISION:: AREA, BARE_AREA, DMDI, DMD, CU_I, CU, CIRI, CIR, TSURF_I, TSURF, EGWA, BARE_EVAP, BARE_EVAP_P, SOIL_LOSS, ANOX_LOSS, TPOT, TACT, ADMD_I, ADMD, P, DP, RO, DP_E, RO_E !, TRAN, EGW,TGW 
    CHARACTER(17):: ZER, DT
    !
    IF(CDAT%OUT_BYFARM%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !DDT = DBLE(DELT)
    !
    CALL CDAT%OUT_BYFARM%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = CDAT%OUT_BYFARM%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. CDAT%IOUT==IU )  THEN
        IF(CDAT%OUT_BYFARM%BINARY) THEN
            WRITE(CDAT%IOUT,'(A,/A)')'CROP INFORMATION BY WBS OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), WBS ID (int), WBS AREA (double), CROP AREA (double), IRRIGATED AREA (double), EFFICIENCY (double), CU_INI (double), CU (double), CIR_INI (double), CIR (double), DEMAND_INI (double), DEMAND (double), ADDED_DEMAND_INI (double), ADDED_DEMAND (double), TOT_DEEP_PERC (double), TOT_SURF_RUNOFF (double), ADDED_DMD_DPERC (double), ADDED_DMD_RUNOFF (double), TRAN_POT (double), ANOXIA LOSS (double), SOIL STRESS LOSS (double), TRAN (double), TRAN_SURF_INI (double), TRAN_SURF (double), TRAN_IRR (double), TRAN_PRECIP (double), TRAN_GW (double), EVAP_IRR (double), EVAP_PRECIP (double), EVAP_GW_CROP (double), EVAP_GW_BARE (double), EVAP_PRECIP_BARE (double),  PRECIPITATION (double)"
        ELSE
            !
            IF (CDAT%IOUT==IU) WRITE(IU,*)
            !                                                                                                                                                                                                                                                                                                                                            ANOXIA_LOSS SOIL_STRESS_LOSS
            CALL CDAT%OUT_BYFARM%SET_HEADER( '    PER    STP    WBS         WBS_AREA        CROP_AREA   IRRIGATED_AREA       EFFICIENCY           CU_INI               CU          CIR_INI              CIR       DEMAND_INI           DEMAND ADDED_DEMAND_INI     ADDED_DEMAND    TOT_DEEP_PERC  TOT_SURF_RUNOFF  ADDED_DMD_DPERC ADDED_DMD_RUNOFF         TRAN_POT      ANOXIA_LOSS SOIL_STRESS_LOSS             TRAN    TRAN_SURF_INI        TRAN_SURF         TRAN_IRR      TRAN_PRECIP          TRAN_GW         EVAP_IRR EVAP_PRECIP_CROP     EVAP_GW_CROP     EVAP_GW_BARE EVAP_PRECIP_BARE    PRECIPITATION             DELT   DYEAR            DATE_START' )
        END IF
    END IF
    DO F=ONE, WBS%NFARM
       AREA= DZ
       CU_I= DZ   !CU = TGW*CDAT%CROP(I)%FTR(K) + EGW * (UNO - CDAT%CROP(I)%FTR(K))
       CU  = DZ
       EGWA= DZ
       CIR = DZ
       DMD = DZ
       CIRI= DZ
       DMDI= DZ
       !EP  = DZ
       TPOT=DZ
       TACT=DZ
       ANOX_LOSS = DZ
       SOIL_LOSS = DZ
       TSURF_I   = DZ
       TSURF     = DZ
       ADMD_I    = DZ
       ADMD      = DZ
       P         = WBS%PRECIP(F)
       DP        = DZ
       RO        = DZ
       DP_E      = DZ
       RO_E      = DZ
       DO CONCURRENT(J=ONE:WBS%CROP(F)%N) 
           I=WBS%CROP(F)%PNT(ONE,J)
           K=WBS%CROP(F)%PNT(TWO,J)
           !
           !EGW = EGW  + CDAT%CROP(I)%EGW (K)
           !TGW = TGW  + CDAT%CROP(I)%TGW(K)
           !
           AREA= AREA + CDAT%CROP(I)%AREA(K)
           EGWA= EGWA + CDAT%CROP(I)%EGWA(K)
           !
           IF(CDAT%HAS_DEMAND_EXT) THEN
               ADMD_I = ADMD_I + CDAT%CROP(I)%DEMAND_EXT_INI(K)
               ADMD   = ADMD   + CDAT%CROP(I)%DEMAND_EXT(K)
           END IF
           !
           CU_I= CU_I + CDAT%CROP(I)%CU(K)
           CU  = CU   + CDAT%CROP(I)%TI(K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%EP(K) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%EGWA(K) !TRAN*CDAT%CROP(I)%FTR(K) + TRAN*(UNO - CDAT%CROP(I)%FTR(K))
           ANOX_LOSS = ANOX_LOSS + CDAT%CROP(I)%ANOX_LOSS(K)
           SOIL_LOSS = SOIL_LOSS + CDAT%CROP(I)%SOIL_LOSS(K)
           !
           !P  = P  + CDAT%CROP(I)%PRECIP(K)
           !EP = EP + CDAT%CROP(I)%EP(K)
           DP   = DP   + CDAT%CROP(I)%DPERC(K)
           RO   = RO   + CDAT%CROP(I)%RNOFF(K)
           DP_E = DP_E + CDAT%CROP(I)%DPERC_EXT(K)
           RO_E = RO_E + CDAT%CROP(I)%RNOFF_EXT(K)
           !
           !IF(CDAT%CROP(I)%NOT_FALLOW(K)) THEN
              TPOT    = TPOT + CDAT%CROP(I)%TGW(K)
              TACT    = TACT + CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%TGWA(K)
              !
              TSURF_I = TSURF_I + CDAT%CROP(I)%TSURF(K)
              TSURF   = TSURF   + CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K)
              !
              CIR = CIR  + CDAT%CROP(I)%CIR (K)
              DMD = DMD  + CDAT%CROP(I)%DEMAND (K)
              CIRI= CIRI + CDAT%CROP(I)%CIR_INI(K)
              IF(CDAT%CROP(I)%EFF(K)>DZ) DMDI= DMDI + CDAT%CROP(I)%CIR_INI(K)/CDAT%CROP(I)%EFF(K)
           !END IF
           !
       END DO
       !
       BARE_AREA  =DZ
       BARE_EVAP  =DZ
       BARE_EVAP_P=DZ
       !
       IF(CDAT%CHECK_BARE) THEN
          DO CONCURRENT (K=ONE:WBS%FID(F)%Count)
              R = WBS%FID(F)%RC(ONE,K)
              C = WBS%FID(F)%RC(TWO,K)
              !
              IF(CDAT%BARE_FRAC(C,R) > DZ) THEN
                  BARE_AREA  = BARE_AREA   + CDAT%BARE_FRAC(C,R) * WBS%AREA(C,R)
                  BARE_EVAP  = BARE_EVAP   + CDAT%BARE_EVAP(C,R)
                  BARE_EVAP_P= BARE_EVAP_P + CDAT%BARE_EVAP_PRECIP(C,R)
              END IF
          END DO
       END IF
       !
       IF(CDAT%OUT_BYFARM%BINARY) THEN
           IF(WBS%FID(F)%Count == Z) THEN
               WRITE(IU) DATE, DYEAR, DELT, KPER, KSTP, F, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ
           ELSE
               WRITE(IU) DATE, DYEAR, DELT, KPER, KSTP, F, WBS%FID(F)%AREA, AREA, WBS%IRR_AREA(F), WBS%EFF(F), CU_I, CU, CIRI, CIR, DMDI, DMD, ADMD_I,ADMD, DP, RO, DP_E, RO_E, TPOT, ANOX_LOSS, SOIL_LOSS, TACT, TSURF_I, TSURF, WBS%TIRR(F), WBS%TPRECIP(F), WBS%TGWA(F), WBS%EIRR(F), WBS%EPRECIP(F), EGWA, BARE_EVAP, BARE_EVAP_P, P
           END IF
       ELSEIF(WBS%FID(F)%Count == Z) THEN
               !
               WRITE(IU, '(3I7, 32A17, 2x F13.7, 2x A)') KPER, KSTP, F, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, DT, DYEAR, DATE
       ELSE
               WRITE(IU, '(3I7, 32A17, 2x F13.7, 2x A)') KPER, KSTP, F, NUM2STR(WBS%FID(F)%AREA), NUM2STR(AREA), NUM2STR(WBS%IRR_AREA(F)), NUM2STR(WBS%EFF(F)), NUM2STR(CU_I), NUM2STR(CU), NUM2STR(CIRI), NUM2STR(CIR ), NUM2STR(DMDI), NUM2STR(DMD), NUM2STR(ADMD_I), NUM2STR(ADMD), NUM2STR(DP  ), NUM2STR(RO  ), NUM2STR(DP_E), NUM2STR(RO_E), NUM2STR(TPOT), NUM2STR(ANOX_LOSS), NUM2STR(SOIL_LOSS), NUM2STR(TACT), NUM2STR(TSURF_I), NUM2STR(TSURF), NUM2STR(WBS%TIRR(F)), NUM2STR(WBS%TPRECIP(F)), NUM2STR(WBS%TGWA(F)), NUM2STR(WBS%EIRR(F)), NUM2STR(WBS%EPRECIP(F)), NUM2STR(EGWA), NUM2STR(BARE_EVAP), NUM2STR(BARE_EVAP_P), NUM2STR(P), DT, DYEAR, DATE
       END IF
       !
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_BYCROP(CDAT, WBS, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(CROP_DATA),INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),  INTENT(IN   ):: WBS
    INTEGER,         INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,INTENT(IN   ):: DELT
    DOUBLE PRECISION,INTENT(IN   ):: DYEAR
    CHARACTER(*),    INTENT(IN   ):: DATE
    INTEGER:: IU, I, K, L, R, C
    DOUBLE PRECISION::  AREA, AREA_IRR, DMDI, DMD, CU_I, CU, CIRI, CIR, TI, TP, TSURF_I, TSURF, EI, EP, EGWA, TGWA, BARE_EVAP, BARE_EVAP_P, SOIL_LOSS, ANOX_LOSS, TPOT, TACT, ADMD, ADMD_I, P, DP, RO, DP_E, RO_E, EFF!, TRAN, EGW,TGW ,BARE_AREA, 
    CHARACTER(17):: ZER, DT
    CHARACTER(20):: BARE
    !
    IF(CDAT%OUT_BYCROP%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    L  = CDAT%CROP_NAME_LEN
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !DDT = DBLE(DELT)
    BARE = 'BARE_LAND'
    !
    CALL CDAT%OUT_BYCROP%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = CDAT%OUT_BYCROP%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. CDAT%IOUT==IU )  THEN
        IF(CDAT%OUT_BYCROP%BINARY) THEN 
            WRITE(CDAT%IOUT,'(A,/A)')'CROP INFORMATION BY CROP OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), CROP ID (int), CROP_NAME (20 char), AREA (double), IRRIGATED AREA (double), EFFICIENCY (double), CU_INI (double), CU (double), CIR_INI (double), CIR (double), DEMAND_INI (double), DEMAND (double), ADDED_DEMAND_INI (double), ADDED_DEMAND (double), TOT_DEEP_PERC (double), TOT_SURF_RUNOFF (double), ADDED_DMD_DPERC (double), ADDED_DMD_RUNOFF (double), TRAN_POT (double),  ANOXIA LOSS (double), SOIL STRESS LOSS (double), TRAN (double), TRAN_SURF_INI (double), TRAN_SURF (double), TRAN_IRR (double), TRAN_PRECIP (double), TRAN_GW (double), EVAP_IRR (double), EVAP_PRECIP (double), EVAP_GW (double),  PRECIPITATION (double)"
        ELSE
            !
            IF (CDAT%IOUT==IU) WRITE(IU,*)
            !
            CALL CDAT%OUT_BYCROP%SET_HEADER( '    PER    STP   CROP  CROP_NAME'//REPEAT(' ',L+4)//'AREA   IRRIGATED_AREA       EFFICIENCY           CU_INI               CU          CIR_INI              CIR       DEMAND_INI           DEMAND ADDED_DEMAND_INI     ADDED_DEMAND    TOT_DEEP_PERC  TOT_SURF_RUNOFF  ADDED_DMD_DPERC ADDED_DMD_RUNOFF         TRAN_POT      ANOXIA_LOSS SOIL_STRESS_LOSS             TRAN    TRAN_SURF_INI        TRAN_SURF         TRAN_IRR      TRAN_PRECIP          TRAN_GW         EVAP_IRR      EVAP_PRECIP          EVAP_GW    PRECIPITATION             DELT   DYEAR            DATE_START' )
        END IF
    END IF
    !
    AREA       = DZ
    BARE_EVAP  = DZ
    BARE_EVAP_P= DZ
    P          = DZ
    DP         = DZ
    RO         = DZ
    IF(CDAT%CHECK_BARE) THEN
          DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%BARE_FRAC(C,R) > DZ  )
                AREA       = AREA        + CDAT%BARE_FRAC(C,R) * WBS%AREA(C,R)
                BARE_EVAP  = BARE_EVAP   + CDAT%BARE_EVAP(C,R)
                IF(CDAT%BARE_PRECEP_EXCESS(C,R) > DZ) THEN
                   P = P + CDAT%BARE_TOT_PRECEP(C,R)
                   BARE_EVAP_P= BARE_EVAP_P + CDAT%BARE_EVAP_PRECIP(C,R)
                   !
                   IF(UPLAY(C,R) == Z) THEN  ! ALL LAYERS ARE IBOUND=Z SO NO PERMIABLE MATERIAL TO PERCOLATE INTO
                                  RO = RO + CDAT%BARE_PRECEP_EXCESS(C,R)
                   ELSE
                                  RO = RO + CDAT%BARE_PRECEP_EXCESS(C,R) * (      CDAT%BARE_FRAC_RUNOFF(C,R))
                                  DP = DP + CDAT%BARE_PRECEP_EXCESS(C,R) * (UNO - CDAT%BARE_FRAC_RUNOFF(C,R))
                   END IF
                END IF
          END DO
    END IF
    !
    IF(CDAT%OUT_BYCROP%BINARY) THEN
        WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,Z,BARE,AREA,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DP,RO,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,BARE_EVAP_P,BARE_EVAP,P
    ELSE
        WRITE(IU, '(3I7, 2x A, 29A17, 2x F13.7, 2x A)') KPER, KSTP, Z, BARE(:L), NUM2STR(AREA), ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, NUM2STR(DP), NUM2STR(RO), ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, NUM2STR(BARE_EVAP_P), NUM2STR(BARE_EVAP), NUM2STR(P), DT, DYEAR, DATE
    END IF
    !
    DO I=ONE, CDAT%NCROP
       AREA= DZ
       AREA_IRR = DZ
       CU_I= DZ   !CU = TGW*CDAT%CROP(I)%FTR(K) + EGW * (UNO - CDAT%CROP(I)%FTR(K))
       CU  = DZ
       EGWA= DZ
       TGWA= DZ
       TSURF_I=DZ
       TSURF=DZ
       TI  = DZ
       TP  = DZ
       EI  = DZ
       EP  = DZ
       CIR = DZ
       DMD = DZ
       CIRI= DZ
       DMDI= DZ
       ANOX_LOSS = DZ
       SOIL_LOSS = DZ
       TPOT=DZ
       TACT=DZ
       ADMD_I = DZ
       ADMD   = DZ
       P      = DZ
       DP     = DZ
       RO     = DZ
       DP_E   = DZ
       RO_E   = DZ
       EFF    = DZ
       DO CONCURRENT(K=ONE:CDAT%CROP(I)%N)
           !
           !EGW = EGW  + CDAT%CROP(I)%EGW (K)
           !TGW = TGW  + CDAT%CROP(I)%TGW(K)
           !
           IF(CDAT%CROP(I)%IRR(K)>Z) AREA_IRR = AREA_IRR + CDAT%CROP(I)%AREA(K)
           AREA= AREA + CDAT%CROP(I)%AREA(K)
           EGWA= EGWA + CDAT%CROP(I)%EGWA(K)
           !
           CU_I= CU_I + CDAT%CROP(I)%CU  (K)
           CU  = CU   + CDAT%CROP(I)%TI  (K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%EP(K) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%EGWA(K)! old=>+ CDAT%CROP(I)%TI(K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%TGWA(K) !CDAT%CROP(I)%EGWA(K) !TRAN*CDAT%CROP(I)%FTR(K) + TRAN*(UNO - CDAT%CROP(I)%FTR(K))
           ANOX_LOSS = ANOX_LOSS + CDAT%CROP(I)%ANOX_LOSS(K)
           SOIL_LOSS = SOIL_LOSS + CDAT%CROP(I)%SOIL_LOSS(K)
           !
           P    = P    + CDAT%CROP(I)%PRECIP(K)
           EP   = EP   + CDAT%CROP(I)%EP(K)
           DP   = DP   + CDAT%CROP(I)%DPERC(K)
           RO   = RO   + CDAT%CROP(I)%RNOFF(K)
           DP_E = DP_E + CDAT%CROP(I)%DPERC_EXT(K)
           RO_E = RO_E + CDAT%CROP(I)%RNOFF_EXT(K)
           !
           IF(CDAT%HAS_DEMAND_EXT) THEN
               ADMD_I = ADMD_I + CDAT%CROP(I)%DEMAND_EXT_INI(K)
               ADMD   = ADMD   + CDAT%CROP(I)%DEMAND_EXT(K)
               EFF    = EFF    + CDAT%CROP(I)%DEMAND_EXT(K)*CDAT%CROP(I)%EFF(K)
           END IF
           !
           !IF(CDAT%CROP(I)%NOT_FALLOW(K)) THEN
              !
              EI  = EI   + CDAT%CROP(I)%TI  (K) * CDAT%CROP(I)%CECT(K)
              TI  = TI   + CDAT%CROP(I)%TI  (K)
              TP  = TP   + CDAT%CROP(I)%TP  (K)
              !
              TPOT    = TPOT + CDAT%CROP(I)%TGW(K)
              TACT    = TACT + CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%TGWA(K)
              !
              TSURF_I = TSURF_I + CDAT%CROP(I)%TSURF(K)
              TSURF   = TSURF   + CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K)
              !
              TGWA= TGWA + CDAT%CROP(I)%TGWA(K)
              CIR = CIR  + CDAT%CROP(I)%CIR (K)
              DMD = DMD  + CDAT%CROP(I)%DEMAND (K)
              CIRI= CIRI + CDAT%CROP(I)%CIR_INI(K)
              EFF = EFF  + CDAT%CROP(I)%DEMAND(K)*CDAT%CROP(I)%EFF(K)
              IF(CDAT%CROP(I)%EFF(K)>DZ) DMDI= DMDI + CDAT%CROP(I)%CIR_INI(K)/CDAT%CROP(I)%EFF(K)
           !END IF
           !
       END DO
       !
       IF(EFF > NEARZERO_30) THEN  !EFF = Sum of CIR
           EFF = EFF/(DMD+ADMD)
           IF(EFF>UNO) EFF=UNO
       ELSE
           EFF=DZ
       END IF
       !
       IF(CDAT%OUT_BYCROP%BINARY) THEN
           IF(CDAT%CROP(I)%N == Z) THEN
               WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,I,CDAT%CROP_NAME(I),DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ
           ELSE
               WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,I,CDAT%CROP_NAME(I),AREA,AREA_IRR,EFF,CU_I,CU,CIRI,CIR,DMDI,DMD,ADMD_I,ADMD,DP,RO,DP_E,RO_E,TPOT,ANOX_LOSS,SOIL_LOSS,TACT,TSURF_I,TSURF,TI,TP,TGWA,EI,EP,EGWA,P
           END IF
       ELSEIF(CDAT%CROP(I)%N == Z) THEN
               !
               WRITE(IU, '(3I7, 2x A, 29A17, 2x F13.7, 2x A)') KPER, KSTP, I, CDAT%CROP_NAME(I)(:L), ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, DT, DYEAR, DATE
       ELSE
               WRITE(IU, '(3I7, 2x A, 29A17, 2x F13.7, 2x A)') KPER, KSTP, I, CDAT%CROP_NAME(I)(:L), NUM2STR(AREA), NUM2STR(AREA_IRR), NUM2STR(EFF), NUM2STR(CU_I), NUM2STR(CU), NUM2STR(CIRI), NUM2STR(CIR), NUM2STR(DMDI), NUM2STR(DMD), NUM2STR(ADMD_I), NUM2STR(ADMD), NUM2STR(DP), NUM2STR(RO), NUM2STR(DP_E), NUM2STR(RO_E), NUM2STR(TPOT), NUM2STR(ANOX_LOSS), NUM2STR(SOIL_LOSS), NUM2STR(TACT), NUM2STR(TSURF_I), NUM2STR(TSURF), NUM2STR(TI), NUM2STR(TP), NUM2STR(TGWA), NUM2STR(EI), NUM2STR(EP), NUM2STR(EGWA), NUM2STR(P), DT, DYEAR, DATE
       END IF
       
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_BYFARM_BYCROP(CDAT, WBS, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(CROP_DATA),INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),  INTENT(IN   ):: WBS
    INTEGER,         INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,INTENT(IN   ):: DELT
    DOUBLE PRECISION,INTENT(IN   ):: DYEAR
    CHARACTER(*),    INTENT(IN   ):: DATE
    INTEGER:: IU, F, I, J, K, R, C, L
    DOUBLE PRECISION::  AREA, AREA_IRR, DMDI, DMD, CU_I, CU, CIRI, CIR, TI, TP, EI, EP, EGWA, TGWA, BARE_EVAP, BARE_EVAP_P, SOIL_LOSS, ANOX_LOSS, TPOT, TACT, TSURF_I, TSURF,ADMD,ADMD_I, P, DP, RO, DP_E, RO_E, EFF!, TRAN, EGW,TGW BARE_AREA, 
    CHARACTER(17):: ZER, DT
    CHARACTER(20):: BARE
    LOGICAL:: FOUND
    !
    IF(CDAT%OUT_BYFARMCROP%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    L  = CDAT%CROP_NAME_LEN
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !DDT = DBLE(DELT)
    BARE = 'BARE_LAND'
    !
    CALL CDAT%OUT_BYFARMCROP%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = CDAT%OUT_BYFARMCROP%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. CDAT%IOUT==IU )  THEN
        IF(CDAT%OUT_BYFARMCROP%BINARY) THEN 
            WRITE(CDAT%IOUT,'(A,/A)')'CROP INFORMATION BY CROP OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), WBS ID (int), CROP ID (int), CROP_NAME (20 char), AREA (double), IRRIGATED AREA (double), EFFICIENCY (double), CU_INI (double), CU (double), CIR_INI (double), CIR (double), DEMAND_INI (double), DEMAND (double), ADDED_DEMAND_INI (double), ADDED_DEMAND (double), TOT_DEEP_PERC (double), TOT_SURF_RUNOFF (double), ADDED_DMD_DPERC (double), ADDED_DMD_RUNOFF (double), TRAN_POT (double),  ANOXIA LOSS (double), SOIL STRESS LOSS (double), TRAN (double), TRAN_SURF_INI (double), TRAN_SURF (double), TRAN_IRR (double), TRAN_PRECIP (double), TRAN_GW (double), EVAP_IRR (double), EVAP_PRECIP (double), EVAP_GW (double),  PRECIPITATION (double)"
        ELSE
            !
            IF (CDAT%IOUT==IU) WRITE(IU,*)
            !
            CALL CDAT%OUT_BYFARMCROP%SET_HEADER( '    PER    STP    WBS   CROP  CROP_NAME'//REPEAT(' ',L+4)//'AREA   IRRIGATED_AREA       EFFICIENCY           CU_INI               CU          CIR_INI              CIR       DEMAND_INI           DEMAND ADDED_DEMAND_INI     ADDED_DEMAND    TOT_DEEP_PERC  TOT_SURF_RUNOFF  ADDED_DMD_DPERC ADDED_DMD_RUNOFF         TRAN_POT      ANOXIA_LOSS SOIL_STRESS_LOSS             TRAN    TRAN_SURF_INI        TRAN_SURF         TRAN_IRR      TRAN_PRECIP          TRAN_GW         EVAP_IRR      EVAP_PRECIP          EVAP_GW    PRECIPITATION             DELT   DYEAR            DATE_START' )
        END IF
    END IF
    !
    DO F=ONE, WBS%NFARM
          IF(WBS%FID(F)%COUNT < ONE) CYCLE
          !   
          AREA       = DZ
          BARE_EVAP  = DZ
          BARE_EVAP_P= DZ     
          P = DZ
          DP = DZ
          RO = DZ
          FOUND = FALSE
          IF(CDAT%CHECK_BARE) THEN
             DO CONCURRENT (K=ONE:WBS%FID(F)%Count)
                   R = WBS%FID(F)%RC(ONE,K)
                   C = WBS%FID(F)%RC(TWO,K)
                   IF(CDAT%BARE_FRAC(C,R) > DZ) THEN
                      FOUND = TRUE 
                      AREA       = AREA        + CDAT%BARE_FRAC(C,R) * WBS%AREA(C,R)
                      BARE_EVAP  = BARE_EVAP   + CDAT%BARE_EVAP(C,R)
                      BARE_EVAP_P= BARE_EVAP_P + CDAT%BARE_EVAP_PRECIP(C,R)
                      P = P + CDAT%BARE_TOT_PRECEP(C,R)
                      !
                      IF(UPLAY(C,R) == Z) THEN  ! ALL LAYERS ARE IBOUND=Z SO NO PERMIABLE MATERIAL TO PERCOLATE INTO
                                     RO = RO + CDAT%BARE_PRECEP_EXCESS(C,R)
                      ELSE
                                     RO = RO + CDAT%BARE_PRECEP_EXCESS(C,R) * (      CDAT%BARE_FRAC_RUNOFF(C,R))
                                     DP = DP + CDAT%BARE_PRECEP_EXCESS(C,R) * (UNO - CDAT%BARE_FRAC_RUNOFF(C,R))
                      END IF
                   END IF
             END DO
          END IF
          !
          IF(FOUND) THEN
            IF(CDAT%OUT_BYFARMCROP%BINARY) THEN
                WRITE(IU) DATE, DYEAR, DELT, KPER, KSTP, F, Z, BARE, AREA, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DP, RO, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, BARE_EVAP_P, BARE_EVAP, P
            ELSE
                WRITE(IU, '(4I7, 2x A, 29A17, 2x F13.7, 2x A)') KPER, KSTP, F, Z, BARE(:L), NUM2STR(AREA), ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, NUM2STR(DP), NUM2STR(RO), ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, NUM2STR(BARE_EVAP_P), NUM2STR(BARE_EVAP), NUM2STR(P), DT, DYEAR, DATE
            END IF
          END IF
          !
          DO I=ONE, CDAT%NCROP
             AREA= DZ
             AREA_IRR = DZ
             CU_I= DZ   !CU = TGW*CDAT%CROP(I)%FTR(K) + EGW * (UNO - CDAT%CROP(I)%FTR(K))
             CU  = DZ
             EGWA= DZ
             TGWA= DZ
             TI  = DZ
             TP  = DZ
             EI  = DZ
             EP  = DZ
             CIR = DZ
             DMD = DZ
             CIRI= DZ
             DMDI= DZ
             ANOX_LOSS = DZ
             SOIL_LOSS = DZ
             TPOT=DZ
             TACT=DZ
             TGWA= DZ
             TSURF_I=DZ
             TSURF  =DZ
             ADMD_I =DZ
             ADMD   =DZ
             P    = DZ
             DP   = DZ
             RO   = DZ
             DP_E = DZ
             RO_E = DZ
             EFF  = DZ
             FOUND = FALSE
             DO CONCURRENT(J=ONE:WBS%CROP(F)%N, WBS%CROP(F)%PNT(ONE,J) == I)
                 K=WBS%CROP(F)%PNT(TWO,J)
                 FOUND = TRUE
                 !
                 !EGW = EGW  + CDAT%CROP(I)%EGW (K)
                 !TGW = TGW  + CDAT%CROP(I)%TGW(K)
                 !
                 IF(CDAT%CROP(I)%IRR(K)>Z) AREA_IRR = AREA_IRR + CDAT%CROP(I)%AREA(K)
                 AREA= AREA + CDAT%CROP(I)%AREA(K)
                 EGWA= EGWA + CDAT%CROP(I)%EGWA(K)
                 !
                 CU_I= CU_I + CDAT%CROP(I)%CU  (K)
                 CU  = CU   + CDAT%CROP(I)%TI  (K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%EP(K) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%EGWA(K) !CDAT%CROP(I)%EGWA(K) !TRAN*CDAT%CROP(I)%FTR(K) + TRAN*(UNO - CDAT%CROP(I)%FTR(K))
                 ANOX_LOSS = ANOX_LOSS + CDAT%CROP(I)%ANOX_LOSS(K)
                 SOIL_LOSS = SOIL_LOSS + CDAT%CROP(I)%SOIL_LOSS(K)
                 !
                 IF(CDAT%HAS_DEMAND_EXT) THEN
                     ADMD_I = ADMD_I + CDAT%CROP(I)%DEMAND_EXT_INI(K)
                     ADMD   = ADMD   + CDAT%CROP(I)%DEMAND_EXT(K)
                     EFF    = EFF    + CDAT%CROP(I)%DEMAND_EXT(K)*CDAT%CROP(I)%EFF(K)
                 END IF
                 !
                 P    = P    + CDAT%CROP(I)%PRECIP(K)
                 EP   = EP   + CDAT%CROP(I)%EP(K)
                 DP   = DP   + CDAT%CROP(I)%DPERC(K)
                 RO   = RO   + CDAT%CROP(I)%RNOFF(K)
                 DP_E = DP_E + CDAT%CROP(I)%DPERC_EXT(K)
                 RO_E = RO_E + CDAT%CROP(I)%RNOFF_EXT(K)
                 !
                 !IF(CDAT%CROP(I)%NOT_FALLOW(K)) THEN
                    TPOT    = TPOT + CDAT%CROP(I)%TGW(K)
                    TACT    = TACT + CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%TGWA(K)
                    TSURF_I = TSURF_I + CDAT%CROP(I)%TSURF(K)
                    TSURF   = TSURF   + CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K)
                    EI  = EI   + CDAT%CROP(I)%TI  (K) * CDAT%CROP(I)%CECT(K)
                    TI  = TI   + CDAT%CROP(I)%TI  (K)
                    TP  = TP   + CDAT%CROP(I)%TP  (K)
                    TGWA= TGWA + CDAT%CROP(I)%TGWA(K)
                    CIR = CIR  + CDAT%CROP(I)%CIR (K)
                    DMD = DMD  + CDAT%CROP(I)%DEMAND (K)
                    CIRI= CIRI + CDAT%CROP(I)%CIR_INI(K)
                    EFF = EFF  + CDAT%CROP(I)%DEMAND(K)*CDAT%CROP(I)%EFF(K)
                    IF(CDAT%CROP(I)%EFF(K)>DZ) DMDI= DMDI + CDAT%CROP(I)%CIR_INI(K)/CDAT%CROP(I)%EFF(K)
                 !END IF
                 !
             END DO
             !
             IF(EFF > NEARZERO_30) THEN  !EFF = Sum of CIR
                 EFF = EFF/(DMD+ADMD)
                 IF(EFF>UNO) EFF=UNO
             ELSE
                 EFF=DZ
             END IF
             !
             IF(FOUND) THEN
                IF(CDAT%OUT_BYFARMCROP%BINARY) THEN
                        WRITE(IU)                     DATE, DYEAR, DELT, KPER, KSTP, F, I, CDAT%CROP_NAME(I), AREA, AREA_IRR, EFF, CU_I, CU, CIRI, CIR, DMDI, DMD, ADMD_I, ADMD, DP, RO, DP_E, RO_E, TPOT, ANOX_LOSS, SOIL_LOSS, TACT, TSURF_I, TSURF, TI, TP, TGWA, EI, EP, EGWA, P
                ELSE
                        WRITE(IU, '(4I7, 2x A, 29A17, 2x F13.7, 2x A)') KPER, KSTP, F, I, CDAT%CROP_NAME(I)(:L), NUM2STR(AREA), NUM2STR(AREA_IRR), NUM2STR(EFF), NUM2STR(CU_I), NUM2STR(CU), NUM2STR(CIRI), NUM2STR(CIR), NUM2STR(DMDI), NUM2STR(DMD), NUM2STR(ADMD_I), NUM2STR(ADMD), NUM2STR(DP), NUM2STR(RO), NUM2STR(DP_E), NUM2STR(RO_E), NUM2STR(TPOT), NUM2STR(ANOX_LOSS), NUM2STR(SOIL_LOSS), NUM2STR(TACT), NUM2STR(TSURF_I), NUM2STR(TSURF), NUM2STR(TI), NUM2STR(TP), NUM2STR(TGWA), NUM2STR(EI), NUM2STR(EP), NUM2STR(EGWA), NUM2STR(P), DT, DYEAR, DATE
                END IF
             END IF
          END DO
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_ALL_CROP(CDAT, WBS, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(CROP_DATA),INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),  INTENT(IN   ):: WBS
    INTEGER,         INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,INTENT(IN   ):: DELT
    DOUBLE PRECISION,INTENT(IN   ):: DYEAR
    CHARACTER(*),    INTENT(IN   ):: DATE
    INTEGER:: IU, F, I, K, R, C, L
    DOUBLE PRECISION:: EFF, AREA, DMDI, DMD, CU_I, CU, CIRI, CIR, TI, TP, EI, EP, EGWA, TGWA, SOIL_LOSS, ANOX_LOSS, TPOT, TACT, TSURF_I, TSURF, ADMD, ADMD_I, P, DP, RO, DP_E, RO_E, HH, GSE, SS, LXX!, TRAN, EGW,TGW  BARE_AREA,BARE_EVAP, BARE_EVAP_P, 
    CHARACTER(17):: ZER, DT
    !CHARACTER(20):: BARE
    !
    IF(CDAT%OUT_ALL%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    L  = CDAT%CROP_NAME_LEN
    !BARE = 'BARE_LAND'
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !DDT = DBLE(DELT)
    !
    CALL CDAT%OUT_ALL%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = CDAT%OUT_ALL%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. CDAT%IOUT==IU )  THEN
        IF(CDAT%OUT_ALL%BINARY) THEN
            WRITE(CDAT%IOUT,'(A,/A)')'DETAILED CROP INFORMATION BY CROP OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), CROP ID (int), CROP_NAME (20 char), WBS ID (int), ROW (int), COL (int), AREA (double), EFFICIENCY (double), CU_INI (double), CU (double), CIR_INI (double), CIR (double), DEMAND_INI (double), DEMAND (double), ADDED_DEMAND_INI (double), ADDED_DEMAND (double), TOT_DEEP_PERC (double), TOT_SURF_RUNOFF (double), ADDED_DMD_DPERC (double), ADDED_DMD_RUNOFF (double), TRAN_POT (double),  ANOXIA LOSS (double), SOIL STRESS LOSS (double), TRAN (double), TRAN_SURF_INI (double), TRAN_SURF (double), TRAN_IRR (double), TRAN_PRECIP (double), TRAN_GW (double), EVAP_IRR (double), EVAP_PRECIP (double), EVAP_GW (double),  PRECIPITATION (double), GW_HEAD (double), GSE (double), ROOT_ELEV (double), LOW_EXTINC_ELEV (double)"
        ELSE
            !
            IF (CDAT%IOUT==IU) WRITE(IU,*)
            !
            CALL CDAT%OUT_ALL%SET_HEADER( '    PER    STP   CROP  CROP_NAME'//REPEAT(' ',L-6)//' WBS    ROW    COL             AREA       EFFICIENCY           CU_INI               CU          CIR_INI              CIR       DEMAND_INI           DEMAND ADDED_DEMAND_INI     ADDED_DEMAND    TOT_DEEP_PERC  TOT_SURF_RUNOFF  ADDED_DMD_DPERC ADDED_DMD_RUNOFF         TRAN_POT      ANOXIA_LOSS SOIL_STRESS_LOSS             TRAN    TRAN_SURF_INI        TRAN_SURF         TRAN_IRR      TRAN_PRECIP          TRAN_GW         EVAP_IRR      EVAP_PRECIP          EVAP_GW    PRECIPITATION          GW_HEAD              GSE        ROOT_ELEV  LOW_EXTINC_ELEV             DELT   DYEAR            DATE_START' )
        END IF
    END IF
    !
    DO I=ONE, CDAT%NCROP
      IF(CDAT%PRINT_CROP%LIST(I).NE.Z) THEN
         DO K=ONE, CDAT%CROP(I)%N
             !
             R = CDAT%CROP(I)%RC(ONE,K)
             C = CDAT%CROP(I)%RC(TWO,K)
             F = CDAT%CROP(I)%FID(K) 
             !
             AREA= CDAT%CROP(I)%AREA(K)
             EGWA= CDAT%CROP(I)%EGWA(K)
             !
             IF(WTABLE(C,R) > NEAR_ninf) THEN
                 HH = WTABLE(C,R)
             ELSE
                 HH = HDRY
             END IF
             !
             GSE = CDAT%CROP(I)%GSE(K)
             !
             CU_I= CDAT%CROP(I)%CU  (K)
             CU  = CDAT%CROP(I)%TI  (K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%EP(K) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%EGWA(K) !CDAT%CROP(I)%EGWA(K) !TRAN*CDAT%CROP(I)%FTR(K) + TRAN*(UNO - CDAT%CROP(I)%FTR(K))
             ANOX_LOSS = CDAT%CROP(I)%ANOX_LOSS(K)
             SOIL_LOSS = CDAT%CROP(I)%SOIL_LOSS(K)
             !
             P    = CDAT%CROP(I)%PRECIP(K)
             EP   = CDAT%CROP(I)%EP(K)
             DP   = CDAT%CROP(I)%DPERC(K)
             RO   = CDAT%CROP(I)%RNOFF(K)
             DP_E = CDAT%CROP(I)%DPERC_EXT(K)
             RO_E = CDAT%CROP(I)%RNOFF_EXT(K)
             !
             SS  = CDAT%CROP(I)%SS(K) 
             LXX = CDAT%CROP(I)%LXX(K) 
             !
             IF(CDAT%HAS_DEMAND_EXT) THEN
                 ADMD_I = CDAT%CROP(I)%DEMAND_EXT_INI(K)
                 ADMD   = CDAT%CROP(I)%DEMAND_EXT(K)
             ELSE
                 ADMD_I = DZ
                 ADMD   = DZ
             END IF
             !
             IF(CDAT%CROP(I)%NOT_FALLOW(K)) THEN
                TPOT    = CDAT%CROP(I)%TGW(K)
                TACT    = CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%TGWA(K)
                TSURF_I = CDAT%CROP(I)%TSURF(K)
                TSURF   = CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K)
                EI  = CDAT%CROP(I)%TI  (K) * CDAT%CROP(I)%CECT(K)
                TI  = CDAT%CROP(I)%TI  (K)
                TP  = CDAT%CROP(I)%TP  (K)
                TGWA= CDAT%CROP(I)%TGWA(K)
                CIR = CDAT%CROP(I)%CIR (K)
                DMD = CDAT%CROP(I)%DEMAND (K)
                CIRI= CDAT%CROP(I)%CIR_INI(K)
                !
                IF(CDAT%CROP(I)%IRR(K)>Z ) THEN; EFF = CDAT%CROP(I)%EFF(K)
                ELSE;                            EFF = DZ
                END IF
                IF(CDAT%CROP(I)%EFF(K)>DZ) THEN;  DMDI= CDAT%CROP(I)%CIR_INI(K)/CDAT%CROP(I)%EFF(K)
                ELSE;                             DMDI= DMD
                END IF
             ELSE
                EI  = DZ
                TI  = DZ
                TP  = DZ
                TGWA= DZ
                CIR = DZ
                DMD = DZ
                CIRI= DZ
                DMDI= DZ
                EFF = DZ
                TPOT=DZ
                TACT=DZ
             END IF
             !
             IF(CDAT%OUT_ALL%BINARY) THEN
                     WRITE(IU) DATE, DYEAR, DELT, KPER, KSTP, I, CDAT%CROP_NAME(I), F, R, C, AREA, EFF, CU_I, CU, CIRI, CIR, DMDI, DMD, ADMD_I, ADMD, DP, RO, DP_E, RO_E, TPOT, ANOX_LOSS, SOIL_LOSS, TACT, TSURF_I, TSURF, TI, TP, TGWA, EI, EP, EGWA, P, HH, GSE, SS, LXX
             ELSE
                     WRITE(IU, '(3I7, 2x A, 3I7, 32A17, 2x F13.7, 2x A)') KPER, KSTP, I, CDAT%CROP_NAME(I)(:L), F, R, C, NUM2STR(AREA), NUM2STR(EFF), NUM2STR(CU_I), NUM2STR(CU), NUM2STR(CIRI), NUM2STR(CIR), NUM2STR(DMDI), NUM2STR(DMD), NUM2STR(ADMD_I), NUM2STR(ADMD), NUM2STR(DP), NUM2STR(RO), NUM2STR(DP_E), NUM2STR(RO_E), NUM2STR(TPOT), NUM2STR(ANOX_LOSS), NUM2STR(SOIL_LOSS), NUM2STR(TACT), NUM2STR(TSURF_I), NUM2STR(TSURF), NUM2STR(TI), NUM2STR(TP), NUM2STR(TGWA), NUM2STR(EI), NUM2STR(EP), NUM2STR(EGWA), NUM2STR(P), NUM2STR(HH), NUM2STR(GSE), NUM2STR(SS), NUM2STR(LXX), DT, DYEAR, DATE
             END IF
         END DO
      END IF
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_DETAIL_CROP(CDAT, WBS, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(CROP_DATA),INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),  INTENT(IN   ):: WBS
    INTEGER,         INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,INTENT(IN   ):: DELT
    DOUBLE PRECISION,INTENT(IN   ):: DYEAR
    CHARACTER(*),    INTENT(IN   ):: DATE
    INTEGER:: IU, F, I, K, R, C, L, LL
    DOUBLE PRECISION:: EFF, AREA, DMDI, DMD, CU_I, CU, CIRI, CIR, TI, TP, EI, EP, EGWA, TGWA, ANOX_LOSS, SOIL_LOSS, TPOT, TACT, TSURF_I, TSURF,ADMD,ADMD_I, P, DP, RO, DP_E, RO_E!, TRAN, EGW,TGW BARE_EVAP, BARE_EVAP, BARE_EVAP_P, 
    CHARACTER(17):: ZER, DT
    DOUBLE PRECISION::  HH, GSE, FTR, FEI, FIESWP, FIESWI, POND, PSI1, PSI2, PSI3, PSI4, SS, LXX, UXX, MXX!, XX
    INTEGER:: GW_INTER, IRR
    !
    IF(CDAT%OUT_DETAIL%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    LL = CDAT%CROP_NAME_LEN
    !BARE = 'BARE_LAND'
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !DDT = DBLE(DELT)
    !
    CALL CDAT%OUT_DETAIL%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = CDAT%OUT_DETAIL%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. CDAT%IOUT==IU )  THEN
        IF(CDAT%OUT_DETAIL%BINARY) THEN
            WRITE(CDAT%IOUT,'(A,/A)')'DETAILED CROP INFORMATION BY CROP OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), CROP ID (int), CROP_NAME (20 char), WBS ID (int), ROW (int), COL (int), LAY (int), GW_INTERACTION_FLAG (int), IRRIGATION_TYPE (int), AREA (double), EFFICIENCY (double), FRAC_TRAN (double), FRAC_EVAP_PRECIP (double), FRAC_EVAP_IRR (double), FRAC_SW_LOSS_PRECIP (double), FRAC_SW_LOSS_IRR (double), CU_INI (double), CU (double), CIR_INI (double), CIR (double), DEMAND_INI (double), DEMAND (double), ADDED_DEMAND_INI (double), ADDED_DEMAND (double), TOT_DEEP_PERC (double), TOT_SURF_RUNOFF (double), ADDED_DMD_DPERC (double), ADDED_DMD_RUNOFF (double), TRAN_POT (double),  ANOXIA LOSS (double), SOIL STRESS LOSS (double), TRAN (double), TRAN_SURF_INI (double), TRAN_SURF (double), TRAN_IRR (double), TRAN_PRECIP (double), TRAN_GW (double), EVAP_IRR (double), EVAP_PRECIP (double), EVAP_GW (double),  PRECIPITATION (double), POND_DEPTH_TOL (double), PSI_1 (double), PSI_2 (double), PSI_3 (double), PSI_4 (double), GW_HEAD (double), GSE (double), UP_EXTINC_ELEV (double), MID_EXTINC_ELEV (double), ROOT_ELEV (double), LOW_EXTINC_ELEV (double)"
        ELSE
            !
            IF (CDAT%IOUT==IU) WRITE(IU,*)
            !                                                                                                                                                                                                                                                                                                                                                       
            CALL CDAT%OUT_DETAIL%SET_HEADER( '    PER    STP   CROP  CROP_NAME'//REPEAT(' ',LL-6)//' WBS    ROW    COL    LAY GW_INT    IRR             AREA       EFFICIENCY        FRAC_TRAN    FRAC_EVAP_IRR FRAC_SW_LOSS_PRE FRAC_SW_LOSS_IRR           CU_INI               CU          CIR_INI              CIR       DEMAND_INI           DEMAND ADDED_DEMAND_INI     ADDED_DEMAND    TOT_DEEP_PERC  TOT_SURF_RUNOFF  ADDED_DMD_DPERC ADDED_DMD_RUNOFF         TRAN_POT      ANOXIA_LOSS SOIL_STRESS_LOSS             TRAN    TRAN_SURF_INI        TRAN_SURF         TRAN_IRR      TRAN_PRECIP          TRAN_GW         EVAP_IRR      EVAP_PRECIP          EVAP_GW    PRECIPITATION   POND_DEPTH_TOL            PSI_1            PSI_2            PSI_3            PSI_4          GW_HEAD              GSE   UP_EXTINC_ELEV  MID_EXTINC_ELEV        ROOT_ELEV  LOW_EXTINC_ELEV             DELT   DYEAR            DATE_START' )
        END IF
    END IF
    !
    DO I=ONE, CDAT%NCROP
      IF(CDAT%PRINT_CROP%LIST(I).NE.Z) THEN
        !
        IF(CDAT%HAS_PSI .AND. CDAT%CROP(I)%N > Z) THEN; 
            PSI1 = CDAT%CROP(I)%PSI(ONE  )
            PSI2 = CDAT%CROP(I)%PSI(TWO  )
            PSI3 = CDAT%CROP(I)%PSI(THREE)
            PSI4 = CDAT%CROP(I)%PSI(FOUR )
        ELSE;          
            PSI1 = DZ
            PSI2 = DZ
            PSI3 = DZ
            PSI4 = DZ
        END IF
        !
        DO K=ONE, CDAT%CROP(I)%N
            !
            R = CDAT%CROP(I)%RC(ONE,K)
            C = CDAT%CROP(I)%RC(TWO,K)
            F = CDAT%CROP(I)%FID(K) 
            L = UPLAY(C,R)
            !
            GW_INTER = CDAT%CROP(I)%GW_INTER(K)
            IRR      = CDAT%CROP(I)%IRR(K)
            !
            IF(WTABLE(C,R) > NEAR_ninf) THEN
                HH = WTABLE(C,R)
            ELSE
                HH = HDRY
            END IF
            !
            GSE = CDAT%CROP(I)%GSE(K)
            !
            AREA= CDAT%CROP(I)%AREA(K)
            EGWA= CDAT%CROP(I)%EGWA(K)
            !
            CU_I= CDAT%CROP(I)%CU  (K)
            CU  = CDAT%CROP(I)%TI  (K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%EP(K) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%EGWA(K) !CDAT%CROP(I)%EGWA(K) !TRAN*CDAT%CROP(I)%FTR(K) + TRAN*(UNO - CDAT%CROP(I)%FTR(K))
            ANOX_LOSS = CDAT%CROP(I)%ANOX_LOSS(K)
            SOIL_LOSS = CDAT%CROP(I)%SOIL_LOSS(K)
            TPOT      = CDAT%CROP(I)%TGW(K)
            TACT      = CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%TGWA(K)
            !
            P    = CDAT%CROP(I)%PRECIP(K)
            EP   = CDAT%CROP(I)%EP(K)
            DP   = CDAT%CROP(I)%DPERC(K)
            RO   = CDAT%CROP(I)%RNOFF(K)
            DP_E = CDAT%CROP(I)%DPERC_EXT(K)
            RO_E = CDAT%CROP(I)%RNOFF_EXT(K)
            !
            IF(CDAT%HAS_DEMAND_EXT) THEN
                ADMD_I = CDAT%CROP(I)%DEMAND_EXT_INI(K)
                ADMD   = CDAT%CROP(I)%DEMAND_EXT(K)
            ELSE
                ADMD_I = DZ
                ADMD   = DZ
            END IF
            !
            FTR = CDAT%CROP(I)%FTR(K)
            FEI = CDAT%CROP(I)%FEI(K)
            FIESWP = CDAT%CROP(I)%FIESWP(K)
            FIESWI = CDAT%CROP(I)%FIESWI(K)
            IF(CDAT%HAS_POND) THEN; POND = CDAT%CROP(I)%POND(K)
            ELSE;                   POND = DZ
            END IF
            !
            IF(CDAT%HAS_PSI) THEN
                    UXX = CDAT%CROP(I)%UXX(K)
                    MXX = CDAT%CROP(I)%MXX(K)
            ELSE
                    UXX = CDAT%CROP(I)%GSE(K)
                    MXX = CDAT%CROP(I)%SS(K) 
            END IF
            SS  = CDAT%CROP(I)%SS(K) 
            LXX = CDAT%CROP(I)%LXX(K) 
            !XX  = CDAT%CROP(I)%XX(K) 
            !
            IF(CDAT%CROP(I)%NOT_FALLOW(K)) THEN
               TSURF_I = CDAT%CROP(I)%TSURF(K)
               TSURF   = CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K)
               EI  = CDAT%CROP(I)%TI  (K) * CDAT%CROP(I)%CECT(K)
               TI  = CDAT%CROP(I)%TI  (K)
               TP  = CDAT%CROP(I)%TP  (K)
               TGWA= CDAT%CROP(I)%TGWA(K)
               CIR = CDAT%CROP(I)%CIR (K)
               DMD = CDAT%CROP(I)%DEMAND (K)
               CIRI= CDAT%CROP(I)%CIR_INI(K)
               !
               IF(CDAT%CROP(I)%IRR(K)>Z ) THEN; EFF = CDAT%CROP(I)%EFF(K)
               ELSE;                            EFF = DZ
               END IF
               IF(CDAT%CROP(I)%EFF(K)>DZ) THEN;  DMDI= CDAT%CROP(I)%CIR_INI(K)/CDAT%CROP(I)%EFF(K)
               ELSE;                             DMDI= DMD
               END IF
            ELSE
               TSURF_I = DZ
               TSURF   = DZ
               EI  = DZ
               TI  = DZ
               TP  = DZ
               TGWA= DZ
               CIR = DZ
               DMD = DZ
               CIRI= DZ
               DMDI= DZ
               EFF = DZ
               TPOT=DZ
               TACT=DZ
            END IF
            !
            IF(CDAT%OUT_DETAIL%BINARY) THEN
                    WRITE(IU) DATE, DYEAR, DELT, KPER, KSTP, I, CDAT%CROP_NAME(I), F, R, C, L, GW_INTER, IRR, AREA, EFF, FTR, FEI, FIESWP, FIESWI, CU_I, CU, CIRI, CIR, DMDI, DMD, ADMD_I, ADMD, DP, RO, DP_E, RO_E, TPOT, ANOX_LOSS, SOIL_LOSS, TACT, TSURF_I, TSURF, TI, TP, TGWA, EI, EP, EGWA, P, POND, PSI1, PSI2, PSI3, PSI4, HH, GSE, UXX, MXX, SS, LXX
            ELSE
                    WRITE(IU, '(3I7, 2x A, 6I7, 44A17, 2x F13.7, 2x A)') KPER, KSTP, I, CDAT%CROP_NAME(I)(:LL), F, R, C, L, GW_INTER, IRR, NUM2STR(AREA), NUM2STR(EFF), NUM2STR(FTR), NUM2STR(FEI), NUM2STR(FIESWP), NUM2STR(FIESWI), NUM2STR(CU_I), NUM2STR(CU), NUM2STR(CIRI), NUM2STR(CIR), NUM2STR(DMDI), NUM2STR(DMD), NUM2STR(ADMD_I), NUM2STR(ADMD), NUM2STR(DP), NUM2STR(RO), NUM2STR(DP_E), NUM2STR(RO_E), NUM2STR(TPOT), NUM2STR(ANOX_LOSS), NUM2STR(SOIL_LOSS), NUM2STR(TACT), NUM2STR(TSURF_I), NUM2STR(TSURF), NUM2STR(TI), NUM2STR(TP), NUM2STR(TGWA), NUM2STR(EI), NUM2STR(EP), NUM2STR(EGWA), NUM2STR(P), NUM2STR(POND), NUM2STR(PSI1), NUM2STR(PSI2), NUM2STR(PSI3), NUM2STR(PSI4), NUM2STR(HH), NUM2STR(GSE), NUM2STR(UXX), NUM2STR(MXX), NUM2STR(SS), NUM2STR(LXX), DT, DYEAR, DATE
            END IF
        END DO
      END IF
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_INPUT(CDAT, WBS, KPER, KSTP)
    CLASS(CROP_DATA),INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),  INTENT(IN   ):: WBS
    INTEGER,         INTENT(IN   ):: KPER, KSTP
    INTEGER:: IU, F, I, K, R, C, LL
    DOUBLE PRECISION:: EFF, AREA!, TRAN, EGW,TGW ARE_AREA, , BARE_EVAP_P, EP
    CHARACTER(17):: ZER, FRAC
    DOUBLE PRECISION::  GSE, FTR, FEI, FIESWP, FIESWI, POND, PSI1, PSI2, PSI3, PSI4, SS, LXX
    INTEGER:: GW_INTER, IRR
    !
    IF(CDAT%OUT_INPUT%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    LL = CDAT%CROP_NAME_LEN
    !BARE = 'BARE_LAND'
    !
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !
    CALL SETUP_CROP_EFFICIENCY(CDAT, WBS,FALSE)  ! BECAUSE EFF IS NOT SET UNTIL FM, THIS ALLOWS FOR IT TO BE PRINTED
    !
    CALL CDAT%OUT_INPUT%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = CDAT%OUT_INPUT%IU
    !
    IF(CDAT%OUT_INPUT%BINARY) CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG='FMP CROP ERROR. PRINT INPUT OPTION TURNED ON, BUT IT IS SET TO WRITE A BINARY FILE. THIS IS NOT SUPPORTED, PLEASE REMOVE BINARY KEYWORD OR SWITCH UNIT IN NAME FROM DATA(BINARY) TO DATA')
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. CDAT%IOUT==IU )  THEN
          !
          IF (CDAT%IOUT==IU) WRITE(IU,*)
          !
          CALL CDAT%OUT_INPUT%SET_HEADER( '    PER    STP   CROP  CROP_NAME'//REPEAT(' ',LL-6)//' WBS    ROW    COL GW_INT    IRR       EFFICIENCY         FRACTION             AREA        FRAC_TRAN    FRAC_EVAP_PRE    FRAC_EVAP_IRR FRAC_SW_LOSS_PRE FRAC_SW_LOSS_IRR              GSE        ROOT_ELEV  LOW_EXTINC_ELEV   POND_DEPTH_TOL            PSI_1            PSI_2            PSI_3            PSI_4' )
    END IF
    !
    IF(.NOT. CDAT%MULTI_CROP_CELLS) THEN
           FRAC = '1.0'
           FRAC = ADJUSTR(FRAC)
    END IF
    !
    DO I=ONE, CDAT%NCROP
       !
       IF(CDAT%HAS_PSI .AND. CDAT%CROP(I)%N > Z) THEN; 
           PSI1 = CDAT%CROP(I)%PSI(ONE  )
           PSI2 = CDAT%CROP(I)%PSI(TWO  )
           PSI3 = CDAT%CROP(I)%PSI(THREE)
           PSI4 = CDAT%CROP(I)%PSI(FOUR )
       ELSE;          
           PSI1 = DZ
           PSI2 = DZ
           PSI3 = DZ
           PSI4 = DZ
       END IF
       !
       DO K=ONE, CDAT%CROP(I)%N
           !
           R = CDAT%CROP(I)%RC(ONE,K)
           C = CDAT%CROP(I)%RC(TWO,K)
           F = CDAT%CROP(I)%FID(K) 
           !
           GW_INTER = CDAT%CROP(I)%GW_INTER(K)
           IRR      = CDAT%CROP(I)%IRR(K)
           !
           GSE = CDAT%CROP(I)%GSE(K)
           AREA= CDAT%CROP(I)%AREA(K)
           !
           IF(CDAT%MULTI_CROP_CELLS) THEN
               FRAC = NUM2STR( CDAT%CROP(I)%FRAC(K))
               FRAC = ADJUSTR(FRAC)
           END IF
           !
           FTR = CDAT%CROP(I)%FTR(K)
           FEI = CDAT%CROP(I)%FEI(K)
           FIESWP = CDAT%CROP(I)%FIESWP(K)
           FIESWI = CDAT%CROP(I)%FIESWI(K)
           IF(CDAT%HAS_POND) THEN; POND = CDAT%CROP(I)%POND(K)
           ELSE;                   POND = DZ
           END IF
           SS  = CDAT%CROP(I)%SS(K) 
           LXX = CDAT%CROP(I)%LXX(K) 
           !
           IF(CDAT%CROP(I)%NOT_FALLOW(K)) THEN
              !
              IF(CDAT%CROP(I)%IRR(K)>Z ) THEN; EFF = CDAT%CROP(I)%EFF(K)
              ELSE;                            EFF = DZ
              END IF
           ELSE
              EFF = DZ
           END IF
           !
           WRITE(IU, '(3I7, 2x A, 5I7, 16A17)') KPER, KSTP, I, CDAT%CROP_NAME(I)(:LL),  F, R, C, GW_INTER, IRR, NUM2STR(EFF), FRAC, NUM2STR(AREA), NUM2STR(FTR), NUM2STR(UNO-FTR), NUM2STR(FEI), NUM2STR(FIESWP), NUM2STR(FIESWI), NUM2STR(GSE), NUM2STR(SS), NUM2STR(LXX), NUM2STR(POND), NUM2STR(PSI1), NUM2STR(PSI2), NUM2STR(PSI3), NUM2STR(PSI4)
       END DO
       
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_BARE(CDAT, WBS, KPER, KSTP, DELT, DYEAR, DATE, FRINGE)
    CLASS(CROP_DATA),INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),  INTENT(IN   ):: WBS
    INTEGER,         INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,INTENT(IN   ):: DELT
    DOUBLE PRECISION,INTENT(IN   ):: DYEAR
    CHARACTER(*),    INTENT(IN   ):: DATE
    DOUBLE PRECISION, DIMENSION(:,:),CONTIGUOUS,INTENT(IN):: FRINGE
    INTEGER:: IU, R, C
    DOUBLE PRECISION:: AREA, FRAC, BARE_EVAP, BARE_EVAP_P, RO, DP, P, H, GSE, LXX!, TRAN, EGW,TGW 
    CHARACTER(17):: ZER, DT
    !
    IF(CDAT%OUT_BARE%IU == Z) RETURN  !NOTHING TO PRINT OUT
    IF(.NOT. CDAT%CHECK_BARE  ) THEN  !NO BARREN LAND TO WRITE OUT
        !WRITE(CDAT%IOUT,'(A)') 'WARNING: FMP CROP REQUESTED TO WRITE OUT BARREN LAND OUTPUT, BUT THERE IS NO BARREN LAND TO REPORT! (PLEASE SPECIFY A ET REF OR BARREN EVAP).'
        CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP REQUESTED TO WRITE OUT BARREN LAND OUTPUT, BUT THERE IS NO BARREN LAND TO REPORT! (PLEASE SPECIFY A ET REF OR BARREN EVAP).', INLINE=TRUE)
        RETURN  
    END IF
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !DDT = DBLE(DELT)
    !
    CALL CDAT%OUT_BARE%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = CDAT%OUT_BARE%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. CDAT%IOUT==IU )  THEN
        IF(CDAT%OUT_BARE%BINARY) THEN 
            WRITE(CDAT%IOUT,'(A,/A)')'BARE LAND INFORMATION OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), ROW (int), COL (int), CELL_FRACTION (double), AREA (double), PRECIPITATION (double), TOT_DEEP_PERC (double), TOT_SURF_RUNOFF (double), EVAP_PRECIP (double), EVAP_GW (double), GW_HEAD (double), GSE (double), LOW_EXTINC_ELEV (double)"
        ELSE
            !
            IF (CDAT%IOUT==IU) WRITE(IU,*)
            !                                                                                                                                                                                    
            CALL CDAT%OUT_BARE%SET_HEADER( '    PER    STP    ROW    COL    CELL_FRACTION             AREA    PRECIPITATION    TOT_DEEP_PERC  TOT_SURF_RUNOFF EVAP_PRECIP_BARE     EVAP_GW_BARE          GW_HEAD              GSE  LOW_EXTINC_ELEV             DELT   DYEAR            DATE_START' )
        END IF
    END IF
    !
    DO C=ONE, WBS%NCOL
    DO R=ONE, WBS%NROW
    IF(CDAT%BARE_FRAC(C,R) > DZ) THEN
        FRAC  = CDAT%BARE_FRAC(C,R)
        AREA  =  FRAC * WBS%AREA(C,R)
        BARE_EVAP  =  CDAT%BARE_EVAP(C,R)
        BARE_EVAP_P=  CDAT%BARE_EVAP_PRECIP(C,R)
        GSE        =  CDAT%BARE_GSE(C,R)
        P = CDAT%BARE_TOT_PRECEP(C,R)
        LXX = GSE-FRINGE(C,R) 
        !
        IF(WTABLE(C,R) <= NEAR_ninf) THEN  ! ALL LAYERS ARE IBOUND=Z SO NO PERMIABLE MATERIAL TO PERCOLATE INTO
                       RO = CDAT%BARE_PRECEP_EXCESS(C,R)
                       DP = DZ
                       CALL SET_NAN(H)
        ELSE
                       RO = CDAT%BARE_PRECEP_EXCESS(C,R) * (      CDAT%BARE_FRAC_RUNOFF(C,R))
                       DP = CDAT%BARE_PRECEP_EXCESS(C,R) * (UNO - CDAT%BARE_FRAC_RUNOFF(C,R))
                       H =  WTABLE(C,R)
        END IF
        IF(CDAT%OUT_BARE%BINARY) THEN
            WRITE(IU) DATE, DYEAR, DELT, KPER, KSTP, R, C, FRAC, AREA, P, DP, RO, BARE_EVAP_P, BARE_EVAP, H, GSE, LXX
        ELSE
            WRITE(IU, '(4I7, 11A17, 2x F13.7, 2x A)') KPER, KSTP, R, C, NUM2STR(FRAC), NUM2STR(AREA), NUM2STR(P), NUM2STR(DP), NUM2STR(RO), NUM2STR(BARE_EVAP_P), NUM2STR(BARE_EVAP), NUM2STR(H), NUM2STR(GSE), NUM2STR(LXX),DT, DYEAR, DATE
        END IF
    END IF
    END DO
    END DO
    !
  END SUBROUTINE
  !
  !SUBROUTINE PRINT_OUT_ROOT(CDAT, WBS, KPER, KSTP, DELT, DYEAR, DATE)  --NOT COMPLETE
  !  CLASS(CROP_DATA),INTENT(INOUT):: CDAT
  !  TYPE(WBS_DATA),  INTENT(IN   ):: WBS
  !  INTEGER,         INTENT(IN   ):: KPER, KSTP
  !  REAL,            INTENT(IN   ):: DELT
  !  DOUBLE PRECISION,INTENT(IN   ):: DYEAR
  !  CHARACTER(*),    INTENT(IN   ):: DATE
  !  INTEGER:: IU, F, I, K, R, C
  !  DOUBLE PRECISION:: 
  !  CHARACTER(17):: ZER, DT
  !  !
  !  IF(CDAT%OUT_ROOT%IU == Z) RETURN  !NOTHING TO PRINT OUT
  !  !
  !  DT = NUM2STR(DELT)
  !  DT = ADJUSTR(DT)
  !  ZER = '0.0'; ZER = ADJUSTR(ZER)
  !  DDT = DBLE(DELT)
  !  !
  !  CALL CDAT%OUT_ROOT%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
  !  !
  !  IU = CDAT%OUT_ROOT%IU
  !  !
  !  IF( (KPER==ONE .AND. KSTP==ONE) .OR. CDAT%IOUT==IU )  THEN
  !      IF(CDAT%OUT_ROOT%BINARY) THEN 
  !          WRITE(CDAT%IOUT,'(A,/A)')'CROP ROOT INFORMATION TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), CROP ID (int), AREA (double), IRRIGATED AREA (double), CU_INI (double), CU (double), CIR_INI (double), CIR (double), DEMAND_INI (double), DEMAND (double), TRAN_IRR (double), TRAN_PRECIP (double), TRAN_GW (double), EVAP_IRR (double), EVAP_PRECIP (double), EVAP_GW (double)"
  !      ELSE
  !          !
  !          IF (CDAT%IOUT==IU) WRITE(IU,*)
  !          !
  !          CALL CDAT%OUT_ROOT%SET_HEADER( '    PER    STP   CROP             AREA   IRRIGATED_AREA           CU_INI               CU          CIR_INI              CIR       DEMAND_INI           DEMAND         TRAN_IRR      TRAN_PRECIP          TRAN_GW         EVAP_IRR      EVAP_PRECIP          EVAP_GW             DELT   DYEAR            DATE_START' )
  !      END IF
  !  END IF
  !  !
  !  DO I=ONE, CDAT%NCROP
  !     DO K=ONE, CDAT%CROP(I)%N
  !         !
  !         R = CDAT%CROP(I)%RC(ONE,K)
  !         C = CDAT%CROP(I)%RC(TWO,K)
  !         F = CDAT%CROP(I)%FID(K) 
  !         !
  !         AREA= CDAT%CROP(I)%AREA(K)
  !         EGWA= CDAT%CROP(I)%EGWA(K)
  !         !
  !         CU_I= CDAT%CROP(I)%CU  (K)
  !         CU  = CDAT%CROP(I)%TI(K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%EPPOT(K) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%EGWA(K) !CDAT%CROP(I)%EGWA(K) !TRAN*CDAT%CROP(I)%FTR(K) + TRAN*(UNO - CDAT%CROP(I)%FTR(K))
  !         EP  = CDAT%CROP(I)%EPPOT(K)
  !         !
  !         IF(CDAT%CROP(I)%NOT_FALLOW(K)) THEN
  !            EI  = CDAT%CROP(I)%TI  (K) * CDAT%CROP(I)%CECT(K)
  !            TI  = CDAT%CROP(I)%TI  (K)
  !            TP  = CDAT%CROP(I)%TP  (K)
  !            TGWA= CDAT%CROP(I)%TGWA(K)
  !            CIR = CDAT%CROP(I)%CIR (K)
  !            DMD = CDAT%CROP(I)%DEMAND (K)
  !            CIRI= CDAT%CROP(I)%CIR_INI(K)
  !            DMDI=DMD
  !            IF(CDAT%CROP(I)%EFF(K)>DZ) DMDI= CDAT%CROP(I)%CIR_INI(K)/CDAT%CROP(I)%EFF(K)
  !         ELSE
  !            EI  = DZ
  !            TI  = DZ
  !            TP  = DZ
  !            TGWA= DZ
  !            CIR = DZ
  !            DMD = DZ
  !            CIRI= DZ
  !            DMDI= DZ
  !         END IF
  !         !
  !         IF(CDAT%OUT_ROOT%BINARY) THEN
  !             IF(CDAT%CROP(I)%N == Z) THEN
  !                 WRITE(IU) DATE, DYEAR, DDT, KPER, KSTP, I, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ
  !             ELSE
  !                 WRITE(IU) DATE, DYEAR, DDT, KPER, KSTP, I, AREA, WBS%IRR_AREA(F), CU_I, CU, CIRI, CIR, DMDI, DMD, TI, TP, TGWA, EI, EP, EGWA, BARE_EVAP, BARE_EVAP_P
  !             END IF
  !         ELSEIF(CDAT%CROP(I)%N == Z) THEN
  !                 !
  !                 WRITE(IU, '(3I7, 14A17, 2x F13.7, 2x A)') KPER, KSTP, I, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, DT, DYEAR, DATE
  !         ELSE
  !                 WRITE(IU, '(6I7, 14A17, 2x F13.7, 2x A)') KPER, KSTP, I, F, R, C, NUM2STR(AREA), NUM2STR(CU_I), NUM2STR(CU), NUM2STR(CIRI), NUM2STR(CIR ), NUM2STR(DMDI), NUM2STR(DMD), NUM2STR(TI), NUM2STR(TP), NUM2STR(TGWA), NUM2STR(EI), NUM2STR(EP), NUM2STR(EGWA), DT, DYEAR, DATE
  !         END IF
  !     END DO
  !     
  !  END DO
  !  !
  !END SUBROUTINE
  !
  PURE FUNCTION RTFUNC(D,M,N,Y)
    !******************************************************************
    !SOLUTION OF ANALYTICAL FUNTION FITTING VERTICAL PRESSURE HEAD
    !DISTRIBUTION OVER DEPTH USING BISECTION METHOD.
    !******************************************************************
    !   SPECIFICATIONS:
    !------------------------------------------------------------------
    DOUBLE PRECISION,INTENT(IN ):: D,M,N,Y
    DOUBLE PRECISION:: RTFUNC    
    !
    !DOUBLE PRECISION:: XACC=1D-5,TOL= 1D-5                           !PRECISION TO SOLVE ROOT AT
    DOUBLE PRECISION:: X1,X2,DX,F,FMID,XMID
    INTEGER:: J
    !
    !1===== DEFINE EXCLUSIONS
    IF(D.LE.UNO) THEN
                     IF(Y < D) THEN
                         RTFUNC=Y
                     ELSE
                         RTFUNC=D
                     END IF
                     RETURN
    ELSEIF (Y.LE.UNO .OR. ABS(D-M).LT.NEARZERO_5 ) THEN
                     RTFUNC=Y
                     RETURN
    END IF
    !
    !2===== DEFINE LATERAL BOUNDS X1 AND X2
    IF(Y.GE.D) THEN
          IF(N > NEARZERO_30) THEN
              X1 = ((LOG(Y/D)/LOG(M/D))**(UNO/N)) * (D-UNO) + UNO - NEARZERO_5
          ELSE
              X1 = ((LOG(Y/D)/LOG(M/D))**(1D30))  * (D-UNO) + UNO - NEARZERO_5
          END IF
          !
          IF(X1 < UNO) X1 = UNO
    ELSE
              X1 = UNO
    END IF
    !
    IF(N > NEARZERO_30) THEN
              X2 = ((DLOG((Y+D)/D)/DLOG(M/D))**(UNO/N)) * (D-UNO) + UNO + NEARZERO_5
    ELSE
              X2 = ((DLOG((Y+D)/D)/DLOG(M/D))**(1D30))  * (D-UNO) + UNO + NEARZERO_5
    END IF
    IF(X2 > Y) X2 = Y + NEARZERO_5
    !
    !3===== FIND THE ROOT OF A FUNCTION KNOWN TO LIE BETWEEN X1 AND X2.
    FMID=FUNC(X2,D,M,N,Y)
    F=FUNC(X1,D,M,N,Y)
    IF(F*FMID.GE.0D0) THEN
        RTFUNC = IEEE_VALUE(F, IEEE_QUIET_NAN)
        RETURN
    END IF
    !
    !3A-----ORIENT SEARCH SO THAT F>0 LIES AT X+DX    
    IF(F < DZ)THEN
        RTFUNC = X1
        DX = X2 - X1
    ELSE
        RTFUNC = X2
        DX = X1 - X2
    ENDIF
    !
    !3B-----BISECTION LOOP
    !       (REDEFINE ROOT, RETURNED AS RTFUNC, UNTIL ITS ACCURACY IS ? XACC)
    DO J=ONE, 250     !----------STOP AFTER 250 ITERATIONS
                 DX = 0.5D0 * DX
                 XMID=RTFUNC+DX
                 FMID=FUNC(XMID,D,M,N,Y)
                 !
                 IF(FMID.LE.DZ) RTFUNC=XMID
                 IF(ABS(DX) < NEARZERO_5 .OR. ABS(FMID).LE.NEARZERO_5) EXIT
                 !
                 IF (J==250) RTFUNC = IEEE_VALUE(F, IEEE_QUIET_NAN)  !  DEBUGGING-----------------------------------------------------
    END DO

  END FUNCTION RTFUNC
  !
  PURE FUNCTION FUNC(X,D,M,N,Y)
    !******************************************************************
    !FORMULATION OF ANALYTICAL FUNTION F(X)=Y AS F(X)-Y=0
    !******************************************************************
    DOUBLE PRECISION,INTENT(IN):: X,D,M,N,Y
    DOUBLE PRECISION:: FUNC
    !
    FUNC = D*((M/D)**(((X-1D0)/(D-1D0))**N)) + X - D - Y
    ! 
  END FUNCTION FUNC
  !
!  PURE ELEMENTAL SUBROUTINE ADJUST_CIR_TO_INCLUDE_PRECIP(CROP)
!    CLASS(CROP_PROP), INTENT(INOUT):: CROP
!    INTEGER:: K
!    !
!    DO CONCURRENT ( K=ONE:CROP%N )
!        !
!        !   NOT FALLOWED CROP         IRRIGATED CROP       PRECIP DOES NOT SATISFY NEEDS
!        IF( CROP%NOT_FALLOW(K) .AND. CROP%IRR(K) > Z .AND. CROP%TPPOT(K) < CROP%TSUR(K) ) THEN
!            !
!            CROP%TSUR(K) = ( CROP%TSUR(K) - CROP%TPPOT(K) ) * (UNO + CROP%CECT(K))  !(TSUR-TP)*(1+ FEI/FTR)  --NOTE THAT IF FTR=0 THEN TGW = 0, SO TSUR =0 WHICH IS < TPPOT SO CONDITION FAILS
!        ELSE
!            CROP%TSUR(K) = DZ
!        END IF
!    END DO
!    !
!  END SUBROUTINE
  !
!  SUBROUTINE GET_CROP_COUNT_AND_NAMES( BL, CDAT, Z, ONE, ERROR )  !=ASSUMES FWEL IS OF SIZE NFARMS  ---Called from FMP main to load FWEL 
!    !USE LINKED_LIST_INSTRUCTION, ONLY:CHARACTER_LINKED_LIST
!    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL   !DATA BLOCK
!    CLASS(CROP_DATA),            INTENT(INOUT):: CDAT
!    INTEGER,                     INTENT(IN   ):: Z, ONE
!    CHARACTER(5),                INTENT(IN   ):: ERROR
!    TYPE(GENERIC_INPUT_FILE):: FL
!    CHARACTER(:), ALLOCATABLE:: LN
!    INTEGER:: I,LLOC,ISTART,ISTOP,IERR,NCROP
!    CHARACTER(20), DIMENSION(:), ALLOCATABLE:: CROPNAME, CTMP
!    CHARACTER(20):: NAME
!    REAL:: R
!    !
!    CALL BL%LIST%START()
!    CALL BL%LIST%SET_LN()
!    !
!    DO I=1, BL%NLINE
!      IF(  BL%LIST%LN==ERROR ) CALL FILE_IO_ERROR(Z,BL%IU, OUTPUT=BL%IOUT,MSG='UNFORTUNATELY UNKNOWN CROP BLOCK ERROR. PLEASE DOUBLE CHECK BLOCK SET UP.')
!      LLOC=ONE
!      CALL URWORD(BL%LIST%LN,LLOC,ISTART,ISTOP,ONE,I,R,BL%IOUT,BL%IU)
!      !
!      IF ( BL%LIST%LN(ISTART:ISTOP) == 'NAME') THEN
!                 CALL FL%OPEN(LLOC, BL%LIST%LN, BL%IOUT, BL%IU, NOSTOP=.TRUE., REQKEY=.TRUE.)  !GET LOCATION THAT HOLDS LIST OF FEEDFILE NAMES
!                 EXIT
!      END IF
!      !
!      CALL BL%LIST%NEXT()
!      CALL BL%LIST%SET_LN()
!    END DO
!    !
!    IF ( BL%LIST%LN(ISTART:ISTOP) .NE. 'NAME') CALL FILE_IO_ERROR(Z,BL%IU, OUTPUT=BL%IOUT,MSG='FAILED TO IDENTIFY "NAME" KEYWORD WITHIN FMP CROP BLOCK. PLEASE DOUBLE CHECK BLOCK SET UP.')
!    !
!    NCROP=Z
!    !
!    IF(FL%IU == Z .AND. FL%ERROR) THEN  !NAMES ON SAME LINE
!       DO
!         CALL URWORD(BL%LIST%LN,LLOC,ISTART,ISTOP,Z,I,R,BL%IOUT,FL%IU)
!         !
!         IF(BL%LIST%LN(ISTART:ISTOP) == ' ') EXIT
!         !
!         NCROP = NCROP + ONE
!         NAME = BL%LIST%LN(ISTART:ISTOP)
!         !
!         IF(ALLOCATED(CROPNAME)) THEN
!             ALLOCATE(CTMP, SOURCE=[CROPNAME,NAME])
!             CALL MOVE_ALLOC(CTMP,CROPNAME)
!         ELSE
!             ALLOCATE(CROPNAME(ONE), SOURCE=NAME)
!         END IF
!       END DO
!    ELSE             !NAMES IN SEPARATE FILE OR INTERNAL
!       !
!       ALLOCATE(CHARACTER(700)::LN)
!       IF(FL%IU == Z) THEN 
!                          CALL BL%LIST%NEXT()
!                          CALL BL%LIST%SET_LN()
!       END IF
!       DO
!         IF(FL%IU == Z) THEN 
!                            LN = BL%LIST%LN
!                            IF(  BL%LIST%LN==ERROR ) CALL FILE_IO_ERROR(Z,BL%IU, OUTPUT=BL%IOUT,MSG='UNFORTUNATELY UNKNOWN FMP CROP BLOCK ERROR. PLEASE DOUBLE CHECK BLOCK SET UP.')
!         ELSE
!                            CALL READ_TO_DATA(LN, FL%IU)
!         END IF
!         !
!         LLOC = ONE
!         CALL URWORD(LN,LLOC,ISTART,ISTOP,Z,I,R,BL%IOUT,FL%IU)
!         READ(LN(ISTART:ISTOP), *, IOSTAT=IERR) I
!         !
!         IF(IERR.NE.Z .OR. I-NCROP.NE.ONE .OR. LN=='') EXIT
!         !
!         NCROP = I
!         CALL URWORD(LN,LLOC,ISTART,ISTOP,Z,I,R,BL%IOUT,FL%IU)
!         NAME = LN(ISTART:ISTOP)
!         !
!         IF(ALLOCATED(CROPNAME)) THEN
!             ALLOCATE(CTMP, SOURCE=[CROPNAME,NAME])
!             CALL MOVE_ALLOC(CTMP,CROPNAME)
!         ELSE
!             ALLOCATE(CROPNAME(ONE), SOURCE=NAME)
!         END IF
!         !
!         IF(FL%IU == Z) THEN 
!                            CALL BL%LIST%NEXT()
!                            CALL BL%LIST%SET_LN()
!         END IF
!       END DO
!       IF(FL%IU .NE. Z) BACKSPACE(FL%IU)
!    END IF
!    CDAT%NCROP = NCROP
!    !
!    END SUBROUTINE
END MODULE!
!#########################################################################################################
! 
MODULE SALINITY_DATA_FMP_INTERFACE!, ONLY: SALINITY_DATA, INITIALIZE_SALINITY_DATA
  !
  USE    FMP_DIMENSION_INTERFACE, ONLY: FMP_DIMENSION
  USE     WBS_DATA_FMP_INTERFACE, ONLY:     WBS_DATA
  USE    CROP_DATA_FMP_INTERFACE, ONLY:    CROP_DATA
  USE CLIMATE_DATA_FMP_INTERFACE, ONLY: CLIMATE_DATA
  !
  USE CONSTANTS
  USE ARRAY_DATA_TYPES,                  ONLY: DOUBLE_VECTOR,LOGICAL_VECTOR
  USE UTIL_INTERFACE,                    ONLY: FILE_IO_ERROR, STOP_ERROR, WARNING_MESSAGE, PARSE_WORD, PARSE_WORD_UP, GET_INTEGER, GET_NUMBER, IS_NUMBER, UPPER, NEAR_ZERO
  USE NUM2STR_INTERFACE,                 ONLY: NUM2STR
  USE ALLOC_INTERFACE,                   ONLY: ALLOC
  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
  USE GENERIC_OUTPUT_FILE_INSTRUCTION,   ONLY: GENERIC_OUTPUT_FILE
  USE LIST_ARRAY_INPUT_INTERFACE,        ONLY: LIST_ARRAY_INPUT, LIST_ARRAY_INPUT_INT, LIST_ARRAY_INPUT_STR
  USE WARNING_TYPE_INSTRUCTION,          ONLY: WARNING_TYPE
  USE ULOAD_AND_SFAC_INTERFACE
  USE EquationParser, ONLY: EVAL
  !
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: SALINITY_DATA, INITIALIZE_SALINITY_DATA
  !
  TYPE SALINITY_EXPRESSION
      INTEGER:: EVAL = Z
      DOUBLE PRECISION:: VAL=DZ
      CHARACTER(:),ALLOCATABLE:: EXP
      DOUBLE PRECISION:: SF=UNO
  END TYPE
  !
  !TYPE SOURCE_SALINITY
  !    DOUBLE PRECISION:: NRD=DZ, SW=DZ, GW=DZ
  !    DOUBLE PRECISION:: ECw
  !    !
  !    CONTAINS
  !    !
  !    PROCEDURE, PASS(SRC):: SET_ECw  => CALC_ECw_FROM_SOURCES
  !END TYPE
  !
  TYPE IRRIGATION_RATIO
      DOUBLE PRECISION:: NRD=DZ, SW=DZ, GW=DZ
      CONTAINS
      !PROCEDURE, PASS(RAT):: SET_RATIO  => CALC_IRRIGATION_RATIO_FROM_SOURCES
  END TYPE
  !
  TYPE SALINITY_DATA
      INTEGER:: IOUT=Z, LOUT=Z
      INTEGER:: NFARM, NCROP, NIRRG, NROW, NCOL, cNROW
      LOGICAL:: SKIP_SALINITY = TRUE
      LOGICAL:: TFR_READ      = FALSE
      LOGICAL:: CROP_FRACTION = FALSE
      LOGICAL:: HAS_CUSTOM_LR = FALSE
      LOGICAL:: HAS_CUSTOM_AW = FALSE
      LOGICAL:: HAS_NON_CUSTOM= FALSE
      TYPE(SALINITY_EXPRESSION),DIMENSION(:),  ALLOCATABLE:: LR_EXP
      TYPE(SALINITY_EXPRESSION),DIMENSION(:),  ALLOCATABLE:: AW_EXP
      TYPE(DOUBLE_VECTOR),      DIMENSION(:),  ALLOCATABLE:: LR
      TYPE(DOUBLE_VECTOR),      DIMENSION(:),  ALLOCATABLE:: AW
      TYPE(LOGICAL_VECTOR),     DIMENSION(:),  ALLOCATABLE:: INUSE
      DOUBLE PRECISION,         DIMENSION(:),  ALLOCATABLE:: ECe
      DOUBLE PRECISION,         DIMENSION(:),  ALLOCATABLE:: ECw
      DOUBLE PRECISION,         DIMENSION(:),  ALLOCATABLE:: MAX_LR
      DOUBLE PRECISION,         DIMENSION(:,:),ALLOCATABLE:: IRR_UNI
      DOUBLE PRECISION,         DIMENSION(:,:),ALLOCATABLE:: SUP_PPM
      DOUBLE PRECISION:: MIN_VARIABLE
      !
      TYPE(GENERIC_OUTPUT_FILE):: OUT_BYFARMCROP
      TYPE(GENERIC_OUTPUT_FILE):: OUT_BYFARM
      TYPE(GENERIC_OUTPUT_FILE):: OUT_ALL
      TYPE(GENERIC_OUTPUT_FILE):: OUT_INPUT
      !
      TYPE(LIST_ARRAY_INPUT_STR):: LR_TFR
      TYPE(LIST_ARRAY_INPUT_STR):: AW_TFR
      TYPE(LIST_ARRAY_INPUT    ):: MAX_LR_TFR
      TYPE(LIST_ARRAY_INPUT    ):: AW_PPM_TFR
      TYPE(LIST_ARRAY_INPUT    ):: STOL
      TYPE(LIST_ARRAY_INPUT    ):: IRR_UNI_TFR
      TYPE(LIST_ARRAY_INPUT_INT):: USED
      !
      CONTAINS
      !
      PROCEDURE, PASS(SALT):: NEXT        => SETUP_NEXT_STRESS_PERIOD!(CDAT,WBS)
      PROCEDURE, PASS(SALT):: NEXT_TS     => SETUP_NEXT_TIME_STEP
      PROCEDURE, PASS(SALT):: CROP_BY_TS  => SETUP_CROP_BY_TIME_STEP
      PROCEDURE, PASS(SALT):: DEMAND_CALC => CALCULATE_SALINTY_DEMAND!(CDAT)
      PROCEDURE, PASS(SALT):: PRINT_OUT_BYFARM
      PROCEDURE, PASS(SALT):: PRINT_OUT_BYFARM_BYCROP
      PROCEDURE, PASS(SALT):: PRINT_OUT_ALL_CROP
      FINAL:: DEALLOCATE_SALINITY_FINAL
  END TYPE
  !
  CONTAINS
  !
  SUBROUTINE DEALLOCATE_SALINITY_FINAL(SALT)
     TYPE(SALINITY_DATA)::SALT
     CALL DEALLOCATE_SALINITY(SALT)
  END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_SALINITY(SALT)
  CLASS(SALINITY_DATA), INTENT(INOUT)::SALT
     !
     SALT%IOUT  = Z
     SALT%LOUT  = Z
     SALT%TFR_READ    = FALSE
     !IF(ALLOCATED(SALT%XXX)) DEALLOCATE(SALT%XXX)
     !
  END SUBROUTINE
  !  
  SUBROUTINE INITIALIZE_SALINITY_DATA( BL, SALT, LINE, FDIM, CROP_FRACTION )
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL   !DATA BLOCK
    CLASS(SALINITY_DATA),        INTENT(INOUT):: SALT
    CHARACTER(*),                INTENT(INOUT):: LINE
    TYPE(FMP_DIMENSION),         INTENT(IN   ):: FDIM
    LOGICAL,                     INTENT(IN   ):: CROP_FRACTION
    !INTEGER,                     INTENT(IN   ):: LENUNI
    !
    !CHARACTER(:),ALLOCATABLE:: ERR
    CHARACTER(5):: ERROR
    CHARACTER(6):: BYCROP, BYFARM
    LOGICAL:: EOF
    INTEGER:: I, LLOC, ISTART, ISTOP, LINELEN, cNROW
    LOGICAL:: BINARY
    TYPE(WARNING_TYPE):: WARN_MSG
    !
    CALL WARN_MSG%INIT()
    !
    WRITE(BL%IOUT,'(/A/)') 'SALINITY BLOCK FOUND AND NOW LOADING PROPERTIES'
    !
    IF(FDIM%NCROP == Z .OR. FDIM%NIRRG==Z) RETURN
    !
    LINELEN = NEG
    !SALT%HAS_SALINITY = TRUE
    SALT%IOUT = BL%IOUT
    SALT%LOUT = BL%IOUT
    SALT%NCROP = FDIM%NCROP
    SALT%NFARM = FDIM%NFARM
    SALT%NIRRG = FDIM%NIRRG
    !
    SALT%NCOL = FDIM%NCOL
    SALT%NROW = FDIM%NROW
    !
    SALT%CROP_FRACTION = CROP_FRACTION
    !
    !SELECT CASE (LENUNI)
    !CASE(Z);     SUP%TO_LITER = 1000D0
    !CASE(ONE);   SUP%TO_LITER = 28.316846592D0
    !CASE(TWO);   SUP%TO_LITER = 1000D0
    !CASE(THREE); SUP%TO_LITER = 0.001D0
    !END SELECT
    !
    cNROW = FDIM%NROW
    IF(CROP_FRACTION) cNROW = cNROW * SALT%NCROP !LOAD IN NCROP SETS OF NROWS
    SALT%cNROW = cNROW
    !
    ALLOCATE(SALT%ECw   (SALT%NFARM)      )
    !
    ALLOCATE(SALT%INUSE (SALT%NCROP)      )
    ALLOCATE(SALT%LR_EXP(SALT%NCROP)      )
    ALLOCATE(SALT%AW_EXP(SALT%NCROP)      )
    ALLOCATE(SALT%LR    (SALT%NCROP)      )
    ALLOCATE(SALT%AW    (SALT%NCROP)      )
    ALLOCATE(SALT%ECe   (SALT%NCROP)      )
    ALLOCATE(SALT%MAX_LR(SALT%NCROP)      )
    !
    ALLOCATE(SALT%SUP_PPM(FOUR,SALT%NCROP))
    !
    ALLOCATE(SALT%IRR_UNI(SALT%NIRRG,SALT%NFARM))
    !
    !ULOAD_LINE = BLNK
    !
    ERROR  = 'ERROR'
    BYFARM = 'BYWBS'
    BYCROP = 'BYCROP'
    !
    SALT%MIN_VARIABLE = DZ
    !
    ! LOOK FOT LINELEN
    CALL BL%START()
    DO I=ONE, BL%NLINE
                    LLOC=ONE
                    CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP)
                    !
                    SELECT CASE(BL%LINE(ISTART:ISTOP))
                    CASE("EXPRESSION_LINE_LENGTH","LINELEN"); CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,LINELEN,MSG='SALINITY BLOCK KEYWORD "EXPRESSION_LINE_LENGTH"; FAILED TO LOAD THE MAXIMUM LENGTH OF THE EXPRESSION LINES.')
                    END SELECT
                    !
                    CALL BL%NEXT()
    END DO
    !
    IF(LINELEN == NEG) THEN
        CALL WARNING_MESSAGE(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='SALINITY BLOCK FAILED TO IDENTIFY KEYWORD "EXPRESSION_LINE_LENGTH" (LINELEN).'//NL//'--- IT WILL BE AUTOMATICALLY SET TO 20 ---'//NL//'IT IS RECOMMENDED TO SPECIFY THE MAXIMUM LENGTH OF LINES USED FOR KEYWORDS "CROP_LEACHING_REQUIREMENT" AND "CROP_SALINITY_DEMAND".'//NL//'NOTE THIS IS ONLY SPACE REQUIRED FOR WHAT IS LOADED AFTER THE RECORD ID,'//NL//'SO IF YOU ONLY USE "RHOADES" OPTION THEN YOU CAN SET IT TO 7 OR GREATER. IF YOU SPECIFY JUST A NUMBER THEN IT SHOULD BE LARGE ENOUGH TO CAPTURE THE NUMBER (e.g. "1.2345E21" SHOULD HAVE A LENGTH GREATER THAN 9'//NL//'IF YOU DO NOT KNOW THE LENGTH, THEN JUST PICK A LARGE NUMBER (SAY 250).', INLINE=TRUE)
        LINELEN = 19
    END IF
    !
    IF(LINELEN < ONE) THEN
        CALL WARNING_MESSAGE(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='SALINITY BLOCK FOUND KEYWORD "EXPRESSION_LINE_LENGTH" (LINELEN) BUT ITS LENTH IS LESS THAN OR EQUAL TO ZERO.'//NL//'--- IT WILL BE AUTOMATICALLY SET TO 20 ---'//NL//'IT IS RECOMMENDED TO SPECIFY THE MAXIMUM LENGTH OF LINES USED FOR KEYWORDS "CROP_LEACHING_REQUIREMENT" AND "CROP_SALINITY_DEMAND".'//NL//'NOTE THIS IS ONLY SPACE REQUIRED FOR WHAT IS LOADED AFTER THE RECORD ID,'//NL//'SO IF YOU ONLY USE "RHOADES" OPTION THEN YOU CAN SET IT TO 7 OR GREATER. IF YOU SPECIFY JUST A NUMBER THEN IT SHOULD BE LARGE ENOUGH TO CAPTURE THE NUMBER (e.g. "1.2345E21" SHOULD HAVE A LENGTH GREATER THAN 9'//NL//'IF YOU DO NOT KNOW THE LENGTH, THEN JUST PICK A LARGE NUMBER (SAY 250).', INLINE=TRUE)
        LINELEN = 19
    END IF
    !
    IF(LINELEN > ONE)  WRITE(BL%IOUT,'(2A)') 'EXPRESSION_LINE_LENGTH (LINELEN) KEYWORD FOUND AND WILL HAVE A MAX EXPRESSION LENGTH OF ', NUM2STR(LINELEN)
    !
    LINELEN = LINELEN + ONE
    IF(LINELEN<20) LINELEN=20
    !
    CALL BL%MAKE_SCRATCH_FILE()  !OR CALL BL%START AND DO I=ONE, BL%NLINE WITH BL%NEXT FOR BL%LINE
    !
    !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
    CALL BL%READ_SCRATCH(EOF, LINE)
    !
    DO WHILE (.NOT. EOF)
      !
      LLOC=ONE
      CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
      !
      SELECT CASE ( LINE(ISTART:ISTOP) )
      !
      CASE("EXPRESSION_LINE_LENGTH","LINELEN"); CONTINUE
      !
      CASE("EXPRESSION_VARIABLE_NEARZERO")
                       CALL GET_NUMBER(LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,SALT%MIN_VARIABLE,  MSG='FMP SALINTY BLOCK "EXPRESSION_VARIABLE_NEARZERO" FAILED TO LOAD THE ACTUAL VALUE.')
      !
      CASE ("CROP_LEACHING_REQUIREMENT")
                        WRITE(BL%IOUT,'(A)') '   CROP_LEACHING_REQUIREMENT                    KEYWORD FOUND.'
                        CALL SALT%LR_TFR%INIT('LR',LLOC, LINE, BL%IOUT, BL%IU, SALT%NCROP, ONE, Z, Z, LINELEN, SALT%NCROP, BYCROP, SCRATCH=BL%SCRATCH, ENTIRE_LINE=TRUE)                  
                        IF(SALT%LR_TFR%TRUNCATED) CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP SALINTY BLOCK LIST-ARRAY INPUT OF "CROP_LEACHING_REQUIREMENT"'  //NL//'INDICATED TO OneWater THAT THE ENTIRE LINE MAY HAVE NOT BEEN LOADED.'//BLN//'THIS MAY BE THE RESULT OF THE KEYWORD "EXPRESSION_LINE_LENGTH" NOT SPECIFYING A LARGE ENOUGH LINELEN'//NL//'   (LINELEN = NUMBER OF CHARACTERS/SPACE TO USE FOR LOADING THE LINE)'//BLN//'THE FOLLOWING IS THE INPUT THAT WAS LOADED,'//NL//'THE "" INDICATE THE START AND END OF WHAT EACH LINE LOADED.'//NL//SALT%LR_TFR%GET_LINES())
      CASE ("CROP_SALINITY_APPLIED_WATER")
                        WRITE(BL%IOUT,'(A)') '   CROP_SALINITY_APPLIED_WATER                    KEYWORD FOUND.'
                        CALL SALT%AW_TFR%INIT('AW',LLOC, LINE, BL%IOUT, BL%IU, SALT%NCROP, ONE, Z, Z, LINELEN, SALT%NCROP, BYCROP, SCRATCH=BL%SCRATCH, ENTIRE_LINE=TRUE)
                        IF(SALT%AW_TFR%TRUNCATED) CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP SALINTY BLOCK LIST-ARRAY INPUT OF "CROP_SALINITY_APPLIED_WATER"'//NL//'INDICATED TO OneWater THAT THE ENTIRE LINE MAY HAVE NOT BEEN LOADED.'//BLN//'THIS MAY BE THE RESULT OF THE KEYWORD "EXPRESSION_LINE_LENGTH" NOT SPECIFYING A LARGE ENOUGH LINELEN'//NL//'   (LINELEN = NUMBER OF CHARACTERS/SPACE TO USE FOR LOADING THE LINE)'//BLN//'THE FOLLOWING IS THE INPUT THAT WAS LOADED,'//NL//'THE "" INDICATE THE START AND END OF WHAT EACH LINE LOADED.'//NL//SALT%AW_TFR%GET_LINES())
      CASE ("CROP_MAX_LEACHING_REQUIREMENT", "MAX_LEACHING_REQUIREMENT")
                        WRITE(BL%IOUT,'(A)') '   CROP_MAX_LEACHING_REQUIREMENT                  KEYWORD FOUND.'
                        CALL SALT%MAX_LR_TFR%INIT('MAX_LR',LLOC, LINE, BL%IOUT, BL%IU, SALT%NCROP, ONE, Z, Z, SALT%NCROP, BYCROP, SCRATCH=BL%SCRATCH)
      CASE ("WBS_SUPPLY_SALT_CONCENTRATION")
                        WRITE(BL%IOUT,'(A)') '   WBS_SUPPLY_SALT_CONCENTRATION  KEYWORD FOUND.'
                        CALL SALT%AW_PPM_TFR%INIT('AW_PPM', LLOC, LINE, BL%IOUT, BL%IU, SALT%NFARM, FOUR, Z, Z, SALT%NFARM, BYFARM, FOUR, 'BYSOURCE', SCRATCH=BL%SCRATCH)
                        !
      CASE ("CROP_SALINITY_TOLERANCE")
                        WRITE(BL%IOUT,'(A)') '   CROP_TOLERANCE                 KEYWORD FOUND.'
                        CALL SALT%STOL%INIT('SAL_TOL', LLOC, LINE, BL%IOUT, BL%IU, SALT%NCROP, ONE, Z, Z, SALT%NCROP, BYCROP, SCRATCH=BL%SCRATCH)
                        !
      CASE ("CROP_HAS_SALINITY_DEMAND", "HAS_CROP_SALINITY_DEMAND")
                        WRITE(BL%IOUT,'(A)') '   CROP_HAS_SALINITY_DEMAND       KEYWORD FOUND.  READ EITHER NCROP LIST, IF USING CROP ID THEN ARRAY IS "NROW by NCOL" AND IF USING CROP FRACTIONS THEN ARRAY IS "NROW*NCROP by NCOL"'
                        CALL SALT%USED%INIT('SAL_CHECK', LLOC, LINE, BL%IOUT, BL%IU, SALT%NCROP, ONE, cNROW, SALT%NCOL, SCRATCH=BL%SCRATCH) !!!---NOTE ITS cNROW---!!!
                        !
      CASE ("WBS_IRRIGATION_UNIFORMITY")
                        WRITE(BL%IOUT,'(A)') '   WBS_IRRIGATION_UNIFORMITY                    KEYWORD FOUND.'
                        CALL SALT%IRR_UNI_TFR%INIT('IRR_UNI', LLOC, LINE, BL%IOUT, BL%IU, SALT%NFARM, SALT%NIRRG, Z, Z, SALT%NFARM, BYFARM, FDIM%NIRRG, 'BYIRRIGATE', SCRATCH=BL%SCRATCH, LISTARRAY=TRUE)
                        !

      CASE ("PRINT")
                        BINARY = FALSE
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        IF(LINE(ISTART:ISTOP) == 'BINARY') THEN
                            BINARY = TRUE
                            CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        END IF
                        !
                        SELECT CASE ( LINE(ISTART:ISTOP) )
                        CASE ("BYWBS","BYFARM")
                                          CALL SALT%OUT_BYFARM%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("BYWBSBYCROP","BYWBSCROP","BYWBS_BYCROP","BYFARMBYCROP","BYFARMCROP","BYFARM_BYCROP")
                                          CALL SALT%OUT_BYFARMCROP%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("ALL")
                                          CALL SALT%OUT_ALL%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        !CASE ("DETAIL")
                        !                  CALL SALT%OUT_ALL%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("INPUT")
                                          CALL SALT%OUT_INPUT%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        !
                        CASE DEFAULT;     CALL STOP_ERROR(LINE,BL%IU,BL%IOUT,'FMP FWELL BLOCK KEYWORD ERROR. IDENTIFIED KEYWORD "PRINT", BUT THE NEXT WORD WAS NOT IDENTIFIED.'//NL//'WORDS EXPECTED ARE: "BYFARM", "BYCROP", "ALL", "INPUT"')
                        END SELECT
      CASE DEFAULT
                        CALL WARN_MSG%ADD('FOUND UNKNOWN KEYWORD "'//LINE(ISTART:ISTOP)//'" ***IT WILL BE IGNORED***'//BLN)
                        
      END SELECT
      !
      !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
      CALL BL%READ_SCRATCH(EOF, LINE)
      !
    END DO
    !
    CALL WARN_MSG%CHECK(HED='FMP SALINITY BLOCK'//NL,INFILE=BL%IU,OUTPUT=BL%IOUT,INLINE=TRUE,CMD_PRINT=TRUE,TAIL=NL)
    !
    SALT%SKIP_SALINITY = FALSE
    !IF(SALT%USED%INUSE) THEN
    !    IF(.NOT. SALT%USED%TRANSIENT) THEN
    !        IF(SALT%USED%LISTLOAD) THEN
    !            IF(ALL(SALT%USED%LIST  == Z)) SALT%SKIP_SALINITY = TRUE
    !        ELSE
    !            IF(ALL(SALT%USED%ARRAY == Z)) SALT%SKIP_SALINITY = TRUE
    !        END IF
    !    END IF
    !ELSE!
    IF(.NOT. SALT%USED%INUSE) THEN
        CALL SALT%USED%INIT('GWRT', ONE, BL%IOUT, BL%IU, SALT%NCROP, ONE, Z, Z)
    END IF
    !                                                                                
    !
    !!!!!!!!ERR = NL
    !!!!!!!!!
    !!!!!!!!IF( .NOT. SALT%AW_TFR%INUSE ) ERR = ERR//NL//'FMP CROP ERROR. FAILED TO LOCATE "LOCATION" OR "FRACTION" KEYWORD IN CROP BLOCK, ONE OF THESE IS REQUIRED WHEN NCROP > 0'//NL
    !!!!!!!!IF( .NOT. SALT%LR_TFR%INUSE ) ERR = ERR//NL//'FMP CROP ERROR. FAILED TO LOCATE "CROP_COEFFICIENT" OR "CONSUMPTIVE_USE" KEYWORD IN CROP BLOCK, ONE OF THESE IS REQUIRED WHEN NCROP > 0'//NL
    !!!!!!!!!
    !!!!!!!!IF(.NOT. CDAT%GW_INTER%INUSE) THEN
    !!!!!!!!    CDAT%GW_ROOT_INTERACTION = TRUE
    !!!!!!!!    LLOC=ONE
    !!!!!!!!    LINE='CONSTANT 0'
    !!!!!!!!    CALL CDAT%GW_INTER%INIT('GWRT',LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, BL%SCRATCH)
    !!!!!!!!END IF
    !!!!!!!!!
    !!!!!!!!IF(.NOT. CDAT%ROOT%INUSE .AND. CDAT%GW_ROOT_INTERACTION)  ERR = TRIM(ERR)//NL//'FMP CROP ERROR. THERE IS INTERACTION BETWEEN THE THE CROP ROOTS AND GROUNDWATER LEVEL TO CALCULATE TRANSPIRATION (DEFAULT BEHAIVOR). THIS REQUIRES THE CROP ROOT DEPTH TO BE SPECIFRIED WITH "ROOT DEPTH" OR "ROOT_DEPTH" KEYWORD IN CROP BLOCK. EITHER SPECIFY ROOT DEPTHS OR USE KEYWORD "GROUNDWATER_INTERACTION" AND SET ALL VALUES TO ZERO TO PREVENT ANY ROOT-GW INTERACTION.'//NL
    !!!!!!!!!
    !!!!!!!!IF(ERR .NE. NL) CALL STOP_ERROR(INFILE=BL%IU,OUTPUT=BL%IOUT,MSG=TRIM(ERR)//NL)
    !
    IF(.NOT. SALT%IRR_UNI_TFR%INUSE) THEN
        CALL SALT%IRR_UNI_TFR%INIT('IRR_UNI', UNO, BL%IOUT, BL%IU, SALT%NFARM, SALT%NIRRG, Z, Z)
    END IF
    !
    ! SET in RP
    !IF(.NOT. SALT%MAX_LR_TFR%INUSE) THEN
    !    CALL SALT%MAX_LR_TFR%INIT('MAX_LR', 0.99D0, BL%IOUT, BL%IU, SALT%NCROP, ONE, Z, Z)
    !END IF
    
    !
  END SUBROUTINE 
  !
  SUBROUTINE SETUP_NEXT_STRESS_PERIOD(SALT,CDAT,WBS)
    CLASS(SALINITY_DATA), INTENT(INOUT):: SALT
    CLASS(CROP_DATA),     INTENT(IN   ):: CDAT
    CLASS(WBS_DATA),      INTENT(IN   ):: WBS
    LOGICAL:: UPDATE
    INTEGER:: I, J, K, R, C, LLOC,ISTART,ISTOP
    CHARACTER(:),ALLOCATABLE:: ERROR
    LOGICAL, DIMENSION(SALT%NCROP):: PRNT
    !
    !IF(SALT%SPKIP_SALINITY) RETURN
    !
    IF(SALT%TFR_READ) THEN
        !
        UPDATE = CDAT%CID%TRANSIENT .OR. (CDAT%MULTI_CROP_CELLS .AND. CDAT%FRAC%TRANSIENT) .OR. CDAT%IRR%TRANSIENT .OR. WBS%NEW_FID
        !
        CALL SALT%LR_TFR     %NEXT()
        CALL SALT%AW_TFR     %NEXT()
        CALL SALT%AW_PPM_TFR %NEXT()
        CALL SALT%STOL       %NEXT()
        CALL SALT%IRR_UNI_TFR%NEXT()
        CALL SALT%USED       %NEXT()
        !
    ELSE
        !
        UPDATE = TRUE
        !
        SALT%TFR_READ = TRUE
    END IF
    !
    IF(UPDATE) CALL SALT%INUSE(:)%ALLOC(CDAT%CROP(:)%N)
    !
    IF( UPDATE ) THEN
            !
            IF(SALT%USED%LISTLOAD) THEN
                DO CONCURRENT (I=ONE:SALT%NCROP)
                      SALT%INUSE(I)%VEC = SALT%USED%LIST(I) .NE. Z
                END DO
            ELSE
                ASSOCIATE (CPR=>CDAT%CROP, TF=>SALT%INUSE, ARRAY=>SALT%USED%ARRAY)
                    DO CONCURRENT (I=ONE:SALT%NCROP)
                         CALL CROP_INPUT_ARRAY_TO_LOGICAL_PROP(CPR(I)%N, CPR(I)%RC, TF(I)%VEC, ARRAY(:,CPR(I)%LD:) )
                    END DO
                END ASSOCIATE
            END IF
            !
            SALT%SKIP_SALINITY = TRUE
            DO I=ONE,SALT%NCROP
                IF(ANY(SALT%INUSE(I)%VEC)) THEN
                   SALT%SKIP_SALINITY = FALSE
                   EXIT
                END IF
            END DO
    END IF
    !
    IF(SALT%SKIP_SALINITY) RETURN !---------------------------------------------
    !
    ERROR = NL
    !
    IF( UPDATE .OR. SALT%USED%TRANSIENT .OR. CDAT%IRR%TRANSIENT) THEN
        !
        IF( CDAT%IRR%LISTLOAD) THEN
            PRNT = TRUE
            DO CONCURRENT (I=ONE:CDAT%NCROP)
            DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, SALT%INUSE(I)%VEC(K) .AND. CDAT%CROP(I)%IRR(K) == Z )
                                                                    SALT%INUSE(I)%VEC(K) = FALSE
                                                                    IF(PRNT(I)) THEN
                                                                                    ERROR = ERROR//BLNK//NUM2STR(I,-8)//NL
                                                                                    PRNT(I) = FALSE
                                                                    END IF
            END DO; END DO

            IF (ERROR.NE.NL) ERROR='FMP SALINTY BLOCK -- FOUND A CROP THAT HAS SALINITY DEMAND,'//NL//                                  &
                                   'BUT IT HAS AN IRRIGATION FLAG EQUAL TO ZERO,'//NL//                                                 &
                                   'SO THERE IS NO WAY TO IRRIGATE CROP TO MEET ADDITINAL SALINITY IRRIGATION DEMAND.'//NL//            &
                                   'THE FOLLOWING IS A LIST OF CROPS THAT HAD THEIR'//NL//                                              &
                                   '"HAS_CROP_SALINITY_DEMAND" FLAG SET FROM TRUE TO FALSE (i.e. 1 BECOMES 0).'//BLN//                  &
                                   ' CROP_ID'//ERROR
        ELSE
            DO CONCURRENT (I=ONE:CDAT%NCROP)
            DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, SALT%INUSE(I)%VEC(K) .AND. CDAT%CROP(I)%IRR(K) == Z )
                                                                    SALT%INUSE(I)%VEC(K) = FALSE
                                                                    R = CDAT%CROP(I)%RC(ONE,K)
                                                                    C = CDAT%CROP(I)%RC(TWO,K)
                                                                    ERROR = ERROR//BLNK//NUM2STR(I,-8)//NUM2STR(R,-10)//' '//NUM2STR(C,-10)//NL
            END DO; END DO
            IF (ERROR.NE.NL) ERROR='FMP SALINTY BLOCK -- FOUND A CROP THAT HAS SALINITY DEMAND,'//NL//                                   &
                                   'BUT IT HAS AN IRRIGATION FLAG EQUAL TO ZERO,'//NL//                                                 &
                                   'SO THERE IS NO WAY TO IRRIGATE CROP TO MEET ADDITINAL SALINITY IRRIGATION DEMAND.'//NL//            &
                                   'THE FOLLOWING IS A LIST OF CROPS THAT HAD THEIR'//NL//                                              &
                                   '"HAS_CROP_SALINITY_DEMAND" FLAG SET FROM TRUE TO FALSE (i.e. 1 BECOMES 0).'//BLN//                  &
                                   ' CROP_ID ROW        COLUMN'//ERROR
        END IF
        !
        IF (ERROR.NE.NL) THEN
            CALL WARNING_MESSAGE(OUTPUT=SALT%LOUT,MSG=ERROR)
            ERROR = NL
        END IF
    END IF
    !
    IF(UPDATE) THEN
               CALL SALT%LR   (:)%ALLOC(CDAT%CROP(:)%N)
               CALL SALT%AW   (:)%ALLOC(CDAT%CROP(:)%N)
    END IF
    !    
    IF( UPDATE .OR. SALT%LR_TFR%TRANSIENT) THEN
        !
        SALT%HAS_CUSTOM_LR = FALSE
        !
        DO CONCURRENT (I=ONE:SALT%NCROP); SALT%LR_EXP(I)%SF = UNO
        END DO
        !
        CALL UPPER(SALT%LR_TFR%LIST)  !ENSURE THAT ALL EXPRESIONS ARE UPPER CASE - ELEMENTAL FUNCTION
        !
        ASSOCIATE (LR=>SALT%LR_EXP, SFAC=>SALT%LR_TFR%SFAC, EXPR=>SALT%LR_TFR%LIST, IN =>SALT%LR_TFR%TFR%IU)
            !
            IF(SFAC%HAS_ALL) THEN
                             DO CONCURRENT (I=ONE:SALT%NCROP); LR(I)%SF = LR(I)%SF * SFAC%ALL
                             END DO
            END IF
            !
            IF(SFAC%HAS_EX1) THEN
                             DO CONCURRENT (I=ONE:SALT%NCROP); LR(I)%SF = LR(I)%SF * SFAC%EX1(I)
                             END DO
            END IF
            !
            DO I=ONE, SALT%NCROP
                !
                IF(IS_NUMBER(EXPR(I))) THEN
                    LR(I)%EVAL = ONE
                    LLOC = ONE
                    CALL GET_NUMBER(EXPR(I),LLOC,ISTART,ISTOP,SALT%IOUT,IN,LR(I)%VAL,  MSG='FMP SALINITY BLOCK LEACHING REQUIREMENT EXPRESSION ERROR; DETECTED SINGLE NUMBER IN EXPRESSION BUT FAILED TO CONVERT IT TO A NUMBER.')
                ELSE
                    LLOC=ONE
                    CALL PARSE_WORD(EXPR(I),LLOC,ISTART,ISTOP)
                    SELECT CASE(EXPR(I)(ISTART:ISTOP))
                    CASE("RHOADES");    LR(I)%EVAL = TWO  !Rhoades Equation (Rhoades, 1974 and Rhoades and Merrill 1976) cited in FAO pub by  Ayers and Wescott (1985)
                    CASE("SKIP","NONE");LR(I)%EVAL = Z  
                    CASE DEFAULT
                                        LR(I)%EVAL = NEG
                                        IF(ALLOCATED(LR(I)%EXP)) DEALLOCATE(LR(I)%EXP, STAT=LLOC)
                                        !
                                        ALLOCATE(LR(I)%EXP, SOURCE=TRIM(EXPR(I)))
                                        SALT%HAS_CUSTOM_LR = TRUE
                    END SELECT
                END IF
            END DO  
        END ASSOCIATE
        IF(SALT%LR_TFR%TRUNCATED .AND. SALT%LR_TFR%TRANSIENT) CALL WARNING_MESSAGE(OUTPUT=SALT%IOUT,MSG='FMP SALINTY BLOCK LIST-ARRAY INPUT OF "CROP_LEACHING_REQUIREMENT"'  //NL//'INDICATED TO OneWater THAT THE ENTIRE LINE MAY HAVE NOT BEEN LOADED.'//BLN//'THIS MAY BE THE RESULT OF THE KEYWORD "EXPRESSION_LINE_LENGTH" NOT SPECIFYING A LARGE ENOUGH LINELEN'//NL//'   (LINELEN = NUMBER OF CHARACTERS/SPACE TO USE FOR LOADING THE LINE)'//BLN//'THE FOLLOWING IS THE INPUT THAT WAS LOADED,'//NL//'THE "" INDICATE THE START AND END OF WHAT EACH LINE LOADED.'//NL//SALT%LR_TFR%GET_LINES())
    END IF
    !
    IF( UPDATE .OR. SALT%AW_TFR%TRANSIENT) THEN
        !
        SALT%HAS_CUSTOM_AW = FALSE
        !
        DO CONCURRENT (I=ONE:SALT%NCROP); SALT%AW_EXP(I)%SF = UNO
        END DO
        !
        CALL UPPER(SALT%AW_TFR%LIST)  !ENSURE THAT ALL EXPRESIONS ARE UPPER CASE - ELEMENTAL FUNCTION
        !
        ASSOCIATE (AW=>SALT%AW_EXP, SFAC=>SALT%AW_TFR%SFAC, EXPR=>SALT%AW_TFR%LIST, IN =>SALT%AW_TFR%TFR%IU)
            !
            IF(SFAC%HAS_ALL) THEN
                             DO CONCURRENT (I=ONE:SALT%NCROP); AW(I)%SF = AW(I)%SF * SFAC%ALL
                             END DO
            END IF
            !
            IF(SFAC%HAS_EX1) THEN
                             DO CONCURRENT (I=ONE:SALT%NCROP); AW(I)%SF = AW(I)%SF * SFAC%EX1(I)
                             END DO
            END IF          
            !
            DO I=ONE, SALT%NCROP
                !
                IF(IS_NUMBER(EXPR(I))) THEN
                    AW(I)%EVAL = ONE
                    LLOC = ONE
                    CALL GET_NUMBER(EXPR(I),LLOC,ISTART,ISTOP,SALT%IOUT,IN,AW(I)%VAL,  MSG='FMP SALINITY BLOCK LEACHING REQUIREMENT EXPRESSION ERROR; DETECTED SINGLE NUMBER IN EXPRESSION BUT FAILED TO CONVERT IT TO A NUMBER.')
                ELSE
                    LLOC=ONE
                    CALL PARSE_WORD(EXPR(I),LLOC,ISTART,ISTOP)
                    SELECT CASE(EXPR(I)(ISTART:ISTOP))
                    CASE("RHOADES");    AW(I)%EVAL = TWO
                    CASE("SKIP","NONE");AW(I)%EVAL = Z  
                    CASE DEFAULT
                                        AW(I)%EVAL = NEG
                                        IF(ALLOCATED(AW(I)%EXP)) DEALLOCATE(AW(I)%EXP, STAT=LLOC)
                                        !
                                        ALLOCATE(AW(I)%EXP, SOURCE=TRIM(EXPR(I)))
                                        SALT%HAS_CUSTOM_AW = TRUE
                    END SELECT
                END IF
            END DO
        END ASSOCIATE
        IF(SALT%AW_TFR%TRUNCATED .AND. SALT%LR_TFR%TRANSIENT) CALL WARNING_MESSAGE(OUTPUT=SALT%IOUT,MSG='FMP SALINTY BLOCK LIST-ARRAY INPUT OF "CROP_SALINITY_APPLIED_WATER"'//NL//'INDICATED TO OneWater THAT THE ENTIRE LINE MAY HAVE NOT BEEN LOADED.'//BLN//'THIS MAY BE THE RESULT OF THE KEYWORD "EXPRESSION_LINE_LENGTH" NOT SPECIFYING A LARGE ENOUGH LINELEN'//NL//'   (LINELEN = NUMBER OF CHARACTERS/SPACE TO USE FOR LOADING THE LINE)'//BLN//'THE FOLLOWING IS THE INPUT THAT WAS LOADED,'//NL//'THE "" INDICATE THE START AND END OF WHAT EACH LINE LOADED.'//NL//SALT%AW_TFR%GET_LINES())
    END IF
    !
    IF( UPDATE .OR. SALT%LR_TFR%TRANSIENT .OR. SALT%AW_TFR%TRANSIENT)  SALT%HAS_NON_CUSTOM = ANY(SALT%LR_EXP(:)%EVAL > Z) .OR. ANY(SALT%AW_EXP(:)%EVAL > Z)
    !
    IF( UPDATE .OR. SALT%AW_PPM_TFR%TRANSIENT) THEN
        SALT%SUP_PPM = SALT%AW_PPM_TFR%ARRAY  !NOTE IT IS STORED AS A LISTARRAY
        !
        ASSOCIATE (SFAC=>SALT%AW_PPM_TFR%SFAC)
            !
            IF(SFAC%HAS_ALL) SALT%SUP_PPM = SALT%SUP_PPM * SFAC%ALL
            !
            IF(SFAC%HAS_EX1) THEN 
                             DO CONCURRENT (            I=ONE:SALT%NFARM); SALT%SUP_PPM(:,I) = SALT%SUP_PPM(:,I) * SFAC%EX1(I)
                             END DO
            END IF
            !
            IF(SFAC%HAS_EX2) THEN 
                             DO CONCURRENT (J=ONE:FOUR, I=ONE:SALT%NFARM); SALT%SUP_PPM(J,I) = SALT%SUP_PPM(J,I) * SFAC%EX2(J)
                             END DO
            END IF
        END ASSOCIATE
        !
        DO CONCURRENT ( I=ONE:SALT%NFARM,J=ONE:FOUR, SALT%SUP_PPM(J,I) < DZ) 
                       SALT%SUP_PPM(J,I) = DZ
                       SELECT CASE(J)
                       CASE(ONE);   ERROR = ERROR//BLNK//NUM2STR(I,-8)//' NRD      SOURCE WATER'//NL
                       CASE(TWO);   ERROR = ERROR//BLNK//NUM2STR(I,-8)//' SW       SOURCE WATER'//NL
                       CASE(THREE); ERROR = ERROR//BLNK//NUM2STR(I,-8)//' GW       SOURCE WATER'//NL
                       CASE(FOUR);  ERROR = ERROR//BLNK//NUM2STR(I,-8)//' EXTERNAL SOURCE WATER'//NL
                       END SELECT
                       
        END DO
        IF (ERROR.NE.NL) THEN
            ERROR='FMP SALINTY BLOCK -- "WBS_SUPPLY_SALT_CONCENTRATION" IS LESS THEN 0,'//NL// &
            'IT IS RESET TO 0.0 ppm [mg/L] (i.e. NO SALT CONCENTRATION) FOR THE FOLLOWING FARMS AND SOURCE WATER TYPES.'//NL//       &
            ' FARM_ID  WATER_SOURCE'//ERROR
            CALL WARNING_MESSAGE(OUTPUT=SALT%LOUT,MSG=ERROR, INLINE=TRUE)
            ERROR = NL
        END IF
    END IF
    !
    IF( UPDATE .OR. SALT%MAX_LR_TFR%TRANSIENT) THEN
        IF(SALT%MAX_LR_TFR%INUSE) THEN
            !
            SALT%MAX_LR = SALT%MAX_LR_TFR%LIST
            !
            ASSOCIATE (SFAC=>SALT%MAX_LR_TFR%SFAC)
              !
              IF(SFAC%HAS_ALL) SALT%MAX_LR = SALT%MAX_LR * SFAC%ALL
              IF(SFAC%HAS_EX1) SALT%MAX_LR = SALT%MAX_LR * SFAC%EX1
              !
            END ASSOCIATE
            !
            DO CONCURRENT ( I=ONE:CDAT%NCROP, SALT%MAX_LR(I) > 0.9999D0) 
                           IF(SALT%MAX_LR(I) > 0.99991D0) ERROR = ERROR//BLNK//NUM2STR(I,-8)//NL
                           SALT%MAX_LR(I) = 0.9999D0
            END DO
            IF (ERROR.NE.NL) THEN
                ERROR='FMP SALINTY BLOCK -- "MAX_LEACHING_REQUIREMENT" IS GREATER THAN 0.9999,'//NL//          &
                'THIS COULD RESULT IN A FLOATING POINT OVERFLOW DUE TO DIVISION BY ZERO.'//NL//               &
                'THE "MAX_LEACHING_REQUIREMENT" IS RESET TO 0.9999 FOR THE FOLLOWING CROPS.'//NL//            &
                ' CROP_ID'//ERROR
                CALL WARNING_MESSAGE(OUTPUT=SALT%LOUT,MSG=ERROR, INLINE=TRUE)
                ERROR = NL
            END IF
        ELSE
            SALT%MAX_LR = 0.99D0
        END IF
    END IF
    !
    IF( UPDATE .OR. SALT%STOL%TRANSIENT) THEN
        SALT%ECe = SALT%STOL%LIST
        !
        IF(SALT%STOL%SFAC%HAS_ALL) SALT%ECe = SALT%ECe * SALT%STOL%SFAC%ALL
        IF(SALT%STOL%SFAC%HAS_EX1) SALT%ECe = SALT%ECe * SALT%STOL%SFAC%EX1
        !
        DO CONCURRENT ( I=ONE:CDAT%NCROP, SALT%ECe(I) < NEARZERO_12) 
                       SALT%ECe(I) = NEARZERO_12
                       ERROR = ERROR//BLNK//NUM2STR(I,-8)//NL
        END DO
        IF (ERROR.NE.NL) THEN
            ERROR='FMP SALINTY BLOCK -- "CROP_SALINITY_TOLERANCE" IS LESS THEN 1E-12,'//NL//                                  &
            'THIS IS TOO CLOSE TO ZERO TO COMPUTE A SALINTY IRRIGATION REQUIREMENT (CROP HAS ZERO TOLERANCE TO SALT).'//NL//  &
            'THE "CROP_SALINITY_TOLERANCE" IS RESET TO 1E-12 FOR THE FOLLOWING CROPS.'//NL//                                  &
            ' CROP_ID'//ERROR
            CALL WARNING_MESSAGE(OUTPUT=SALT%LOUT,MSG=ERROR, INLINE=TRUE)
            ERROR = NL
        END IF
    END IF
    !
    IF( UPDATE .OR. SALT%IRR_UNI_TFR%TRANSIENT) THEN
        !
        SALT%IRR_UNI = SALT%IRR_UNI_TFR%ARRAY   !NOTE IT IS STORED AS A LISTARRAY
        !
        ASSOCIATE (SFAC=>SALT%IRR_UNI_TFR%SFAC)
            !
            IF(SFAC%HAS_ALL) SALT%IRR_UNI = SALT%IRR_UNI * SFAC%ALL
            !
            IF(SFAC%HAS_EX1) THEN 
                             DO CONCURRENT (                  I=ONE:SALT%NFARM); SALT%IRR_UNI(:,I) = SALT%IRR_UNI(:,I) * SFAC%EX1(I)
                             END DO
            END IF
            !
            IF(SFAC%HAS_EX2) THEN 
                             DO CONCURRENT (J=ONE:SALT%NIRRG, I=ONE:SALT%NFARM); SALT%IRR_UNI(J,I) = SALT%IRR_UNI(J,I) * SFAC%EX2(J)
                             END DO
            END IF
        END ASSOCIATE
        !
        DO I=ONE, SALT%NFARM
            IF( ANY(SALT%IRR_UNI(:,I)<NEARZERO_30) ) CALL STOP_ERROR(OUTPUT=SALT%LOUT,MSG='IRRIGATION UNIFORMITY (DU) MUST BE GREATER THAN ZER0 (>0). TO PREVENT ANY DIV/0 ERRORS.')
        END DO
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE SETUP_NEXT_TIME_STEP(SALT)
    CLASS(SALINITY_DATA), INTENT(INOUT):: SALT
    INTEGER:: I
    !
    DO CONCURRENT(I=ONE:SALT%NCROP, SALT%LR(I)%N > Z); SALT%LR(I)%VEC = DZ
    END DO
    DO CONCURRENT(I=ONE:SALT%NCROP, SALT%AW(I)%N > Z); SALT%AW(I)%VEC = DZ
    END DO
    SALT%ECw = DZ
    !
  END SUBROUTINE
  !
  SUBROUTINE SETUP_CROP_BY_TIME_STEP(SALT,CDAT) !CROP LOADS BY TIME STEP SO IT COULD CHANGE IRRIGATION FLAGS
    CLASS(SALINITY_DATA), INTENT(INOUT):: SALT
    CLASS(CROP_DATA),     INTENT(IN   ):: CDAT
    INTEGER:: I, K, R, C
    CHARACTER(:),ALLOCATABLE:: ERROR
    LOGICAL, DIMENSION(SALT%NCROP):: PRNT
    !
    IF(SALT%USED%LISTLOAD) THEN
        DO CONCURRENT (I=ONE:SALT%NCROP)
              SALT%INUSE(I)%VEC = SALT%USED%LIST(I) .NE. Z
        END DO
    ELSE
        ASSOCIATE (CPR=>CDAT%CROP, TF=>SALT%INUSE, ARRAY=>SALT%USED%ARRAY)
            DO CONCURRENT (I=ONE:SALT%NCROP)
                 CALL CROP_INPUT_ARRAY_TO_LOGICAL_PROP(CPR(I)%N, CPR(I)%RC, TF(I)%VEC, ARRAY(:,CPR(I)%LD:) )
            END DO
        END ASSOCIATE
    END IF
    !
    SALT%SKIP_SALINITY = TRUE
    DO I=ONE,SALT%NCROP
        IF(ANY(SALT%INUSE(I)%VEC)) THEN
           SALT%SKIP_SALINITY = FALSE
           EXIT
        END IF
    END DO
    !
    IF(SALT%SKIP_SALINITY) RETURN !---------------------------------------------
    !
    ERROR = NL
    !
    IF( CDAT%IRR%LISTLOAD) THEN
        PRNT = TRUE
        DO CONCURRENT (I=ONE:CDAT%NCROP)
        DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, SALT%INUSE(I)%VEC(K) .AND. CDAT%CROP(I)%IRR(K) == Z )
                                                                SALT%INUSE(I)%VEC(K) = FALSE
                                                                IF(PRNT(I)) THEN
                                                                                ERROR = ERROR//BLNK//NUM2STR(I,-8)//NL
                                                                                PRNT(I) = FALSE
                                                                END IF
        END DO; END DO

        IF (ERROR.NE.NL) ERROR='FMP SALINTY BLOCK -- FOUND A CROP THAT HAS SALINITY DEMAND,'//NL//                                  &
                               'BUT IT HAS AN IRRIGATION FLAG EQUAL TO ZERO,'//NL//                                                 &
                               'SO THERE IS NO WAY TO IRRIGATE CROP TO MEET ADDITINAL SALINITY IRRIGATION DEMAND.'//NL//            &
                               'THE FOLLOWING IS A LIST OF CROPS THAT HAD THEIR'//NL//                                              &
                               '"HAS_CROP_SALINITY_DEMAND" FLAG SET FROM TRUE TO FALSE (i.e. 1 BECOMES 0).'//BLN//                  &
                               ' CROP_ID'//ERROR
    ELSE
        DO CONCURRENT (I=ONE:CDAT%NCROP)
        DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, SALT%INUSE(I)%VEC(K) .AND. CDAT%CROP(I)%IRR(K) == Z )
                                                                SALT%INUSE(I)%VEC(K) = FALSE
                                                                R = CDAT%CROP(I)%RC(ONE,K)
                                                                C = CDAT%CROP(I)%RC(TWO,K)
                                                                ERROR = ERROR//BLNK//NUM2STR(I,-8)//NUM2STR(R,-10)//' '//NUM2STR(C,-10)//NL
        END DO; END DO
        IF (ERROR.NE.NL) ERROR='FMP SALINTY BLOCK -- FOUND A CROP THAT HAS SALINITY DEMAND,'//NL//                                   &
                               'BUT IT HAS AN IRRIGATION FLAG EQUAL TO ZERO,'//NL//                                                 &
                               'SO THERE IS NO WAY TO IRRIGATE CROP TO MEET ADDITINAL SALINITY IRRIGATION DEMAND.'//NL//            &
                               'THE FOLLOWING IS A LIST OF CROPS THAT HAD THEIR'//NL//                                              &
                               '"HAS_CROP_SALINITY_DEMAND" FLAG SET FROM TRUE TO FALSE (i.e. 1 BECOMES 0).'//BLN//                  &
                               ' CROP_ID ROW        COLUMN'//ERROR
    END IF
    !
    IF (ERROR.NE.NL) CALL WARNING_MESSAGE(OUTPUT=SALT%LOUT,MSG=ERROR)
    !
    DEALLOCATE(ERROR)
    !
  END SUBROUTINE
  !
  SUBROUTINE CALCULATE_SALINTY_DEMAND(SALT,CDAT,WBS,CLIM) !<== ASSUMES CIR HAS BEEN CALCULATED
    CLASS(SALINITY_DATA), INTENT(INOUT):: SALT
    TYPE(CROP_DATA),      INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),       INTENT(IN   ):: WBS
    TYPE(CLIMATE_DATA),   INTENT(IN   ):: CLIM
    INTEGER:: I, K, N
    DOUBLE PRECISION:: ECw, ETc, DU, MIN_VAR
    CHARACTER(4),     DIMENSION(:), ALLOCATABLE:: NAM
    DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE:: VAL
    !
    ! CALCULATE SOURCE WATER SALINITY (ECw) --INCLUDES WATER FROM PREVIOUS SALINITY APPLICATION
    ! SW (mg/L)   GW (mg/L)   NRD (mg/L)   MAGIC (mg/L)       (1dS/m = 640ppm = 640 mg/L)
    !
    DO CONCURRENT (I=ONE:SALT%NFARM)
        IF(WBS%SUPPLY(I)%USED > DZ) THEN
            SALT%ECw(I) =                                             &
                        ( WBS%SUPPLY(I)%SFR   *  SALT%SUP_PPM(1,I) +  &
                          WBS%SUPPLY(I)%WEL   *  SALT%SUP_PPM(2,I) +  &
                          WBS%SUPPLY(I)%NRD   *  SALT%SUP_PPM(3,I) +  &
                          WBS%SUPPLY(I)%MAGIC *  SALT%SUP_PPM(4,I)   ) / WBS%SUPPLY(I)%USED
        ELSEIF(WBS%SUPPLY(I)%HAS_MAGIC) THEN
            SALT%ECw(I) = ( SALT%SUP_PPM(1,I) + SALT%SUP_PPM(2,I) + SALT%SUP_PPM(3,I) + SALT%SUP_PPM(4,I) ) / 4D0
            
        ELSE
            SALT%ECw(I) = ( SALT%SUP_PPM(1,I) + SALT%SUP_PPM(2,I) + SALT%SUP_PPM(3,I) ) / 3D0
        END IF
    END DO
    !
    SALT%ECw = SALT%ECw / 640D0 !mg/l  => dS/m
    !
    IF(SALT%SKIP_SALINITY) RETURN  !NOTHING HAS SALINTIY
    !
    ! CONSTRUCT CUSTOM EQUATION VARIABLES IF NECESSARY
    !
    IF(SALT%HAS_CUSTOM_LR .OR. SALT%HAS_CUSTOM_AW) THEN
        N = 24
        ALLOCATE(VAL(N))
        ALLOCATE(NAM,   SOURCE =  &
        [       &  
        'LR  ', &  ! 1 
        'DU  ', &  ! 2
        'CIR ', &  ! 3  
        'ECW ', &  ! 4 
        'ECE ', &  ! 5 
        'CU  ', &  ! 6 
        'DMD ', &  ! 7 
        'ETP ', &  ! 8 
        'ETC ', &  ! 9 
        'P   ', &  ! 10
        'AREA', &  ! 11
        'TGW ', &  ! 12
        'TP  ', &  ! 13
        'TI  ', &  ! 14
        'EFF ', &  ! 15
        'ROOT', &  ! 16
        'DP_P', &  ! 17
        'DP_I', &  ! 18
        'DP  ', &  ! 19
        'ADRS', &  ! 20
        'ETI ', &  ! 21
        'ADMD', &  ! 22
        'ETR ', &  ! 23
        'CAPF'  &  ! 24
        ])
        MIN_VAR = SALT%MIN_VARIABLE
        IF(MIN_VAR>DZ) MIN_VAR = DNEG*MIN_VAR
    END IF
    !
    ! CALCULATE LEACHING REQUIREMENT (LR)
    !
    !!!DO I=ONE, CDAT%NCROP
    !!!DO K=ONE, CDAT%CROP(I)%N
    !!!!
    !!!IRR = CDAT%CROP(I)%IRR(K)
    !!!IF(SALT%INUSE(I)%VEC(K) .AND. IRR > Z) THEN
    !!!    !
    !!!    SALT%LR(I)%VEC(K) = DZ
    !!!    !
    !!!    SELECT CASE(SALT%LR_EXP(I)%EVAL)
    !!!    !CASE(Z)  ! SKIP
    !!!    !         SALT%LR(I)%VEC(K) = DZ
    !!!    CASE(ONE) ! SPECIFIC VALUE
    !!!              !
    !!!              SALT%LR(I)%VEC(K) = SALT%LR_EXP(I)%VAL
    !!!              !
    !!!    CASE(TWO) ! RHOADES EQUATION => LR = ECw/(5*ECe - ECw)
    !!!              !                    
    !!!              ECw = SALT%ECw( CDAT%CROP(I)%FID(K) )
    !!!              !
    !!!              SALT%LR(I)%VEC(K) = ECw / (FIVE*SALT%ECe(I) - ECw)
    !!!    CASE(NEG) ! CUSTOM EQUATION
    !!!              ! 
    !!!              CALL SET_VAL(N, VAL, I, K, SALT, CDAT, WBS, MIN_VAR, SALT%MIN_VARIABLE)
    !!!              ! 
    !!!              SALT%LR(I)%VEC(K) = EVAL(SALT%LR_EXP(I)%EXP,NAM,VAL,FALSE,FALSE) 
    !!!    END SELECT
    !!!    !
    !!!END IF
    !!!END DO
    !!!END DO
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z); SALT%LR(I)%VEC = DZ
    END DO
    !
    IF(SALT%HAS_NON_CUSTOM) THEN
          DO CONCURRENT (I=ONE:CDAT%NCROP    )
          DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)
              !
              IF(SALT%INUSE(I)%VEC(K)) THEN
                  !
                  SELECT CASE(SALT%LR_EXP(I)%EVAL)
                  !CASE(Z)  ! SKIP
                  !         SALT%LR(I)%VEC(K) = DZ
                  CASE(ONE) ! SPECIFIC VALUE
                            !
                            SALT%LR(I)%VEC(K) = SALT%LR_EXP(I)%VAL
                            !
                  CASE(TWO) ! RHOADES EQUATION => LR = ECw/(5*ECe - ECw)
                            !                    
                            ECw = SALT%ECw( CDAT%CROP(I)%FID(K) )
                            !
                            SALT%LR(I)%VEC(K) = ECw / (FIVE*SALT%ECe(I) - ECw)
                  END SELECT
              END IF
              !
          END DO; END DO
    END IF
    !
    IF (SALT%HAS_CUSTOM_LR) THEN
       DO I=ONE,CDAT%NCROP
          IF(SALT%LR_EXP(I)%EVAL==NEG .AND. CDAT%CROP(I)%N > Z) THEN
              DO K=ONE, CDAT%CROP(I)%N
                                      IF(SALT%INUSE(I)%VEC(K)) THEN
                                            CALL SET_VAL(N, VAL, I, K, SALT, CDAT, WBS, CLIM, MIN_VAR, SALT%MIN_VARIABLE)
                                            ! 
                                            SALT%LR(I)%VEC(K) = EVAL(SALT%LR_EXP(I)%EXP,NAM,VAL) 
                                      END IF
              END DO
          END IF
       END DO
    END IF
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP, SALT%LR_EXP(I)%SF.NE.UNO); SALT%LR(I)%VEC = SALT%LR(I)%VEC * SALT%LR_EXP(I)%SF
    END DO
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP)
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)
        !
        IF(SALT%LR(I)%VEC(K) > SALT%MAX_LR(I)) SALT%LR(I)%VEC(K) = SALT%MAX_LR(I)
        IF(SALT%LR(I)%VEC(K) < DZ            ) SALT%LR(I)%VEC(K) = DZ
        !
        !SALT%LR(I)%VEC(K) = UNO - SALT%LR(I)%VEC(K)  !NOTE THIS IS STORED AS 1 - LR
    END DO; END DO
    !
    ! CALCULATE ADDITIPONAL APPLIED WATER (AW)
    !
    !!!DO I=ONE, CDAT%NCROP
    !!!DO K=ONE, CDAT%CROP(I)%N
    !!!!
    !!!IRR = CDAT%CROP(I)%IRR(K)
    !!!IF(SALT%INUSE(I)%VEC(K) .AND. IRR > Z) THEN
    !!!    !
    !!!    SELECT CASE(SALT%AW_EXP(I)%EVAL)
    !!!    CASE(Z)   ! SKIP
    !!!              SALT%AW(I)%VEC(K) = DZ
    !!!    CASE(ONE) ! SPECIFIC VALUE
    !!!              !
    !!!              SALT%AW(I)%VEC(K) = SALT%AW_EXP(I)%VAL
    !!!              !
    !!!    CASE(TWO) ! RHOADES EQUATION => AW = (ETc/DU)/(1-LR)
    !!!              !
    !!!              IF(CDAT%CROP(I)%TI(K) > NEARZERO_12) THEN
    !!!                   ETc = CDAT%CROP(I)%TI(K)*(UNO + CDAT%CROP(I)%CECT(K))  !ONLY IRRIGATION ET
    !!!                   DU  = SALT%IRR_UNI(IRR,CDAT%CROP(I)%FID(K))
    !!!                   !
    !!!                   SALT%AW(I)%VEC(K) = ETc / ( DU*(UNO-SALT%LR(I)%VEC(K)) ) - ETc  
    !!!              ELSE
    !!!                  SALT%AW(I)%VEC(K) = DZ
    !!!              END IF
    !!!    CASE(NEG) ! CUSTOM EQUATION
    !!!              !
    !!!              CALL SET_VAL(N, VAL, I, K, SALT, CDAT, WBS, MIN_VAR, SALT%MIN_VARIABLE)
    !!!              !
    !!!              SALT%AW(I)%VEC(K) = EVAL(SALT%AW_EXP(I)%EXP,NAM,VAL,FALSE,FALSE) 
    !!!    END SELECT
    !!!    !
    !!!END IF
    !!!END DO
    !!!END DO
    DO CONCURRENT (I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z); SALT%AW(I)%VEC = DZ
    END DO
    !
    IF(SALT%HAS_NON_CUSTOM) THEN
       DO CONCURRENT (I=ONE:CDAT%NCROP    )
       DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)
           !
           IF(SALT%INUSE(I)%VEC(K)) THEN
                !
               SELECT CASE(SALT%AW_EXP(I)%EVAL)
               !CASE(Z)   ! SKIP
               !          SALT%AW(I)%VEC(K) = DZ
               CASE(ONE) ! SPECIFIC VALUE
                         !
                         SALT%AW(I)%VEC(K) = SALT%AW_EXP(I)%VAL
                         !
               CASE(TWO) ! RHOADES EQUATION => AW = (ETc/DU)/(1-LR)
                         !
                         IF(CDAT%CROP(I)%TI(K) > NEARZERO_12) THEN
                              ETc = CDAT%CROP(I)%TI(K)*(UNO + CDAT%CROP(I)%CECT(K))  !ONLY IRRIGATION ET
                              DU  = SALT%IRR_UNI(CDAT%CROP(I)%IRR(K),CDAT%CROP(I)%FID(K))
                              !
                              SALT%AW(I)%VEC(K) = ETc / ( DU*(UNO-SALT%LR(I)%VEC(K)) ) - ETc  
                         ELSE
                             SALT%AW(I)%VEC(K) = DZ
                         END IF
               END SELECT
           END IF
           !
       END DO; END DO
    END IF
    !
    IF (SALT%HAS_CUSTOM_AW) THEN
       DO I=ONE,CDAT%NCROP
          IF(SALT%AW_EXP(I)%EVAL==NEG .AND. CDAT%CROP(I)%N > Z) THEN
              DO K=ONE, CDAT%CROP(I)%N
                                      IF(SALT%INUSE(I)%VEC(K)) THEN
                                            !
                                            CALL SET_VAL(N, VAL, I, K, SALT, CDAT, WBS, CLIM, MIN_VAR, SALT%MIN_VARIABLE)
                                            !
                                            SALT%AW(I)%VEC(K) = EVAL(SALT%AW_EXP(I)%EXP,NAM,VAL) 
                                      END IF
              END DO
          END IF
       END DO
    END IF
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP, SALT%AW_EXP(I)%SF.NE.UNO); SALT%AW(I)%VEC = SALT%AW(I)%VEC * SALT%AW_EXP(I)%SF
    END DO
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP)
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, SALT%INUSE(I)%VEC(K) .AND. SALT%AW(I)%VEC(K) > NEARZERO_12)
            !
            CALL CDAT%ADD_EXTERNAL_DEMAND(SALT%AW(I)%VEC(K),I,K,Z,FALSE)
    END DO; END DO
    !    
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_VAL(N, VAL, I, K, SALT, CDAT, WBS, CLIM, MIN1, MIN2) ! Populates array VAL
    INTEGER,                        INTENT(IN ):: N
    DOUBLE PRECISION, DIMENSION(N), INTENT(OUT):: VAL
    INTEGER,                        INTENT(IN ):: I, K
    CLASS(SALINITY_DATA),           INTENT(IN ):: SALT
    TYPE(CROP_DATA),                INTENT(IN ):: CDAT
    TYPE(WBS_DATA),                 INTENT(IN ):: WBS
    TYPE(CLIMATE_DATA),             INTENT(IN ):: CLIM
    DOUBLE PRECISION,               INTENT(IN ):: MIN1, MIN2
    INTEGER:: R, C
    !
    R = CDAT%CROP(I)%RC(ONE,K)
    C = CDAT%CROP(I)%RC(TWO,K)
    !
    VAL(1 ) = SALT%LR(I)%VEC(K)                                    ! LR  
    VAL(2 ) = SALT%IRR_UNI(CDAT%CROP(I)%IRR(K),CDAT%CROP(I)%FID(K))! DU
    VAL(3 ) = CDAT%CROP(I)%CIR(K)                                  ! CIR 
    VAL(4 ) = SALT%ECw( CDAT%CROP(I)%FID(K) )                      ! ECw 
    VAL(5 ) = SALT%ECe(I)                                          ! ECe 
    VAL(6 ) = CDAT%CROP(I)%CU(K)                                   ! CU  
    VAL(7 ) = CDAT%CROP(I)%DEMAND(K)                               ! DMD 
    VAL(8 ) = CDAT%CROP(I)%EP(K) + CDAT%CROP(I)%TP(K)              ! ETp 
    VAL(9 ) = VAL(3) + VAL(8)                                      ! ETc 
    VAL(10) = CDAT%CROP(I)%PRECIP(K)                               ! P
    VAL(11) = CDAT%CROP(I)%AREA(K)                                 ! AREA
    VAL(12) = CDAT%CROP(I)%TGWA(K)                                 ! TGW 
    VAL(13) = CDAT%CROP(I)%TP(K)                                   ! TP  
    VAL(14) = CDAT%CROP(I)%TI(K)                                   ! TI  
    VAL(15) = CDAT%CROP(I)%EFF(K)                                  ! EFF 
    VAL(16) = CDAT%CROP(I)%ROOT(K)                                 ! ROOT
    !                                                              
    VAL(17) = CDAT%CROP(I)%PRECIP(K) - VAL(8)                      ! DP_P
    VAL(17) = VAL(17) * (UNO - CDAT%CROP(I)%FIESWP(K))             ! 
    IF(VAL(17) < NEARZERO_15) VAL(17) = DZ                         ! DP_P
    !
    VAL(18) = CDAT%CROP(I)%DEMAND(K) * (UNO - CDAT%CROP(I)%EFF(K)) * (UNO - CDAT%CROP(I)%FIESWI(K)) ! DP_I  --Inefficient losses to dp
    IF(CDAT%CROP(I)%DEMAND_EXT(K) > DZ) THEN                       !
             VAL(18) = VAL(18)  &
                     + CDAT%CROP(I)%DEMAND_EXT(K) * (UNO - CDAT%CROP(I)%EFF(K)) * (UNO - CDAT%CROP(I)%FIESWI(K))  & ! --Inefficient extra losses to dp
                     + CDAT%CROP(I)%DEMAND_EXT(K) *        CDAT%CROP(I)%EFF(K)  * (UNO - CDAT%CROP(I)%ADRF(K))      ! --Extra losses to dp
    END IF                                                         !
    IF(VAL(18) < NEARZERO_15) VAL(18) = DZ                         ! DP_I
    !
    VAL(19) = VAL(17) + VAL(18)                                    ! DP
    !
    VAL(20) = CDAT%CROP(I)%ADRF(K)                                 ! ADRS
    VAL(21) = VAL(7 ) * VAL(15)                                    ! ETI 
    VAL(22) = CDAT%CROP(I)%ADMD(K)                                 ! ADMD
    IF(CLIM%HAS_REF_ET) THEN
         VAL(23) = CLIM%REF_ET(C,R)                                ! ETR
    ELSE
         VAL(23) = MIN2
    END IF    
    VAL(24) = CDAT%CROP(I)%SS(K)-CDAT%CROP(I)%LXX(K)               ! CAPF
    ! 
    !
    IF(MIN2 > NEARZERO_30) THEN
       DO CONCURRENT(R=ONE:N, MIN1 < VAL(R) .AND. VAL(R) < MIN2)
           IF(VAL(R)<DZ) THEN
               VAL(R) = MIN1
           ELSE
               VAL(R) = MIN2
           END IF
       END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CROP_INPUT_ARRAY_TO_LOGICAL_PROP(N, RC, PROP, ARRAY)  !CLONE OF CROP_INPUT_ARRAY_TO_PROP ROUTINE LOCATED IN CROP MODULE
    INTEGER,                   INTENT(IN ):: N
    INTEGER, DIMENSION(TWO,N), INTENT(IN ):: RC
    LOGICAL, DIMENSION(N),     INTENT(OUT):: PROP
    INTEGER, DIMENSION(:,:),   INTENT(IN ):: ARRAY
    CONTIGUOUS:: ARRAY
    INTEGER:: K
    !
    DO CONCURRENT (K=ONE:N)
                         PROP(K) = ARRAY( RC(TWO,K), RC(ONE,K) ).NE.Z  !NOTE ARRAY IS STORED AS NCOL, NROW
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_BYFARM(SALT,CDAT, WBS, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(SALINITY_DATA), INTENT(INOUT):: SALT
    CLASS(CROP_DATA),     INTENT(IN   ):: CDAT
    TYPE(WBS_DATA),       INTENT(IN   ):: WBS
    INTEGER,              INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,     INTENT(IN   ):: DELT
    DOUBLE PRECISION,     INTENT(IN   ):: DYEAR
    CHARACTER(*),         INTENT(IN   ):: DATE
    INTEGER:: IU, F, I, J, K, IRR
    DOUBLE PRECISION:: AREA, CU, CIR, DMD, CIRI, DMDI, LR, ECe, ECw, AW, LF, P, DP, DP_TOT, SALT_AREA, ETi, DMD_FRAC, DU, CDMD, PIN
    CHARACTER(17):: ZER, DT
    CHARACTER(14):: PC

    !
    IF(SALT%OUT_BYFARM%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !DDT = DBLE(DELT)
    !
    CALL SALT%OUT_BYFARM%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = SALT%OUT_BYFARM%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. SALT%IOUT==IU )  THEN
        IF(SALT%OUT_BYFARM%BINARY) THEN          
            WRITE(SALT%IOUT,'(A,/A)')'SALINITY IRRIGATION INFORMATION BY WBS OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), WBS ID (int), PERCENT INCREASE (double), WBS AREA (double), CROP AREA (double), IRRIGATED AREA (double), SALINITY AREA (double), EFFICIENCY (double), PRECIPITATION (double), TOTAL IRRIGATION (double), TOTAL DEEP PERCOLOTION (double), LEACH FRACTION (double), CU (double), ET FROM IRRIGATION (double), SALT_REQ_IRR (double), SALT_IRR (double), SALT_REQ_DEMAND (double), SALT_DEMAND (double), LEACH REQUIREMENT (double), ECe (double), ECw (double), IRRIGATION UNIFORMITY (double)"
        ELSE
            !
            IF (SALT%IOUT==IU) WRITE(IU,*)
            !
            CALL SALT%OUT_BYFARM%SET_HEADER( '    PER    STP    WBS  DEMAND%CHANGE       FARM_AREA        CROP_AREA   IRRIGATED_AREA    SALINITY_AREA       EFFICIENCY    PRECIPITATION TOTAL_IRRIGATION  TOTAL_DEEP_PERC   LEACH_FRACTION               CU           ET_IRR     SALT_REQ_IRR         SALT_IRR  SALT_REQ_DEMAND      SALT_DEMAND        LEACH_REQ              ECe              ECw   IRR_UNIFORMITY             DELT   DYEAR            DATE_START' )
        END IF
    END IF
    !
    DO F=ONE, WBS%NFARM
       AREA= DZ
       CU  = DZ
       CIR = DZ
       DMD = DZ
       CIRI= DZ
       DMDI= DZ
       LR = DZ
       ECe =DZ
       ECw =DZ
       AW  =DZ
       LF  =DZ
       P   =DZ
       DP_TOT=DZ
       SALT_AREA = DZ
       ETi = DZ
       DMD_FRAC = UNO
       DU = DZ
       CDMD=DZ
       DO CONCURRENT(J=ONE:WBS%CROP(F)%N) 
           I=WBS%CROP(F)%PNT(ONE,J)
           K=WBS%CROP(F)%PNT(TWO,J)
           IRR = CDAT%CROP(I)%IRR(K)
           !
           AREA= AREA + CDAT%CROP(I)%AREA(K)
           CU  = CU   + CDAT%CROP(I)%TI(K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%EP(K) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%EGWA(K) !TRAN*CDAT%CROP(I)%FTR(K) + TRAN*(UNO - CDAT%CROP(I)%FTR(K))
           ETi = ETi  + CDAT%CROP(I)%TI(K)*(UNO + CDAT%CROP(I)%CECT(K))  !ONLY IRRIGATION ET
           P   = P    + CDAT%CROP(I)%PRECIP(K)
           AW  = AW   + CDAT%CROP(I)%DEMAND(K) + CDAT%CROP(I)%DEMAND_EXT(K)  
           CDMD= CDMD + CDAT%CROP(I)%DEMAND(K)
           !DMD_FRAC, LF, LR, AW, ECe, ECw, DU
           ! 
           IF(SALT%INUSE(I)%VEC(K)) THEN
               !
               IF(CDAT%HAS_DEMAND_EXT) THEN
                   IF(NEAR_ZERO(CDAT%CROP(I)%DEMAND_EXT_INI(K))) THEN
                       DMD_FRAC=DZ
                   ELSE
                       DMD_FRAC = CDAT%CROP(I)%DEMAND_EXT(K) / CDAT%CROP(I)%DEMAND_EXT_INI(K)
                       IF(NEAR_ZERO(DMD_FRAC)) DMD_FRAC=DZ
                   END IF
               END IF
               !
               SALT_AREA = SALT_AREA + CDAT%CROP(I)%AREA(K)
               LR = LR + SALT%LR(I)%VEC(K) * CDAT%CROP(I)%AREA(K)
               !
               CIRI= CIRI + SALT%AW(I)%VEC(K)
               CIR = CIR  + SALT%AW(I)%VEC(K)*DMD_FRAC
               !
               ECe = ECe + SALT%ECe(I)*CDAT%CROP(I)%AREA(K)
               ECw = ECw + SALT%ECw(I)*CDAT%CROP(I)%AREA(K)
               DU  = DU  + SALT%IRR_UNI(IRR,CDAT%CROP(I)%FID(K))*CDAT%CROP(I)%AREA(K)
               !
               IF(CDAT%CROP(I)%EFF(K)>DZ) THEN
                   DMDI = DMDI + SALT%AW(I)%VEC(K)/CDAT%CROP(I)%EFF(K)
                   DMD  = DMD  + (SALT%AW(I)%VEC(K)/CDAT%CROP(I)%EFF(K))*DMD_FRAC
               END IF
           END IF
           !
           DP = CDAT%CROP(I)%PRECIP(K) - CDAT%CROP(I)%TP(K) - CDAT%CROP(I)%EP(K)  ! 'DP_P'
           DP = DP * (UNO - CDAT%CROP(I)%FIESWP(K))         ! 
           IF(DP < NEARZERO_12) DP = DZ                     ! 'DP_P'
           !
           DP_TOT = DP_TOT + DP
           !
           DP = CDAT%CROP(I)%DEMAND(K) * (UNO - CDAT%CROP(I)%EFF(K)) * (UNO - CDAT%CROP(I)%FIESWI(K)) ! 'DP_I'  --Inefficient losses to dp
           IF(CDAT%CROP(I)%DEMAND_EXT(K) > DZ) THEN                       !
                    DP = DP  &
                            + CDAT%CROP(I)%DEMAND_EXT(K) * (UNO - CDAT%CROP(I)%EFF(K)) * (UNO - CDAT%CROP(I)%FIESWI(K))  & ! --Inefficient extra losses to dp
                            + CDAT%CROP(I)%DEMAND_EXT(K) *        CDAT%CROP(I)%EFF(K)  * (UNO - CDAT%CROP(I)%ADRF(K))      ! --Extra losses to dp
           END IF                                                         !
           IF(DP < NEARZERO_12) DP = DZ                         ! 'DP_I'
           DP_TOT = DP_TOT + DP
           !
       END DO
       !
       IF(SALT_AREA > DZ) THEN
               LR  = LR  / SALT_AREA
               ECe = ECe / SALT_AREA
               ECw = ECw / SALT_AREA
               DU  = DU  / SALT_AREA
       END IF
       !
       IF(AW+P>DZ) THEN
           LF = DP_TOT/(AW+P)
       ELSE
           LF = DZ
       END IF
       !
       IF(CDMD>NEARZERO_10 .AND. DMD>UNO) THEN
           !
           PIN = (DMD/CDMD)*100D0
           !
           IF(PIN < 100000D0) THEN
                WRITE(PC,'(1x F12.2)') PIN
           ELSE
               WRITE(PC,'(1x ES12.2)') PIN
           END IF
       ELSE
           PC='         0.00'
           PIN=DZ
       END IF
       !
       IF(SALT%OUT_BYFARM%BINARY) THEN
           IF(WBS%FID(F)%Count == Z) THEN
               WRITE(IU) DATE, DYEAR, DELT, KPER, KSTP, F, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ
           ELSE
               WRITE(IU) DATE, DYEAR, DELT, KPER, KSTP, F,PIN, WBS%FID(F)%AREA, AREA, WBS%IRR_AREA(F), SALT_AREA, WBS%EFF(F), P, AW, DP_TOT, LF, CU, ETi, CIRI, CIR, DMDI, DMD, LR, ECe, ECw, DU
           END IF   
       ELSEIF(WBS%FID(F)%Count == Z) THEN
               !
               PC='        0.00'
               WRITE(IU, '(3I7, A, 20A17, 2x F13.7, 2x A)') KPER, KSTP, F, PC, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, DT, DYEAR, DATE
       ELSE
               WRITE(IU, '(3I7, A, 20A17, 2x F13.7, 2x A)') KPER, KSTP, F, PC, NUM2STR(WBS%FID(F)%AREA), NUM2STR(AREA), NUM2STR(WBS%IRR_AREA(F)), NUM2STR(SALT_AREA), NUM2STR(WBS%EFF(F)), NUM2STR(P), NUM2STR(AW), NUM2STR(DP_TOT), NUM2STR(LF), NUM2STR(CU), NUM2STR(ETi), NUM2STR(CIRI), NUM2STR(CIR), NUM2STR(DMDI), NUM2STR(DMD), NUM2STR(LR), NUM2STR(ECe), NUM2STR(ECw), NUM2STR(DU), DT, DYEAR, DATE
       END IF
       
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_BYFARM_BYCROP(SALT, CDAT, WBS, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(SALINITY_DATA), INTENT(INOUT):: SALT
    CLASS(CROP_DATA),     INTENT(IN   ):: CDAT
    TYPE(WBS_DATA),       INTENT(IN   ):: WBS
    INTEGER,              INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,     INTENT(IN   ):: DELT
    DOUBLE PRECISION,     INTENT(IN   ):: DYEAR
    CHARACTER(*),         INTENT(IN   ):: DATE
    INTEGER:: IU, F, I, J, K, L, IRR
    DOUBLE PRECISION::  AREA, AREA_IRR, CU, CIR, DMD, CIRI, DMDI, LR, ECe, ECw, AW, LF, P, DP, DP_TOT, SALT_AREA, ETi, DMD_FRAC, DU, PIN, CDMD
    CHARACTER(17):: ZER, DT
    CHARACTER(14):: PC
    LOGICAL:: FOUND
    !
    IF(SALT%OUT_BYFARMCROP%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    L  = CDAT%CROP_NAME_LEN
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !DDT = DBLE(DELT)
    !
    CALL SALT%OUT_BYFARMCROP%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = SALT%OUT_BYFARMCROP%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. SALT%IOUT==IU )  THEN
        IF(SALT%OUT_BYFARMCROP%BINARY) THEN          
            WRITE(SALT%IOUT,'(A,/A)')'SALINITY IRRIGATION BY WBS BY CROP OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), WBS ID (int), CROP ID (int), CROP_NAME (20 char), PERCENT INCREASE (double), CROP AREA (double), IRRIGATED AREA (double), SALINITY AREA (double), PRECIPITATION (double), TOTAL IRRIGATION (double), TOTAL DEEP PERCOLOTION (double), LEACH FRACTION (double), CU (double), ET FROM IRRIGATION (double), SALT_REQ_IRR (double), SALT_IRR (double), SALT_REQ_DEMAND (double), SALT_DEMAND (double), LEACH REQUIREMENT (double), ECe (double), ECw (double), IRRIGATION UNIFORMITY (double)"
        ELSE
            !
            IF (SALT%IOUT==IU) WRITE(IU,*)
            !                                                                                  
            CALL SALT%OUT_BYFARMCROP%SET_HEADER( '    PER    STP    WBS   CROP  CROP_NAME'//REPEAT(' ',L-7)//'DEMAND%CHANGE      CROP_AREA   IRRIGATED_AREA    SALINITY_AREA    PRECIPITATION TOTAL_IRRIGATION  TOTAL_DEEP_PERC   LEACH_FRACTION               CU           ET_IRR     SALT_REQ_IRR         SALT_IRR  SALT_REQ_DEMAND      SALT_DEMAND        LEACH_REQ              ECe              ECw   IRR_UNIFORMITY             DELT   DYEAR            DATE_START' )
        END IF
    END IF
    !
    DO F=ONE, WBS%NFARM
    DO I=ONE, CDAT%NCROP
       AREA= DZ
       AREA_IRR=DZ
       SALT_AREA = DZ
       CU  = DZ
       CIR = DZ
       DMD = DZ
       CIRI= DZ
       DMDI= DZ
       LR = DZ
       ECe =DZ
       ECw =DZ
       AW  =DZ
       LF  =DZ
       P   =DZ
       DP_TOT=DZ
       ETi = DZ
       DMD_FRAC = UNO
       DU = DZ
       CDMD=DZ
       FOUND = FALSE
       DO CONCURRENT(J=ONE:WBS%CROP(F)%N, WBS%CROP(F)%PNT(ONE,J) == I)
           K=WBS%CROP(F)%PNT(TWO,J)
           FOUND = TRUE
           IRR = CDAT%CROP(I)%IRR(K)
           !
           AREA= AREA + CDAT%CROP(I)%AREA(K)
           IF(IRR>Z) AREA_IRR = AREA_IRR + CDAT%CROP(I)%AREA(K)
           CU  = CU   + CDAT%CROP(I)%TI(K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%EP(K) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%EGWA(K) !TRAN*CDAT%CROP(I)%FTR(K) + TRAN*(UNO - CDAT%CROP(I)%FTR(K))
           ETi = ETi  + CDAT%CROP(I)%TI(K)*(UNO + CDAT%CROP(I)%CECT(K))  !ONLY IRRIGATION ET
           P   = P    + CDAT%CROP(I)%PRECIP(K)
           AW  = AW   + CDAT%CROP(I)%DEMAND(K) + CDAT%CROP(I)%DEMAND_EXT(K)  
           CDMD= CDMD + CDAT%CROP(I)%DEMAND(K)
           !DMD_FRAC, LF, LR, AW, ECe, ECw, DU
           ! 
           IF(SALT%INUSE(I)%VEC(K)) THEN
               !
               IF(CDAT%HAS_DEMAND_EXT) THEN
                   IF(NEAR_ZERO(CDAT%CROP(I)%DEMAND_EXT_INI(K))) THEN
                       DMD_FRAC=DZ
                   ELSE
                       DMD_FRAC = CDAT%CROP(I)%DEMAND_EXT(K) / CDAT%CROP(I)%DEMAND_EXT_INI(K)
                       IF(NEAR_ZERO(DMD_FRAC)) DMD_FRAC=DZ
                   END IF
               END IF
               !
               SALT_AREA = SALT_AREA + CDAT%CROP(I)%AREA(K)
               LR = LR + SALT%LR(I)%VEC(K) * CDAT%CROP(I)%AREA(K)
               !
               CIRI= CIRI + SALT%AW(I)%VEC(K)
               CIR = CIR  + SALT%AW(I)%VEC(K)*DMD_FRAC
               !
               ECe = ECe + SALT%ECe(I)*CDAT%CROP(I)%AREA(K)
               ECw = ECw + SALT%ECw(I)*CDAT%CROP(I)%AREA(K)
               DU  = DU  + SALT%IRR_UNI(IRR,CDAT%CROP(I)%FID(K))*CDAT%CROP(I)%AREA(K)
               !
               IF(CDAT%CROP(I)%EFF(K)>DZ) THEN
                   DMDI = DMDI + SALT%AW(I)%VEC(K)/CDAT%CROP(I)%EFF(K)
                   DMD  = DMD  + (SALT%AW(I)%VEC(K)/CDAT%CROP(I)%EFF(K))*DMD_FRAC
               END IF
           END IF
           !
           DP = CDAT%CROP(I)%PRECIP(K) - CDAT%CROP(I)%TP(K) - CDAT%CROP(I)%EP(K)  ! 'DP_P'
           DP = DP * (UNO - CDAT%CROP(I)%FIESWP(K))         ! 
           IF(DP < NEARZERO_12) DP = DZ                     ! 'DP_P'
           !
           DP_TOT = DP_TOT + DP
           !
           DP = CDAT%CROP(I)%DEMAND(K) * (UNO - CDAT%CROP(I)%EFF(K)) * (UNO - CDAT%CROP(I)%FIESWI(K)) ! 'DP_I'  --Inefficient losses to dp
           IF(CDAT%CROP(I)%DEMAND_EXT(K) > DZ) THEN                       !
                    DP = DP  &
                            + CDAT%CROP(I)%DEMAND_EXT(K) * (UNO - CDAT%CROP(I)%EFF(K)) * (UNO - CDAT%CROP(I)%FIESWI(K))  & ! --Inefficient extra losses to dp
                            + CDAT%CROP(I)%DEMAND_EXT(K) *        CDAT%CROP(I)%EFF(K)  * (UNO - CDAT%CROP(I)%ADRF(K))      ! --Extra losses to dp
           END IF                                                         !
           IF(DP < NEARZERO_12) DP = DZ                         ! 'DP_I'
           DP_TOT = DP_TOT + DP
           !
       END DO
       !
       IF(FOUND) THEN
               IF(SALT_AREA > DZ) THEN
                       LR  = LR  / SALT_AREA
                       ECe = ECe / SALT_AREA
                       ECw = ECw / SALT_AREA
                       DU  = DU  / SALT_AREA
               END IF
               !
               IF(AW+P>DZ) THEN
                   LF = DP_TOT/(AW+P)
               ELSE
                   LF = DZ
               END IF
               !
               IF(CDMD>NEARZERO_10 .AND. DMD>UNO) THEN
                   !
                   PIN = (DMD/CDMD)*100D0
                   !
                   IF(PIN < 100000D0) THEN
                        WRITE(PC,'(1x F12.2)') PIN
                   ELSE
                       WRITE(PC,'(1x ES12.2)') PIN
                   END IF
               ELSE
                   PC='         0.00'
                   PIN=DZ
               END IF
               !
               IF(SALT%OUT_BYFARMCROP%BINARY) THEN
                   WRITE(IU) DATE, DYEAR, DELT, KPER, KSTP, F, I, CDAT%CROP_NAME(I), PIN, AREA, WBS%IRR_AREA(F), SALT_AREA, P, AW, DP_TOT, LF, CU, ETi, CIRI, CIR, DMDI, DMD, LR, ECe, ECw, DU 
               ELSE
                       WRITE(IU, '(4I7, 2x A, A, 18A17, 2x F13.7, 2x A)') KPER, KSTP, F, I, CDAT%CROP_NAME(I)(:L), PC, NUM2STR(AREA), NUM2STR(WBS%IRR_AREA(F)), NUM2STR(SALT_AREA), NUM2STR(P), NUM2STR(AW), NUM2STR(DP_TOT), NUM2STR(LF), NUM2STR(CU), NUM2STR(ETi), NUM2STR(CIRI), NUM2STR(CIR), NUM2STR(DMDI), NUM2STR(DMD), NUM2STR(LR), NUM2STR(ECe), NUM2STR(ECw), NUM2STR(DU), DT, DYEAR, DATE
               END IF
       END IF
    END DO
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_ALL_CROP(SALT,CDAT, WBS, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(SALINITY_DATA), INTENT(INOUT):: SALT
    CLASS(CROP_DATA),     INTENT(IN   ):: CDAT
    TYPE(WBS_DATA),       INTENT(IN   ):: WBS
    INTEGER,              INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,     INTENT(IN   ):: DELT
    DOUBLE PRECISION,     INTENT(IN   ):: DYEAR
    CHARACTER(*),         INTENT(IN   ):: DATE
    INTEGER:: IU, F, I, K, L, R, C, IRR
    DOUBLE PRECISION::  AREA, CU, CIR, DMD, CIRI, DMDI, LR, ECe, ECw, AW, LF, P, DP, DP_TOT, ETi, DMD_FRAC, DU, CDMD, PIN, EFF
    CHARACTER(17):: ZER, DT
    CHARACTER(13):: PC
    !
    IF(SALT%OUT_ALL%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    L  = CDAT%CROP_NAME_LEN
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !DDT = DBLE(DELT)
    !
    CALL SALT%OUT_ALL%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = SALT%OUT_ALL%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. SALT%IOUT==IU )  THEN
        IF(SALT%OUT_ALL%BINARY) THEN          
            WRITE(SALT%IOUT,'(A,/A)')'SALINITY IRRIGATION INFORMATION BY WBS OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), CROP ID (int), CROP_NAME (20 char), WBS ID (int), ROW (int), COL (int), PERCENT INCREASE (double), WBS AREA (double), CROP AREA (double), IRRIGATED AREA (double), SALINITY AREA (double), EFFICIENCY (double), PRECIPITATION (double), TOTAL IRRIGATION (double), TOTAL DEEP PERCOLOTION (double), LEACH FRACTION (double), CU (double), ET FROM IRRIGATION (double), SALT_REQ_IRR (double), SALT_IRR (double), SALT_REQ_DEMAND (double), SALT_DEMAND (double), LEACH REQUIREMENT (double), ECe (double), ECw (double), IRRIGATION UNIFORMITY (double)"
        ELSE
            !
            IF (SALT%IOUT==IU) WRITE(IU,*)
            !                                       
            CALL SALT%OUT_ALL%SET_HEADER( '    PER    STP   CROP  CROP_NAME'//REPEAT(' ',L-6)//' WBS    ROW    COL    DEMAND%CHANGE        CROP_AREA       EFFICIENCY    PRECIPITATION TOTAL_IRRIGATION  TOTAL_DEEP_PERC   LEACH_FRACTION               CU           ET_IRR     SALT_REQ_IRR         SALT_IRR  SALT_REQ_DEMAND      SALT_DEMAND        LEACH_REQ              ECe              ECw   IRR_UNIFORMITY             DELT   DYEAR            DATE_START' )
        END IF
    END IF
    !
    DO I=ONE, CDAT%NCROP
     IF(CDAT%PRINT_CROP%LIST(I).NE.Z) THEN
        DO K=ONE, CDAT%CROP(I)%N
          !
          IF(SALT%INUSE(I)%VEC(K)) THEN
              !
              IRR = CDAT%CROP(I)%IRR(K)
              R   = CDAT%CROP(I)%RC(ONE,K)
              C   = CDAT%CROP(I)%RC(TWO,K)
              F   = CDAT%CROP(I)%FID(K) 
              !
              EFF=DZ
              IF(CDAT%CROP(I)%EFF(K)>DZ) EFF = CDAT%CROP(I)%EFF(K)
              !
              AREA= CDAT%CROP(I)%AREA(K)
              CU  = CDAT%CROP(I)%TI(K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%EP(K) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%EGWA(K) !TRAN*CDAT%CROP(I)%FTR(K) + TRAN*(UNO - CDAT%CROP(I)%FTR(K))
              ETi = CDAT%CROP(I)%TI(K)*(UNO + CDAT%CROP(I)%CECT(K))  !ONLY IRRIGATION ET
              P   = CDAT%CROP(I)%PRECIP(K)
              AW  = CDAT%CROP(I)%DEMAND(K) + CDAT%CROP(I)%DEMAND_EXT(K)  
              CDMD= CDAT%CROP(I)%DEMAND(K)
              !
              IF(NEAR_ZERO(CDAT%CROP(I)%DEMAND_EXT_INI(K))) THEN
                  DMD_FRAC=DZ
              ELSE
                  DMD_FRAC = CDAT%CROP(I)%DEMAND_EXT(K) / CDAT%CROP(I)%DEMAND_EXT_INI(K)
                  IF(NEAR_ZERO(DMD_FRAC)) DMD_FRAC=DZ
              END IF
              !
              LR = SALT%LR(I)%VEC(K)
              !
              CIRI= SALT%AW(I)%VEC(K)
              CIR = SALT%AW(I)%VEC(K)*DMD_FRAC
              !
              ECe = SALT%ECe(I)
              ECw = SALT%ECw(I)
              DU  = SALT%IRR_UNI(IRR,CDAT%CROP(I)%FID(K))
              !
              IF(EFF>DZ) THEN
                  DMDI =  CIRI/EFF
                  DMD  = (CIRI/EFF)*DMD_FRAC
              ELSE
                  DMDI = DZ
                  DMD  = DZ
              END IF
              !
              P = CDAT%CROP(I)%PRECIP(K) - CDAT%CROP(I)%TP(K) - CDAT%CROP(I)%EP(K)  ! 'DP_P'
              DP = DP * (UNO - CDAT%CROP(I)%FIESWP(K))         ! 
              IF(DP < NEARZERO_12) DP = DZ                     ! 'DP_P'
              !
              DP_TOT = DP
              !
              DP = CDAT%CROP(I)%DEMAND(K) * (UNO - EFF) * (UNO - CDAT%CROP(I)%FIESWI(K)) ! 'DP_I'  --Inefficient losses to dp
              IF(CDAT%CROP(I)%DEMAND_EXT(K) > DZ) THEN                       !
                       DP = DP  &
                               + CDAT%CROP(I)%DEMAND_EXT(K) * (UNO - EFF) * (UNO - CDAT%CROP(I)%FIESWI(K))  & ! --Inefficient extra losses to dp
                               + CDAT%CROP(I)%DEMAND_EXT(K) *        EFF  * (UNO - CDAT%CROP(I)%ADRF(K))      ! --Extra losses to dp
              END IF                                                         !
              IF(DP < NEARZERO_12) DP = DZ                         ! 'DP_I'
              DP_TOT = DP_TOT + DP
              !
              !
              IF(AW+P>DZ) THEN
                  LF = DP_TOT/(AW+P)
              ELSE
                  LF = DZ
              END IF
              !
              IF(CDMD>NEARZERO_10 .AND. DMD>UNO) THEN
                  !
                  PIN = (DMD/CDMD)*100D0
                  !
                  IF(PIN < 100000D0) THEN
                       WRITE(PC,'(1x F12.2)') PIN
                  ELSE
                      WRITE(PC,'(1x ES12.2)') PIN
                  END IF
              ELSE
                  PC='         0.00'
                  PIN=DZ
              END IF
              !
              IF(SALT%OUT_ALL%BINARY) THEN
                      WRITE(IU) DATE, DYEAR, DELT, KPER, KSTP, I, CDAT%CROP_NAME(I), F, R, C, PIN, AREA, EFF, P, AW, DP_TOT, LF, CU, ETi, CIRI, CIR, DMDI, DMD, LR, ECe, ECw, DU
              ELSE
                      WRITE(IU, '(3I7, 2x A, 3I7, 18A17, 2x F13.7, 2x A)') KPER, KSTP, I, CDAT%CROP_NAME(I)(:L),  F, R, C, PC, NUM2STR(AREA), NUM2STR(EFF), NUM2STR(P), NUM2STR(AW), NUM2STR(DP_TOT), NUM2STR(LF), NUM2STR(CU), NUM2STR(ETi), NUM2STR(CIRI), NUM2STR(CIR), NUM2STR(DMDI), NUM2STR(DMD), NUM2STR(LR), NUM2STR(ECe), NUM2STR(ECw), NUM2STR(DU), DT, DYEAR, DATE
              END IF
          END IF
        END DO
     END IF
    END DO
    !
  END SUBROUTINE
  !
END MODULE 
!
!#########################################################################################################
!
!MODULE MANAGED_RECHARGE_FMP_INTERFACE
!  !
!  USE FMP_DIMENSION_INTERFACE,           ONLY: FMP_DIMENSION
!  !
!  USE CONSTANTS
!  USE UTIL_INTERFACE,                       ONLY: STOP_ERROR, WARNING_MESSAGE, NUM2STR, PARSE_WORD_UP, GET_NUMBER, READ_TO_DATA, ALLOC
!  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
!  USE LIST_ARRAY_INPUT_INTERFACE,        ONLY: LIST_ARRAY_INPUT, LIST_ARRAY_INPUT_INT
!  USE WARNING_TYPE_INSTRUCTION,          ONLY: WARNING_TYPE
!  USE SFR_INPUT_DATA_TYPES,              ONLY: SFR_NAMED_LOCATION, WBS_SEG_RCH_WT_TFR, SFR_SEGRCH_TFR, SFR_SEG_TFR, FMP_FLOW_REMOVE_SFR
!  USE LINKED_LIST_INSTRUCTION,           ONLY: INTEGER_LINKED_LIST
!  USE SORT_INTERFACE,                    ONLY: SORT, REVERSE_ORDER
!  USE ARRAY_DATA_TYPES,                  ONLY: COMPRESSED_LOCATION_STORAGE
!  USE ULOAD_AND_SFAC_INTERFACE
!  IMPLICIT NONE
!  PRIVATE
!  PUBLIC:: MANAGED_RECHARGE_DATA, INITIALIZE_MANAGED_RECHARGE_DATA
!  !
!  TYPE MAR_SOURCE_LOC
!      INTEGER:: N=Z
!      LOGICAL:: NO_WT = TRUE
!      INTEGER,         DIMENSION(:),ALLOCATABLE:: ISTRM
!      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE:: WT
!      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE:: FLOW
!      !DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE:: FLOW_OLD
!      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE:: LLIM, ULIM
!      DOUBLE PRECISION:: TOT_RCH_INI, TOT_RCH_MET
!  END TYPE
!  !
!  TYPE MANAGED_RECHARGE_DATA
!      LOGICAL:: HAS_MAR = FALSE
!      INTEGER:: IOUT=Z, LOUT=Z
!      INTEGER:: NFARM = Z
!      INTEGER:: NSEG  = Z
!      INTEGER:: NSFR_MAR_DELIV  = Z
!      INTEGER:: NMAR_ID         = Z
!      !
!      LOGICAL:: REQ_SFR    = FALSE
!      LOGICAL:: TFR_READ   = FALSE
!      !
!      TYPE(MAR_SOURCE_LOC),                   DIMENSION(:),ALLOCATABLE:: DELIV_LOC
!      TYPE(COMPRESSED_LOCATION_STORAGE),DIMENSION(:),ALLOCATABLE:: IMAR
!      !
!      TYPE(WBS_SEG_RCH_WT_TFR):: MAR_SFR_TFR
!      !
!      TYPE(LIST_ARRAY_INPUT_INT):: IMAR_TFR
!      TYPE(LIST_ARRAY_INPUT    ):: MAR_DMD
!      TYPE(LIST_ARRAY_INPUT    ):: DELIV_L_LIM
!      TYPE(LIST_ARRAY_INPUT    ):: DELIV_U_LIM
!      !
!      CONTAINS
!      !
!      PROCEDURE, PASS(MAR):: NEXT     => SETUP_NEXT_STRESS_PERIOD
!      PROCEDURE, PASS(MAR):: NEXT_TS  => SETUP_NEXT_TIME_STEP
!      !
!      !!!PROCEDURE, PASS(MAR):: SET_SFR_SRD_FLOW
!      !!!PROCEDURE, PASS(MAR):: BUILD_SRD_LOC_FLOW
!      !
!      FINAL:: DEALLOCATE_MANAGED_RECHARGE_FINAL
!  END TYPE
!  !
!  CONTAINS
!  !
!  SUBROUTINE DEALLOCATE_MANAGED_RECHARGE_FINAL(MAR)
!     TYPE(MANAGED_RECHARGE_DATA)::MAR
!     CALL DEALLOCATE_MANAGED_RECHARGE(MAR)
!  END SUBROUTINE
!  !
!  SUBROUTINE DEALLOCATE_MANAGED_RECHARGE(MAR)
!  CLASS(MANAGED_RECHARGE_DATA), INTENT(INOUT)::MAR
!     !
!     MAR%IOUT  = Z
!     MAR%LOUT  = Z
!     MAR%NFARM = Z
!     MAR%NSFR_MAR_DELIV = Z
!     MAR%NMAR_ID        = Z
!     MAR%REQ_SFR        = FALSE
!     MAR%TFR_READ       = FALSE
!     MAR%HAS_MAR        = FALSE
!     !
!     IF(ALLOCATED(MAR%DELIV_LOC)) DEALLOCATE(MAR%DELIV_LOC )
!     IF(ALLOCATED(MAR%IMAR     )) DEALLOCATE(MAR%IMAR      )
!     !
!  END SUBROUTINE
!  !  
!  SUBROUTINE INITIALIZE_MANAGED_RECHARGE_DATA( BL, MAR, LINE, FDIM, NSEG )
!    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL   !DATA BLOCK
!    CLASS(MANAGED_RECHARGE_DATA),INTENT(INOUT):: MAR
!    CHARACTER(*),                INTENT(INOUT):: LINE
!    TYPE(FMP_DIMENSION),         INTENT(IN   ):: FDIM
!    INTEGER,                     INTENT(IN   ):: NSEG
!    CHARACTER(5):: ERROR
!    LOGICAL:: EOF
!    INTEGER:: LLOC, ISTART, ISTOP, F
!    INTEGER:: RET_SET, DIV_SET
!    TYPE(WARNING_TYPE):: WARN_MSG
!    !FDIM%SFR_ID%GET(LINE, LLOC, ISTART, ISTOP, SEG, RCH)
!    WRITE(BL%IOUT,'(/A/)') 'SURFACEWATER BLOCK FOUND AND NOW LOADING PROPERTIES'
!    !
!    MAR%HAS_MAR = TRUE
!    !
!    MAR%IOUT = BL%IOUT
!    MAR%LOUT = BL%IOUT
!    MAR%NFARM= FDIM%NFARM
!    MAR%NSEG = NSEG
!    MAR%NSFR_MAR_DELIV = FDIM%NSFR_MAR_DELIV
!    MAR%NMAR_ID        = FDIM%NMAR_ID       
!    !
!    ERROR='ERROR'
!    CALL WARN_MSG%INIT()
!    ALLOCATE(MAR%DELIV_LOC(MAR%NMAR_ID))
!    ALLOCATE(MAR%IMAR  (MAR%NMAR_ID))
!    !
!    CALL BL%MAKE_SCRATCH_FILE()
!    !
!    !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
!    CALL BL%READ_SCRATCH(EOF, LINE)
!    !
!    DO WHILE (.NOT. EOF)
!      !
!      LLOC=ONE
!      CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
!      !
!      SELECT CASE ( LINE(ISTART:ISTOP) )
!         CASE ("RECHARGE_LOCATION")
!                        WRITE(BL%IOUT,'(A)') '   RECHARGE_LOCATION     KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD.'
!                        !
!                        CALL MAR%IMAR_TFR%INIT('IMAR', LLOC, LINE, BL%IOUT, BL%IU, Z, Z, FDIM%NROW, FDIM%NCOL, SCRATCH=BL%SCRATCH, CDIM=[3,0,0]) 
!                        !
!      CASE ("SFR_DELIVERY_FOR_RECHARGE")
!                        WRITE(BL%IOUT,'(A)') '   SFR_DELIVERY_FOR_RECHARGE KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST STYLE INPUT OF SEGMENT AND REACH INTEGERS.'
!                        !
!                        !
!                        ! NOTE MAR%ISRD_TFR%WBS is the IMAR ID and NOT the WBS
!                        IF(MAR%NSFR_MAR_DELIV > Z) THEN
!                            CALL MAR%MAR_SFR_TFR%INIT('MAR_SFR', LLOC, LINE, BL%IOUT, BL%IU, SCRATCH=BL%SCRATCH, DIM=[FDIM%NSFR_MAR_DELIV], WILD_IN=FDIM%SFR_ID )
!                            !
!                            MAR%REQ_SFR = TRUE
!                        ELSE
!                            CALL WARNING_MESSAGE(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP MANAGED_RECHARGE BLOCK "SFR_DELIVERY_FOR_RECHARGE" KEYWORD IS ONLY ALLOWED'//BLN//'IF YOU SPECIFY IN THE "GLOBAL DIMENSION" BLOCK THE "NSFR_DELIV" KEYWORD WITH A VALUE GREATER THAN ZERO.'//BLN//'EITHER KEYWORD NSFR_DELIV WAS NOT FOUND IN THE GLOBAL DIMENSION BLOCK OR IT WAS SET TO ZERO OR LESS.'//NL//'ITS CURRENT VALUE IS:'//NUM2STR(MAR%NSFR_MAR_DELIV)//BLN//'SEMI-ROUTED DILIVERIES WILL BE IGNORED DURING SIMULATION.')
!                        END IF
!                        !
!      CASE ("DESIRED_RECHARGE")
!                        WRITE(BL%IOUT,'(A)') '   DESIRED_RECHARGE KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST STYLE INPUT OF SEGMENT AND REACH INTEGERS.'
!                        !
!                        IF(MAR%NMAR_ID > Z) THEN
!                            CALL MAR%MAR_DMD%INIT('SRD_LOWER_LIM',  LLOC, LINE, BL%IOUT, BL%IU,MAR%NSFR_MAR_DELIV, ONE, Z, Z, SCRATCH=BL%SCRATCH)
!                        ELSE
!                            CALL WARNING_MESSAGE(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP MANAGED_RECHARGE BLOCK "DESIRED_RECHARGE" KEYWORD IS ONLY ALLOWED'//BLN//'IF YOU SPECIFY IN THE "GLOBAL DIMENSION" BLOCK THE "NSFR_DELIV" KEYWORD WITH A VALUE GREATER THAN ZERO.'//BLN//'EITHER KEYWORD NSFR_DELIV WAS NOT FOUND IN THE GLOBAL DIMENSION BLOCK OR IT WAS SET TO ZERO OR LESS.'//NL//'ITS CURRENT VALUE IS:'//NUM2STR(MAR%NSFR_MAR_DELIV)//BLN//'SEMI-ROUTED DILIVERIES WILL BE IGNORED DURING SIMULATION.')
!                        END IF
!                        !
!      CASE ("SFR_DELIVERY_LOWER_LIMIT")
!                        WRITE(BL%IOUT,'(A)') '   SFR_DELIVERY_LOWER_LIMIT KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST STYLE INPUT OF SEGMENT AND REACH INTEGERS.'
!                        !
!                        IF(MAR%NSFR_MAR_DELIV > Z) THEN
!                            CALL MAR%DELIV_L_LIM%INIT('MAR_LOWER_LIM',  LLOC, LINE, BL%IOUT, BL%IU,MAR%NSFR_MAR_DELIV, ONE, Z, Z, SCRATCH=BL%SCRATCH)
!                        ELSE
!                            CALL WARNING_MESSAGE(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP MANAGED_RECHARGE BLOCK "SFR_DELIVERY_LOWER_LIMIT" KEYWORD IS ONLY ALLOWED'//BLN//'IF YOU SPECIFY IN THE "GLOBAL DIMENSION" BLOCK THE "NSFR_DELIV" KEYWORD WITH A VALUE GREATER THAN ZERO.'//BLN//'EITHER KEYWORD NSFR_DELIV WAS NOT FOUND IN THE GLOBAL DIMENSION BLOCK OR IT WAS SET TO ZERO OR LESS.'//NL//'ITS CURRENT VALUE IS:'//NUM2STR(MAR%NSFR_MAR_DELIV)//BLN//'SEMI-ROUTED DILIVERIES WILL BE IGNORED DURING SIMULATION.')
!                        END IF
!                        !
!      CASE ("SFR_DELIVERY_UPPER_LIMIT")
!                        WRITE(BL%IOUT,'(A)') '   SFR_DELIVERY_UPPER_LIMIT KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST STYLE INPUT OF SEGMENT AND REACH INTEGERS.'
!                        !
!                        IF(MAR%NSFR_MAR_DELIV > Z) THEN
!                            CALL MAR%DELIV_U_LIM%INIT('MAR_UPPER_LIM',  LLOC, LINE, BL%IOUT, BL%IU,MAR%NSFR_MAR_DELIV, ONE, Z, Z, SCRATCH=BL%SCRATCH)
!                        ELSE
!                            CALL WARNING_MESSAGE(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP MANAGED_RECHARGE BLOCK "SFR_DELIVERY_UPPER_LIMIT" KEYWORD IS ONLY ALLOWED'//BLN//'IF YOU SPECIFY IN THE "GLOBAL DIMENSION" BLOCK THE "NSFR_DELIV" KEYWORD WITH A VALUE GREATER THAN ZERO.'//BLN//'EITHER KEYWORD NSFR_DELIV WAS NOT FOUND IN THE GLOBAL DIMENSION BLOCK OR IT WAS SET TO ZERO OR LESS.'//NL//'ITS CURRENT VALUE IS:'//NUM2STR(MAR%NSFR_MAR_DELIV)//BLN//'SEMI-ROUTED DILIVERIES WILL BE IGNORED DURING SIMULATION.')
!                        END IF
!                        !
!      CASE DEFAULT
!                        CALL WARN_MSG%ADD('FOUND UNKNOWN KEYWORD "'//LINE(ISTART:ISTOP)//'" ***IT WILL BE IGNORED***'//BLN)
!                        
!      END SELECT
!      !
!      !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
!      CALL BL%READ_SCRATCH(EOF, LINE)
!      !
!    END DO
!    !
!    CALL WARN_MSG%CHECK(HED='FMP MANAGED_RECHARGE BLOCK'//NL,INFILE=BL%IU,OUTPUT=BL%IOUT,INLINE=TRUE,CMD_PRINT=TRUE,TAIL=NL)
!    !
!    IF(MAR%NSFR_MAR_DELIV > Z .AND. MAR%MAR_SFR_TFR%INUSE) THEN
!        !
!        IF(.NOT. MAR%DELIV_L_LIM%INUSE) CALL MAR%DELIV_L_LIM%INIT('SRD_LOWER_LIM', DZ,   BL%IOUT, BL%IU, MAR%NSFR_MAR_DELIV, ONE, Z, Z)
!        IF(.NOT. MAR%DELIV_U_LIM%INUSE) CALL MAR%DELIV_U_LIM%INIT('SRD_UPPER_LIM', D100, BL%IOUT, BL%IU, MAR%NSFR_MAR_DELIV, ONE, Z, Z)
!    END IF
!    !
!    !
!  END SUBROUTINE 
!  !
!  SUBROUTINE SETUP_NEXT_STRESS_PERIOD(MAR, FDIM, SEG_NSTRM, STRM)
!    !
!    CLASS(MANAGED_RECHARGE_DATA),       INTENT(INOUT):: MAR
!    TYPE(FMP_DIMENSION),                INTENT(IN   ):: FDIM
!    INTEGER, DIMENSION(:),  CONTIGUOUS, INTENT(IN   ):: SEG_NSTRM
!    REAL,    DIMENSION(:,:),CONTIGUOUS, INTENT(IN   ):: STRM
!    !
!    INTEGER:: I,J,K,F,N
!    LOGICAL:: UPDATE
!    LOGICAL:: MAR_CHK
!    TYPE(WARNING_TYPE):: WRN
!    !
!    ! NOTE MAR%ISRD_TFR%WBS is the IMAR ID and NOT the WBS
!    !
!    IF(.NOT. MAR%HAS_MAR) RETURN
!    !
!    IF(MAR%TFR_READ) THEN
!        !
!        UPDATE = FALSE
!        !
!        CALL MAR%MAR_DMD%NEXT()
!        !
!        CALL MAR%MAR_SFR_TFR%NEXT(FDIM%SFR_ID)
!        CALL MAR%IMAR_TFR%NEXT()
!        CALL MAR%DELIV_L_LIM%NEXT()
!        CALL MAR%DELIV_U_LIM%NEXT()
!    ELSE
!        UPDATE = TRUE
!        !
!        MAR%TFR_READ = TRUE
!    END IF
!    !
!    CALL WRN%INIT()
!    !
!    IF(UPDATE .OR. MAR%IMAR_TFR%TRANSIENT) THEN
!        IF(MAR%IMAR_TFR%HAS_IXJ) THEN
!            CALL MAR%IMAR_TFR%IXJ%TO_LAC_BYDIM(THREE, TWO, ONE, MAR%IMAR)  !(IDIM1, IDIM2, DIM_ID, LAC)
!        ELSE
!            DO CONCURRENT (I=ONE:MAR%NMAR_ID)
!                                     CALL MAR%IMAR(I)%BUILD( I, MAR%IMAR_TFR%ARRAY )
!            END DO
!        END IF
!    END IF
!    !
!    IF(MAR%MAR_SFR_TFR%INUSE) THEN
!                   MAR_CHK = UPDATE .OR. MAR%MAR_SFR_TFR%TRANSIENT
!    ELSE
!                   MAR_CHK = FALSE
!    END IF
!    !
!    IF(MAR_CHK) THEN  
!        !
!        DO K=ONE, MAR%NSFR_MAR_DELIV
!            IF(MAR%MAR_SFR_TFR%WBS(K) > MAR%NFARM) THEN
!                MAR%MAR_SFR_TFR%WBS(K)  = Z
!                MAR%MAR_SFR_TFR%SR(:,K) = Z
!                MAR%MAR_SFR_TFR%WT(K)   = DZ
!            END IF
!            !
!            IF(MAR%NSEG < MAR%MAR_SFR_TFR%SR(ONE,K)) THEN
!                J = MAR%MAR_SFR_TFR%WBS(K)
!                I = MAR%MAR_SFR_TFR%SR(ONE,K)
!                CALL WRN%ADD( NUM2STR(J,-5)//BLNK//NUM2STR(I,-5)//'    SFR_DELIVERY_FOR_RECHARGE Segment is greater then SFR number of segments'//NL )
!            END IF
!        END DO
!        !
!    END IF
!    !
!    IF(WRN%RAISED) CALL WRN%CHECK('MANAGED_RECHARGE BLOCK ERROR.'//NL//'THE FOLLOWING ARE A LIST OF BAD FMP-SFR LINKS AND THE REASON THEY ARE BAD.'//BLN//'FARM  SEGMENT  REASON', OUTPUT=MAR%IOUT, KILL=TRUE)
!    !
!    IF(MAR_CHK) THEN
!        !
!        DO CONCURRENT(K=ONE:MAR%NSFR_MAR_DELIV, MAR%MAR_SFR_TFR%WBS(K) > Z )
!            IF( MAR%MAR_SFR_TFR%SR(ONE,K) > Z .AND. MAR%MAR_SFR_TFR%SR(TWO,K) < ONE) THEN
!                F = MAR%MAR_SFR_TFR%WBS(K)
!                I = MAR%MAR_SFR_TFR%SR(ONE,K)
!                J = MAR%MAR_SFR_TFR%SR(TWO,K)
!                MAR%MAR_SFR_TFR%WBS(K)  = Z
!                MAR%MAR_SFR_TFR%SR(:,K) = Z
!                MAR%MAR_SFR_TFR%WT(K)   = DZ
!                CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  SFR_DELIVERY_FOR_RECHARGE Segment is greater then 0, but delivery Reach is  0, the delivery Segment is reset to 0'//NL )
!            END IF
!        END DO
!        !
!        DO CONCURRENT(K=ONE:MAR%NSFR_MAR_DELIV, MAR%MAR_SFR_TFR%WBS(K) > Z )
!            IF( MAR%MAR_SFR_TFR%SR(ONE,K) < ONE) THEN
!                F = MAR%MAR_SFR_TFR%WBS(K)
!                I = MAR%MAR_SFR_TFR%SR(ONE,K)
!                J = MAR%MAR_SFR_TFR%SR(TWO,K)
!                MAR%MAR_SFR_TFR%WBS(K)  = Z
!                MAR%MAR_SFR_TFR%SR(:,K) = Z
!                MAR%MAR_SFR_TFR%WT(K)   = DZ
!                CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  SFR_DELIVERY_FOR_RECHARGE Segment is less then 0, it is reset to 0'//NL )
!            END IF
!        END DO
!        !
!        DO CONCURRENT(K=ONE:MAR%NSFR_MAR_DELIV, MAR%MAR_SFR_TFR%WBS(K) > Z )
!            IF( MAR%MAR_SFR_TFR%SR(TWO,K) < Z) THEN
!                F = MAR%MAR_SFR_TFR%WBS(K)
!                I = MAR%MAR_SFR_TFR%SR(ONE,K)
!                J = MAR%MAR_SFR_TFR%SR(TWO,K)
!                MAR%MAR_SFR_TFR%WBS(K)  = Z
!                MAR%MAR_SFR_TFR%SR(:,K) = Z
!                MAR%MAR_SFR_TFR%WT(K)   = DZ
!                CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  SFR_DELIVERY_FOR_RECHARGE Reach is less then 0, reset to 0'//NL )
!            END IF
!        END DO
!        !
!        DO CONCURRENT(K=ONE:MAR%NSFR_MAR_DELIV, MAR%MAR_SFR_TFR%WBS(K) > Z )
!            IF( MAR%MAR_SFR_TFR%SR(ONE,K) == Z .AND. MAR%MAR_SFR_TFR%SR(TWO,K) > Z) THEN
!                F = MAR%MAR_SFR_TFR%WBS(K)
!                I = MAR%MAR_SFR_TFR%SR(ONE,K)
!                J = MAR%MAR_SFR_TFR%SR(TWO,K)
!                MAR%MAR_SFR_TFR%WBS(K)  = Z
!                MAR%MAR_SFR_TFR%SR(:,K) = Z
!                MAR%MAR_SFR_TFR%WT(K)   = DZ
!                CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  SFR_DELIVERY_FOR_RECHARGE Segment is 0, but delivery Reach is greater than 0, the delivery Reach is reset to 0'//NL )
!            END IF
!        END DO
!        !
!    END IF
!    !
!    IF(WRN%RAISED) CALL WRN%CHECK('MANAGED_RECHARGE BLOCK WARNING.'//NL//'THE FOLLOWING ARE A LIST OF BAD FMP-SFR LINKS THAT CONTAINED PROBLEM SEGMENTS THAT HAD TO BE CHANGED.'//BLN//'FARM  SEGMENT REACH  REASON', OUTPUT=MAR%IOUT, INIT=TRUE)
!    !
!    ! CHECK FOR BAD REACHES
!    !
!    IF(MAR_CHK) THEN
!        !
!        DO CONCURRENT(K=ONE:MAR%NSFR_MAR_DELIV, MAR%MAR_SFR_TFR%WBS(K) > Z .AND. MAR%MAR_SFR_TFR%SR(ONE,K) > Z )
!           I = MAR%MAR_SFR_TFR%SR(ONE,K)            !ISEG
!           J = MAR%MAR_SFR_TFR%SR(TWO,K)            !IRCH
!           N = SEG_NSTRM(I+ONE) -  SEG_NSTRM(I)  !NRCH
!           IF(J > N) THEN
!                 F = MAR%MAR_SFR_TFR%WBS(K)
!                 MAR%MAR_SFR_TFR%WBS(K)  = Z
!                 MAR%MAR_SFR_TFR%SR(:,K) = Z
!                 MAR%MAR_SFR_TFR%WT(K)   = DZ
!                 CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'    SFR_DELIVERY_FOR_RECHARGE reach is greater then SFR number of reaches ('//NUM2STR(N)//') for specified segment'//NL )
!           END IF
!        END DO
!    END IF
!    !
!    IF(WRN%RAISED) CALL WRN%CHECK('MANAGED_RECHARGE BLOCK ERROR.'//NL//'THE FOLLOWING ARE A LIST OF BAD FMP-SFR LINKS AND THE REASON THEY ARE BAD.'//BLN//'FARM  SEGMENT REACH  REASON', OUTPUT=MAR%IOUT, KILL=TRUE)
!    !
!    !------------------------------------------------------------------------
!    !
!    IF(MAR_CHK .OR. MAR%DELIV_L_LIM%TRANSIENT .OR. MAR%DELIV_U_LIM%TRANSIENT) CALL BUILD_MAR_LOC_FLOW(MAR, SEG_NSTRM)
!    !
!    !------------------------------------------------------------------------
!    !
!  END SUBROUTINE
!  !
!  SUBROUTINE SETUP_NEXT_TIME_STEP(MAR)
!    !
!    CLASS(MANAGED_RECHARGE_DATA), INTENT(INOUT):: MAR
!    !
!    !
!  END SUBROUTINE
!  !
!  !SUBROUTINE ADD_SRD_TO_SFR_DELIV(SWF, SFR_DELIV)
!  !  !
!  !  CLASS(SURFACE_WATER_DATA), INTENT(IN):: SWF
!  !  TYPE(FMP_FLOW_REMOVE_SFR), INTENT(INOUT):: SFR_DELIV
!  !  INTEGER:: F, L, K
!  !  !
!  !  DO CONCURRENT (F=ONE:SWF%NFARM, SWF%SRDLOC(F)%N > Z) 
!  !    DO CONCURRENT (K = ONE:SWF%SRDLOC(F)%N,  SWF%SRDLOC(F)%ISTRM(K) > Z)
!  !          !
!  !          CALL SFR_DELIV%ADD_ISTRM( SWF%SRDLOC(F)%ISTRM(K) )
!  !    END DO
!  !  END DO
!  !  !
!  !END SUBROUTINE
!  !!
!  SUBROUTINE BUILD_MAR_LOC_FLOW(MAR, SEG_NSTRM)
!    !
!    CLASS(MANAGED_RECHARGE_DATA),           INTENT(INOUT):: MAR
!    INTEGER, DIMENSION(:),   CONTIGUOUS, INTENT(IN   ):: SEG_NSTRM
!    INTEGER:: F, K, I, DIM
!    DOUBLE PRECISION:: WT_SUM
!      INTEGER:: N=Z
!      LOGICAL:: NO_WT = TRUE
!      INTEGER,         DIMENSION(:),ALLOCATABLE:: ISTRM
!      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE:: WT
!      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE:: FLOW
!      !DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE:: FLOW_OLD
!      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE:: LLIM, ULIM
!      DOUBLE PRECISION:: TOT_RCH_INI, TOT_RCH_MET
!    !
!    DO I=ONE, MAR%NMAR_ID
!      !
!      ASSOCIATE( MARLOC => MAR%DELIV_LOC(I),     &
!                 MAR_ID => MAR%MAR_SFR_TFR%WBS,  &
!                 SR     => MAR%MAR_SFR_TFR%SR,   &
!                 LLIM   => MAR%DELIV_L_LIM%LIST, &
!                 ULIM   => MAR%DELIV_U_LIM%LIST   )
!                 !
!         MARLOC%TOT_RCH_INI = DZ
!         MARLOC%TOT_RCH_MET = DZ
!         !
!         MARLOC%N = Z
!         !
!         DIM = COUNT(I == MAR_ID)
!         !
!         IF(DIM > Z) THEN
!             !
!             MARLOC%N = DIM
!             !
!             CALL ALLOC(MARLOC%ISTRM,DIM)      !(ARR, N)
!             CALL ALLOC(MARLOC%WT,   DIM)      !(ARR, N)
!             CALL ALLOC(MARLOC%FLOW, DIM)      !(ARR, N)
!             CALL ALLOC(MARLOC%LLIM, DIM)      !(ARR, N)
!             CALL ALLOC(MARLOC%ULIM, DIM)      !(ARR, N)
!             !
!             DIM = Z
!             DO K=ONE, SWF%NSFR_DELIV
!                 IF(I == MAR_ID(K)) THEN
!                     DIM = DIM + ONE
!                     !
!                     MARLOC%ISTRM(DIM) = SEG_NSTRM(SR(ONE,K))  + SR(TWO,K)
!                     MARLOC%WT   (DIM) = SWF%ISRD_TFR%WT(K)
!                     MARLOC%LLIM (DIM) = LLIM(K)
!                     MARLOC%ULIM (DIM) = ULIM(K)
!                     !
!                 END IF
!             END DO
!             !
!             MARLOC%NO_WT = TRUE
!             !
!             IF(DIM > ONE) THEN
!                IF( ALL(NEGNEARZERO_5 < MARLOC%WT .AND. MARLOC%WT < NEAR_ONE_5) ) THEN
!                    !
!                    MARLOC%NO_WT = FALSE
!                    !
!                    DO CONCURRENT(K=ONE:DIM)
!                        IF(   MARLOC%WT(K) < DZ  ) THEN
!                                                               MARLOC%WT(K) = DZ
!                        ELSEIF(MARLOC%WT(K) > UNO) THEN
!                                                               MARLOC%WT(K) = UNO
!                        END IF
!                    END DO
!                    !
!                    WT_SUM = SUM( MARLOC%WT )
!                    !
!                    IF(WT_SUM.NE.UNO) MARLOC%WT = MARLOC%WT / WT_SUM  !RESCALE TO SUM TO ONE
!                    !
!                    CALL SORT(DIM,MARLOC%WT,MARLOC%ISTRM) !SORTS FROM SMALLEST TO LARGEST
!                    !
!                    CALL REVERSE_ORDER(    DIM,MARLOC%WT)
!                    CALL REVERSE_ORDER(    DIM,MARLOC%ISTRM)
!                    !
!                    !!!ASSOCIATE(IDX=>SWF%SRDLOC(F)%ISTRM)
!                    !!!   FORALL(K=ONE:DIM)
!                    !!!          SWF%SRDLOC(F)%SEGRCH(ONE,K) = ISTRM(4,IDX(K)) !SEG
!                    !!!          SWF%SRDLOC(F)%SEGRCH(TWO,K) = ISTRM(5,IDX(K)) !RCH
!                    !!!   END DO
!                    !!!END ASSOCIATE
!                END IF !( ALL(NEGNEARZERO_5 < SWF%SRDLOC(F)%WT .AND. SWF%SRDLOC(F)%WT < NEAR_ONE_5) ) THEN
!             END IF !(DIM > ONE) THEN
!         END IF !(DIM > Z) THEN
!      END ASSOCIATE
!    END DO
!    !
!  END SUBROUTINE
!  !!
!  !SUBROUTINE APPLY_SRD_DEMAND(SWF, F, DEMAND, SFR_DELIV)
!  !  !
!  !  CLASS(SURFACE_WATER_DATA), INTENT(INOUT):: SWF
!  !  INTEGER,                   INTENT(IN   ):: F
!  !  TYPE(FMP_FLOW_REMOVE_SFR), INTENT(INOUT):: SFR_DELIV
!  !  DOUBLE PRECISION,          INTENT(IN   ):: DEMAND
!  !  INTEGER:: K
!  !  DOUBLE PRECISION:: DMD,SUP,DTMP,TOT_FLOW
!  !  !
!  !  ASSOCIATE(         DIM => SWF%SRDLOC(F)%N,           &
!  !                    NO_WT=> SWF%SRDLOC(F)%NO_WT,       &
!  !             TOT_DMD_INI => SWF%SRDLOC(F)%TOT_DMD_INI, &
!  !             TOT_DMD_MET => SWF%SRDLOC(F)%TOT_DMD_MET, &
!  !                    FLOW => SWF%SRDLOC(F)%FLOW,        &
!  !                    LLIM => SWF%SRDLOC(F)%LLIM,        &
!  !                    ULIM => SWF%SRDLOC(F)%ULIM,        &
!  !                   ISTRM => SWF%SRDLOC(F)%ISTRM,       &
!  !                      WT => SWF%SRDLOC(F)%WT)
!  !    ! 
!  !    DMD = DEMAND
!  !    TOT_DMD_INI = DMD
!  !    TOT_DMD_MET = DZ
!  !    !
!  !    IF    (DIM == ONE) THEN
!  !                             CALL SFR_DELIV%APPLY_DMD(ISTRM(ONE), DMD, TOT_DMD_MET, LLIM(ONE), ULIM(ONE))
!  !                             FLOW(ONE) = TOT_DMD_MET
!  !    ELSEIF(DIM  > ONE) THEN
!  !        !
!  !        FORALL(K=ONE:DIM); FLOW(K) = DZ
!  !        END DO
!  !        !
!  !        TOT_FLOW = DZ
!  !        DO K=ONE, DIM
!  !           !
!  !           CALL SFR_DELIV%SET_TO_INFLOW(ISTRM(K), DTMP, LLIM(K), ULIM(K))
!  !           !
!  !           TOT_FLOW = TOT_FLOW + DTMP
!  !        END DO
!  !        !
!  !        IF(TOT_DMD_INI > TOT_FLOW) THEN  !SRD WILL NEVER MEET DEMAND
!  !            !
!  !            DO K=ONE, DIM
!  !                !
!  !                CALL SFR_DELIV%APPLY_DMD(ISTRM(K), DMD, SUP, LLIM(K), ULIM(K))
!  !                !
!  !                FLOW(K)     = FLOW(K)     + SUP
!  !                TOT_DMD_MET = TOT_DMD_MET + SUP
!  !                !
!  !                DMD = DMD - SUP
!  !                !
!  !            END DO
!  !            !
!  !        ELSEIF(NO_WT) THEN !REMOVE DEMAND IN ORDER
!  !            !
!  !            DO K=ONE, DIM
!  !                !
!  !                CALL SFR_DELIV%APPLY_DMD(ISTRM(K), DMD, SUP, LLIM(K), ULIM(K))
!  !                !
!  !                FLOW(K)     = FLOW(K)     + SUP
!  !                TOT_DMD_MET = TOT_DMD_MET + SUP
!  !                !
!  !                DMD = DMD - SUP
!  !                IF(DMD < NEARZERO_29) EXIT
!  !                !
!  !            END DO
!  !        ELSE
!  !            DO K=ONE, DIM !FIRST PASS
!  !                !
!  !                DTMP = TOT_DMD_INI * WT(K)
!  !                !
!  !                CALL SFR_DELIV%APPLY_DMD(ISTRM(K), DTMP, SUP, LLIM(K), ULIM(K))
!  !                !
!  !                FLOW(K)     = FLOW(K)     + SUP
!  !                TOT_DMD_MET = TOT_DMD_MET + SUP
!  !                !
!  !                DMD = DMD - SUP
!  !                IF(DMD < NEARZERO_29) EXIT
!  !                !
!  !            END DO
!  !            !
!  !            IF(TOT_DMD_INI - TOT_DMD_MET > NEARZERO_29) THEN  !NOT FULL MET, UPDATE AVAILIBLE FLOW
!  !                !
!  !                TOT_FLOW = DZ
!  !                DO K=ONE, DIM
!  !                   TOT_FLOW = TOT_FLOW + SFR_DELIV%GET_INFLOW(ISTRM(K))
!  !                END DO
!  !                !
!  !                IF(TOT_FLOW > NEARZERO_29) THEN
!  !                    !
!  !                    TOT_FLOW = DMD / TOT_FLOW !FRACTION OF DEMAND == USED FOR DMD * (SFR_DELIV%GET_INFLOW(ISTRM(K))/TOT_FLOW) -- BUT INSTEAD HOLDING DMD/TOT_INFLOW
!  !                    !
!  !                    DO K=ONE, DIM !SECOND PASS
!  !                        !
!  !                        DTMP = SFR_DELIV%GET_INFLOW(ISTRM(K)) * TOT_FLOW  ! TOT_FLOW = DMD / TOT_FLOW
!  !                        !
!  !                        IF(DTMP > NEARZERO_29) THEN
!  !                            CALL SFR_DELIV%APPLY_DMD(ISTRM(K), DTMP, SUP, LLIM(K), ULIM(K))
!  !                            !
!  !                            FLOW(K)     = FLOW(K)     + SUP
!  !                            TOT_DMD_MET = TOT_DMD_MET + SUP
!  !                            !
!  !                            DMD = DMD - SUP
!  !                            IF(DMD < NEARZERO_29) EXIT
!  !                        END IF
!  !                        !
!  !                    END DO
!  !                END IF
!  !            END IF
!  !        END IF
!  !    END IF
!  !  END ASSOCIATE
!  !  !
!  !END SUBROUTINE
!END MODULE
!
!#########################################################################################################
!